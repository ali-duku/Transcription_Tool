<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-3DP5ZC653Y"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-3DP5ZC653Y');
        
        // Analytics Helper Functions
        function trackEvent(eventName, eventParams) {
            if (typeof gtag !== 'undefined') {
                gtag('event', eventName, eventParams);
            }
        }
        
        // ===== VERSION CONFIGURATION =====
        // DISPLAY_VERSION: The version shown in the UI (header and What's New modal)
        // Update this when you want to change what version is displayed to users
        const DISPLAY_VERSION = '6.8';
        
        // CURRENT_VERSION: Internal version number that triggers the What's New modal
        // Update this when you release a new version to trigger:
        //   - Auto-open of What's New modal (only if user hasn't seen this version)
        //   - Version reload checks
        // This can be different from DISPLAY_VERSION (e.g., use "6.6.1" for minor updates)
        // Example: Change '6.7' to '6.8' when releasing version 6.8
        const CURRENT_VERSION = '6.8';
        const VERSION_SEEN_KEY = 'whatsNewVersionSeen';
        
        // ===== UNDO/REDO SYSTEM =====
        const formUndoHistory = [];
        const formRedoHistory = [];
        const MAX_HISTORY_SIZE = 100;
        let isFormUndoRedoInProgress = false;
        
        // Action types
        const ACTION_TYPES = {
            ADD_ITEM: 'add_item',
            REMOVE_ITEM: 'remove_item',
            DUPLICATE_ITEM: 'duplicate_item',
            FIELD_CHANGE: 'field_change',
            MOVE_ITEM: 'move_item',
            CLEAR_FORM: 'clear_form',
            LOAD_JSON: 'load_json',
            PASTE: 'paste',
            PASTE_SECTION: 'paste_section',
            PASTE_QUESTION: 'paste_question',
            PASTE_BBOX: 'paste_bbox'
        };
        
        // Record an action for undo/redo
        function recordFormAction(action) {
            if (isFormUndoRedoInProgress) return;
            
            // Clear redo history when new action is recorded
            formRedoHistory.length = 0;
            
            // Add to undo history
            formUndoHistory.push(action);
            
            // Limit history size
            if (formUndoHistory.length > MAX_HISTORY_SIZE) {
                formUndoHistory.shift();
            }
            
            updateUndoRedoButtons();
        }
        
        // Update undo/redo button states
        function updateUndoRedoButtons() {
            const undoBtn = document.getElementById('undo-btn');
            const redoBtn = document.getElementById('redo-btn');
            
            if (undoBtn) {
                undoBtn.disabled = formUndoHistory.length === 0;
                undoBtn.style.opacity = formUndoHistory.length === 0 ? '0.5' : '1';
                undoBtn.style.cursor = formUndoHistory.length === 0 ? 'not-allowed' : 'pointer';
            }
            
            if (redoBtn) {
                redoBtn.disabled = formRedoHistory.length === 0;
                redoBtn.style.opacity = formRedoHistory.length === 0 ? '0.5' : '1';
                redoBtn.style.cursor = formRedoHistory.length === 0 ? 'not-allowed' : 'pointer';
            }
        }
        
        // Undo last action
        function undoAction() {
            if (formUndoHistory.length === 0 || isFormUndoRedoInProgress) return;
            
            isFormUndoRedoInProgress = true;
            const action = formUndoHistory.pop();
            
            try {
                executeUndo(action);
                // Move to redo history
                formRedoHistory.push(action);
                updateUndoRedoButtons();
            } catch (e) {
                console.error('Error undoing action:', e);
                // Put action back if undo failed
                formUndoHistory.push(action);
            } finally {
                isFormUndoRedoInProgress = false;
            }
        }
        
        // Redo last undone action
        function redoAction() {
            if (formRedoHistory.length === 0 || isFormUndoRedoInProgress) return;
            
            isFormUndoRedoInProgress = true;
            const action = formRedoHistory.pop();
            
            try {
                executeRedo(action);
                // Move back to undo history
                formUndoHistory.push(action);
                updateUndoRedoButtons();
            } catch (e) {
                console.error('Error redoing action:', e);
                // Put action back if redo failed
                formRedoHistory.push(action);
            } finally {
                isFormUndoRedoInProgress = false;
            }
        }
        
        // Execute undo for an action
        function executeUndo(action) {
            switch (action.type) {
                case ACTION_TYPES.ADD_ITEM:
                    // Undo add = remove
                    if (action.element && action.element.parentNode) {
                        // Check if this is a choice item BEFORE removing it
                        const isChoiceItem = action.element.classList.contains('choice-item') || 
                                           (action.element.closest && action.element.closest('[id^="choices-list-"]') !== null);
                        let questionEl = null;
                        if (isChoiceItem) {
                            // Find the parent question element before removing
                            const choicesList = action.element.closest('[id^="choices-list-"]');
                            questionEl = choicesList ? choicesList.closest('.array-item') : 
                                        (action.element.closest('.array-item[data-type="question"]') || 
                                         action.element.closest('.array-item'));
                        }
                        
                        // For matching items, find question element before removing
                        const isMatchingItem = action.element.classList.contains('matching-item') || 
                                             (action && action.isMatchingItem === true);
                        let matchingQuestionEl = null;
                        if (isMatchingItem && action.questionEl) {
                            matchingQuestionEl = action.questionEl;
                        } else if (isMatchingItem) {
                            const matchingContainer = action.element.closest('#matching-container');
                            matchingQuestionEl = matchingContainer ? matchingContainer.closest('.array-item') : 
                                                 action.element.closest('.array-item');
                        }
                        
                        action.element.remove();
                        if (action.updateNumbers) {
                            updateNumbersForContainer(action.containerId);
                        }
                        
                        // Update choice UI if this was a choice item (use the questionEl we found before removal)
                        if (isChoiceItem && questionEl) {
                            setTimeout(() => {
                                updateCorrectAnswerRadios(questionEl);
                                updateCheckboxSummary(questionEl);
                            }, 0);
                        }
                        
                        // Update matching UI if this was a matching item (use the questionEl we found before removal)
                        if (isMatchingItem && matchingQuestionEl) {
                            setTimeout(() => {
                                if (action.side) {
                                    updateMatchingItemNumbers(matchingQuestionEl, action.side);
                                } else {
                                    updateMatchingItemNumbers(matchingQuestionEl, 'left');
                                }
                                updateRelationshipUI(matchingQuestionEl);
                            }, 0);
                        }
                    }
                    break;
                    
                case ACTION_TYPES.REMOVE_ITEM:
                    // Undo remove = restore element
                    if (action.element && action.parent && action.nextSibling) {
                        action.parent.insertBefore(action.element, action.nextSibling);
                    } else if (action.element && action.parent) {
                        action.parent.appendChild(action.element);
                    }
                    if (action.updateNumbers) {
                        updateNumbersForContainer(action.containerId);
                    }
                    // Reattach previews and event listeners
                    if (action.element) {
                        attachPreviews(action.element);
                        // For matching items, ensure textarea has RTL direction
                        if (action.element.classList.contains('matching-item')) {
                            const textarea = action.element.querySelector('textarea');
                            if (textarea) {
                                textarea.setAttribute('dir', 'rtl');
                            }
                        }
                    }
                    // Update choice UI if this was a choice item (after element is restored)
                    setTimeout(() => {
                        updateChoiceUIIfNeeded(action.element);
                    }, 0);
                    // Update matching UI if this was a matching item (after element is restored)
                    setTimeout(() => {
                        updateMatchingUIIfNeeded(action.element, action);
                    }, 0);
                    break;
                    
                case ACTION_TYPES.DUPLICATE_ITEM:
                    // Undo duplicate = remove duplicated element
                    if (action.duplicatedElement && action.duplicatedElement.parentNode) {
                        action.duplicatedElement.remove();
                        if (action.updateNumbers) {
                            updateNumbersForContainer(action.containerId);
                        }
                    }
                    break;
                    
                case ACTION_TYPES.FIELD_CHANGE:
                    // Undo field change = restore old value
                    if (action.field) {
                        action.field.value = action.oldValue;
                        // Trigger input event to update previews
                        action.field.dispatchEvent(new Event('input', { bubbles: true }));
                    }
                    break;
                    
                case ACTION_TYPES.MOVE_ITEM:
                    // Undo move = move back
                    if (action.element && action.oldParent && action.oldNextSibling) {
                        action.oldParent.insertBefore(action.element, action.oldNextSibling);
                    } else if (action.element && action.oldParent) {
                        action.oldParent.appendChild(action.element);
                    }
                    if (action.updateNumbers) {
                        updateNumbersForContainer(action.containerId);
                    }
                    break;
                    
                case ACTION_TYPES.CLEAR_FORM:
                    // Undo clear = restore form state
                    if (action.savedState) {
                        isFormUndoRedoInProgress = true;
                        try {
                            populateFormFromJSON(action.savedState);
                        } finally {
                            isFormUndoRedoInProgress = false;
                        }
                    }
                    break;
                    
                case ACTION_TYPES.LOAD_JSON:
                    // Undo load = restore previous form state
                    if (action.previousState) {
                        isFormUndoRedoInProgress = true;
                        try {
                            populateFormFromJSON(action.previousState);
                        } finally {
                            isFormUndoRedoInProgress = false;
                        }
                    }
                    break;
                    
                case ACTION_TYPES.PASTE:
                    // Undo paste = restore old element content
                    if (action.pastedElement && action.oldElement && action.parent) {
                        // Restore the content from the old element, preserving all field values
                        restoreSectionContent(action.pastedElement, action.oldElement);
                        // Reinitialize the element
                        attachPreviews(action.pastedElement);
                        applyFontSettings(action.pastedElement);
                        attachBboxValidation(action.pastedElement);
                        // Reattach event listeners by triggering any necessary initialization
                        const questionTypeSelect = action.pastedElement.querySelector('select[onchange*="toggleQuestionType"]');
                        if (questionTypeSelect) {
                            toggleQuestionType(questionTypeSelect);
                        }
                        if (action.updateNumbers) {
                            updateNumbersForContainer(action.containerId);
                        }
                    }
                    break;
                    
                case ACTION_TYPES.PASTE_SECTION:
                case ACTION_TYPES.PASTE_QUESTION:
                    // Undo paste = remove pasted element
                    if (action.pastedElement && action.pastedElement.parentNode) {
                        action.pastedElement.remove();
                        if (action.updateNumbers) {
                            updateNumbersForContainer(action.containerId);
                        }
                    }
                    break;
                    
                case ACTION_TYPES.PASTE_BBOX:
                    // Undo bbox paste = restore old values
                    if (action.targetRow && action.oldState) {
                        const pageInput = action.targetRow.querySelector('.bbox-page');
                        const x0Input = action.targetRow.querySelector('.bbox-x0');
                        const y0Input = action.targetRow.querySelector('.bbox-y0');
                        const x1Input = action.targetRow.querySelector('.bbox-x1');
                        const y1Input = action.targetRow.querySelector('.bbox-y1');
                        
                        if (pageInput) pageInput.value = action.oldState.page || '';
                        if (x0Input) x0Input.value = action.oldState.x0 || '';
                        if (y0Input) y0Input.value = action.oldState.y0 || '';
                        if (x1Input) x1Input.value = action.oldState.x1 || '';
                        if (y1Input) y1Input.value = action.oldState.y1 || '';
                        
                        // Trigger validation
                        validateAndNormalizeBbox(action.targetRow);
                    }
                    break;
            }
        }
        
        // Execute redo for an action
        function executeRedo(action) {
            switch (action.type) {
                case ACTION_TYPES.ADD_ITEM:
                    // Redo add = add again
                    if (action.element && action.parent && action.nextSibling) {
                        action.parent.insertBefore(action.element, action.nextSibling);
                    } else if (action.element && action.parent) {
                        action.parent.appendChild(action.element);
                    }
                    if (action.updateNumbers) {
                        updateNumbersForContainer(action.containerId);
                    }
                    // Reattach previews and event listeners
                    if (action.element) {
                        attachPreviews(action.element);
                        // For matching items, ensure textarea has RTL direction
                        if (action.element.classList.contains('matching-item')) {
                            const textarea = action.element.querySelector('textarea');
                            if (textarea) {
                                textarea.setAttribute('dir', 'rtl');
                            }
                        }
                    }
                    // Update choice UI if this was a choice item (after element is added back)
                    setTimeout(() => {
                        updateChoiceUIIfNeeded(action.element);
                    }, 0);
                    // Update matching UI if this was a matching item (after element is added back)
                    setTimeout(() => {
                        updateMatchingUIIfNeeded(action.element, action);
                    }, 0);
                    break;
                    
                case ACTION_TYPES.REMOVE_ITEM:
                    // Redo remove = remove again
                    if (action.element && action.element.parentNode) {
                        // Check if this is a choice item BEFORE removing it
                        const isChoiceItem = action.element.classList.contains('choice-item') || 
                                           (action.element.closest && action.element.closest('[id^="choices-list-"]') !== null);
                        let questionEl = null;
                        if (isChoiceItem) {
                            // Find the parent question element before removing
                            const choicesList = action.element.closest('[id^="choices-list-"]');
                            questionEl = choicesList ? choicesList.closest('.array-item') : 
                                        (action.element.closest('.array-item[data-type="question"]') || 
                                         action.element.closest('.array-item'));
                        }
                        
                        // For matching items, find question element before removing
                        const isMatchingItem = action.element.classList.contains('matching-item') || 
                                             (action && action.isMatchingItem === true);
                        let matchingQuestionEl = null;
                        if (isMatchingItem && action.questionEl) {
                            matchingQuestionEl = action.questionEl;
                        } else if (isMatchingItem) {
                            const matchingContainer = action.element.closest('#matching-container');
                            matchingQuestionEl = matchingContainer ? matchingContainer.closest('.array-item') : 
                                                action.element.closest('.array-item');
                        }
                        
                        action.element.remove();
                        if (action.updateNumbers) {
                            updateNumbersForContainer(action.containerId);
                        }
                        
                        // Update choice UI if this was a choice item (use the questionEl we found before removal)
                        if (isChoiceItem && questionEl) {
                            setTimeout(() => {
                                updateCorrectAnswerRadios(questionEl);
                                updateCheckboxSummary(questionEl);
                            }, 0);
                        }
                        
                        // Update matching UI if this was a matching item (use the matchingQuestionEl we found before removal)
                        if (isMatchingItem && matchingQuestionEl) {
                            setTimeout(() => {
                                if (action.side) {
                                    updateMatchingItemNumbers(matchingQuestionEl, action.side);
                                } else {
                                    updateMatchingItemNumbers(matchingQuestionEl, 'left');
                                }
                                updateRelationshipUI(matchingQuestionEl);
                            }, 0);
                        }
                    }
                    break;
                    
                case ACTION_TYPES.DUPLICATE_ITEM:
                    // Redo duplicate = duplicate again
                    if (action.duplicatedElement && action.parent && action.nextSibling) {
                        // Clone the element for redo (since it may have been removed during undo)
                        const cloned = action.duplicatedElement.cloneNode(true);
                        action.parent.insertBefore(cloned, action.nextSibling);
                        // Reinitialize the cloned element
                        attachPreviews(cloned);
                        applyFontSettings(cloned);
                        attachBboxValidation(cloned);
                        // Update the action to reference the new cloned element for future operations
                        action.duplicatedElement = cloned;
                        if (action.updateNumbers) {
                            updateNumbersForContainer(action.containerId);
                        }
                    }
                    break;
                    
                case ACTION_TYPES.FIELD_CHANGE:
                    // Redo field change = apply new value
                    if (action.field) {
                        action.field.value = action.newValue;
                        // Trigger input event to update previews
                        action.field.dispatchEvent(new Event('input', { bubbles: true }));
                    }
                    break;
                    
                case ACTION_TYPES.MOVE_ITEM:
                    // Redo move = move again
                    if (action.element && action.newParent && action.newNextSibling) {
                        action.newParent.insertBefore(action.element, action.newNextSibling);
                    } else if (action.element && action.newParent) {
                        action.newParent.appendChild(action.element);
                    }
                    if (action.updateNumbers) {
                        updateNumbersForContainer(action.containerId);
                    }
                    break;
                    
                case ACTION_TYPES.CLEAR_FORM:
                    // Redo clear = clear form again
                    if (action.clearFunction) {
                        isFormUndoRedoInProgress = true;
                        try {
                            action.clearFunction(true); // Pass true to indicate internal call
                        } finally {
                            isFormUndoRedoInProgress = false;
                        }
                    }
                    break;
                    
                case ACTION_TYPES.LOAD_JSON:
                    // Redo load = load JSON again
                    if (action.jsonData) {
                        isFormUndoRedoInProgress = true;
                        try {
                            populateFormFromJSON(action.jsonData);
                        } finally {
                            isFormUndoRedoInProgress = false;
                        }
                    }
                    break;
                    
                case ACTION_TYPES.PASTE:
                    // Redo paste = restore pasted content
                    if (action.pastedElement && action.pastedState && action.parent) {
                        // Save the current state as the new oldElement for future undo
                        const currentState = action.pastedElement.cloneNode(true);
                        // Restore the pasted content from the saved pastedState, preserving all field values
                        restoreSectionContent(action.pastedElement, action.pastedState);
                        // Reinitialize the element
                        attachPreviews(action.pastedElement);
                        applyFontSettings(action.pastedElement);
                        attachBboxValidation(action.pastedElement);
                        // Reattach event listeners
                        const questionTypeSelect = action.pastedElement.querySelector('select[onchange*="toggleQuestionType"]');
                        if (questionTypeSelect) {
                            toggleQuestionType(questionTypeSelect);
                        }
                        // Update oldElement for future undo (current state becomes the old state)
                        action.oldElement = currentState;
                        if (action.updateNumbers) {
                            updateNumbersForContainer(action.containerId);
                        }
                    }
                    break;
                    
                case ACTION_TYPES.PASTE_SECTION:
                case ACTION_TYPES.PASTE_QUESTION:
                    // Redo paste = paste again
                    if (action.pastedElement && action.parent && action.nextSibling) {
                        // Clone the element since it may have been removed during undo
                        const cloned = action.pastedElement.cloneNode(true);
                        action.parent.insertBefore(cloned, action.nextSibling);
                        attachPreviews(cloned);
                        applyFontSettings(cloned);
                        attachBboxValidation(cloned);
                        // Update the action to reference the new cloned element
                        action.pastedElement = cloned;
                        if (action.updateNumbers) {
                            updateNumbersForContainer(action.containerId);
                        }
                    } else if (action.pastedElement && action.parent) {
                        // Clone the element since it may have been removed during undo
                        const cloned = action.pastedElement.cloneNode(true);
                        action.parent.appendChild(cloned);
                        attachPreviews(cloned);
                        applyFontSettings(cloned);
                        attachBboxValidation(cloned);
                        // Update the action to reference the new cloned element
                        action.pastedElement = cloned;
                        if (action.updateNumbers) {
                            updateNumbersForContainer(action.containerId);
                        }
                    }
                    break;
                    
                case ACTION_TYPES.PASTE_BBOX:
                    // Redo bbox paste = restore pasted values
                    if (action.targetRow && action.pastedState) {
                        // Save current state as new oldState for future undo
                        const currentState = {
                            page: action.targetRow.querySelector('.bbox-page')?.value || '',
                            x0: action.targetRow.querySelector('.bbox-x0')?.value || '',
                            y0: action.targetRow.querySelector('.bbox-y0')?.value || '',
                            x1: action.targetRow.querySelector('.bbox-x1')?.value || '',
                            y1: action.targetRow.querySelector('.bbox-y1')?.value || ''
                        };
                        
                        const pageInput = action.targetRow.querySelector('.bbox-page');
                        const x0Input = action.targetRow.querySelector('.bbox-x0');
                        const y0Input = action.targetRow.querySelector('.bbox-y0');
                        const x1Input = action.targetRow.querySelector('.bbox-x1');
                        const y1Input = action.targetRow.querySelector('.bbox-y1');
                        
                        if (pageInput) pageInput.value = action.pastedState.page || '';
                        if (x0Input) x0Input.value = action.pastedState.x0 || '';
                        if (y0Input) y0Input.value = action.pastedState.y0 || '';
                        if (x1Input) x1Input.value = action.pastedState.x1 || '';
                        if (y1Input) y1Input.value = action.pastedState.y1 || '';
                        
                        // Update oldState for future undo
                        action.oldState = currentState;
                        
                        // Trigger validation
                        validateAndNormalizeBbox(action.targetRow);
                    }
                    break;
            }
        }
        
        // Helper to update numbers for a container (content sections, questions, etc.)
        function updateNumbersForContainer(containerId) {
            if (containerId === 'content_sections_container') {
                updateContentSectionNumbers();
            } else if (containerId === 'questions_container') {
                updateQuestionNumbers();
            }
        }
        
        // Helper to update choice UI if the element is a choice item
        function updateChoiceUIIfNeeded(element) {
            if (!element) return;
            
            // Check if this is a choice item - choice items have class 'choice-item'
            // or are inside a choices-list container
            const isChoiceItem = element.classList.contains('choice-item') || 
                                 (element.closest && element.closest('[id^="choices-list-"]') !== null);
            
            if (isChoiceItem) {
                // Find the parent question element
                // Choices are inside choices-list which is inside a question
                const choicesList = element.closest('[id^="choices-list-"]');
                const questionEl = choicesList ? choicesList.closest('.array-item') : 
                                  (element.closest('.array-item[data-type="question"]') || 
                                   element.closest('.array-item'));
                
                if (questionEl) {
                    // Use setTimeout to ensure DOM is fully updated before updating UI
                    setTimeout(() => {
                        // Update correct answer UI
                        updateCorrectAnswerRadios(questionEl);
                        updateCheckboxSummary(questionEl);
                    }, 0);
                }
            }
        }
        
        // Helper to update matching relationship UI if the element is a matching item
        function updateMatchingUIIfNeeded(element, action) {
            if (!element) return;
            
            // Check if this is a matching item or if action has the flag
            const isMatchingItem = element.classList.contains('matching-item') || 
                                  (action && action.isMatchingItem === true);
            
            if (isMatchingItem) {
                // Get question element from action if available, otherwise find it
                let questionEl = null;
                if (action && action.questionEl) {
                    questionEl = action.questionEl;
            } else {
                    const matchingContainer = element.closest('#matching-container');
                    questionEl = matchingContainer ? matchingContainer.closest('.array-item') : 
                                element.closest('.array-item');
                }
                
                if (questionEl) {
                    // Use setTimeout to ensure DOM is fully updated before updating UI
                    setTimeout(() => {
                        // Update matching item numbers if we have the side
                        if (action && action.side) {
                            updateMatchingItemNumbers(questionEl, action.side);
                        }
                        // Update relationship UI to refresh dropdown options
                        updateRelationshipUI(questionEl);
                    }, 0);
                }
            }
        }
        
        // Helper function to restore section content from a cloned element
        function restoreSectionContent(targetElement, sourceElement) {
            // Replace innerHTML to restore structure
            targetElement.innerHTML = sourceElement.innerHTML;
            
            // Restore all input, textarea, and select values
            // We need to match them carefully since structure might be the same
            const sourceInputs = Array.from(sourceElement.querySelectorAll('input, textarea, select'));
            const targetInputs = Array.from(targetElement.querySelectorAll('input, textarea, select'));
            
            // Match inputs by their position in the DOM tree
            sourceInputs.forEach((sourceInput, index) => {
                if (index < targetInputs.length) {
                    const targetInput = targetInputs[index];
                    const sourceType = sourceInput.type || '';
                    const sourceTag = sourceInput.tagName.toLowerCase();
                    
                    // Restore value based on input type
                    if (sourceType === 'checkbox' || sourceType === 'radio') {
                        targetInput.checked = sourceInput.checked;
                        // Trigger change event
                        targetInput.dispatchEvent(new Event('change', { bubbles: true }));
                    } else if (sourceTag === 'select') {
                        targetInput.value = sourceInput.value;
                        // Trigger change event for selects (important for question type toggles)
                        targetInput.dispatchEvent(new Event('change', { bubbles: true }));
                    } else {
                        // For text inputs and textareas
                        targetInput.value = sourceInput.value;
                        // Trigger input event to update previews
                        targetInput.dispatchEvent(new Event('input', { bubbles: true }));
                }
            }
        });
        }
        
        // Initialize undo/redo buttons on page load
        updateUndoRedoButtons();
        
        // Session tracking
        let sessionStartTime = Date.now();
        
        // Track session duration
        function trackSessionDuration(context = 'periodic') {
            const sessionDuration = Math.round((Date.now() - sessionStartTime) / 1000); // Duration in seconds
            const sessionDurationMinutes = Math.round(sessionDuration / 60 * 10) / 10;
            
            trackEvent('session_duration', {
                session_duration_seconds: sessionDuration,
                session_duration_minutes: sessionDurationMinutes,
                context: context
            });
        }
        
        // Start a new session (reset start time and track event)
        function startNewSession(context = 'page_load') {
            sessionStartTime = Date.now();
            trackEvent('session_started', {
                timestamp: new Date().toISOString(),
                context: context
            });
        }
        
        // Track session duration every 5 minutes
        setInterval(() => {
            trackSessionDuration('periodic');
        }, 5 * 60 * 1000); // 5 minutes
        
        // Track session end on page unload
        window.addEventListener('beforeunload', () => {
            const sessionDuration = Math.round((Date.now() - sessionStartTime) / 1000); // Duration in seconds
            const sessionDurationMinutes = Math.round(sessionDuration / 60 * 10) / 10;
            
            // Track final session duration
            trackEvent('session_ended', {
                session_duration_seconds: sessionDuration,
                session_duration_minutes: sessionDurationMinutes
            });
        });
        
        // Track initial session start on page load
        startNewSession('page_load');
        
        // Categorize and count validation errors
        function categorizeValidationErrors(validationErrors) {
            const categories = {
                required_field: 0,
                block_latex: 0,
                image_description: 0,
                quote_error: 0,
                dollar_sign: 0,
                table_markdown: 0,
                list_markdown: 0,
                blockquote_markdown: 0,
                html_tag: 0,
                image_reference: 0,
                image_mismatch: 0,
                image_numbering: 0,
                question_id: 0,
                question_text: 0,
                guide_answer: 0,
                guide_pdf_page: 0,
                blank_format: 0,
                matching_format: 0,
                choice_format: 0,
                duplicate_id: 0,
                other: 0
            };
            
            validationErrors.forEach(error => {
                const errorLower = error.toLowerCase();
                if (errorLower.includes('required') || errorLower.includes('missing')) {
                    if (errorLower.includes('question id')) categories.question_id++;
                    else if (errorLower.includes('question text')) categories.question_text++;
                    else if (errorLower.includes('guide answer')) categories.guide_answer++;
                    else if (errorLower.includes('guide pdf page') || errorLower.includes('guide page')) categories.guide_pdf_page++;
                    else if (errorLower.includes('content')) categories.required_field++;
                    else categories.required_field++;
                } else if (errorLower.includes('block latex') || errorLower.includes('block laTeX')) {
                    categories.block_latex++;
                } else if (errorLower.includes('image description')) {
                    categories.image_description++;
                } else if (errorLower.includes('quote error')) {
                    categories.quote_error++;
                } else if (errorLower.includes('dollar sign')) {
                    categories.dollar_sign++;
                } else if (errorLower.includes('table markdown')) {
                    categories.table_markdown++;
                } else if (errorLower.includes('list markdown')) {
                    categories.list_markdown++;
                } else if (errorLower.includes('blockquote markdown')) {
                    categories.blockquote_markdown++;
                } else if (errorLower.includes('html tag') || errorLower.includes('<br>')) {
                    categories.html_tag++;
                } else if (errorLower.includes('image') && (errorLower.includes('not being used') || errorLower.includes('missing') || errorLower.includes('not found'))) {
                    categories.image_reference++;
                } else if (errorLower.includes('image') && (errorLower.includes('mismatch') || errorLower.includes('count'))) {
                    categories.image_mismatch++;
                } else if (errorLower.includes('image') && (errorLower.includes('number') || errorLower.includes('skip') || errorLower.includes('order'))) {
                    categories.image_numbering++;
                } else if (errorLower.includes('blank') || errorLower.includes('fill in the blank')) {
                    categories.blank_format++;
                } else if (errorLower.includes('matching')) {
                    categories.matching_format++;
                } else if (errorLower.includes('choice') || errorLower.includes('checkbox') || errorLower.includes('multiple choice')) {
                    categories.choice_format++;
                } else if (errorLower.includes('duplicate')) {
                    categories.duplicate_id++;
                } else {
                    categories.other++;
                }
            });
            
            return categories;
        }
        
        // Get current form statistics with section sizes
        function getFormStats() {
            const questions = document.querySelectorAll('#questions_container > .array-item');
            const contentSections = document.querySelectorAll('#content_sections_container > .array-item');
            
            const questionTypes = {};
            const questionSizes = [];
            const contentSectionSizes = [];
            
            questions.forEach(q => {
                const typeSelect = q.querySelector('select[onchange*="toggleQuestionType"]');
                const type = typeSelect ? typeSelect.value : 'unknown';
                questionTypes[type] = (questionTypes[type] || 0) + 1;
                
                // Calculate question size (sum of all text fields)
                let questionSize = 0;
                const questionText = q.querySelector('textarea[placeholder*="Enter question text"]');
                const setupText = q.querySelector('textarea[placeholder*="Enter set-up text"]');
                const guideAnswer = q.querySelector('#guide-answer-container textarea, .guide-answer-notes');
                
                if (questionText) questionSize += (questionText.value || '').length;
                if (setupText) questionSize += (setupText.value || '').length;
                if (guideAnswer) questionSize += (guideAnswer.value || '').length;
                
                questionSizes.push(questionSize);
            });
            
            contentSections.forEach(section => {
                // Calculate content section size
                let sectionSize = 0;
                const sectionTitle = section.querySelector('input[placeholder="Section title"]');
                const sectionText = section.querySelector('textarea[placeholder*="Enter content"]');
                
                if (sectionTitle) sectionSize += (sectionTitle.value || '').length;
                if (sectionText) sectionSize += (sectionText.value || '').length;
                
                contentSectionSizes.push(sectionSize);
            });
            
            // Calculate averages
            const avgQuestionSize = questionSizes.length > 0 
                ? Math.round(questionSizes.reduce((a, b) => a + b, 0) / questionSizes.length) 
                : 0;
            const avgContentSectionSize = contentSectionSizes.length > 0 
                ? Math.round(contentSectionSizes.reduce((a, b) => a + b, 0) / contentSectionSizes.length) 
                : 0;
            
            return {
                totalQuestions: questions.length,
                totalContentSections: contentSections.length,
                questionTypes: questionTypes,
                avgQuestionSize: avgQuestionSize,
                avgContentSectionSize: avgContentSectionSize,
                totalQuestionSize: questionSizes.reduce((a, b) => a + b, 0),
                totalContentSectionSize: contentSectionSizes.reduce((a, b) => a + b, 0)
            };
        }
    </script>
    
    <title>Math Textbook Transcription Workflow</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/marked@12.0.2/lib/marked.umd.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            width: 100%;
            max-width: 100%;
            overflow-x: hidden; /* Prevent horizontal scrollbar */
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-primary);
            min-height: 100vh;
            padding: 0;
            margin: 0;
            width: 100%;
            max-width: 100%;
            overflow-x: hidden; /* Prevent horizontal scrollbar */
        }

        .container {
            width: 100%;
            max-width: 100%;
            margin: 0;
            background: white;
            border-radius: 0;
            box-shadow: none;
            overflow: hidden;
            min-height: 100vh;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 4px 15px;
            text-align: center;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            padding: 0 min(10px, 1vw); /* Responsive padding */
            max-width: 100%;
            margin: 0;
            gap: min(15px, 1.5vw); /* Responsive gap */
        }
        
        /* Optimize header spacing for zoomed states */
        @media (max-width: 1400px) {
            .header-content {
                padding: 0 8px;
                gap: 10px;
            }
        }
        
        @media (max-width: 1200px) {
            .header-content {
                padding: 0 6px;
                gap: 8px;
            }
        }

        .header-text {
            flex: 1;
            text-align: left;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .header-title {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .header-meta {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.65rem;
            opacity: 0.8;
        }

        .dark-mode-toggle {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            width: 32px;
            height: 32px;
            padding: 0;
            border-radius: 50%;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        
        .dark-mode-toggle i {
            font-size: 0.85rem;
            line-height: 1;
        }

        .dark-mode-toggle:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
            transform: scale(1.1);
        }

        .dark-mode-toggle:active {
            transform: scale(0.95);
        }

        .auto-save-indicator {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.7rem;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .auto-save-indicator.saving {
            background: rgba(255, 193, 7, 0.2);
            border-color: rgba(255, 193, 7, 0.5);
            color: #ffc107;
            font-weight: 600;
            animation: pulse 2s infinite;
        }

        .auto-save-indicator.saved {
            background: rgba(40, 167, 69, 0.2);
            border-color: rgba(40, 167, 69, 0.5);
            color: #28a745;
            font-weight: 600;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .header h1 {
            font-size: 0.9rem;
            margin: 0;
            font-weight: 700;
        }

        .header p {
            font-size: 0.7rem;
            opacity: 0.85;
            margin: 0;
            white-space: nowrap;
        }

        .workflow-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: min(15px, 1.5vw); /* Responsive gap that scales with viewport */
            padding: min(15px, 1.5vw); /* Responsive padding */
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
            align-items: start; /* Align items to top */
            min-height: calc(100vh - 200px); /* Ensure container has minimum height */
        }
        
        /* Ensure columns don't grow beyond their allocated space */
        .workflow-container > * {
            min-width: 0; /* Allow flex/grid children to shrink below content size */
            max-width: 100%;
            box-sizing: border-box;
        }
        
        /* Left column - scrollable */
        .workflow-container > .form-section:not(.toggle-section) {
            max-height: calc(100vh - 75px);
            overflow-y: auto;
            overflow-x: hidden;
            position: relative;
        }
        
        /* Right column - sticky and independently scrollable */
        .workflow-container > .form-section.toggle-section {
            position: sticky;
            top: min(15px, 1.5vw); /* Responsive top offset */
            align-self: start;
            max-height: calc(200vh - 75px); /* Increased to 2x viewport for more expansion */
            height: calc(100vh - 75px);
            overflow: hidden; /* Let child panels handle scrolling */
            display: flex;
            flex-direction: column;
        }
        
        /* Use full width at all zoom levels - remove max-width restrictions */
        @media (min-width: 1920px) {
            .workflow-container {
                max-width: 100%; /* Use full width instead of 95% */
                margin: 0;
                padding: min(20px, 2vw); /* Slightly more padding on very large screens */
            }
            
            .header-content {
                max-width: 100%; /* Use full width instead of 95% */
                margin: 0;
                padding: 0 min(30px, 3vw); /* Responsive padding */
            }
        }
        
        /* Optimize for zoomed-in states (smaller effective viewport) */
        @media (max-width: 1400px) {
            .workflow-container {
                gap: 10px;
                padding: 10px;
            }
            
            .workflow-container > .form-section.toggle-section {
                top: 10px;
            }
        }
        
        /* Further optimize for highly zoomed states */
        @media (max-width: 1200px) {
            .workflow-container {
                gap: 8px;
                padding: 8px;
            }
        }
        

        .form-section {
            background: #f8f9fa;
            border-radius: 12px;
            padding: min(15px, 1.5vw); /* Responsive padding */
            border: 2px solid #e9ecef;
            min-width: 0; /* Allow flex/grid children to shrink */
            max-width: 100%; /* Prevent expansion beyond column */
            box-sizing: border-box;
        }
        
        /* Reduce padding on smaller viewports (zoomed in) */
        @media (max-width: 1400px) {
            .form-section {
                padding: 10px;
            }
        }
        
        @media (max-width: 1200px) {
            .form-section {
                padding: 8px;
            }
        }

        .form-section h2 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 1rem;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .form-section h2 i {
            font-size: 0.9rem;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #495057;
        }

        .form-group input, .form-group textarea, .form-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            font-size: 14px;
            line-height: 1.5;
            transition: border-color 0.3s ease;
            font-feature-settings: "kern" 1, "liga" 1; /* Better character spacing */
            text-rendering: optimizeLegibility; /* Better diacritic rendering */
        }

        .form-group input[type="checkbox"] {
            width: auto;
            height: 18px;
            width: 18px;
            margin: 0;
            cursor: pointer;
            accent-color: #667eea;
        }

        .form-group.checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
        }

        .form-group.checkbox-group label {
            margin: 0;
            cursor: pointer;
            font-weight: 600;
            color: #495057;
            user-select: none;
        }

        .form-group input:focus, .form-group textarea:focus, .form-group select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        /* Default RTL direction for content textareas (Arabic content) */
        .form-group textarea:not([data-ltr="true"]), 
        .form-group input[type="text"]:not([data-ltr="true"]) {
            direction: rtl !important;
            text-align: right !important;
        }
        
        /* Default LTR direction for ID fields and standards (English/technical content) */
        .form-group textarea[data-ltr="true"], 
        .form-group input[type="text"][data-ltr="true"] {
            direction: ltr !important;
            text-align: left !important;
        }

        .form-group textarea {
            min-height: 80px;
            max-height: none;
            resize: vertical;
            overflow-y: auto; /* Show scrollbar when content exceeds height */
            box-sizing: border-box;
        }

        .array-item {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            position: relative;
        }

        .array-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .row-actions { display: inline-flex; gap: 8px; align-items: center; margin-top: 8px; }

        .remove-btn {
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
        }

        .reorder-btn {
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            transition: background-color 0.3s ease;
        }

        .reorder-btn:hover {
            background: #5a6268;
        }

        .reorder-btn:disabled {
            background: #adb5bd;
            cursor: not-allowed;
            opacity: 0.5;
        }

        .array-item-header-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .collapse-btn {
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }

        .collapse-btn:hover {
            background: #5a6268;
        }

        .array-item.collapsed .section-content {
            display: none;
        }

        .array-item.collapsed .collapse-btn i {
            transform: rotate(-90deg);
        }

        .copy-section-btn {
            background: #17a2b8;
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            transition: background-color 0.3s ease;
        }

        .copy-section-btn:hover {
            background: #138496;
        }

        .paste-section-btn {
            background: #17a2b8;
        }

        .paste-section-btn:hover {
            background: #138496;
        }

        .paste-replace-btn {
            background: #ffc107;
        }

        .paste-replace-btn:hover {
            background: #e0a800;
        }

        .duplicate-btn {
            background: #6f42c1;
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            transition: background-color 0.3s ease;
        }

        .duplicate-btn:hover {
            background: #5a32a3;
        }

        .add-btn {
            background: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 12px;
            cursor: pointer;
            font-weight: 500;
            font-size: 0.7rem;
            display: inline-flex;
            align-items: center;
            gap: 3px;
            transition: background-color 0.3s ease;
        }
        
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-top: 15px;
            margin-bottom: 15px;
        }

        .add-btn:hover {
            background: #218838;
        }

        /* Add-bbox-btn and add-section-btn inherit from add-btn but can be customized */
        .add-bbox-btn,
        .add-section-btn {
            background: #17a2b8;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 12px;
            cursor: pointer;
            font-weight: 500;
            font-size: 0.7rem;
            display: inline-flex;
            align-items: center;
            gap: 3px;
            transition: background-color 0.3s ease;
        }

        .add-bbox-btn:hover,
        .add-section-btn:hover {
            background: #138496;
        }

        .bbox-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr 1fr;
            gap: 8px;
            margin-bottom: 10px;
        }

        .bbox-inputs input {
            padding: 8px;
            font-size: 12px;
        }

        .bbox-container {
            margin-bottom: 15px;
        }

        .text-field-container {
            position: relative;
        }

        .text-field-container textarea {
            margin-bottom: 8px;
        }

        /* Live rendered preview under each textarea */
        .live-preview {
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 12px;
            background: #ffffff;
            color: #212529;
            font-size: 14px;
            line-height: 1.5;
            position: relative;
            min-height: 80px;
            height: auto; /* Match content size, managed by JS */
            max-height: none; /* Allow unlimited expansion */
            resize: vertical;
            overflow-y: auto;
            overflow-x: hidden;
            font-feature-settings: "kern" 1, "liga" 1; /* Better character spacing */
            text-rendering: optimizeLegibility; /* Better diacritic rendering */
        }
        
        .preview-label {
            font-size: 11px;
            font-weight: 600;
            color: #667eea !important;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
            display: block;
            opacity: 0.9;
        }
        
        /* Prevent required asterisk on preview labels */
        .preview-label::after {
            content: none !important;
        }
        
        .input-label {
            font-size: 11px;
            font-weight: 600;
            color: #667eea;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
            display: block;
            opacity: 0.9;
        }
        .live-preview table { border-collapse: collapse; width: 100%; margin: 8px 0; }
        .live-preview th, .live-preview td { border: 1px solid #ccc; padding: 6px 8px; }
        /* Respect markdown alignment; provide a default only when none specified */
        .live-preview th:not([align]), .live-preview td:not([align]) { text-align: start; }
        /* Default direction will be set dynamically based on content type */
        .live-preview blockquote { border-left: 4px solid #667eea; margin: 8px 0; padding: 6px 10px; color: #495057; background: #f8f9fa; }
        /* List styling to ensure proper visibility */
        .live-preview ul, .live-preview ol { margin: 8px 0; padding-left: 30px; }
        .live-preview ul { list-style-type: disc; }
        .live-preview ol { list-style-type: decimal; }
        .live-preview li { margin: 4px 0; display: list-item; }
        .live-preview ul ul { list-style-type: circle; margin: 4px 0; }
        .live-preview ul ul ul { list-style-type: square; }
        .live-preview ol ol { list-style-type: lower-alpha; }
        .live-preview ol ol ol { list-style-type: lower-roman; }
        /* RTL list styling */
        .live-preview[dir="rtl"] ul,
        .live-preview[dir="rtl"] ol { padding-left: 0; padding-right: 30px; }
        .live-preview[dir="rtl"] ul ul,
        .live-preview[dir="rtl"] ol ol { padding-left: 0; padding-right: 30px; }
        /* Keep KaTeX math LTR even when container is RTL */
        /* Force all LaTeX elements to be LTR regardless of parent direction */
        .live-preview .__math_block,
        .live-preview .__math_inline,
        .live-preview .katex,
        .live-preview .katex *,
        .live-preview[dir="rtl"] .__math_block,
        .live-preview[dir="rtl"] .__math_inline,
        .live-preview[dir="rtl"] .katex,
        .live-preview[dir="rtl"] .katex * {
            direction: ltr !important;
            unicode-bidi: isolate !important;
        }
        .live-preview[dir="rtl"] .katex-display { direction: ltr !important; }
        /* Force image descriptions to always be LTR regardless of parent direction */
        .live-preview .image-description-math,
        .live-preview[dir="rtl"] .image-description-math,
        .choice-preview-mini .image-description-math,
        .choice-preview-mini[dir="rtl"] .image-description-math {
            direction: ltr !important;
            unicode-bidi: isolate !important;
        }
        /* Center LaTeX block math */
        .live-preview .__math_block {
            text-align: center !important;
            margin: 1em auto !important;
            display: block !important;
        }
        .live-preview .katex-display {
            text-align: center !important;
            margin: 1em auto !important;
            display: block !important;
        }
        /* Ensure KaTeX math blocks are centered even in RTL containers */
        .live-preview[dir="rtl"] .__math_block,
        .live-preview[dir="rtl"] .katex-display {
            text-align: center !important;
            margin: 1em auto !important;
        }
        /* Force centering for all math elements */
        .live-preview .katex,
        .live-preview .katex * {
            text-align: center !important;
        }
        /* Override any inherited text alignment for math blocks */
        .live-preview div[class*="math"],
        .live-preview div[class*="katex"] {
            text-align: center !important;
            margin: 1em auto !important;
        }
        /* Additional centering for math containers */
        .live-preview .__math_block {
            width: 100% !important;
            text-align: center !important;
        }
        /* Math block error styling */
        .live-preview .__math_block_error {
            color: #d32f2f !important;
            background-color: #ffebee !important;
            border: 2px solid #f44336 !important;
            padding: 12px !important;
            margin: 10px 0 !important;
            border-radius: 6px !important;
            font-family: 'Courier New', monospace !important;
            font-size: 14px !important;
            line-height: 1.4 !important;
            text-align: left !important;
        }
        .live-preview .__math_block_error strong {
            color: #b71c1c !important;
        }
        .live-preview .__math_block_error code {
            background-color: #f5f5f5 !important;
            padding: 2px 4px !important;
            border-radius: 3px !important;
            font-family: 'Courier New', monospace !important;
            color: #d32f2f !important;
        }
        .live-preview .katex-display {
            width: 100% !important;
            text-align: center !important;
        }
        /* Make math reflect Markdown emphasis when wrapped by <strong>/<em> */
        .live-preview strong .katex, .live-preview b .katex { font-weight: 700; }
        .live-preview em .katex, .live-preview i .katex { font-style: italic; }

        /* Ensure LaTeX in Correct Answer Position preview is always LTR */
        /* Only apply block styles to actual block math elements */
        .choice-preview-mini .__math_block,
        .choice-preview-mini .katex-display {
            direction: ltr !important;
            unicode-bidi: isolate !important;
            text-align: center !important;
            margin: 1em auto !important;
            display: block !important;
        }
        .choice-preview-mini .__math_inline,
        .choice-preview-mini .katex,
        .choice-preview-mini .katex * {
            direction: ltr !important;
            unicode-bidi: isolate !important;
        }
        .choice-preview-mini[dir="rtl"] .__math_block,
        .choice-preview-mini[dir="rtl"] .__math_inline,
        .choice-preview-mini[dir="rtl"] .katex,
        .choice-preview-mini[dir="rtl"] .katex *,
        .choice-preview-mini[dir="rtl"] .katex-display {
            direction: ltr !important;
            unicode-bidi: isolate !important;
            text-align: center !important;
        }
        /* Inline math should stay inline and flow with text */
        .choice-preview-mini .__math_inline {
            direction: ltr !important;
            display: inline !important;
        }
        /* Don't apply block styles to katex-html (used in inline math) */
        .choice-preview-mini .katex-html {
            direction: ltr !important;
        }

        .markdown-btn {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.7rem;
            font-weight: 500;
            transition: background-color 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 3px;
            line-height: 1;
            height: auto;
            min-height: auto;
        }
        .markdown-btn:hover {
            background: var(--bg-tertiary);
            border-color: var(--accent);
        }
        .markdown-btn:active {
            transform: scale(0.95);
        }
        .table-btn {
            background: #17a2b8;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 0.7rem;
            font-weight: 500;
            display: inline-flex;
            align-items: center;
            gap: 3px;
            transition: background-color 0.3s ease;
            line-height: 1;
            height: auto;
            min-height: auto;
        }

        .table-btn:hover {
            background: #138496;
        }

        .image-btn {
            background: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 0.7rem;
            font-weight: 500;
            display: inline-flex;
            align-items: center;
            gap: 3px;
            transition: background-color 0.3s ease;
            line-height: 1;
            height: auto;
            min-height: auto;
        }

        /* Buttons between textarea and preview styling */
        .text-field-container button {
            margin-top: 8px;
            margin-bottom: 8px;
            margin-right: 5px;
        }
        
        /* First button should have more left margin to space from red line */
        .text-field-container button:first-of-type {
            margin-left: 8px;
        }
        
        /* Last button should not have right margin */
        .text-field-container button:last-of-type {
            margin-right: 0;
        }
        
        .text-field-container textarea {
            margin-top: 0;
            margin-bottom: 0;
        }

        .image-btn:hover {
            background: #1e7e34;
        }

        .blank-btn {
            background: #17a2b8;
            color: white;
            border: none;
            padding: 4px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.7rem;
            font-weight: 500;
            display: inline-flex;
            align-items: center;
            gap: 3px;
            transition: background-color 0.3s ease;
        }

        .blank-btn:hover {
            background: #138496;
        }

        .dir-btn {
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 0.7rem;
            font-weight: 500;
            display: inline-flex;
            align-items: center;
            gap: 3px;
            transition: background-color 0.3s ease;
            line-height: 1;
            height: auto;
            min-height: auto;
        }
        .dir-btn:hover { background: #5a6268; }

        .json-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }


        .json-preview {
            background: #2d3748;
            color: #e2e8f0;
            border-radius: 15px;
            padding: 25px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.6;
            overflow-x: auto;
            max-height: 600px;
            overflow-y: auto;
            border: 1px solid #4a5568;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .json-key {
            color: #81e6d9;
        }

        .json-string {
            color: #feb2b2;
        }

        .json-number {
            color: #90cdf4;
        }

        .json-boolean {
            color: #fbb6ce;
        }

        .json-null {
            color: #a0aec0;
        }

        .json-preview-content {
            color: #e2e8f0;
            line-height: 1.6;
        }
        
        /* Enhanced JSON formatting styles */
        .json-bracket {
            color: #e2e8f0;
            font-weight: bold;
        }
        
        .json-colon {
            color: #e2e8f0;
            margin: 0 2px;
        }
        
        .json-comma {
            color: #e2e8f0;
            margin-right: 4px;
        }
        
        .json-indent {
            color: transparent;
            user-select: none;
        }
        
        /* Improve overall JSON readability */
        .json-preview {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            line-height: 1.6;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        /* JSON syntax highlighting improvements */
        .json-key {
            color: #81e6d9;
            font-weight: 600;
        }
        
        .json-string {
            color: #feb2b2;
        }
        
        .json-number {
            color: #90cdf4;
            font-weight: 600;
        }
        
        .json-boolean {
            color: #fbb6ce;
            font-weight: 600;
        }
        
        .json-null {
            color: #a0aec0;
            font-style: italic;
        }
        
        /* Hover effects for better interaction */
        .json-preview:hover {
            border-color: #4a5568;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.4);
        }

        .preview-section {
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            border-left: 3px solid #667eea;
        }

        .preview-indent {
            margin-left: 20px;
            margin-bottom: 8px;
            padding: 5px 0;
        }

        .preview-indent-double {
            margin-left: 40px;
            margin-bottom: 8px;
            padding: 5px 0;
            color: #cbd5e0;
            font-style: italic;
        }

        .validation-error {
            border-color: #dc3545 !important;
            box-shadow: 0 0 0 0.2rem rgba(220, 53, 69, 0.25);
        }

        /* Validation success styling removed per user request - green checkmark indicator removed */

        .required-field {
            border-left: 3px solid #dc3545;
        }

        .required-field label::after {
            content: " *";
            color: #dc3545;
            font-weight: bold;
        }

        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 2px solid #e9ecef;
        }
        .tabs.main-tabs {
            border-bottom: 3px solid #667eea;
            margin-bottom: 20px;
        }

        .tab {
            padding: 6px 14px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 600;
            color: #6c757d;
            border-bottom: 2px solid transparent;
            transition: all 0.3s ease;
        }

        .tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }
        .main-tab-content {
            display: none;
        }
        .main-tab-content.active {
            display: block;
        }
        .main-tab-content#final-preview.active {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 135px); /* 75px (header) + 60px (main tabs + margin) */
            min-height: 0;
        }
        .final-preview-container {
            flex: 1;
            min-height: 0;
            overflow-y: auto;
            padding: 16px;
            background: var(--bg-primary);
        }
        .final-preview-section {
            margin-bottom: 32px;
            padding: 20px;
            background: var(--bg-secondary);
            border-radius: 8px;
            border: 2px solid var(--border-color);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        [data-theme="dark"] .final-preview-section {
            border: 2px solid #4a5568;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            background: #2d3748;
        }
        .final-preview-section h3 {
            margin-top: 0;
            margin-bottom: 16px;
            color: var(--accent);
            font-size: 1.2rem;
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 8px;
        }
        .final-preview-section h4 {
            margin-top: 0;
            margin-bottom: 12px;
            color: var(--text-primary);
            font-size: 1.1rem;
        }
        .final-preview-question {
            margin-bottom: 24px;
            padding: 16px;
            background: white;
            border-radius: 6px;
            border: 2px solid #e0e0e0;
            border-left: 4px solid var(--accent);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12);
        }
        .final-preview-question h4 {
            margin-top: 0;
            margin-bottom: 12px;
            color: var(--accent);
        }
        .final-preview-question .question-type-badge {
            display: inline-block;
            padding: 4px 8px;
            background: var(--accent);
            color: white;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
            margin-top: 4px;
            margin-bottom: 12px;
        }
        .final-preview-question .preview-section {
            margin-bottom: 16px;
        }
        .final-preview-question .preview-section-label {
            margin: 0 0 8px 0;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .final-preview-section .preview-section-label {
            margin: 0 0 8px 0;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .final-preview-section .preview-section {
            margin-bottom: 16px;
        }
        .final-preview-section .setup-text {
            margin-bottom: 0;
            padding: 0;
            background: none;
            border-radius: 0;
            border: none;
        }
        .final-preview-question .setup-text {
            margin-bottom: 0;
            padding: 0;
            background: none;
            border-radius: 0;
            border: none;
        }
        .final-preview-question .question-text {
            margin-bottom: 0;
            padding: 0;
            font-weight: normal;
            color: var(--text-primary);
        }
        .final-preview-question .choices-container {
            margin: 0;
        }
        .final-preview-question .choice-item {
            padding: 8px 12px;
            margin: 8px 0;
            background: #f8f9fa;
            border-radius: 4px;
            border-left: 3px solid #dee2e6;
        }
        .final-preview-question .choice-item.correct {
            background: #d4edda;
            border-left-color: #28a745;
        }
        .final-preview-question .choice-item .choice-id {
            font-weight: 600;
            color: var(--accent);
            margin-right: 8px;
        }
        .final-preview-question .blanks-container {
            margin: 0;
        }
        .final-preview-question .choices-container {
            margin: 0;
        }
        .final-preview-question .blank-answer {
            padding: 8px 12px;
            margin: 8px 0;
            background: #fff3cd;
            border-radius: 4px;
            border-left: 3px solid #ffc107;
        }
        .final-preview-question .blank-answer .blank-number {
            font-weight: 600;
            color: #856404;
            margin-right: 8px;
        }
        .final-preview-question .blank-answer {
            text-decoration: none;
        }
        .final-preview-question .blank-answer * {
            text-decoration: none;
        }
        .final-preview-question .matching-container {
            margin: 16px 0;
        }
        .final-preview-question .matching-items {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            margin: 16px 0;
        }
        .final-preview-question .matching-side {
            padding: 12px;
            background: #f8f9fa;
            border-radius: 4px;
        }
        .final-preview-question .matching-side h5 {
            margin-top: 0;
            margin-bottom: 12px;
            font-size: 0.9rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            font-weight: 600;
        }
        .final-preview-question .matching-item {
            padding: 8px;
            margin: 6px 0;
            background: white;
            border-radius: 4px;
            border: 1px solid #dee2e6;
            word-wrap: break-word;
            overflow-wrap: break-word;
            word-break: break-word;
            max-width: 100%;
            box-sizing: border-box;
        }
        .final-preview-question .matching-item .live-preview {
            max-width: 100%;
            overflow-wrap: break-word;
            word-wrap: break-word;
            word-break: break-word;
        }
        .final-preview-question .matching-side {
            min-width: 0;
            overflow: hidden;
        }
        .final-preview-question .matching-items {
            overflow: hidden;
        }
        .final-preview-question .matching-relationships {
            margin-top: 16px;
            padding: 12px;
            background: #e7f3ff;
            border-radius: 4px;
        }
        .final-preview-question .matching-relationships h5 {
            margin-top: 0;
            margin-bottom: 8px;
            font-size: 0.9rem;
            color: #0056b3;
        }
        .final-preview-question .relationship-item {
            padding: 6px;
            margin: 4px 0;
            background: white;
            border-radius: 4px;
        }
        .final-preview-question .guide-answer {
            margin-top: 0;
            margin-bottom: 0;
            padding: 0;
            background: none;
            border-radius: 0;
            border: none;
        }
        .final-preview-question .guide-answer .preview-section-label {
            margin: 0 0 8px 0;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        [data-theme="dark"] .final-preview-question {
            background: #2d3748;
            color: var(--text-primary);
            border: 2px solid #4a5568;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.4);
        }
        [data-theme="dark"] .final-preview-question .setup-text {
            background: none;
            border: none;
        }
        [data-theme="dark"] .final-preview-question .preview-section-label {
            color: #a0aec0;
        }
        [data-theme="dark"] .final-preview-question .choice-item {
            background: #2d3238;
            border-left-color: #6c757d;
        }
        [data-theme="dark"] .final-preview-question .choice-item.correct {
            background: #1e4620;
            border-left-color: #28a745;
        }
        [data-theme="dark"] .final-preview-question .blank-answer {
            background: #3d3520;
            border-left-color: #ffc107;
        }
        [data-theme="dark"] .final-preview-question .matching-side {
            background: #2d3238;
        }
        [data-theme="dark"] .final-preview-question .matching-item {
            background: #1e1e1e;
            border-color: #6c757d;
        }
        [data-theme="dark"] .final-preview-question .matching-relationships {
            background: #1a3d52;
        }
        [data-theme="dark"] .final-preview-question .relationship-item {
            background: #1e1e1e;
        }
        [data-theme="dark"] .final-preview-question .guide-answer {
            background: none;
            border: none;
        }

        .highlight {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }

        .highlight h4 {
            color: #856404;
            margin-bottom: 10px;
        }

        .highlight p {
            color: #856404;
            margin: 0;
        }

        .generate-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 6px;
            padding: 5px 12px;
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
            width: auto;
            margin-top: 0;
            transition: transform 0.3s ease;
        }

        .generate-btn:hover {
            transform: translateY(-2px);
        }

        /* Embedded BBox Drawer Modal */
        .bbox-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.55); display: none; align-items: center; justify-content: center; z-index: 9999; }
        .bbox-modal.show { display: flex; }
        .bbox-dialog { width: 90vw; height: 88vh; background: var(--bg-primary); color: var(--text-primary); border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,0.4); display: flex; flex-direction: column; overflow: hidden; border: 1px solid var(--border-color); }
        .bbox-toolbar { padding: 10px; background: var(--bg-secondary); display: flex; flex-wrap: wrap; gap: 8px; align-items: center; border-bottom: 1px solid var(--border-color); }
        .bbox-toolbar .group { display:flex; align-items:center; gap:8px; padding-right: 10px; border-right: 1px solid var(--border-color); }
        .bbox-toolbar .group:last-child { border-right: none; }
        .bbox-btn { background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); padding: 4px 8px; border-radius: 6px; cursor: pointer; font-size: 0.8rem; }
        .bbox-btn.primary { background: var(--accent); border-color: var(--accent); }
        .bbox-btn.danger { background: #dc2626; border-color: #dc2626; }
        .bbox-content { flex: 1; display: grid; grid-template-columns: 1fr 340px; gap: 10px; padding: 10px; }
        .bbox-canvas-wrap { position: relative; overflow:auto; background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 10px; }
        .bbox-canvas-wrap canvas { display:block; }
        #em-pdf { background: #ffffff; }
        #em-draw { position:absolute; top:0; left:0; pointer-events:auto; }
        .bbox-sidebar { background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 10px; padding: 10px; display: flex; flex-direction: column; gap: 8px; }
        .bbox-bbox-list { flex:1; overflow:auto; display:flex; flex-direction:column; gap:6px; }
        .bbox-item { padding:6px; border: 1px solid var(--border-color); border-radius: 8px; background: var(--bg-primary); display: flex; justify-content: space-between; align-items: center; gap: 8px; }
        .bbox-footer { padding: 10px; background: var(--bg-secondary); border-top: 1px solid var(--border-color); display: flex; justify-content: flex-end; gap: 10px; position: sticky; bottom: 0; z-index: 2; }
        /* Ensure the PDF area scrolls independently while footer stays visible */
        .bbox-content { overflow: hidden; }
        .bbox-canvas-wrap { height: 100%; overscroll-behavior: contain; }

        @media (max-width: 768px) {
            .workflow-container {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2rem;
            }

            .header-content {
                flex-direction: column;
                gap: 20px;
            }
        }

        /* Dark Mode Styles */
        :root {
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --bg-tertiary: #e9ecef;
            --text-primary: #212529;
            --text-secondary: #6c757d;
            --border-color: #dee2e6;
            --shadow: rgba(0,0,0,0.1);
            --accent: #667eea;
            --accent-dark: #764ba2;
        }

        [data-theme="dark"] {
            --bg-primary: #1a1a1a;
            --bg-secondary: #2d2d2d;
            --bg-tertiary: #3d3d3d;
            --text-primary: #ffffff;
            --text-secondary: #b0b0b0;
            --border-color: #4a4a4a;
            --shadow: rgba(0,0,0,0.3);
            --accent: #667eea;
            --accent-dark: #764ba2;
        }

        [data-theme="dark"] body {
            background: #000000;
        }

        [data-theme="dark"] .container {
            background: #000000;
            color: var(--text-primary);
        }

        [data-theme="dark"] .form-section,
        [data-theme="dark"] .preview-section {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
        }

        [data-theme="dark"] .form-group input,
        [data-theme="dark"] .form-group textarea,
        [data-theme="dark"] .form-group select {
            background: var(--bg-primary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        [data-theme="dark"] .form-group input:focus,
        [data-theme="dark"] .form-group textarea:focus,
        [data-theme="dark"] .form-group select:focus {
            border-color: var(--accent);
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.2);
        }

        [data-theme="dark"] .form-group.checkbox-group label {
            color: var(--text-primary);
        }

        [data-theme="dark"] .btn {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        [data-theme="dark"] .btn:hover {
            background: var(--accent);
            color: white;
        }

        [data-theme="dark"] .btn.primary {
            background: var(--accent);
            color: white;
        }

        [data-theme="dark"] .btn.primary:hover {
            background: var(--accent-dark);
        }

        [data-theme="dark"] .highlight {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
        }

        [data-theme="dark"] .array-item {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
        }

        [data-theme="dark"] .bbox-container {
            background: var(--bg-secondary);
        }

        [data-theme="dark"] .bbox-item {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
        }

        [data-theme="dark"] .reorder-btn {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        [data-theme="dark"] .reorder-btn:hover {
            background: #5a6268;
        }

        [data-theme="dark"] .reorder-btn:disabled {
            background: var(--bg-secondary);
            opacity: 0.4;
        }

        [data-theme="dark"] .copy-section-btn {
            background: #17a2b8;
            border: 1px solid var(--border-color);
        }

        [data-theme="dark"] .copy-section-btn:hover {
            background: #138496;
        }

        [data-theme="dark"] .paste-section-btn {
            background: #17a2b8;
        }

        [data-theme="dark"] .paste-section-btn:hover {
            background: #138496;
        }

        [data-theme="dark"] .paste-replace-btn {
            background: #ffc107;
        }

        [data-theme="dark"] .paste-replace-btn:hover {
            background: #e0a800;
        }

        [data-theme="dark"] .duplicate-btn {
            background: #6f42c1;
            border: 1px solid var(--border-color);
        }

        [data-theme="dark"] .duplicate-btn:hover {
            background: #5a32a3;
        }

        [data-theme="dark"] .preview-content {
            background: var(--bg-primary);
            color: var(--text-primary);
        }

        [data-theme="dark"] .json-preview {
            background: var(--bg-primary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        [data-theme="dark"] .json-preview-content {
            color: var(--text-primary);
        }

        [data-theme="dark"] .json-key {
            color: #ff79c6;
        }

        [data-theme="dark"] .json-string {
            color: #f1fa8c;
        }

        [data-theme="dark"] .json-number {
            color: #bd93f9;
        }

        [data-theme="dark"] .json-boolean {
            color: #8be9fd;
        }

        [data-theme="dark"] .json-null {
            color: #6272a4;
        }

        [data-theme="dark"] .preview-indent {
            color: var(--text-secondary);
        }

        [data-theme="dark"] .preview-indent-double {
            color: var(--text-secondary);
        }

        [data-theme="dark"] .dark-mode-toggle {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        [data-theme="dark"] .dark-mode-toggle:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        /* BBox Modal Dark Mode */
        [data-theme="dark"] .bbox-modal {
            background: rgba(0, 0, 0, 0.8);
        }

        [data-theme="dark"] .bbox-dialog {
            background: var(--bg-primary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        [data-theme="dark"] .bbox-toolbar {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
        }

        [data-theme="dark"] .bbox-toolbar .group {
            border-right: 1px solid var(--border-color);
        }

        [data-theme="dark"] .bbox-btn {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        [data-theme="dark"] .bbox-btn:hover {
            background: var(--accent);
            color: white;
        }

        [data-theme="dark"] .bbox-btn.primary {
            background: var(--accent);
            border-color: var(--accent);
        }

        [data-theme="dark"] .bbox-btn.primary:hover {
            background: var(--accent-dark);
        }

        [data-theme="dark"] .bbox-btn.danger {
            background: #dc2626;
            border-color: #dc2626;
        }

        [data-theme="dark"] .bbox-btn.danger:hover {
            background: #b91c1c;
        }

        [data-theme="dark"] .bbox-content {
            background: var(--bg-primary);
        }

        [data-theme="dark"] .bbox-footer {
            background: var(--bg-secondary);
        }

        /* Improved Title Contrast for Dark Mode */
        [data-theme="dark"] h1,
        [data-theme="dark"] h2,
        [data-theme="dark"] h3,
        [data-theme="dark"] h4,
        [data-theme="dark"] h5,
        [data-theme="dark"] h6 {
            color: #ffffff;
            font-weight: 600;
        }

        [data-theme="dark"] .header h1 {
            color: #ffffff;
            font-weight: 700;
        }

        [data-theme="dark"] .header p {
            color: #e5e7eb;
        }
        
        /* What's New Button Styles */
        #whats-new-btn {
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            text-align: center !important;
            padding-left: 8px !important;
            padding-right: 12px !important;
        }
        
        #whats-new-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        
        #whats-new-btn:active {
            transform: translateY(0);
        }
        
        /* What's New Modal Styles */
        .whats-new-modal-content {
            background: white;
            border-radius: 12px;
            max-width: 800px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }
        
        .whats-new-modal-body {
            padding: 30px;
        }
        
        .whats-new-modal-header {
            color: #2c3e50;
        }
        
        .whats-new-modal-list {
            margin: 0;
            padding-left: 25px;
            line-height: 1.8;
            color: #495057;
        }
        
        .whats-new-version-badge {
            color: #666;
            font-size: 0.9rem;
        }
        
        .whats-new-modal-footer {
            border-top: 2px solid #e9ecef;
            padding-top: 20px;
            text-align: center;
            color: #6c757d;
            font-size: 0.9rem;
        }
        
        /* What's New Modal Dark Mode */
        [data-theme="dark"] .whats-new-modal-content {
            background: var(--bg-primary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }
        
        [data-theme="dark"] .whats-new-modal-header {
            color: var(--text-primary);
        }
        
        [data-theme="dark"] .whats-new-modal-list {
            color: var(--text-secondary);
        }
        
        [data-theme="dark"] .whats-new-version-badge {
            color: var(--text-secondary);
        }
        
        [data-theme="dark"] .whats-new-modal-footer {
            border-top-color: var(--border-color);
            color: var(--text-secondary);
        }
        
        [data-theme="dark"] .whats-new-modal-footer a {
            color: var(--accent);
        }
        
        [data-theme="dark"] .whats-new-modal-footer a:hover {
            color: var(--accent-dark);
        }

        [data-theme="dark"] .form-section h3 {
            color: #ffffff;
            font-weight: 600;
        }

        [data-theme="dark"] .form-section h4 {
            color: #f3f4f6;
            font-weight: 600;
        }

        [data-theme="dark"] .form-section label {
            color: #f9fafb;
            font-weight: 500;
        }

        [data-theme="dark"] .tab-button {
            color: #d1d5db;
            font-weight: 500;
        }

        [data-theme="dark"] .tab-button.active {
            color: #ffffff;
            font-weight: 600;
        }

        [data-theme="dark"] .tab-button:hover {
            color: #ffffff;
        }

        /* Live Preview Dark Mode */
        [data-theme="dark"] .live-preview {
            background: var(--bg-primary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            min-height: 80px;
            height: auto; /* Match content size, managed by JS */
            max-height: none; /* Allow unlimited expansion */
            resize: vertical;
            overflow-y: auto;
            overflow-x: hidden;
        }
        
        [data-theme="dark"] .preview-label {
            color: #818cf8 !important;
            opacity: 0.9;
        }
        
        /* Prevent required asterisk on preview labels in dark mode */
        [data-theme="dark"] .preview-label::after {
            content: none !important;
        }
        
        [data-theme="dark"] .input-label {
            color: #818cf8;
        }

        [data-theme="dark"] .live-preview table {
            border-collapse: collapse;
            width: 100%;
            margin: 8px 0;
        }

        [data-theme="dark"] .live-preview th,
        [data-theme="dark"] .live-preview td {
            border: 1px solid var(--border-color);
            padding: 6px 8px;
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        [data-theme="dark"] .live-preview th {
            background: var(--bg-tertiary);
            font-weight: bold;
        }

        [data-theme="dark"] .live-preview blockquote {
            border-left: 4px solid var(--accent);
            margin: 8px 0;
            padding: 6px 10px;
            color: var(--text-secondary);
            background: var(--bg-secondary);
        }

        [data-theme="dark"] .live-preview ul,
        [data-theme="dark"] .live-preview ol {
            margin: 8px 0;
            padding-left: 30px;
        }
        [data-theme="dark"] .live-preview ul { list-style-type: disc; }
        [data-theme="dark"] .live-preview ol { list-style-type: decimal; }
        [data-theme="dark"] .live-preview li { margin: 4px 0; display: list-item; }
        [data-theme="dark"] .live-preview ul ul { list-style-type: circle; margin: 4px 0; }
        [data-theme="dark"] .live-preview ul ul ul { list-style-type: square; }
        [data-theme="dark"] .live-preview ol ol { list-style-type: lower-alpha; }
        [data-theme="dark"] .live-preview ol ol ol { list-style-type: lower-roman; }
        /* RTL list styling in dark mode */
        [data-theme="dark"] .live-preview[dir="rtl"] ul,
        [data-theme="dark"] .live-preview[dir="rtl"] ol { padding-left: 0; padding-right: 30px; }
        [data-theme="dark"] .live-preview[dir="rtl"] ul ul,
        [data-theme="dark"] .live-preview[dir="rtl"] ol ol { padding-left: 0; padding-right: 30px; }

        /* Save indicator dark mode */
        [data-theme="dark"] .auto-save-indicator {
            background: rgba(255, 255, 255, 0.05);
            border-color: rgba(255, 255, 255, 0.2);
        }

        [data-theme="dark"] .auto-save-indicator.saving {
            background: rgba(255, 193, 7, 0.15);
            border-color: rgba(255, 193, 7, 0.4);
            color: #ffc107;
            font-weight: 600;
        }

        [data-theme="dark"] .auto-save-indicator.saved {
            background: rgba(40, 167, 69, 0.15);
            border-color: rgba(40, 167, 69, 0.4);
            color: #4caf50;
            font-weight: 600;
        }

        /* Save button styling */
        #saveBtn {
            transition: all 0.3s ease;
        }

        #saveBtn:hover {
            background: rgba(102, 126, 234, 0.3);
            border-color: rgba(102, 126, 234, 0.5);
        }

        #saveBtn:active {
            transform: scale(0.95);
        }
        
        /* Undo/Redo button styling - match save button style */
        #undo-btn:disabled,
        #redo-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        #undo-btn:not(:disabled):hover,
        #redo-btn:not(:disabled):hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
            transform: scale(1.1);
        }
        
        #undo-btn:not(:disabled):active,
        #redo-btn:not(:disabled):active {
            transform: scale(0.95);
        }

        /* Form Header and Navigation Styles */
        .form-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .navigation-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }


        /* Quick Jump Menu */
        /* Search Results Dropdown */
        /* Search input placeholder styling */
        #searchFilter {
            text-align: left !important;
            direction: ltr !important;
        }
        
        #searchFilter::placeholder {
            text-align: left !important;
            direction: ltr !important;
            font-size: 0.9rem !important; /* Fixed font size for placeholder */
        }
        
        /* Fix font size for search input (not affected by font size selector) */
        #searchFilter {
            font-size: 0.9rem !important; /* Fixed font size to match default */
        }
        
        /* Fix font size for JSON input and its placeholder */
        #json_input {
            font-size: 14px !important; /* Fixed font size to match default */
        }
        
        #json_input::placeholder {
            font-size: 14px !important; /* Fixed font size for placeholder */
        }
        
        .search-results-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            margin-top: 4px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            max-height: 400px;
            overflow-y: auto;
            z-index: 10000;
            font-size: 0.9rem;
        }
        
        .search-result-item {
            padding: 12px;
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .search-result-item:last-child {
            border-bottom: none;
        }
        
        .search-result-item:hover,
        .search-result-item.highlighted {
            background-color: var(--bg-secondary);
        }
        
        .search-result-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .search-result-type {
            font-size: 0.75rem;
            padding: 2px 6px;
            border-radius: 4px;
            background: var(--accent);
            color: white;
            font-weight: 500;
        }
        
        .search-result-preview {
            font-size: 0.85rem;
            color: var(--text-secondary);
            line-height: 1.4;
            margin-top: 4px;
        }
        
        .search-result-preview .highlight {
            background-color: #ffd700;
            color: #000;
            padding: 2px 4px;
            border-radius: 3px;
            font-weight: 600;
        }
        
        .search-result-empty {
            padding: 16px;
            text-align: center;
            color: var(--text-secondary);
            font-style: italic;
        }
        
        [data-theme="dark"] .search-result-preview .highlight {
            background-color: #ffd700;
            color: #000;
        }
        
        .quick-jump select {
            padding: 4px 8px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            background: white;
            color: #495057;
            font-size: 0.75rem;
            cursor: pointer;
            transition: border-color 0.2s ease;
            min-width: 120px;
            max-width: 180px;
        }
        
        /* Quick jump in header - ensure it doesn't expand header */
        .header-content .quick-jump select {
            max-width: 150px;
        }

        .quick-jump select:hover {
            border-color: #667eea;
        }

        .quick-jump select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        /* Header select styling (font size and line height) */
        .header-select {
            background: rgba(255, 255, 255, 0.2) !important;
            border: 1px solid rgba(255, 255, 255, 0.3) !important;
            border-radius: 4px;
            color: white !important;
        }
        
        .header-select option {
            background: #2c3e50;
            color: white;
        }

        /* Dark mode navigation styles */
        [data-theme="dark"] .quick-jump select {
            background: #2d3748 !important;
            border-color: #4a5568 !important;
            color: #e2e8f0 !important;
        }

        [data-theme="dark"] .quick-jump select:hover {
            border-color: #667eea !important;
        }
        
        [data-theme="dark"] .quick-jump select option {
            background: #2d3748;
            color: #e2e8f0;
        }

        /* Dark mode header select styling */
        [data-theme="dark"] .header-select {
            background: rgba(255, 255, 255, 0.15) !important;
            border: 1px solid rgba(255, 255, 255, 0.25) !important;
            color: white !important;
        }
        
        [data-theme="dark"] .header-select option {
            background: #2d3748;
            color: #e2e8f0;
        }

        /* Responsive navigation */
        @media (max-width: 768px) {
            .form-header {
                flex-direction: column;
                align-items: stretch;
            }

            .navigation-controls {
                justify-content: space-between;
            }

            .quick-jump select {
                min-width: 100px;
                max-width: 130px;
                font-size: 0.7rem;
                padding: 3px 6px;
            }
            
            .header-content .quick-jump select {
                max-width: 120px;
            }
        }


        /* Visual Field Validation */
        .form-group {
            position: relative;
        }

        /* Green checkmark removed per user request - .form-group.valid styling removed */

        .form-group.invalid input,
        .form-group.invalid textarea,
        .form-group.invalid select {
            border-color: #dc3545;
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 12 12' width='12' height='12' fill='none' stroke='%23dc3545'%3e%3ccircle cx='6' cy='6' r='4.5'/%3e%3cpath d='m5.5 5.5 1 1m0-1-1 1'/%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 12px center;
            background-size: 16px;
            padding-right: 40px;
        }

        .form-group.required label::after {
            content: " *";
            color: #dc3545;
            font-weight: bold;
        }

        .form-group.required:not(.valid):not(.invalid) input,
        .form-group.required:not(.valid):not(.invalid) textarea,
        .form-group.required:not(.valid):not(.invalid) select {
            border-left: 4px solid #ffc107;
        }

        /* Validation message */
        .validation-message {
            font-size: 0.8rem;
            margin-top: 4px;
            padding: 4px 8px;
            border-radius: 4px;
            display: none;
        }

        .validation-message.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
            display: block;
        }

        .validation-message.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
            display: block;
        }

        /* Dark mode field validation */
        body.dark-mode .form-group.valid input,
        body.dark-mode .form-group.valid textarea,
        body.dark-mode .form-group.valid select {
            border-color: #28a745;
            background-color: #2d3748;
        }

        body.dark-mode .form-group.invalid input,
        body.dark-mode .form-group.invalid textarea,
        body.dark-mode .form-group.invalid select {
            border-color: #dc3545;
            background-color: #2d3748;
        }

        body.dark-mode .validation-message.error {
            background: #2d3748;
            color: #feb2b2;
            border-color: #4a5568;
        }

        body.dark-mode .validation-message.success {
            background: #2d3748;
            color: #68d391;
            border-color: #4a5568;
        }

        /* Floating Action Buttons - Hidden */
        .floating-actions {
            display: none;
        }

        .fab-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
            align-items: center;
        }

        .fab {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9rem;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.15);
            transition: all 0.3s ease;
            position: relative;
        }

        .fab:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
        }

        .fab:active {
            transform: translateY(0);
        }

        .fab-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .fab-primary:hover {
            background: linear-gradient(135deg, #5a6fd8 0%, #6a4190 100%);
        }

        .fab-secondary {
            background: #f8f9fa;
            color: #495057;
            border: 1px solid #dee2e6;
        }

        .fab-secondary:hover {
            background: #e9ecef;
            border-color: #adb5bd;
        }

        /* FAB animations */
        .fab {
            animation: fabSlideIn 0.3s ease-out;
        }

        @keyframes fabSlideIn {
            from {
                opacity: 0;
                transform: translateX(100px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        /* Dark mode FABs */
        body.dark-mode .fab-secondary {
            background: #2d3748;
            color: #e2e8f0;
            border-color: #4a5568;
        }

        body.dark-mode .fab-secondary:hover {
            background: #4a5568;
            border-color: #718096;
        }

        /* Responsive FABs */
        @media (max-width: 768px) {
            .floating-actions {
                bottom: 20px;
                right: 20px;
            }

            .fab {
                width: 36px;
                height: 36px;
                font-size: 0.85rem;
            }

            .fab-container {
                gap: 10px;
            }
        }

        /* Hide FABs when printing */
        @media print {
            .floating-actions {
                display: none;
            }
        }

        /* PDF Viewer Toggle Styles */
        .toggle-section {
            display: flex;
            flex-direction: column;
        }

        .view-toggle-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
            padding-bottom: 4px;
            border-bottom: 1px solid #dee2e6;
        }

        .view-toggle-buttons {
            display: flex;
            gap: 6px;
        }

        .view-toggle-btn {
            padding: 5px 10px;
            border: 1px solid #dee2e6;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 4px;
            font-weight: 500;
            font-size: 0.8rem;
        }

        .view-toggle-btn:hover {
            border-color: #667eea;
            background: #f8f9fa;
        }

        .view-toggle-btn.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .view-panel {
            display: none;
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            flex-direction: column;
            min-height: 0; /* Allow flex child to shrink */
        }

        .view-panel.active {
            display: flex;
        }
        
        /* Ensure JSON preview panel content is scrollable */
        #json-preview-panel {
            min-height: 0;
            max-height: none; /* Allow unlimited expansion */
        }
        
        #json-preview-panel .json-preview {
            flex: 1;
            min-height: 200px;
            max-height: 2000px; /* Allow expansion up to 2000px (much larger than before) */
            overflow-y: auto;
            resize: vertical; /* Allow manual resizing */
        }

        /* PDF Viewer Specific */
        #pdf-viewer-panel {
            background: #f8f9fa;
            border-radius: 6px;
            padding: 8px;
            display: flex;
            flex-direction: column;
            flex: 1;
            min-height: 0; /* Allow flex child to shrink */
            overflow: hidden; /* Prevent panel from scrolling, let canvas container handle it */
        }

        .pdf-viewer-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            align-items: center;
            margin-bottom: 8px;
            padding: 6px;
            background: white;
            border-radius: 6px;
            border: 1px solid #dee2e6;
            flex-shrink: 0; /* Prevent controls from shrinking */
        }

        .pdf-source-toggle {
            display: flex;
            gap: 4px;
        }

        .pdf-source-btn {
            padding: 4px 8px;
            border: 1px solid #dee2e6;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 3px;
        }

        .pdf-source-btn:hover {
            border-color: #667eea;
            background: #f8f9fa;
        }

        .pdf-source-btn.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .pdf-canvas-container {
            position: relative;
            background: #e9ecef;
            border-radius: 6px;
            overflow: auto;
            flex: 1; /* Fill remaining vertical space */
            min-height: 0; /* Allow flex child to shrink below content size */
            width: 100%;
            max-width: 100%;
            display: flex;
            justify-content: flex-start;
            align-items: flex-start;
            padding: 10px;
            box-sizing: border-box;
            overflow-x: auto; /* Horizontal scroll when zoomed */
            overflow-y: auto; /* Vertical scroll when needed */
        }

        #main-pdf-canvas {
            display: block;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            background: white;
            flex-shrink: 0; /* Prevent canvas from shrinking */
            margin: 0 auto; /* Center when smaller than container */
        }

        /* Dark mode for PDF viewer */
        [data-theme="dark"] .view-toggle-btn {
            background: var(--bg-primary);
            color: var(--text-primary);
            border-color: var(--border-color);
        }

        [data-theme="dark"] .view-toggle-btn:hover {
            background: var(--bg-secondary);
            border-color: #667eea;
        }

        [data-theme="dark"] .view-toggle-btn.active {
            background: #667eea;
            color: white;
        }

        [data-theme="dark"] #pdf-viewer-panel {
            background: var(--bg-secondary);
        }

        [data-theme="dark"] .pdf-viewer-controls {
            background: var(--bg-primary);
            border-color: var(--border-color);
        }

        [data-theme="dark"] .pdf-source-btn {
            background: var(--bg-primary);
            color: var(--text-primary);
            border-color: var(--border-color);
        }

        [data-theme="dark"] .pdf-source-btn:hover {
            background: var(--bg-secondary);
            border-color: #667eea;
        }

        [data-theme="dark"] .pdf-source-btn.active {
            background: #667eea;
            color: white;
        }

        [data-theme="dark"] .pdf-canvas-container {
            background: var(--bg-tertiary);
        }

    </style>
</head>
<body>
    <!-- Embedded BBox Drawer Modal -->
    <div id="bboxModal" class="bbox-modal" aria-hidden="true">
        <div class="bbox-dialog">
            <div class="bbox-toolbar">
                <div class="group">
                    <label class="bbox-btn">
                        <input id="em-text-pdf-file" type="file" accept="application/pdf" style="display:none" />
                        Upload Textbook PDF
                    </label>
                    <label class="bbox-btn">
                        <input id="em-guide-pdf-file" type="file" accept="application/pdf" style="display:none" />
                        Upload Answers PDF
                    </label>
                    <div class="muted">Doc: <span id="em-doc-label">Textbook</span></div>
                    <button id="em-prev" class="bbox-btn" title="Previous page"></button>
                    <div class="muted">Page <span id="em-page-num">0</span>/<span id="em-page-count">0</span></div>
                    <input id="em-goto" type="number" min="1" step="1" placeholder="#" title="Go to page" style="width:80px" />
                    <button id="em-goto-btn" class="bbox-btn" title="Go to page">Go</button>
                    <button id="em-next" class="bbox-btn" title="Next page"></button>
                </div>
                <div class="group">
                    <button id="em-zoom-out" class="bbox-btn" title="Zoom out">-</button>
                    <span id="em-zoom-display" style="color: var(--text-secondary); font-size: 0.9rem; padding: 0 8px;">100%</span>
                    <button id="em-zoom-in" class="bbox-btn" title="Zoom in">+</button>
                    <button id="em-zoom-reset" class="bbox-btn" title="Reset zoom to default">Reset</button>
                </div>
                <div class="group">
                    <span class="muted">Drawing: Always On</span>
                    <button id="em-undo" class="bbox-btn" title="Undo last bounding box">Undo</button>
                    <button id="em-add" class="bbox-btn" title="Add a new bounding box">Add BBox</button>
                    <button id="em-clear" class="bbox-btn danger" title="Clear all bounding boxes on current page">Clear Page</button>
                </div>
                <div class="group">
                    <div class="muted">Coords</div>
                    <div id="em-coords" class="muted"></div>
                </div>
                <div class="group" style="margin-left:auto">
                    <button id="em-close" class="bbox-btn danger" title="Close"></button>
                </div>
            </div>
            <div class="bbox-content">
                <div class="bbox-canvas-wrap" id="em-canvas-wrap">
                    <canvas id="em-pdf"></canvas>
                    <canvas id="em-draw"></canvas>
                </div>
                <div class="bbox-sidebar">
                    <h3 style="margin:0 0 6px">Bounding Boxes</h3>
                    <div class="muted">Per current page</div>
                    <div id="em-list" class="bbox-bbox-list"></div>
                </div>
            </div>
            <div class="bbox-footer">
                <button id="em-cancel" class="bbox-btn">Cancel</button>
                <button id="em-confirm" class="bbox-btn primary">Use Selected</button>
            </div>
        </div>
    </div>
                    <div class="container">
            <div class="header">
                <div class="header-content">
                    <div class="header-text">
                        <div class="header-title">
                            <i class="fas fa-book-open" style="font-size: 0.85rem;"></i>
                            <h1>Math Textbook Transcription</h1>
                        </div>
                        <div class="header-meta">
                            <span id="version-display">v<span id="version-number"></span></span>
                            <span></span>
                            <button id="whats-new-btn" onclick="openWhatsNew()" title="View latest updates and improvements" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border: none; color: white; padding: 4px 10px; border-radius: 12px; cursor: pointer; font-size: 0.65rem; font-weight: 600; display: flex; align-items: center; justify-content: center; gap: 5px; transition: all 0.3s; box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);">
                                <i class="fas fa-sparkles"></i> What's New
                            </button>
                            <span></span>
                            <span>DUKU</span>
                        </div>
                    </div>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <!-- Undo/Redo Buttons -->
                        <button id="undo-btn" onclick="undoAction()" title="Undo (Ctrl+Z)" class="dark-mode-toggle" disabled>
                            <i class="fas fa-undo"></i>
                        </button>
                        <button id="redo-btn" onclick="redoAction()" title="Redo (Ctrl+Y)" class="dark-mode-toggle" disabled>
                            <i class="fas fa-redo"></i>
                        </button>
                        <!-- Font Settings -->
                        <div class="font-settings" style="display: flex; gap: 6px; align-items: center; background: rgba(255, 255, 255, 0.1); padding: 4px 8px; border-radius: 6px;">
                            <label style="font-size: 0.7rem; opacity: 0.9;">Font:</label>
                            <select id="fontSizeSelect" onchange="changeFontSize(this.value)" title="Change font size" class="header-select" style="padding: 2px 6px; font-size: 0.7rem; cursor: pointer; outline: none;">
                                <option value="14" selected>14px</option>
                                <option value="16">16px</option>
                                <option value="18">18px</option>
                                <option value="20">20px</option>
                                <option value="22">22px</option>
                                <option value="24">24px</option>
                                <option value="26">26px</option>
                                <option value="28">28px</option>
                                <option value="30">30px</option>
                                <option value="32">32px</option>
                                <option value="36">36px</option>
                                <option value="40">40px</option>
                                <option value="44">44px</option>
                                <option value="48">48px</option>
                            </select>
                            <label style="font-size: 0.7rem; opacity: 0.9; margin-left: 4px;">Line:</label>
                            <select id="lineHeightSelect" onchange="changeLineHeight(this.value)" title="Change line height" class="header-select" style="padding: 2px 6px; font-size: 0.7rem; cursor: pointer; outline: none;">
                                <option value="1.5" selected>1.5</option>
                                <option value="1.8">1.8</option>
                                <option value="2.0">2.0</option>
                                <option value="2.2">2.2</option>
                                <option value="2.5">2.5</option>
                            </select>
                        </div>
                        <span></span>
                        <div id="saveIndicator" class="auto-save-indicator">
                            <span>No changes</span>
                        </div>
                        <div class="quick-jump" style="display: flex; gap: 8px; align-items: center; position: relative;">
                            <div style="position: relative; width: 400px;">
                                <div style="position: relative;">
                                    <input type="text" id="searchFilter" placeholder="Search content & questions..." title="Search across all content sections and questions" style="padding: 6px 12px; padding-right: 80px; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary); font-size: 0.9rem; width: 100%; outline: none; text-align: left; direction: ltr;" oninput="performSearch(this.value)" onfocus="handleSearchFocus()" onblur="handleSearchBlur()" onkeydown="handleSearchKeydown(event)">
                                    <span id="searchResultsCount" style="position: absolute; right: 12px; top: 50%; transform: translateY(-50%); color: var(--text-secondary); font-size: 0.85rem; pointer-events: none; display: none;"></span>
                                </div>
                                <div id="searchResultsDropdown" class="search-results-dropdown" style="display: none;"></div>
                            </div>
                            <button id="clearSearchBtn" onclick="clearSearch()" title="Clear search" style="display: none; padding: 6px 10px; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-secondary); color: var(--text-primary); cursor: pointer; font-size: 0.9rem;">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div class="quick-jump">
                            <select id="quickJumpSelect" onchange="quickJumpTo(this.value)" title="Quickly jump to any form section, content section, or question">
                                <option value="">Quick Jump...</option>
                                <optgroup label="Form Sections">
                                    <option value="basic">Basic Info</option>
                                    <option value="preamble">Lesson Preamble</option>
                                    <option value="content">Content Sections</option>
                                    <option value="questions">Questions</option>
                                </optgroup>
                                <optgroup label="Content Sections" id="contentSectionsGroup">
                                    <!-- Dynamically populated -->
                                </optgroup>
                                <optgroup label="Questions" id="questionsGroup">
                                    <!-- Dynamically populated -->
                                </optgroup>
                            </select>
                        </div>
                        <button id="saveBtn" class="dark-mode-toggle" onclick="saveProgress()" title="Save Progress (Ctrl+S)">
                            <i class="fas fa-save"></i>
                        </button>
                        <button class="dark-mode-toggle" onclick="location.reload()" title="Reload Page">
                            <i class="fas fa-sync-alt"></i>
                        </button>
                        <button class="dark-mode-toggle" onclick="scrollToTop()" title="Scroll to Top">
                            <i class="fas fa-arrow-up"></i>
                        </button>
                        <button id="autoResizeToggle" class="dark-mode-toggle" onclick="toggleAutoResize()" title="Toggle Auto-Resize Textareas">
                            <i class="fas fa-arrows-alt-v"></i>
                        </button>
                        <button id="darkModeToggle" class="dark-mode-toggle" onclick="toggleDarkMode()">
                            <i class="fas fa-moon"></i>
                        </button>
                    </div>
                </div>
            </div>
            

        <div class="workflow-container">
            <!-- Form Section -->
            <div class="form-section">
                <!-- Main Tab Navigation: Input Form / Final Preview -->
                <div class="tabs main-tabs">
                    <button class="tab active" id="main-tab-input" onclick="showMainTab('input-form')" title="Edit the form data">Input Form</button>
                    <button class="tab" id="main-tab-preview" onclick="showMainTab('final-preview')" title="Preview all sections and questions">Final Preview</button>
                </div>
                
                <!-- Input Form Tab Content -->
                <div id="input-form" class="main-tab-content active">
                <div class="tabs">
                    <button class="tab active" onclick="showTab('basic')" title="Basic page information (page numbers, page type)">Basic Info</button>
                    <button class="tab" onclick="showTab('preamble')" title="Lesson metadata (ID, title, standards, terminology)">Lesson Preamble</button>
                    <button class="tab" onclick="showTab('content')" title="Instructional content sections">Content</button>
                    <button class="tab" onclick="showTab('questions')" title="Practice questions">Questions</button>
                </div>

                <!-- Basic Info Tab -->
                <div id="basic" class="tab-content active">
                                         <div class="form-group required-field">
                         <label>Textbook Page Number</label>
                         <input type="number" id="textbook_page" placeholder="e.g., 36" min="1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57" title="The actual page number in the physical textbook">
                     </div>
                     
                     <div class="form-group required-field">
                         <label>PDF Page Number</label>
                         <input type="number" id="textbook_pdf_page" placeholder="e.g., 44" min="1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57" title="The page number in the digital PDF file">
                     </div>
                     
                     <div class="form-group required-field">
                         <label>Guidebook PDF Pages (Start - End)</label>
                         <div class="bbox-inputs" style="grid-template-columns: 1fr 1fr;">
                             <input type="number" id="guidebook_start_page" placeholder="Start page (e.g., 78)" min="1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57" title="First page number in the guidebook PDF range">
                             <input type="number" id="guidebook_end_page" placeholder="End page (e.g., 85)" min="1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57" title="Last page number in the guidebook PDF range">
                         </div>
                         <small style="color: #6c757d; font-size: 12px;">Will generate array from start to end page (inclusive)</small>
                     </div>
                    
                    <div class="form-group required-field">
                        <label>Page Type</label>
                        <select id="page_type" title="Categorizes the content type for organization">
                            <option value="content" selected>Content</option>
                            <option value="project">Project</option>
                            <option value="vocabulary">Vocabulary</option>
                            <option value="unit_table_of_content">Unit Table of Content</option>
                            <option value="table_of_content">Table of Content</option>
                            <option value="other">Other</option>
                        </select>
                    </div>
                    
                    <div class="highlight">
                        <h4><i class="fas fa-lightbulb"></i> Basic Info Tips</h4>
                        <p> Textbook page: The actual page number in the physical book</p>
                        <p> PDF page: The page number in the digital PDF file</p>
                        <p> Guidebook pages: Range of pages in the teacher's guide</p>
                        <p> Page type: Categorizes the content type for organization</p>
                    </div>
                </div>

                <!-- Lesson Preamble Tab -->
                <div id="preamble" class="tab-content">
                    <div class="form-group">
                        <label>Lesson ID</label>
                        <input type="text" id="lesson_id" placeholder="e.g., 2-1" data-ltr="true" title="Unique identifier for the lesson (e.g., 2-1 for chapter 2, lesson 1)">
                    </div>
                    
                    <div class="form-group">
                        <label>Lesson Title</label>
                        <span class="input-label">Input Markdown</span>
                        <input type="text" id="lesson_title" placeholder="e.g., Parallel and Perpendicular Lines" title="The title of the lesson (supports markdown formatting)">
                    </div>
                    
                    <div class="form-group">
                        <label>Lesson Standards</label>
                        <div id="lesson_standards">
                            <div class="array-item">
                                <input type="text" placeholder="e.g., CCSS.MATH.CONTENT.8.G.A.1" data-ltr="true" title="Educational standard code (e.g., Common Core State Standards)">
                                <div class="row-actions">
                                    <button class="add-bbox-btn" onclick="addLessonStandardBefore(this)" title="Add Standard Before">
                                        <i class="fas fa-plus"></i> Before
                                    </button>
                                    <button class="add-bbox-btn" onclick="addLessonStandardAfter(this)" title="Add Standard After">
                                        <i class="fas fa-plus"></i> After
                                    </button>
                                    <button class="reorder-btn" onclick="moveItemUp(this)" title="Move Up"><i class="fas fa-arrow-up"></i></button>
                                    <button class="reorder-btn" onclick="moveItemDown(this)" title="Move Down"><i class="fas fa-arrow-down"></i></button>
                                    <button class="remove-btn" onclick="removeArrayItem(this)"></button>
                                </div>
                            </div>
                        </div>
                        <button class="add-btn" onclick="addLessonStandard()" title="Add a new lesson standard">
                            <i class="fas fa-plus"></i> Add Standard
                        </button>
                    </div>
                    
                    <div class="form-group">
                        <label>Terminology</label>
                        <div id="terminology">
                            <div class="array-item">
                                <span class="input-label">Input Markdown</span>
                                <input type="text" placeholder="e.g., Parallel Lines" title="Terminology term with definition (supports markdown formatting)">
                                <div class="row-actions">
                                    <button class="add-bbox-btn" onclick="addTerminologyBefore(this)" title="Add Term Before">
                                        <i class="fas fa-plus"></i> Before
                                    </button>
                                    <button class="add-bbox-btn" onclick="addTerminologyAfter(this)" title="Add Term After">
                                        <i class="fas fa-plus"></i> After
                                    </button>
                                    <button class="reorder-btn" onclick="moveItemUp(this)" title="Move Up"><i class="fas fa-arrow-up"></i></button>
                                    <button class="reorder-btn" onclick="moveItemDown(this)" title="Move Down"><i class="fas fa-arrow-down"></i></button>
                                    <button class="remove-btn" onclick="removeArrayItem(this)"></button>
                                </div>
                            </div>
                        </div>
                        <button class="add-btn" onclick="addTerminology()" title="Add a new terminology term">
                            <i class="fas fa-plus"></i> Add Term
                        </button>
                    </div>
                    
                    <div class="form-group">
                        <label>Lesson Text</label>
                        <div class="text-field-container">
                            <span class="input-label">Input Markdown</span>
                            <textarea id="lesson_text" placeholder="Additional lesson text not captured above..." title="Additional lesson text that supports markdown formatting"></textarea>
                            <button type="button" class="markdown-btn" onclick="insertBold(this.parentElement.querySelector('textarea'))" title="Make selected text bold (**text**)">
                                <i class="fas fa-bold"></i>
                            </button>
                            <button type="button" class="markdown-btn" onclick="insertItalic(this.parentElement.querySelector('textarea'))" title="Make selected text italic (*text*)">
                                <i class="fas fa-italic"></i>
                            </button>
                            <button type="button" class="markdown-btn" onclick="insertBulletList(this.parentElement.querySelector('textarea'))" title="Convert line(s) to bullet list (- item)">
                                <i class="fas fa-list-ul"></i>
                            </button>
                            <button type="button" class="markdown-btn" onclick="insertNumberedList(this.parentElement.querySelector('textarea'))" title="Convert line(s) to numbered list (1. item)">
                                <i class="fas fa-list-ol"></i>
                            </button>
                            <button type="button" class="markdown-btn" onclick="insertBlockquote(this.parentElement.querySelector('textarea'))" title="Convert line(s) to blockquote (> text)">
                                <i class="fas fa-quote-right"></i>
                            </button>
                            <button type="button" class="markdown-btn" onclick="insertInlineLatex(this.parentElement.querySelector('textarea'))" title="Wrap selection with $ or insert $$">
                                <i class="fas fa-dollar-sign"></i>
                            </button>
                            <button type="button" class="markdown-btn" onclick="insertBlockLatex(this.parentElement.querySelector('textarea'))" title="Wrap selection with block LaTeX ($$\\n...\\n$$) or insert $$\\n\\n$$">
                                <i class="fas fa-square-root-alt"></i>
                            </button>
                            <button type="button" class="markdown-btn" onclick="removeMarkdownFormatting(this)" title="Undo last markdown formatting operation">
                                <i class="fas fa-undo"></i>
                            </button>
                            <button type="button" class="markdown-btn" onclick="redoMarkdownFormatting(this)" title="Redo last undone markdown formatting operation">
                                <i class="fas fa-redo"></i>
                            </button>
                            <button type="button" class="dir-btn" onclick="toggleDirection(this.parentElement.querySelector('textarea'))" title="Toggle text direction (LTR/RTL)">LTR</button>
                        </div>
                    </div>
                    
                    <div class="highlight">
                        <h4><i class="fas fa-lightbulb"></i> Lesson Preamble Tips</h4>
                        <p> Lesson ID: Use format like "2-1" for Unit 2, Lesson 1</p>
                        <p> Lesson Title: Brief, descriptive title for the lesson</p>
                        <p> Standards: Educational standards this lesson addresses</p>
                        <p> Terminology: Key mathematical terms students need to know</p>
                        <p> Lesson Text: Additional context not captured in other fields</p>
                        <p> <strong>Note:</strong> Tables and images are not allowed in this section</p>
                    </div>
                </div>

                <!-- Content Tab -->
                <div id="content" class="tab-content">
                    <div id="content_sections_container">
                    </div>
                    
                    <div class="button-group">
                        <button class="add-btn" onclick="addContentSection()" title="Add a new instructional content section">
                            <i class="fas fa-plus"></i> Add Content Section
                        </button>
                        <button class="add-btn paste-section-btn" onclick="pasteSectionAtEnd('content')" title="Paste a copied content section at the end">
                            <i class="fas fa-paste"></i> Paste Section
                        </button>
                    </div>
                    
                    <div class="highlight">
                        <h4><i class="fas fa-lightbulb"></i> Content Section Tips</h4>
                        <p> Use **bold** and *italic* for emphasis</p>
                        <p> Include LaTeX with $$ for math expressions</p>
                        <p> Insert tables with the <i class="fas fa-table"></i> button</p>
                        <p> Insert images with the <i class="fas fa-image"></i> button</p>
                        <p> <strong>Coordinate System:</strong> [x0, y0] = top-right, [x1, y1] = bottom-left</p>
                        <p> <strong>Auto-validation:</strong> Coordinates are automatically normalized when you finish entering them</p>
                        <p> <strong>Reordering:</strong> Use <i class="fas fa-arrow-up"></i> <i class="fas fa-arrow-down"></i> to reorder sections and bboxes</p>
                        <p> <strong>Copy/Paste:</strong> Use <i class="fas fa-copy"></i> to copy a section. Yellow <i class="fas fa-paste"></i> replaces current section, blue Paste button adds new section</p>
                    </div>
                </div>

                <!-- Questions Tab -->
                <div id="questions" class="tab-content">
                    <div id="questions_container">
                    </div>
                    
                    <div class="button-group">
                        <button class="add-btn" onclick="addQuestion()" title="Add a new practice question">
                            <i class="fas fa-plus"></i> Add Question
                        </button>
                        <button class="add-btn paste-section-btn" onclick="pasteSectionAtEnd('question')" title="Paste a copied question at the end">
                            <i class="fas fa-paste"></i> Paste Question
                        </button>
                    </div>
                    
                    <div class="highlight">
                        <h4><i class="fas fa-lightbulb"></i> Question Tips</h4>
                        <p> Question Text: The main question students need to answer</p>
                        <p> Guide Answer: Step-by-step solution or answer key</p>
                        <p> Set-up Text: Context or information shared across multiple questions</p>
                        <p> Insert tables and images using the buttons in each text field</p>
                        <p> <strong>Important:</strong> Setup text and question text share the same image array</p>
                        <p> <strong>Coordinate System:</strong> [x0, y0] = top-right, [x1, y1] = bottom-left</p>
                        <p> <strong>Auto-validation:</strong> Coordinates are automatically normalized when you finish entering them</p>
                        <p> <strong>Reordering:</strong> Use <i class="fas fa-arrow-up"></i> <i class="fas fa-arrow-down"></i> to reorder questions and bboxes</p>
                        <p> <strong>Copy/Paste:</strong> Use <i class="fas fa-copy"></i> to copy a question. Yellow <i class="fas fa-paste"></i> replaces current question, blue Paste button adds new question</p>
                    </div>
                </div>
                </div>
                <!-- End Input Form Tab Content -->

                <!-- Final Preview Tab Content -->
                <div id="final-preview" class="main-tab-content">
                    <div id="final-preview-content" class="final-preview-container">
                        <!-- Preview content will be generated dynamically -->
                    </div>
                </div>
                <!-- End Final Preview Tab Content -->

                
            </div>

            <!-- JSON Preview / PDF Viewer Section -->
            <div class="form-section toggle-section">
                <!-- Toggle Header -->
                <div class="view-toggle-header">
                    <div class="view-toggle-buttons">
                        <button id="toggle-pdf-btn" class="view-toggle-btn" onclick="showPdfViewer()" title="View and navigate PDF pages">
                            <i class="fas fa-file-pdf"></i> PDF Viewer
                        </button>
                        <button id="toggle-json-btn" class="view-toggle-btn active" onclick="showJsonPreview()" title="View generated JSON output">
                            <i class="fas fa-code"></i> JSON Preview
                        </button>
                    </div>
                    <button class="generate-btn" onclick="generateJSON()" style="width:auto;" title="Generate JSON from all form data (validates before generating)">
                        <i class="fas fa-magic" style="font-size: 0.75rem;"></i> Generate JSON
                    </button>
                </div>
                
                <!-- PDF Viewer Panel (hidden by default) -->
                <div id="pdf-viewer-panel" class="view-panel" style="display: none;">
                    <!-- PDF controls and canvas will be inserted here by JavaScript -->
                </div>
                
                <!-- JSON Preview Panel (visible by default) -->
                <div id="json-preview-panel" class="view-panel active">
                    <!-- Input JSON (Import Area) -->
                    <div class="form-group">
                        <label>Load JSON or Python Dict to populate the form</label>
                        <div class="json-controls" style="margin-bottom:8px;">
                            <button class="add-btn" type="button" onclick="event.stopPropagation(); loadJSON()" title="Load JSON or Python dictionary from the text area below to populate the form">
                                <i class="fas fa-file-upload"></i> Load JSON/Dict
                            </button>
                            <button class="add-btn" type="button" onclick="event.stopPropagation(); confirmClearForm()" title="Clear all form data and start fresh">
                                <i class="fas fa-broom"></i> Clear Form
                            </button>
                            <button class="add-btn" type="button" onclick="event.stopPropagation(); openBboxDrawerForPDFs()" title="Upload textbook or guidebook PDF for drawing bounding boxes">
                                <i class="fas fa-file-pdf"></i> Upload PDFs
                            </button>
                        </div>
                        <textarea id="json_input" placeholder="Paste JSON or Python dict here..." data-ltr="true" title="Paste JSON or Python dictionary here, then click 'Load JSON/Dict' to populate the form"></textarea>
                    </div>
                    <!-- Output JSON (Preview Area) -->
                    <div class="json-controls" style="margin-bottom:8px;">
                        <button class="add-btn" onclick="copyJSON()" title="Copy the generated JSON to clipboard">
                            <i class="fas fa-copy"></i> Copy JSON
                        </button>
                    </div>
                    <div class="json-preview" id="json_output">
                        <span class="json-key">//</span> <span class="json-string">JSON will be generated here...</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ========================================
        // User-Friendly Error Messages
        // ========================================
        const ErrorMessages = {
            // Location formatters
            contentSection: (index) => ` Content Section ${index + 1}`,
            question: (index, isMCQ) => ` Question ${index + 1}${isMCQ ? ' (MCQ)' : ''}`,
            
            // Missing images
            missingImageContent: (sIndex, imgNum) => 
                `${ErrorMessages.contentSection(sIndex)} - Problem: You used image #${imgNum} in your text, but you haven't added any image boxes for this section yet.\n    Fix: Click "+ Add Image" and draw the box for this image on the PDF.`,
            
            missingImageQuestion: (qIndex, imgNum) => 
                `${ErrorMessages.question(qIndex, false)} - Problem: You used image #${imgNum} in your question, but you haven't added any image boxes in "Question Images" yet.\n    Fix: Scroll to "Question Images" section and add the image box.`,
            
            missingImageAnswer: (qIndex, imgNum) => 
                `${ErrorMessages.question(qIndex, false)} - Problem: You used image #${imgNum} in your answer, but you haven't added any image boxes in "Answer Images" yet.\n    Fix: Scroll to "Answer Images" section and add the image box.`,
            
            missingImageChoice: (qIndex, imgNum) => 
                `${ErrorMessages.question(qIndex, true)} - Problem: You used image #${imgNum} in choice text, but you haven't added any image boxes in "Question Images" yet.\n    Fix: Scroll to "Question Images" section and add the image box.`,
            
            missingTableImageContent: (sIndex, imgNum) => 
                `${ErrorMessages.contentSection(sIndex)} - Problem: Your table uses image #${imgNum}, but you haven't added any image boxes for this section yet.\n    Fix: Click "+ Add Image" and draw the box for this image on the PDF.`,
            
            missingTableImageQuestion: (qIndex, imgNum) => 
                `${ErrorMessages.question(qIndex, false)} - Problem: Your table uses image #${imgNum}, but you haven't added any image boxes in "Question Images" yet.\n    Fix: Scroll to "Question Images" section and add the image box.`,
            
            missingTableImageAnswer: (qIndex, imgNum) => 
                `${ErrorMessages.question(qIndex, false)} - Problem: Your answer table uses image #${imgNum}, but you haven't added any image boxes in "Answer Images" yet.\n    Fix: Scroll to "Answer Images" section and add the image box.`,
            
            // Unused images
            unusedImageContent: (sIndex, imgNum) => 
                `${ErrorMessages.contentSection(sIndex)} - Problem: You have an image box (#${imgNum}) that's not being used in your text.\n    Fix: Either delete this image box or add ![image description](${imgNum}) in your text where you want the image to appear.`,
            
            unusedImageQuestion: (qIndex, imgNum, isMCQ) => 
                isMCQ
                    ? `${ErrorMessages.question(qIndex, true)} - Problem: You have an image box (#${imgNum}) in "Question Images" that's not being used in your question or choices.\n    Fix: Either delete this image box or add the image to your question or one of your choices.`
                    : `${ErrorMessages.question(qIndex, false)} - Problem: You have an image box (#${imgNum}) in "Question Images" that's not being used in your question text.\n    Fix: Either delete this image box or add the image to your question using the "Insert Image" button.`,
            
            unusedImageAnswer: (qIndex, imgNum) => 
                `${ErrorMessages.question(qIndex, false)} - Problem: You have an image box (#${imgNum}) in "Answer Images" that's not being used in your answer.\n    Fix: Either delete this image box or add the image to your answer using the "Insert Image" button.`,
            
            // Duplicate indices
            duplicateImagesContent: (sIndex, numbers) => 
                `${ErrorMessages.contentSection(sIndex)} - Problem: You used the same image numbers more than once: ${numbers.map(n => '#' + n).join(', ')}\n    Fix: Each image should have a unique number. Change duplicate images to use the next available numbers.`,
            
            duplicateImagesQuestion: (qIndex, numbers, isMCQ) => 
                isMCQ
                    ? `${ErrorMessages.question(qIndex, true)} - Problem: You used the same image numbers more than once in your question or choices: ${numbers.map(n => '#' + n).join(', ')}\n    Fix: Each image should have a unique number across your question and all choices. Use: 0, 1, 2, 3...`
                    : `${ErrorMessages.question(qIndex, false)} - Problem: You used the same image numbers more than once in your question: ${numbers.map(n => '#' + n).join(', ')}\n    Fix: Each image in your question should have a unique number (starting from 0). The images should go: 0, 1, 2, 3...`,
            
            duplicateImagesAnswer: (qIndex, numbers) => 
                `${ErrorMessages.question(qIndex, false)} - Problem: You used the same image numbers more than once in your answer: ${numbers.map(n => '#' + n).join(', ')}\n    Fix: Each image in your answer should have a unique number (starting from 0). Use: 0, 1, 2, 3...`,
            
            // Count mismatch
            countMismatchContent: (sIndex, textCount, boxCount) => 
                `${ErrorMessages.contentSection(sIndex)} - Problem: Your text uses ${textCount} image${textCount !== 1 ? 's' : ''}, but you have ${boxCount} image box${boxCount !== 1 ? 'es' : ''} drawn.\n    Fix: ${textCount > boxCount ? 'Add more image boxes to match your text.' : 'Either delete the extra image boxes or use all your images in the text.'}`,
            
            countMismatchQuestion: (qIndex, textCount, boxCount, isMCQ) => 
                isMCQ
                    ? `${ErrorMessages.question(qIndex, true)} - Problem: Your question and choices use ${textCount} image${textCount !== 1 ? 's' : ''} total, but you have ${boxCount} image box${boxCount !== 1 ? 'es' : ''} in "Question Images".\n    Fix: Make sure the number of image boxes matches the total number of images across your question and all choices (${textCount}).`
                    : `${ErrorMessages.question(qIndex, false)} - Problem: Your question uses ${textCount} image${textCount !== 1 ? 's' : ''}, but you have ${boxCount} image box${boxCount !== 1 ? 'es' : ''} in "Question Images".\n    Fix: Make sure the number of image boxes matches the number of images you used (${textCount}).`,
            
            countMismatchAnswer: (qIndex, textCount, boxCount) => 
                `${ErrorMessages.question(qIndex, false)} - Problem: Your answer uses ${textCount} image${textCount !== 1 ? 's' : ''}, but you have ${boxCount} image box${boxCount !== 1 ? 'es' : ''} in "Answer Images".\n    Fix: Make sure the number of image boxes matches the number of images you used in your answer (${textCount}).`,
            
            // Must start from 0
            mustStartFromZeroContent: (sIndex, startNum) => 
                `${ErrorMessages.contentSection(sIndex)} - Problem: Your images should start from number 0, but you started from #${startNum}.\n    Fix: Rename your first image to #0, second image to #1, and so on.`,
            
            mustStartFromZeroQuestion: (qIndex, startNum) => 
                `${ErrorMessages.question(qIndex, false)} - Problem: Your question images should start from number 0, but you started from #${startNum}.\n    Fix: Change your images to start from 0: use ![description](0) for the first image.`,
            
            mustStartFromZeroAnswer: (qIndex, startNum) => 
                `${ErrorMessages.question(qIndex, false)} - Problem: Your answer images should start from number 0, but you started from #${startNum}.\n    Fix: Change your images to start from 0: use ![description](0) for the first image in your answer.`,
            
            // Gaps in sequence
            gapInSequenceContent: (sIndex, before, after) => 
                `${ErrorMessages.contentSection(sIndex)} - Problem: Your image numbers skip from #${before} to #${after}. You're missing #${before + 1}.\n    Fix: Use image numbers in order without skipping: 0, 1, 2, 3, 4...`,
            
            gapInSequenceQuestion: (qIndex, before, after) => 
                `${ErrorMessages.question(qIndex, false)} - Problem: Your question image numbers skip from #${before} to #${after}. You're missing #${before + 1}.\n    Fix: Use image numbers in order without skipping: 0, 1, 2, 3, 4...`,
            
            gapInSequenceAnswer: (qIndex, before, after) => 
                `${ErrorMessages.question(qIndex, false)} - Problem: Your answer image numbers skip from #${before} to #${after}. You're missing #${before + 1}.\n    Fix: Use image numbers in order without skipping: 0, 1, 2, 3, 4...`,
            
            // Wrong order
            wrongOrderContent: (sIndex, foundOrder) => 
                `${ErrorMessages.contentSection(sIndex)} - Problem: Your images appear in wrong order. They should go 0, 1, 2, 3... but you have: ${foundOrder.join(', ')}\n    Fix: Rearrange your images in your text so they appear in order from top to bottom: 0, then 1, then 2, etc.`,
            
            wrongOrderQuestion: (qIndex, foundOrder, isMCQ) => 
                isMCQ
                    ? `${ErrorMessages.question(qIndex, true)} - Problem: Your images appear in wrong order across question and choices. They should go 0, 1, 2, 3... but you have: ${foundOrder.join(', ')}\n    Fix: Images should appear in order: first in setup text, then question text, then choice A, then choice B, etc.`
                    : `${ErrorMessages.question(qIndex, false)} - Problem: Your images appear in wrong order. They should go 0, 1, 2, 3... but you have: ${foundOrder.join(', ')}\n    Fix: Images should appear in order as you read the question from top to bottom.`,
            
            wrongOrderAnswer: (qIndex, foundOrder) => 
                `${ErrorMessages.question(qIndex, false)} - Problem: Your answer images appear in wrong order. They should go 0, 1, 2, 3... but you have: ${foundOrder.join(', ')}\n    Fix: Rearrange the images in your answer so they appear in order from top to bottom.`,
            
            // Out of range
            outOfRangeContent: (sIndex, imgNum, maxNum) => 
                `${ErrorMessages.contentSection(sIndex)} - Problem: Your table tries to use image #${imgNum}, but you only have images #0 to #${maxNum} (${maxNum + 1} image${maxNum !== 0 ? 's' : ''} total).\n    Fix: Either add more image boxes or change the table to use an existing image number (0 to ${maxNum}).`,
            
            outOfRangeQuestion: (qIndex, imgNum, maxNum, isChoice) => 
                isChoice
                    ? `${ErrorMessages.question(qIndex, true)} - Problem: Your choice text tries to use image #${imgNum}, but you only have images #0 to #${maxNum} in "Question Images".\n    Fix: Either add more image boxes or change the choice to use an existing image number (0 to ${maxNum}).`
                    : `${ErrorMessages.question(qIndex, false)} - Problem: Your table tries to use image #${imgNum}, but you only have images #0 to #${maxNum} in "Question Images".\n    Fix: Either add more image boxes or change the table to use an existing image number (0 to ${maxNum}).`,
            
            outOfRangeAnswer: (qIndex, imgNum, maxNum) => 
                `${ErrorMessages.question(qIndex, false)} - Problem: Your answer table tries to use image #${imgNum}, but you only have images #0 to #${maxNum} in "Answer Images".\n    Fix: Either add more image boxes or change the table to use an existing image number (0 to ${maxNum}).`,
            
            // Required fields
            requiredContent: (sIndex) => 
                `${ErrorMessages.contentSection(sIndex)} - Problem: This section is empty.\n    Fix: Add some content text for this section or delete it if you don't need it.`,
            
            requiredQuestionID: (qIndex) => 
                `${ErrorMessages.question(qIndex, false)} - Problem: Question ID is missing.\n    Fix: Enter a question number or ID (for example: 1, 2, 3...).`,
            
            requiredQuestionText: (qIndex) => 
                `${ErrorMessages.question(qIndex, false)} - Problem: Question text is missing.\n    Fix: Type the question text in the "Question Text" field.`,
            
            requiredAnswer: (qIndex) => 
                `${ErrorMessages.question(qIndex, false)} - Problem: Answer is missing.\n    Fix: Type the answer in the "Guide Answer" field.`,
            
            requiredGuidePage: (qIndex) => 
                `${ErrorMessages.question(qIndex, false)} - Problem: Guide PDF page number is missing.\n    Fix: Enter the page number from the teacher guide where this answer appears (for example: 78).`,
            
            invalidGuidePage: (qIndex) => 
                `${ErrorMessages.question(qIndex, false)} - Problem: Guide PDF page must be a whole number (like 1, 2, 3... not 1.5 or text).\n    Fix: Enter a valid page number like 78.`,
            
            guidePageOutOfRange: (qIndex, guidePage, startPage, endPage) => 
                `${ErrorMessages.question(qIndex, false)} - Problem: Guide PDF page (${guidePage}) is outside the guidebook range (${startPage}-${endPage}).\n    Fix: Enter a page number between ${startPage} and ${endPage} (inclusive).`,
            
            requiredChoices: (qIndex) => 
                `${ErrorMessages.question(qIndex, true)} - Problem: You haven't added any answer choices yet.\n    Fix: Click "+ Add Choice" to add answer options (A, B, C, D...).`,
            
            requiredCheckboxChoices: (qIndex) => 
                ` Question ${qIndex + 1} (Checkbox) - Problem: You haven't added any answer choices yet.\n    Fix: Click "+ Add Choice" to add checkbox options.`,
            
            requiredCorrectAnswer: (qIndex) => 
                `${ErrorMessages.question(qIndex, true)} - Problem: You haven't selected which choice is the correct answer.\n    Fix: Click one of the radio buttons to select the correct answer position.`,
            
            requiredCheckedChoice: (qIndex) => 
                ` Question ${qIndex + 1} (Checkbox) - Problem: At least one choice must be marked as correct.\n    Fix: Check at least one " Correct Answer" checkbox to indicate which choice(s) are correct.`,

            inconsistentChoiceIDs: (qIndex, questionType) =>
                `${ErrorMessages.question(qIndex, questionType === 'checkbox')} - Problem: Choice IDs are inconsistent. Either all choices should have IDs or none should.\n    Fix: Fill in all choice IDs (A, B, C...) or leave them all empty.`,

            // Fill in the blanks errors
            noBlanksFound: (qIndex) =>
                ` Question ${qIndex + 1} (Fill in the Blanks) - Problem: No blanks found in question text.\n    Fix: Add blanks using the format ___1___, ___2___, ___3___, etc. (exactly 3 underscores on each side).`,

            invalidBlankFormat: (qIndex, details) =>
                ` Question ${qIndex + 1} (Fill in the Blanks) - Problem: Invalid blank format detected.\n   ${details}\n    Fix: Use exactly ___1___, ___2___, etc. (3 underscores, number, 3 underscores, no spaces or dashes).`,

            blankAnswerMismatch: (qIndex, blanksCount, answersCount) =>
                ` Question ${qIndex + 1} (Fill in the Blanks) - Problem: Number of blanks (${blanksCount}) doesn't match number of answers (${answersCount}).\n    Fix: Provide an answer for each blank in your question text.`,

            missingBlankAnswers: (qIndex, missingBlanks) =>
                ` Question ${qIndex + 1} (Fill in the Blanks) - Problem: Missing answers for blanks: ${missingBlanks.join(', ')}.\n    Fix: Fill in the answer for each blank.`,

            // Matching errors
            matchingNoLeftItems: (qIndex) =>
                ` Question ${qIndex + 1} (Matching) - Problem: No left items added.\n    Fix: Click "+ Add Left Item" to add items to the left column.`,

            matchingNoRightItems: (qIndex) =>
                ` Question ${qIndex + 1} (Matching) - Problem: No right items added.\n    Fix: Click "+ Add Right Item" to add items to the right column.`,

            matchingEmptyLeftItem: (qIndex, itemNum) =>
                ` Question ${qIndex + 1} (Matching) - Problem: Left item L${itemNum} is empty.\n    Fix: Enter text for this left item or remove it.`,

            matchingEmptyRightItem: (qIndex, itemNum) =>
                ` Question ${qIndex + 1} (Matching) - Problem: Right item R${itemNum} is empty.\n    Fix: Enter text for this right item or remove it.`,

            matchingInvalidRelationship: (qIndex, leftIdx, rightIdx, leftCount, rightCount) =>
                ` Question ${qIndex + 1} (Matching) - Problem: Invalid relationship [${leftIdx}, ${rightIdx}]. Left index out of range (1-${leftCount}) or right index out of range (1-${rightCount}).\n    Fix: Make sure all relationships reference valid item positions.`,

            matchingIncompleteRelationship: (qIndex, relNum) =>
                ` Question ${qIndex + 1} (Matching) - Problem: Relationship #${relNum} is incomplete (missing left or right selection).\n    Fix: Select both left and right items for this relationship or remove it.`,
            
            // Annotate errors
            annotateNoImageOrTable: (qIndex) =>
                ` Question ${qIndex + 1} (Annotate) - Problem: Guide answer must contain either an image or a table.\n    Fix: Click "Insert Image" or "Insert Table" in the guide answer field to add content that students will annotate.`,
            
            // Create table errors
            createTableNoTable: (qIndex) =>
                ` Question ${qIndex + 1} (Create Table) - Problem: Guide answer must contain a table.\n    Fix: Click "Insert Table" in the guide answer field to add the table structure students should create.`,
            
            // Warnings
            warningSectionTitle: (sIndex) => 
                ` Content Section ${sIndex + 1} - Suggestion: You might want to add a section title to make it easier to organize your content.\n    Tip: A good title helps identify what this section is about.`,
            
            // Bbox validation
            invalidBboxPage: (location, imgNum) => 
                `${location}, Image #${imgNum} - Problem: Page number must be a whole number between 1 and 9999.\n    Fix: Enter a valid page number (like 23, not 23.5 or text).`,
            
            invalidBboxX0: (location, imgNum) => 
                `${location}, Image #${imgNum} - Problem: Left position (x0) must be a whole number.\n    Fix: Make sure this field contains only numbers.`,
            
            invalidBboxY0: (location, imgNum) => 
                `${location}, Image #${imgNum} - Problem: Top position (y0) must be a whole number.\n    Fix: Make sure this field contains only numbers.`,
            
            invalidBboxX1: (location, imgNum) => 
                `${location}, Image #${imgNum} - Problem: Right position (x1) must be a whole number.\n    Fix: Make sure this field contains only numbers.`,
            
            invalidBboxY1: (location, imgNum) => 
                `${location}, Image #${imgNum} - Problem: Bottom position (y1) must be a whole number.\n    Fix: Make sure this field contains only numbers.`,
            
            invalidBboxX0X1: (location, imgNum) => 
                `${location}, Image #${imgNum} - Problem: The left edge must be to the left of the right edge.\n    Fix: Check your box coordinates - left (x0) should be smaller than right (x1).`,
            
            invalidBboxY0Y1: (location, imgNum) => 
                `${location}, Image #${imgNum} - Problem: The top edge must be above the bottom edge.\n    Fix: Check your box coordinates - top (y0) should be smaller than bottom (y1).`
        };

        function showTab(tabName) {
            // Hide all tab contents (only within the input-form main tab)
            const inputFormTab = document.getElementById('input-form');
            if (inputFormTab) {
                const tabContents = inputFormTab.querySelectorAll('.tab-content');
            tabContents.forEach(content => content.classList.remove('active'));
            
                // Remove active class from all tabs within input-form
                const tabs = inputFormTab.querySelectorAll('.tabs:not(.main-tabs) .tab');
            tabs.forEach(tab => tab.classList.remove('active'));
            }
            
            // Show selected tab content
            const targetTabContent = document.getElementById(tabName);
            if (targetTabContent) {
                targetTabContent.classList.add('active');
            }
            
            // Add active class to corresponding tab button (only within input-form)
            if (inputFormTab) {
                const tabButtons = inputFormTab.querySelectorAll('.tabs:not(.main-tabs) .tab');
            tabButtons.forEach(tab => {
                if (tab.getAttribute('onclick')?.includes(`'${tabName}'`) || 
                    tab.getAttribute('onclick')?.includes(`"${tabName}"`)) {
                    tab.classList.add('active');
                }
            });
            }
            
            // Track tab navigation
            trackEvent('tab_navigation', {
                tab_name: tabName
            });
        }

        function showMainTab(tabName) {
            // Hide all main tab contents
            const mainTabContents = document.querySelectorAll('.main-tab-content');
            mainTabContents.forEach(content => content.classList.remove('active'));
            
            // Remove active class from all main tabs
            const mainTabs = document.querySelectorAll('.main-tabs .tab');
            mainTabs.forEach(tab => tab.classList.remove('active'));
            
            // Show selected main tab content
            const targetMainTabContent = document.getElementById(tabName);
            if (targetMainTabContent) {
                targetMainTabContent.classList.add('active');
                
                // If showing final preview, generate it
                if (tabName === 'final-preview') {
                    generateFinalPreview();
                }
            }
            
            // Add active class to corresponding main tab button
            mainTabs.forEach(tab => {
                if (tab.id === `main-tab-${tabName === 'input-form' ? 'input' : 'preview'}`) {
                    tab.classList.add('active');
                }
            });
            
            // Track main tab navigation
            trackEvent('main_tab_navigation', {
                tab_name: tabName
            });
        }

        // Navigate to input field from preview
        function navigateToInput(element) {
            if (!element) return;
            
            // Determine which inner tab to switch to based on the element's location
            let targetTab = 'basic'; // default
            
            // Check if element is in content sections
            if (element.closest('#content_sections_container')) {
                targetTab = 'content';
            }
            // Check if element is in questions
            else if (element.closest('#questions_container')) {
                targetTab = 'questions';
            }
            // Check if element is in preamble
            else if (element.closest('#preamble')) {
                targetTab = 'preamble';
            }
            
            // Find the closest array-item (section/question) and expand it if collapsed
            const arrayItem = element.closest('.array-item');
            if (arrayItem && arrayItem.classList.contains('collapsed')) {
                arrayItem.classList.remove('collapsed');
            }
            
            // Switch to input form main tab first
            showMainTab('input-form');
            
            // Wait a bit, then switch to the correct inner tab
            setTimeout(function() {
                showTab(targetTab);
                
                // Wait for tab switch, then scroll to element
                setTimeout(function() {
                    if (element && element.scrollIntoView) {
                        element.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        // Highlight the element briefly
                        const originalBg = element.style.backgroundColor;
                        element.style.backgroundColor = '#fff3cd';
                        element.style.transition = 'background-color 0.3s ease';
                        setTimeout(function() {
                            element.style.backgroundColor = originalBg;
                            setTimeout(function() {
                                element.style.transition = '';
                            }, 300);
                        }, 2000);
                        // Focus the input if it's an input or textarea
                        if (element.tagName === 'INPUT' || element.tagName === 'TEXTAREA') {
                            element.focus();
                        } else {
                            // Try to find and focus the input/textarea within
                            const input = element.querySelector('input, textarea');
                            if (input) input.focus();
                        }
                    }
                }, 100);
            }, 50);
        }

        // Generate Final Preview
        function generateFinalPreview() {
            const previewContainer = document.getElementById('final-preview-content');
            if (!previewContainer) return;
            
            let html = '';
            
            // First, render all content sections
            const contentSections = document.querySelectorAll('#content_sections_container > .array-item');
            if (contentSections.length > 0) {
                html += '<div class="final-preview-section"><h3>Content Sections</h3>';
                contentSections.forEach((sectionEl, index) => {
                    const titleInput = sectionEl.querySelector('input[placeholder="Section title"]');
                    const textarea = sectionEl.querySelector('.text-field-container textarea');
                    const title = titleInput ? titleInput.value || '' : '';
                    const text = textarea ? textarea.value || '' : '';
                    
                    html += `<div class="final-preview-section">`;
                    
                    // Section Title Preview (separate box)
                    if (title && titleInput) {
                        // Find existing preview for title
                        let titlePreview = null;
                        let sibling = titleInput.nextElementSibling;
                        while (sibling) {
                            if (sibling.classList && sibling.classList.contains('live-preview')) {
                                titlePreview = sibling;
                                break;
                            }
                            sibling = sibling.nextElementSibling;
                        }
                        
                        if (titlePreview && titlePreview.innerHTML) {
                            // Use existing preview exactly as it is, but always RTL in final preview
                            const sectionId = 'content-section-' + index;
                            sectionEl.setAttribute('data-preview-id', sectionId);
                            html += `<div class="preview-section" data-navigate-to="${sectionId}" data-target-element="title" style="position: relative;"><div style="position: absolute; top: 8px; right: 8px; color: var(--accent); font-size: 0.85rem; opacity: 0.7; cursor: pointer; padding: 4px; border-radius: 4px; transition: all 0.2s ease;" onclick="navigateToInput(document.querySelector('#content_sections_container > .array-item:nth-child(${index + 1}) input[placeholder=\\'Section title\\']'))" onmouseover="this.style.opacity='1'; this.style.background='var(--bg-tertiary)';" onmouseout="this.style.opacity='0.7'; this.style.background='transparent';" title="Click to edit"><i class="fas fa-edit"></i></div><h5 class="preview-section-label">Section Title</h5><div class="setup-text"><div class="live-preview" dir="rtl" style="text-align: right;">${titlePreview.innerHTML}</div></div></div>`;
                        } else {
                            // Render title preview if it doesn't exist, but always RTL in final preview
                            const tempTitlePreview = document.createElement('div');
                            tempTitlePreview.className = 'live-preview';
                            tempTitlePreview.setAttribute('dir', 'rtl');
                            tempTitlePreview.style.textAlign = 'right';
                            renderLivePreviewToElement(titleInput, tempTitlePreview);
                            const sectionId = 'content-section-' + index;
                            sectionEl.setAttribute('data-preview-id', sectionId);
                            html += `<div class="preview-section" data-navigate-to="${sectionId}" data-target-element="title" style="position: relative;"><div style="position: absolute; top: 8px; right: 8px; color: var(--accent); font-size: 0.85rem; opacity: 0.7; cursor: pointer; padding: 4px; border-radius: 4px; transition: all 0.2s ease;" onclick="navigateToInput(document.querySelector('#content_sections_container > .array-item:nth-child(${index + 1}) input[placeholder=\\'Section title\\']'))" onmouseover="this.style.opacity='1'; this.style.background='var(--bg-tertiary)';" onmouseout="this.style.opacity='0.7'; this.style.background='transparent';" title="Click to edit"><i class="fas fa-edit"></i></div><h5 class="preview-section-label">Section Title</h5><div class="setup-text"><div class="live-preview" dir="rtl" style="text-align: right;">${tempTitlePreview.innerHTML}</div></div></div>`;
                        }
                    }
                    
                    // Content Preview (separate box)
                    if (text && textarea) {
                        // Find existing preview for content
                        let contentPreview = null;
                        let sibling = textarea.nextElementSibling;
                        while (sibling) {
                            if (sibling.classList && sibling.classList.contains('live-preview')) {
                                contentPreview = sibling;
                                break;
                            }
                            sibling = sibling.nextElementSibling;
                        }
                        
                        if (contentPreview && contentPreview.innerHTML) {
                            // Use existing preview exactly as it is, but always RTL in final preview
                            const sectionId = 'content-section-' + index;
                            html += `<div class="preview-section" data-navigate-to="${sectionId}" data-target-element="content" style="position: relative;"><div style="position: absolute; top: 8px; right: 8px; color: var(--accent); font-size: 0.85rem; opacity: 0.7; cursor: pointer; padding: 4px; border-radius: 4px; transition: all 0.2s ease;" onclick="navigateToInput(document.querySelector('#content_sections_container > .array-item:nth-child(${index + 1}) .text-field-container textarea'))" onmouseover="this.style.opacity='1'; this.style.background='var(--bg-tertiary)';" onmouseout="this.style.opacity='0.7'; this.style.background='transparent';" title="Click to edit"><i class="fas fa-edit"></i></div><h5 class="preview-section-label">Content</h5><div class="setup-text"><div class="live-preview" dir="rtl" style="text-align: right;">${contentPreview.innerHTML}</div></div></div>`;
                        } else {
                            // Render content preview if it doesn't exist, but always RTL in final preview
                            const tempContentPreview = document.createElement('div');
                            tempContentPreview.className = 'live-preview';
                            tempContentPreview.setAttribute('dir', 'rtl');
                            tempContentPreview.style.textAlign = 'right';
                            renderLivePreviewToElement(textarea, tempContentPreview);
                            const sectionId = 'content-section-' + index;
                            html += `<div class="preview-section" data-navigate-to="${sectionId}" data-target-element="content" style="position: relative;"><div style="position: absolute; top: 8px; right: 8px; color: var(--accent); font-size: 0.85rem; opacity: 0.7; cursor: pointer; padding: 4px; border-radius: 4px; transition: all 0.2s ease;" onclick="navigateToInput(document.querySelector('#content_sections_container > .array-item:nth-child(${index + 1}) .text-field-container textarea'))" onmouseover="this.style.opacity='1'; this.style.background='var(--bg-tertiary)';" onmouseout="this.style.opacity='0.7'; this.style.background='transparent';" title="Click to edit"><i class="fas fa-edit"></i></div><h5 class="preview-section-label">Content</h5><div class="setup-text"><div class="live-preview" dir="rtl" style="text-align: right;">${tempContentPreview.innerHTML}</div></div></div>`;
                        }
                    }
                    
                    // If neither title nor content exists
                    if (!title && !text) {
                        html += '<p style="color: #6c757d; font-style: italic;">(No content)</p>';
                    }
                    
                    html += `</div>`;
                });
                html += '</div>';
            }
            
            // Then, render all questions
            const questions = document.querySelectorAll('#questions_container > .array-item');
            if (questions.length > 0) {
                html += '<div class="final-preview-section"><h3>Questions</h3>';
                questions.forEach((questionEl, index) => {
                    html += renderQuestionPreview(questionEl, index);
                });
                html += '</div>';
            }
            
            // If no content, show message
            if (contentSections.length === 0 && questions.length === 0) {
                html = '<div class="final-preview-section"><p style="color: #6c757d; font-style: italic;">No content sections or questions to preview. Add some content in the Input Form tab.</p></div>';
            }
            
            previewContainer.innerHTML = html;
            
            // Apply current font size and line height to all live-preview elements in final preview
            const savedFontSize = localStorage.getItem('fontSize') || '14';
            const savedLineHeight = localStorage.getItem('lineHeight') || '1.5';
            const fontSize = savedFontSize + 'px';
            const lineHeight = savedLineHeight;
            
            // Apply to all live-preview elements in the final preview container
            previewContainer.querySelectorAll('.live-preview').forEach(el => {
                el.style.fontSize = fontSize;
                el.style.lineHeight = lineHeight;
            });
            
            // Draw matching lines after DOM is ready
            setTimeout(function() {
                drawMatchingLines();
            }, 300);
            
            // Also try again after a longer delay in case rendering takes time
            setTimeout(function() {
                drawMatchingLines();
            }, 1000);
            
            // Re-render any LaTeX or markdown in the preview
            previewContainer.querySelectorAll('.live-preview').forEach(preview => {
                // Math rendering will be handled by existing KaTeX setup
                if (window.renderMathInElement) {
                    window.renderMathInElement(preview, {
                        delimiters: [
                            {left: '$$', right: '$$', display: true},
                            {left: '$', right: '$', display: false}
                        ]
                    });
                }
            });
        }

        // Helper function to render markdown to an element (similar to renderLivePreview but for a target element)
        function renderLivePreviewToElement(textarea, targetElement) {
            if (!targetElement || !textarea) return;
            
            try {
                // Check if textarea already has a rendered preview - if so, use that
                let existingPreview = null;
                let sibling = textarea.nextElementSibling;
                while (sibling) {
                    if (sibling.classList && sibling.classList.contains('live-preview')) {
                        existingPreview = sibling;
                        break;
                    }
                    sibling = sibling.nextElementSibling;
                }
                
                // If preview exists and has content, copy it
                if (existingPreview && existingPreview.innerHTML) {
                    targetElement.innerHTML = existingPreview.innerHTML;
                    targetElement.setAttribute('dir', existingPreview.getAttribute('dir') || 'rtl');
                    targetElement.style.textAlign = existingPreview.style.textAlign || 'right';
                    return;
                }
                
                // Otherwise, trigger a render by calling renderLivePreview if the preview element exists
                // First, check if we can attach preview to the textarea temporarily
                // But we don't want to modify the DOM, so we'll do a simplified render
                
                // Use the same math extraction approach as renderLivePreview
                let md = (textarea.value || '').replace(/\r\n?/g, '\n');
                const isLTR = textarea.hasAttribute('data-ltr');
                const direction = isLTR ? 'ltr' : 'rtl';
                const textAlign = isLTR ? 'left' : 'right';
                
                targetElement.setAttribute('dir', direction);
                targetElement.style.textAlign = textAlign;
                
                // Extract math expressions BEFORE markdown parsing (same as renderLivePreview)
                const mathBlocks = [];
                const inlineMath = [];
                
                // Extract block math ($$\n...\n$$)
                md = md.replace(/\$\$\s*\\n([\s\S]*?)\\n\s*\$\$/g, (m, inner) => {
                    let fixed = inner.replace(/\\n/g, '\n').trim();
                    // Escape < and > symbols to prevent HTML interpretation issues
                    fixed = fixed.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                    const hasEnv = /\\begin\{(aligned|align\*?|gather\*?)\}/.test(fixed);
                    const hasLineBreaks = /\\\\/.test(fixed); // contains \\
                    if (hasLineBreaks && !hasEnv) {
                        fixed = `\\begin{aligned}\n${fixed}\n\\end{aligned}`;
                    }
                    const idx = mathBlocks.push(fixed) - 1;
                    return `@@MATH_BLOCK_${idx}@@`;
                });
                
                // Extract inline math ($...$) - increased limit to handle long expressions like arrays
                md = md.replace(/(^|[^$])\$\s*([^$\n]{1,5000}?)\s*\$(?!\$)/g, (m, pre, inner) => {
                    // Only process if we have a valid closing $ and reasonable content length
                    if (inner.trim().length === 0) return m; // Don't process empty math
                    // Escape < and > symbols to prevent HTML interpretation issues
                    const escapedInner = inner.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                    return `${pre}@@INLINE_MATH_${inlineMath.push(escapedInner)-1}@@`;
                });
                
                // Render markdown
                if (window.marked && typeof window.marked.parse === 'function') {
                    if (window.marked.setOptions) {
                        window.marked.setOptions({ gfm: true, breaks: true });
                    }
                    let html = window.marked.parse(md);
                    
                    // Re-inject math placeholders as elements for KaTeX to render (block math first)
                    mathBlocks.forEach((content, i) => {
                        const token = `@@MATH_BLOCK_${i}@@`;
                        const holder = `<div class="__math_block" data-math-idx="${i}" style="text-align: center; margin: 1em auto; display: block;"></div>`;
                        html = html.split(token).join(holder);
                    });
                    
                    // Unescape HTML entities that were escaped during math processing
                    html = html.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
                    
                    targetElement.innerHTML = html;
                    
                    // Replace inline math placeholders in text nodes
                    const walker = document.createTreeWalker(targetElement, NodeFilter.SHOW_TEXT, null);
                    const textNodes = [];
                    while (walker.nextNode()) textNodes.push(walker.currentNode);
                    const inlineRe = /@@INLINE_MATH_(\d+)@@/g;
                    textNodes.forEach(node => {
                        const text = node.nodeValue;
                        if (!inlineRe.test(text)) return;
                        inlineRe.lastIndex = 0;
                        const frag = document.createDocumentFragment();
                        let lastIndex = 0;
                        let match;
                        while ((match = inlineRe.exec(text)) !== null) {
                            const before = text.slice(lastIndex, match.index);
                            if (before) frag.appendChild(document.createTextNode(before));
                            const idx = parseInt(match[1], 10);
                            const span = document.createElement('span');
                            span.className = '__math_inline';
                            span.setAttribute('data-im', String(idx));
                            frag.appendChild(span);
                            lastIndex = match.index + match[0].length;
                        }
                        const after = text.slice(lastIndex);
                        if (after) frag.appendChild(document.createTextNode(after));
                        node.parentNode.replaceChild(frag, node);
                    });
                    
                    // Process images to match original rendering exactly
                    // Create a temporary container to hold all images before processing
                    const tempContainer = document.createElement('div');
                    tempContainer.innerHTML = targetElement.innerHTML;
                    const imgs = tempContainer.querySelectorAll('img[alt]');
                    
                    imgs.forEach(img => {
                        const alt = img.getAttribute('alt') || '';
                        const src = img.getAttribute('src') || '';
                        
                        // Description is in alt, index is in src (from markdown ![desc](index))
                        let description = alt;
                        
                        // Create container matching original format
                        const container = document.createElement('div');
                        container.style.display = 'block';
                        container.style.textAlign = 'center';
                        container.style.margin = '12px auto';
                        
                        // Create placeholder matching original
                        const placeholder = document.createElement('div');
                        placeholder.style.width = '200px';
                        placeholder.style.height = '150px';
                        placeholder.style.backgroundColor = '#f0f0f0';
                        placeholder.style.border = '2px dashed #ccc';
                        placeholder.style.borderRadius = '4px';
                        placeholder.style.display = 'flex';
                        placeholder.style.alignItems = 'center';
                        placeholder.style.justifyContent = 'center';
                        placeholder.style.margin = '0 auto';
                        placeholder.innerHTML = '<span style="color: #999; font-size: 14px;"> Image</span>';
                        
                        // Create caption span
                        const captionSpan = document.createElement('span');
                        captionSpan.className = 'image-description-math';
                        captionSpan.style.display = 'block';
                        captionSpan.style.marginTop = '4px';
                        captionSpan.style.direction = 'ltr';
                        captionSpan.style.unicodeBidi = 'isolate';
                        
                        // Add description if it exists
                        if (description) {
                            // Check for LaTeX in description (from original renderLivePreview processing)
                            if (description.includes('@@INLINE_MATH_')) {
                                const parts = description.split(/@@INLINE_MATH_(\d+)@@/);
                                parts.forEach((part, idx) => {
                                    if (idx % 2 === 0) {
                                        if (part) captionSpan.appendChild(document.createTextNode(part));
                                    } else {
                                        const mathSpan = document.createElement('span');
                                        mathSpan.className = '__math_inline';
                                        mathSpan.setAttribute('data-im', part);
                                        captionSpan.appendChild(mathSpan);
                                    }
                                });
                            } else {
                                captionSpan.appendChild(document.createTextNode(description));
                            }
                            container.appendChild(placeholder);
                            if (captionSpan.firstChild) {
                                container.appendChild(captionSpan);
                            }
                        } else {
                            container.appendChild(placeholder);
                        }
                        
                        // Replace img with container
                        img.parentElement.replaceChild(container, img);
                    });
                    
                    // Update targetElement with processed HTML
                    targetElement.innerHTML = tempContainer.innerHTML;
                    
                    // Render math with KaTeX directly (same approach as renderLivePreview)
                    if (window.katex) {
                        // Render block math
                        const blockNodes = targetElement.querySelectorAll('.__math_block');
                        blockNodes.forEach(node => {
                            const i = parseInt(node.getAttribute('data-math-idx'), 10);
                            const originalTex = mathBlocks[i] || '';
                            const isBold = !!(node.closest('strong, b'));
                            const isItalic = !!(node.closest('em, i'));
                            let texToRender = originalTex;
                            // Avoid wrapping environments like aligned/align in macros
                            if (texToRender && !/\\begin\{[\s\S]*?\}/.test(texToRender)) {
                                if (isBold && isItalic) texToRender = `\\boldsymbol{\\mathit{${texToRender}}}`;
                                else if (isBold) texToRender = `\\boldsymbol{${texToRender}}`;
                                else if (isItalic) texToRender = `\\mathit{${texToRender}}`;
                            }
                            try { 
                                // Unescape HTML entities back to original symbols for KaTeX
                                texToRender = texToRender.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
                                window.katex.render(texToRender, node, { 
                                    displayMode: true,
                                    throwOnError: false,
                                    output: 'html'
                                }); 
                                // Force centering after rendering
                                node.style.textAlign = 'center';
                                node.style.margin = '1em auto';
                            } catch (e) {
                                console.error('KaTeX block error:', e);
                            }
                        });
                        
                        // Render inline math
                        const inlineNodes = targetElement.querySelectorAll('.__math_inline');
                        inlineNodes.forEach(node => {
                            const i = parseInt(node.getAttribute('data-im'), 10);
                            const originalTex = inlineMath[i] || '';
                            const isBold = !!(node.closest('strong, b'));
                            const isItalic = !!(node.closest('em, i'));
                            let texToRender = originalTex;
                            if (texToRender) {
                                if (isBold && isItalic) texToRender = `\\boldsymbol{\\mathit{${texToRender}}}`;
                                else if (isBold) texToRender = `\\boldsymbol{${texToRender}}`;
                                else if (isItalic) texToRender = `\\mathit{${texToRender}}`;
                            }
                            try { 
                                // Unescape HTML entities back to original symbols for KaTeX
                                texToRender = texToRender.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
                                window.katex.render(texToRender, node, { 
                                    displayMode: false,
                                    throwOnError: false,
                                    output: 'html'
                                }); 
                            } catch (e) {
                                console.error('KaTeX inline error:', e);
                            }
                        });
                    }
                    
                    // Force all LaTeX elements to be LTR regardless of parent direction
                    const allMathElements = targetElement.querySelectorAll('.__math_block, .__math_inline, .katex, .katex-display, .katex-html, .katex *');
                    allMathElements.forEach(mathEl => {
                        mathEl.setAttribute('dir', 'ltr');
                        mathEl.style.direction = 'ltr';
                        mathEl.style.unicodeBidi = 'isolate';
                    });
                } else {
                    // Fallback: plain text
                    targetElement.textContent = md;
                }
                
            } catch (e) {
                console.error('Error rendering preview:', e);
                // Fallback: simple text display
                targetElement.textContent = textarea ? textarea.value || '' : '';
            }
        }

        // Render a question preview based on its type
        function renderQuestionPreview(questionEl, index) {
            const questionIdInput = findFieldByLabel(questionEl, 'Question ID', 'input');
            const questionId = questionIdInput ? questionIdInput.value || `${index + 1}` : `${index + 1}`;
            
            const questionTypeSelect = questionEl.querySelector('select[onchange*="toggleQuestionType"]');
            const questionType = questionTypeSelect ? questionTypeSelect.value : 'free_form';
            
            const setupTextarea = findFieldByLabel(questionEl, 'Set-up Text', 'textarea');
            const setupText = setupTextarea ? setupTextarea.value || '' : '';
            
            const questionTextarea = questionEl.querySelector('textarea[placeholder*="Enter question text"]');
            const questionText = questionTextarea ? questionTextarea.value || '' : '';
            
            const questionTypeLabels = {
                'free_form': 'Free Form',
                'multiple_choice': 'Multiple Choice',
                'checkbox': 'Checkbox',
                'fill_in_the_blanks': 'Fill in the Blanks',
                'matching': 'Matching',
                'annotate': 'Annotate',
                'create_table': 'Create Table'
            };
            
            let html = `<div class="final-preview-question">`;
            html += `<h4>Question ${questionId}</h4>`;
            html += `<span class="question-type-badge">${questionTypeLabels[questionType] || 'Question'}</span>`;
            
            // Setup text - show if not empty (check both value and trimmed value)
            // Always RTL in final preview
            if (setupTextarea && setupText && setupText.trim()) {
                const setupPreview = document.createElement('div');
                setupPreview.className = 'live-preview setup-text';
                setupPreview.setAttribute('dir', 'rtl');
                setupPreview.style.textAlign = 'right';
                renderLivePreviewToElement(setupTextarea, setupPreview);
                const questionIndex = Array.from(document.querySelectorAll('#questions_container > .array-item')).indexOf(questionEl);
                // Store the setup textarea reference for navigation
                const setupTextareaId = setupTextarea.id || `setup-textarea-${Date.now()}-${questionIndex}`;
                if (!setupTextarea.id) {
                    setupTextarea.id = setupTextareaId;
                }
                html += `<div class="preview-section" style="position: relative;"><div style="position: absolute; top: 8px; right: 8px; color: var(--accent); font-size: 0.85rem; opacity: 0.7; cursor: pointer; padding: 4px; border-radius: 4px; transition: all 0.2s ease;" onclick="navigateToInput(document.getElementById('${setupTextareaId}'))" onmouseover="this.style.opacity='1'; this.style.background='var(--bg-tertiary)';" onmouseout="this.style.opacity='0.7'; this.style.background='transparent';" title="Click to edit"><i class="fas fa-edit"></i></div><h5 class="preview-section-label">Setup Text</h5><div class="setup-text"><div class="live-preview" dir="rtl" style="text-align: right;">${setupPreview.innerHTML}</div></div></div>`;
            }
            
            // Question text - always RTL in final preview
            if (questionText) {
                const questionPreview = document.createElement('div');
                questionPreview.className = 'live-preview question-text';
                questionPreview.setAttribute('dir', 'rtl');
                questionPreview.style.textAlign = 'right';
                renderLivePreviewToElement(questionTextarea, questionPreview);
                const questionIndex = Array.from(document.querySelectorAll('#questions_container > .array-item')).indexOf(questionEl);
                html += `<div class="preview-section" style="position: relative;"><div style="position: absolute; top: 8px; right: 8px; color: var(--accent); font-size: 0.85rem; opacity: 0.7; cursor: pointer; padding: 4px; border-radius: 4px; transition: all 0.2s ease;" onclick="navigateToInput(document.querySelectorAll('#questions_container > .array-item')[${questionIndex}].querySelector('textarea[placeholder*=\\'Enter question text\\']'))" onmouseover="this.style.opacity='1'; this.style.background='var(--bg-tertiary)';" onmouseout="this.style.opacity='0.7'; this.style.background='transparent';" title="Click to edit"><i class="fas fa-edit"></i></div><h5 class="preview-section-label">Question Text</h5><div class="question-text"><div class="live-preview" dir="rtl" style="text-align: right;">${questionPreview.innerHTML}</div></div></div>`;
            }
            
            // Render based on question type
            if (questionType === 'multiple_choice' || questionType === 'checkbox') {
                html += renderMultipleChoicePreview(questionEl, questionType);
                // Guide answer is already included in renderMultipleChoicePreview
            } else if (questionType === 'fill_in_the_blanks') {
                html += renderFillInBlanksPreview(questionEl);
                // Guide answer is already included in renderFillInBlanksPreview
            } else if (questionType === 'matching') {
                html += renderMatchingPreview(questionEl);
                // Guide answer is already included in renderMatchingPreview
            } else if (questionType === 'annotate' || questionType === 'create_table' || questionType === 'free_form') {
                html += renderGuideAnswerPreview(questionEl, questionType);
            }
            
            html += `</div>`;
            return html;
        }

        // Render multiple choice or checkbox preview
        function renderMultipleChoicePreview(questionEl, questionType) {
            const choicesList = questionEl.querySelector('[id^="choices-list-"]');
            if (!choicesList) return '';
            
            const choices = choicesList.querySelectorAll('.choice-item');
            if (choices.length === 0) return '';
            
            const questionIndex = Array.from(document.querySelectorAll('#questions_container > .array-item')).indexOf(questionEl);
            let html = '<div class="preview-section"><div class="choices-container"><h5 class="preview-section-label">Choices</h5>';
            
            choices.forEach((choiceEl, index) => {
                const choiceIdInput = choiceEl.querySelector('input[placeholder*="Choice ID"]');
                const choiceId = choiceIdInput ? choiceIdInput.value || String.fromCharCode(65 + index) : String.fromCharCode(65 + index);
                
                const choiceTextarea = choiceEl.querySelector('textarea');
                const choiceText = choiceTextarea ? choiceTextarea.value || '' : '';
                
                // For multiple_choice, check if this choice position is selected in the correct answer radios
                let isCorrect = false;
                if (questionType === 'multiple_choice') {
                    const radiosContainer = questionEl.querySelector('[id^="correct-answer-radios-"]');
                    if (radiosContainer) {
                        const checkedRadio = radiosContainer.querySelector('.choice-correct-radio:checked');
                        if (checkedRadio && parseInt(checkedRadio.value) === index + 1) {
                            isCorrect = true;
                        }
                    }
                } else if (questionType === 'checkbox') {
                    isCorrect = choiceEl.querySelector('input[type="checkbox"].choice-correct:checked') !== null;
                }
                
                html += `<div class="choice-item ${isCorrect ? 'correct' : ''}" style="position: relative;"><div style="position: absolute; top: 8px; right: 8px; color: var(--accent); font-size: 0.85rem; opacity: 0.7; cursor: pointer; padding: 4px; border-radius: 4px; transition: all 0.2s ease;" onclick="navigateToInput(document.querySelectorAll('#questions_container > .array-item')[${questionIndex}].querySelectorAll('.choice-item')[${index}].querySelector('textarea'))" onmouseover="this.style.opacity='1'; this.style.background='var(--bg-tertiary)';" onmouseout="this.style.opacity='0.7'; this.style.background='transparent';" title="Click to edit"><i class="fas fa-edit"></i></div>`;
                html += `<span class="choice-id">${escapeHtml(choiceId)}.</span>`;
                
                if (choiceText) {
                    const choicePreview = document.createElement('div');
                    choicePreview.className = 'live-preview';
                    // Always RTL in final preview
                    choicePreview.setAttribute('dir', 'rtl');
                    choicePreview.style.textAlign = 'right';
                    renderLivePreviewToElement(choiceTextarea, choicePreview);
                    html += `<div class="live-preview" dir="rtl" style="text-align: right;">${choicePreview.innerHTML}</div>`;
                } else {
                    html += '<span style="color: #6c757d; font-style: italic;">(No choice text)</span>';
                }
                
                if (isCorrect) {
                    html += ' <span style="color: #28a745; font-weight: 600;"> Correct</span>';
                }
                
                html += `</div>`;
            });
            
            html += '</div></div>';
            
            // Guide answer (same approach as fill_in_the_blanks and matching)
            // For multiple_choice and checkbox, guide answer is inside the choices container
            const choicesContainer = questionEl.querySelector('#choices-container');
            if (choicesContainer) {
                const guideAnswerTextarea = choicesContainer.querySelector('.guide-answer-notes');
                if (guideAnswerTextarea && guideAnswerTextarea.value && guideAnswerTextarea.value.trim()) {
                    const guidePreview = document.createElement('div');
                    guidePreview.className = 'live-preview';
                    // Always RTL in final preview
                    guidePreview.setAttribute('dir', 'rtl');
                    guidePreview.style.textAlign = 'right';
                    renderLivePreviewToElement(guideAnswerTextarea, guidePreview);
                    html += `<div class="preview-section" style="position: relative;"><div style="position: absolute; top: 8px; right: 8px; color: var(--accent); font-size: 0.85rem; opacity: 0.7; cursor: pointer; padding: 4px; border-radius: 4px; transition: all 0.2s ease;" onclick="navigateToInput(document.querySelectorAll('#questions_container > .array-item')[${questionIndex}].querySelector('#choices-container .guide-answer-notes'))" onmouseover="this.style.opacity='1'; this.style.background='var(--bg-tertiary)';" onmouseout="this.style.opacity='0.7'; this.style.background='transparent';" title="Click to edit"><i class="fas fa-edit"></i></div><div class="guide-answer"><h5 class="preview-section-label">Guide Answer</h5><div class="live-preview" dir="rtl" style="text-align: right;">${guidePreview.innerHTML}</div></div></div>`;
                }
            }
            
            return html;
        }

        // Render fill in the blanks preview
        function renderFillInBlanksPreview(questionEl) {
            const blanksContainer = questionEl.querySelector('#blanks-container');
            if (!blanksContainer) return '';
            
            const blanksAnswersContainer = questionEl.querySelector('#blanks-answers-container');
            const questionTextarea = questionEl.querySelector('textarea[placeholder*="Enter question text"]');
            const questionText = questionTextarea ? questionTextarea.value || '' : '';
            
            const questionIndex = Array.from(document.querySelectorAll('#questions_container > .array-item')).indexOf(questionEl);
            let html = '';
            
            // Blank answers list (comes first)
            const blankAnswers = blanksContainer.querySelectorAll('.blank-answer-item');
            if (blankAnswers.length > 0) {
                html += '<div class="preview-section"><div class="blanks-container"><h5 class="preview-section-label">Answers</h5>';
                
                blankAnswers.forEach((blankEl, index) => {
                    const blankNumber = index + 1;
                    const blankTextarea = blankEl.querySelector('textarea');
                    const blankText = blankTextarea ? blankTextarea.value || '' : '';
                    
                    html += `<div class="blank-answer" style="position: relative;"><div style="position: absolute; top: 8px; right: 8px; color: var(--accent); font-size: 0.85rem; opacity: 0.7; cursor: pointer; padding: 4px; border-radius: 4px; transition: all 0.2s ease;" onclick="navigateToInput(document.querySelectorAll('#questions_container > .array-item')[${questionIndex}].querySelectorAll('#blanks-container .blank-answer-item')[${index}].querySelector('textarea'))" onmouseover="this.style.opacity='1'; this.style.background='var(--bg-tertiary)';" onmouseout="this.style.opacity='0.7'; this.style.background='transparent';" title="Click to edit"><i class="fas fa-edit"></i></div>`;
                    html += `<span class="blank-number">Blank ${blankNumber}:</span>`;
                    
                    if (blankText) {
                        const blankPreview = document.createElement('div');
                        blankPreview.className = 'live-preview';
                        // Always RTL in final preview
                        blankPreview.setAttribute('dir', 'rtl');
                        blankPreview.style.textAlign = 'right';
                        renderLivePreviewToElement(blankTextarea, blankPreview);
                        html += `<div class="live-preview" dir="rtl" style="text-align: right;">${blankPreview.innerHTML}</div>`;
                    } else {
                        html += '<span style="color: #6c757d; font-style: italic;">(No answer)</span>';
                    }
                    
                    html += `</div>`;
                });
                
                html += '</div></div>';
            }
            
            // Add filled blanks preview (question text with answers inserted) - comes after Answers
            if (questionText && blanksAnswersContainer && typeof parseBlanksFromText === 'function') {
                const blankItems = blanksAnswersContainer.querySelectorAll('.blank-answer-item');
                const blankAnswersMap = {};
                
                blankItems.forEach(item => {
                    const blankNum = item.dataset.blankNumber;
                    const textarea = item.querySelector('.blank-answer-input');
                    if (textarea && blankNum) {
                        blankAnswersMap[blankNum] = textarea.value.trim();
                    }
                });
                
                const blanks = parseBlanksFromText(questionText);
                const allFilled = blanks.length > 0 && blanks.every(num => blankAnswersMap[num] && blankAnswersMap[num].trim());
                
                if (allFilled) {
                    // Replace blanks with answers
                    let filledText = questionText;
                    blanks.forEach(num => {
                        const answer = blankAnswersMap[num] || '';
                        const regex = new RegExp(`___${num}___`, 'g');
                        // Use the same styling as the input form preview
                        // Don't escape here - renderLivePreviewToElement will handle it properly
                        filledText = filledText.replace(regex, `<span style="display: inline-block; padding: 2px 6px; background: linear-gradient(135deg, #28a745 0%, #20c997 100%); color: white; border-radius: 3px; font-weight: 600; box-shadow: 0 1px 3px rgba(0,0,0,0.2);">${answer}</span>`);
                    });
                    
                    const filledPreview = document.createElement('div');
                    filledPreview.className = 'live-preview';
                    // Always RTL in final preview
                    filledPreview.setAttribute('dir', 'rtl');
                    filledPreview.style.textAlign = 'right';
                    
                    // Create temporary textarea to use renderLivePreviewToElement
                    const tempTextarea = document.createElement('textarea');
                    tempTextarea.value = filledText;
                    tempTextarea.setAttribute('dir', 'rtl');
                    renderLivePreviewToElement(tempTextarea, filledPreview);
                    
                    html += `<div class="preview-section" style="position: relative;"><div style="position: absolute; top: 8px; right: 8px; color: var(--accent); font-size: 0.85rem; opacity: 0.7; cursor: pointer; padding: 4px; border-radius: 4px; transition: all 0.2s ease;" onclick="navigateToInput(document.querySelectorAll('#questions_container > .array-item')[${questionIndex}].querySelector('textarea[placeholder*=\\'Enter question text\\']'))" onmouseover="this.style.opacity='1'; this.style.background='var(--bg-tertiary)';" onmouseout="this.style.opacity='0.7'; this.style.background='transparent';" title="Click to edit"><i class="fas fa-edit"></i></div><h5 class="preview-section-label">Preview with Answers</h5><div class="live-preview" dir="rtl" style="text-align: right;">${filledPreview.innerHTML}</div></div>`;
                }
            }
            
            // Guide answer - always RTL in final preview
            const guideAnswerTextarea = blanksContainer.querySelector('.guide-answer-notes');
            if (guideAnswerTextarea && guideAnswerTextarea.value && guideAnswerTextarea.value.trim()) {
                const guidePreview = document.createElement('div');
                guidePreview.className = 'live-preview';
                guidePreview.setAttribute('dir', 'rtl');
                guidePreview.style.textAlign = 'right';
                renderLivePreviewToElement(guideAnswerTextarea, guidePreview);
                    html += `<div class="preview-section" style="position: relative;"><div style="position: absolute; top: 8px; right: 8px; color: var(--accent); font-size: 0.85rem; opacity: 0.7; cursor: pointer; padding: 4px; border-radius: 4px; transition: all 0.2s ease;" onclick="navigateToInput(document.querySelectorAll('#questions_container > .array-item')[${questionIndex}].querySelector('#blanks-container .guide-answer-notes'))" onmouseover="this.style.opacity='1'; this.style.background='var(--bg-tertiary)';" onmouseout="this.style.opacity='0.7'; this.style.background='transparent';" title="Click to edit"><i class="fas fa-edit"></i></div><div class="guide-answer"><h5 class="preview-section-label">Guide Answer</h5><div class="live-preview" dir="rtl" style="text-align: right;">${guidePreview.innerHTML}</div></div></div>`;
            }
            
            return html;
        }

        // Render matching preview
        function renderMatchingPreview(questionEl) {
            const matchingContainer = questionEl.querySelector('#matching-container');
            if (!matchingContainer) return '';
            
            const leftList = matchingContainer.querySelector('[id^="matching-left-list-"]');
            const rightList = matchingContainer.querySelector('[id^="matching-right-list-"]');
            const relationships = matchingContainer.querySelectorAll('.relationship-item');
            
            // Collect relationships data
            const relationshipsMap = [];
            relationships.forEach((relEl, index) => {
                // Find all select elements in this relationship item
                const selects = relEl.querySelectorAll('select');
                if (selects.length >= 2) {
                    const leftSelect = selects[0];
                    const rightSelect = selects[1];
                    const leftVal = leftSelect ? parseInt(leftSelect.value) : null;
                    const rightVal = rightSelect ? parseInt(rightSelect.value) : null;
                    if (leftVal && rightVal && !isNaN(leftVal) && !isNaN(rightVal)) {
                        relationshipsMap.push({ left: leftVal - 1, right: rightVal - 1 }); // Convert to 0-indexed
                    }
                }
            });
            
            // Collect left and right items with their textareas for proper rendering
            const leftItems = [];
            const rightItems = [];
            
            if (leftList) {
                const leftItemEls = leftList.querySelectorAll('.matching-item');
                leftItemEls.forEach((itemEl, index) => {
                    const textarea = itemEl.querySelector('textarea');
                    leftItems.push({ index: index, textarea: textarea, text: textarea ? textarea.value || '' : '' });
                });
            }
            
            if (rightList) {
                const rightItemEls = rightList.querySelectorAll('.matching-item');
                rightItemEls.forEach((itemEl, index) => {
                    const textarea = itemEl.querySelector('textarea');
                    rightItems.push({ index: index, textarea: textarea, text: textarea ? textarea.value || '' : '' });
                });
            }
            
            const questionIndex = Array.from(document.querySelectorAll('#questions_container > .array-item')).indexOf(questionEl);
            let html = '<div class="preview-section"><div class="matching-container">';
            html += '<h5 class="preview-section-label">Matching Items</h5>';
            
            // Create a container with relative positioning for SVG lines
            // Use a simpler grid layout: left items | spacer for lines | right items
            html += `<div class="matching-items" id="matching-items-${Date.now()}" style="position: relative; display: grid; grid-template-columns: 1fr 120px 1fr; gap: 20px; align-items: start; margin: 16px 0; overflow: hidden;">`;
            
            // Left items with unique IDs for positioning
            html += '<div class="matching-side" id="left-side-container" style="position: relative; min-width: 0; overflow: hidden;">';
            html += '<h5 style="font-size: 0.85rem; margin: 0 0 8px 0; color: var(--text-secondary); text-transform: uppercase; font-weight: 600;">Left Items</h5>';
            leftItems.forEach((item, index) => {
                const itemId = `left-item-${Date.now()}-${index}`;
                html += `<div id="${itemId}" class="matching-item" data-left-index="${index}" style="margin-bottom: 12px; padding: 8px; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 4px; word-wrap: break-word; overflow-wrap: break-word; word-break: break-word; max-width: 100%; box-sizing: border-box; position: relative;"><div style="position: absolute; top: 8px; right: 8px; color: var(--accent); font-size: 0.85rem; opacity: 0.7; cursor: pointer; padding: 4px; border-radius: 4px; transition: all 0.2s ease;" onclick="navigateToInput(document.querySelectorAll('#questions_container > .array-item')[${questionIndex}].querySelectorAll('[id^=\\'matching-left-list-\\'] .matching-item')[${index}].querySelector('textarea'))" onmouseover="this.style.opacity='1'; this.style.background='var(--bg-tertiary)';" onmouseout="this.style.opacity='0.7'; this.style.background='transparent';" title="Click to edit"><i class="fas fa-edit"></i></div>`;
                html += `<strong>L${index + 1}:</strong> `;
                if (item.textarea && item.text) {
                    const itemPreview = document.createElement('div');
                    itemPreview.className = 'live-preview';
                    // Always RTL in final preview
                    itemPreview.setAttribute('dir', 'rtl');
                    itemPreview.style.textAlign = 'right';
                    renderLivePreviewToElement(item.textarea, itemPreview);
                    html += `<div class="live-preview" dir="rtl" style="text-align: right; display: inline-block; margin-left: 4px; max-width: 100%; overflow-wrap: break-word; word-wrap: break-word; word-break: break-word; box-sizing: border-box;">${itemPreview.innerHTML}</div>`;
                } else {
                    html += '<span style="color: #6c757d; font-style: italic;">(Empty)</span>';
                }
                html += '</div>';
            });
            html += '</div>';
            
            // SVG container - will be positioned after items render
            const svgContainerId = `svg-container-${Date.now()}`;
            html += `<div id="${svgContainerId}" style="position: relative; width: 120px; min-height: 200px; flex-shrink: 0;"></div>`;
            
            // Right items with unique IDs for positioning
            html += '<div class="matching-side" id="right-side-container" style="position: relative; min-width: 0; overflow: hidden;">';
            html += '<h5 style="font-size: 0.85rem; margin: 0 0 8px 0; color: var(--text-secondary); text-transform: uppercase; font-weight: 600;">Right Items</h5>';
            rightItems.forEach((item, index) => {
                const itemId = `right-item-${Date.now()}-${index}`;
                html += `<div id="${itemId}" class="matching-item" data-right-index="${index}" style="margin-bottom: 12px; padding: 8px; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 4px; word-wrap: break-word; overflow-wrap: break-word; word-break: break-word; max-width: 100%; box-sizing: border-box; position: relative;"><div style="position: absolute; top: 8px; right: 8px; color: var(--accent); font-size: 0.85rem; opacity: 0.7; cursor: pointer; padding: 4px; border-radius: 4px; transition: all 0.2s ease;" onclick="navigateToInput(document.querySelectorAll('#questions_container > .array-item')[${questionIndex}].querySelectorAll('[id^=\\'matching-right-list-\\'] .matching-item')[${index}].querySelector('textarea'))" onmouseover="this.style.opacity='1'; this.style.background='var(--bg-tertiary)';" onmouseout="this.style.opacity='0.7'; this.style.background='transparent';" title="Click to edit"><i class="fas fa-edit"></i></div>`;
                html += `<strong>R${index + 1}:</strong> `;
                if (item.textarea && item.text) {
                    const itemPreview = document.createElement('div');
                    itemPreview.className = 'live-preview';
                    // Always RTL in final preview
                    itemPreview.setAttribute('dir', 'rtl');
                    itemPreview.style.textAlign = 'right';
                    renderLivePreviewToElement(item.textarea, itemPreview);
                    html += `<div class="live-preview" dir="rtl" style="text-align: right; display: inline-block; margin-left: 4px; max-width: 100%; overflow-wrap: break-word; word-wrap: break-word; word-break: break-word; box-sizing: border-box;">${itemPreview.innerHTML}</div>`;
                } else {
                    html += '<span style="color: #6c757d; font-style: italic;">(Empty)</span>';
                }
                html += '</div>';
            });
            html += '</div>';
            
            html += '</div>'; // Close grid container
            
            // Store relationship data in data attributes for JavaScript to process later
            if (relationshipsMap.length > 0) {
                // Store as JSON string, properly escaped for HTML attribute
                const relationshipsJson = JSON.stringify(relationshipsMap).replace(/"/g, '&quot;');
                html += '<div data-relationships="' + relationshipsJson + '" data-svg-container-id="' + svgContainerId + '" style="display: none;"></div>';
            }
            html += '</div></div>'; // Close matching-container and preview-section
            
            // Guide answer - separate preview section - always RTL in final preview
            const guideAnswerTextarea = matchingContainer.querySelector('.guide-answer-notes');
            if (guideAnswerTextarea && guideAnswerTextarea.value && guideAnswerTextarea.value.trim()) {
                const guidePreview = document.createElement('div');
                guidePreview.className = 'live-preview';
                guidePreview.setAttribute('dir', 'rtl');
                guidePreview.style.textAlign = 'right';
                renderLivePreviewToElement(guideAnswerTextarea, guidePreview);
                html += `<div class="preview-section"><div class="guide-answer"><h5 class="preview-section-label">Guide Answer</h5><div class="live-preview" dir="rtl" style="text-align: right;">${guidePreview.innerHTML}</div></div></div>`;
            }
            
            return html;
        }

        // Render guide answer preview (for free_form, annotate, create_table)
        function renderGuideAnswerPreview(questionEl, questionType) {
            // Check all possible locations for guide answer
            let guideAnswerTextarea = null;
            
            // First, check in #guide-answer-container (for multiple_choice, checkbox, free_form, annotate, create_table)
            const guideAnswerContainer = questionEl.querySelector('#guide-answer-container');
            if (guideAnswerContainer) {
                guideAnswerTextarea = guideAnswerContainer.querySelector('textarea');
            }
            
            // If not found, check in blanks container (for fill_in_the_blanks)
            if (!guideAnswerTextarea) {
                const blanksContainer = questionEl.querySelector('#blanks-container');
                if (blanksContainer) {
                    guideAnswerTextarea = blanksContainer.querySelector('.guide-answer-notes');
                }
            }
            
            // If not found, check in matching container (for matching)
            if (!guideAnswerTextarea) {
                const matchingContainer = questionEl.querySelector('#matching-container');
                if (matchingContainer) {
                    guideAnswerTextarea = matchingContainer.querySelector('.guide-answer-notes');
                }
            }
            
            if (!guideAnswerTextarea || !guideAnswerTextarea.value || !guideAnswerTextarea.value.trim()) {
                return '';
            }
            
            const guidePreview = document.createElement('div');
            guidePreview.className = 'live-preview';
            // Always RTL in final preview
            guidePreview.setAttribute('dir', 'rtl');
            guidePreview.style.textAlign = 'right';
            renderLivePreviewToElement(guideAnswerTextarea, guidePreview);
            
            // Always use "Guide Answer" as the label
            const questionIndex = Array.from(document.querySelectorAll('#questions_container > .array-item')).indexOf(questionEl);
            // Find the selector for the guide answer textarea
            let guideSelector = '';
            if (questionEl.querySelector('#guide-answer-container textarea')) {
                guideSelector = '#guide-answer-container textarea';
            } else if (questionEl.querySelector('#blanks-container .guide-answer-notes')) {
                guideSelector = '#blanks-container .guide-answer-notes';
            } else if (questionEl.querySelector('#matching-container .guide-answer-notes')) {
                guideSelector = '#matching-container .guide-answer-notes';
            }
            
            return `<div class="preview-section" style="position: relative;"><div style="position: absolute; top: 8px; right: 8px; color: var(--accent); font-size: 0.85rem; opacity: 0.7; cursor: pointer; padding: 4px; border-radius: 4px; transition: all 0.2s ease;" onclick="navigateToInput(document.querySelectorAll('#questions_container > .array-item')[${questionIndex}].querySelector('${guideSelector}'))" onmouseover="this.style.opacity='1'; this.style.background='var(--bg-tertiary)';" onmouseout="this.style.opacity='0.7'; this.style.background='transparent';" title="Click to edit"><i class="fas fa-edit"></i></div><div class="guide-answer"><h5 class="preview-section-label">Guide Answer</h5><div class="live-preview" dir="rtl" style="text-align: right;">${guidePreview.innerHTML}</div></div></div>`;
        }

        // Helper function to escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Draw matching lines after DOM is rendered
        function drawMatchingLines() {
            const previewContainer = document.getElementById('final-preview-content');
            if (!previewContainer) {
                console.log('drawMatchingLines: previewContainer not found');
                return;
            }
            
            // Find all matching containers with relationship data
            const relationshipDataEls = previewContainer.querySelectorAll('[data-relationships]');
            console.log('drawMatchingLines: found', relationshipDataEls.length, 'relationship data elements');
            
            relationshipDataEls.forEach(function(dataEl) {
                try {
                    const relationshipsJson = dataEl.getAttribute('data-relationships');
                    if (!relationshipsJson) {
                        console.log('drawMatchingLines: no relationships data');
                        return;
                    }
                    
                    // Unescape HTML entities
                    const relationshipsStr = relationshipsJson.replace(/&quot;/g, '"');
                    const relationships = JSON.parse(relationshipsStr);
                    const svgContainerId = dataEl.getAttribute('data-svg-container-id');
                    
                    console.log('drawMatchingLines: relationships', relationships, 'svgContainerId', svgContainerId);
                    
                    const svgContainer = document.getElementById(svgContainerId);
                    const matchingContainer = dataEl.closest('.matching-container');
                    
                    if (!svgContainer) {
                        console.log('drawMatchingLines: svgContainer not found for id', svgContainerId);
                        return;
                    }
                    if (!matchingContainer) {
                        console.log('drawMatchingLines: matchingContainer not found');
                        return;
                    }
                    
                    const leftContainer = matchingContainer.querySelector('#left-side-container');
                    const rightContainer = matchingContainer.querySelector('#right-side-container');
                    
                    if (!leftContainer) {
                        console.log('drawMatchingLines: leftContainer not found');
                        return;
                    }
                    if (!rightContainer) {
                        console.log('drawMatchingLines: rightContainer not found');
                        return;
                    }
                    
                    const leftItems = leftContainer.querySelectorAll('.matching-item');
                    const rightItems = rightContainer.querySelectorAll('.matching-item');
                    
                    console.log('drawMatchingLines: leftItems', leftItems.length, 'rightItems', rightItems.length);
                    
                    // Calculate container height
                    const leftHeight = leftContainer.offsetHeight;
                    const rightHeight = rightContainer.offsetHeight;
                    const svgHeight = Math.max(leftHeight, rightHeight, 200);
                    svgContainer.style.height = svgHeight + 'px';
                    
                    const markerId = 'arrowhead-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
                    let svg = '<svg width="120" height="' + svgHeight + '" style="position: absolute; top: 0; left: 0; pointer-events: none; z-index: 1;" xmlns="http://www.w3.org/2000/svg">';
                    svg += '<defs><marker id="' + markerId + '" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto"><polygon points="0 0, 10 3, 0 6" fill="#28a745" /></marker></defs>';
                    
                    relationships.forEach(function(rel) {
                        if (rel.left >= 0 && rel.left < leftItems.length && rel.right >= 0 && rel.right < rightItems.length) {
                            const leftItem = leftItems[rel.left];
                            const rightItem = rightItems[rel.right];
                            
                            const leftRect = leftItem.getBoundingClientRect();
                            const rightRect = rightItem.getBoundingClientRect();
                            const containerRect = svgContainer.getBoundingClientRect();
                            
                            const leftY = leftRect.top - containerRect.top + (leftRect.height / 2);
                            const rightY = rightRect.top - containerRect.top + (rightRect.height / 2);
                            
                            console.log('drawMatchingLines: drawing line from L' + (rel.left + 1) + ' to R' + (rel.right + 1), 'leftY:', leftY, 'rightY:', rightY);
                            
                            svg += '<line x1="0" y1="' + leftY + '" x2="120" y2="' + rightY + '" stroke="#28a745" stroke-width="2" marker-end="url(#' + markerId + ')" />';
                        }
                    });
                    
                    svg += '</svg>';
                    svgContainer.innerHTML = svg;
                    console.log('drawMatchingLines: SVG drawn');
                } catch (e) {
                    console.error('Error drawing matching lines:', e);
                }
            });
        }

        // Quick jump functionality
        function quickJumpTo(value) {
            if (!value) return;
            
            // Check if it's a main tab
            if (['basic', 'preamble', 'content', 'questions'].includes(value)) {
                // Switch to input form tab first
                showMainTab('input-form');
                setTimeout(() => {
                showTab(value);
                }, 100);
            } else if (value.startsWith('content-')) {
                // Jump to specific content section
                showMainTab('input-form');
                setTimeout(() => {
                showTab('content');
                setTimeout(() => {
                    const sectionId = value.replace('content-', '');
                    const element = document.querySelector(`#content_sections_container .array-item:nth-child(${sectionId})`);
                    if (element) {
                        element.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        element.style.backgroundColor = '#fff3cd';
                        setTimeout(() => element.style.backgroundColor = '', 2000);
                    }
                    }, 100);
                }, 100);
            } else if (value.startsWith('question-')) {
                // Jump to specific question
                showTab('questions');
                setTimeout(() => {
                    const questionId = value.replace('question-', '');
                    const element = document.querySelector(`#questions_container .array-item:nth-child(${questionId})`);
                    if (element) {
                        element.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        element.style.backgroundColor = '#fff3cd';
                        setTimeout(() => element.style.backgroundColor = '', 2000);
                    }
                }, 100);
            }
            
            // Reset select
            document.getElementById('quickJumpSelect').value = '';
        }



        // Search/Filter functionality
        // Helper function to get context around a match
        function getContextPreview(text, searchTerm, maxLength = 100) {
            const lowerText = text.toLowerCase();
            const lowerTerm = searchTerm.toLowerCase();
            const index = lowerText.indexOf(lowerTerm);
            
            if (index === -1) {
                // If exact match not found, return first part of text
                return text.substring(0, maxLength) + (text.length > maxLength ? '...' : '');
            }
            
            // Get context around the match
            const start = Math.max(0, index - 30);
            const end = Math.min(text.length, index + searchTerm.length + 30);
            let preview = text.substring(start, end);
            
            // Highlight the match
            const matchIndex = preview.toLowerCase().indexOf(lowerTerm);
            if (matchIndex !== -1) {
                const before = preview.substring(0, matchIndex);
                const match = preview.substring(matchIndex, matchIndex + searchTerm.length);
                const after = preview.substring(matchIndex + searchTerm.length);
                preview = before + '<span class="highlight">' + escapeHtml(match) + '</span>' + after;
            }
            
            // Add ellipsis if needed
            if (start > 0) preview = '...' + preview;
            if (end < text.length) preview = preview + '...';
            
            return preview;
        }
        
        // Helper function to escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Helper function to clear search highlights without clearing the input
        function clearSearchHighlights() {
            const contentSections = document.querySelectorAll('#content_sections_container .array-item');
            const questions = document.querySelectorAll('#questions_container .array-item');
            
            // Remove highlighting from content sections
            contentSections.forEach(section => {
                section.style.display = '';
                section.style.border = '';
                section.style.borderRadius = '';
                section.style.padding = '';
                section.style.marginBottom = '';
                section.style.backgroundColor = '';
            });
            
            // Remove highlighting from questions
            questions.forEach(question => {
                question.style.display = '';
                question.style.border = '';
                question.style.borderRadius = '';
                question.style.padding = '';
                question.style.marginBottom = '';
                question.style.backgroundColor = '';
            });
        }
        
        // Helper function to jump to an element
        function jumpToElement(element) {
            if (!element) return;
            
            // Determine which tab the element belongs to and switch if needed
            const contentContainer = document.getElementById('content_sections_container');
            const questionsContainer = document.getElementById('questions_container');
            
            if (contentContainer && contentContainer.contains(element)) {
                // Element is in content sections - switch to content tab
                showTab('content');
            } else if (questionsContainer && questionsContainer.contains(element)) {
                // Element is in questions - switch to questions tab
                showTab('questions');
            }
            
            // Remove any existing highlights (but keep search input)
            clearSearchHighlights();
            
            // Show the element if it's hidden
            element.style.display = '';
            
            // Wait a moment for tab switch to complete, then scroll
            setTimeout(() => {
                element.scrollIntoView({ behavior: 'smooth', block: 'center' });
                
                // Highlight briefly
                const originalBorder = element.style.border;
                const originalBg = element.style.backgroundColor;
                element.style.border = '3px solid var(--accent)';
                element.style.borderRadius = '8px';
                element.style.padding = '15px';
                element.style.backgroundColor = 'rgba(102, 126, 234, 0.1)';
                element.style.transition = 'all 0.3s';
                
                setTimeout(() => {
                    element.style.border = originalBorder;
                    element.style.borderRadius = '';
                    element.style.padding = '';
                    element.style.backgroundColor = originalBg;
                }, 2000);
            }, 100);
            
            // Close dropdown
            const dropdown = document.getElementById('searchResultsDropdown');
            if (dropdown) {
                dropdown.style.display = 'none';
            }
        }
        
        let searchDropdownSelectedIndex = -1;
        
        function performSearch(searchTerm) {
            const term = searchTerm.trim();
            const clearBtn = document.getElementById('clearSearchBtn');
            const dropdown = document.getElementById('searchResultsDropdown');
            const resultsCount = document.getElementById('searchResultsCount');
            
            // Show/hide clear button
            if (term.length > 0) {
                clearBtn.style.display = 'block';
            } else {
                clearBtn.style.display = 'none';
            }
            
            if (term.length === 0) {
                // Clear search - show all items
                clearSearch();
                if (dropdown) dropdown.style.display = 'none';
                if (resultsCount) resultsCount.style.display = 'none';
                trackEvent('search_performed', { search_term_length: 0 });
                return;
            }
            
            const results = [];
            const lowerTerm = term.toLowerCase();
            
            // Search content sections
            const contentSections = document.querySelectorAll('#content_sections_container .array-item');
            contentSections.forEach((section, index) => {
                const sectionTitle = section.querySelector('input[placeholder*="Section title"]')?.value || '';
                const sectionContent = section.querySelector('textarea[placeholder*="Enter content"]')?.value || '';
                
                const sectionNumber = index + 1;
                
                // Check section title separately
                if (sectionTitle.toLowerCase().includes(lowerTerm)) {
                    results.push({
                        type: 'Content Title',
                        title: `Content Section ${sectionNumber}`,
                        preview: getContextPreview(sectionTitle, term),
                        element: section,
                        index: sectionNumber
                    });
                }
                
                // Check section content separately
                if (sectionContent.toLowerCase().includes(lowerTerm)) {
                    results.push({
                        type: 'Content Text',
                        title: `Content Section ${sectionNumber}`,
                        preview: getContextPreview(sectionContent, term),
                        element: section,
                        index: sectionNumber
                    });
                }
            });
            
            // Search questions
            const questionsContainer = document.getElementById('questions_container');
            if (questionsContainer) {
                const questions = questionsContainer.querySelectorAll('.array-item');
                questions.forEach((question, index) => {
                    const questionIdInput = question.querySelector('input[placeholder*="e.g., 1"]');
                    const questionId = questionIdInput?.value || '';
                    const questionText = question.querySelector('textarea[placeholder*="Enter question text"]')?.value || '';
                    const setupText = question.querySelector('textarea[placeholder*="Text shared across"]')?.value || '';
                    const guideAnswer = question.querySelector('textarea[placeholder*="Enter guide answer"]')?.value || '';
                    const guideAnswerNotes = question.querySelector('.guide-answer-notes')?.value || '';
                    
                    const qType = question.querySelector('select[onchange*="toggleQuestionType"]')?.value || '';
                    const typeLabel = qType === 'multiple_choice' ? 'MCQ' : qType === 'checkbox' ? 'Checkbox' : qType === 'fill_in_the_blanks' ? 'Fill-in-Blanks' : qType === 'matching' ? 'Matching' : 'Question';
                    
                    // Get question number - use ID if available, otherwise use index + 1
                    const questionNumber = questionId || String(index + 1);
                    const questionTitle = `Question ${questionNumber}`;
                    
                    // Check each field separately and create results for each match
                    // Priority order: Question ID, Question Text, Setup Text, Guide Answer, Choices
                    
                    if (questionId.toLowerCase().includes(lowerTerm)) {
                        results.push({
                            type: typeLabel,
                            title: questionTitle + ' (ID)',
                            preview: getContextPreview(questionId, term),
                            element: question,
                            index: index + 1
                        });
                    }
                    
                    if (questionText.toLowerCase().includes(lowerTerm)) {
                        results.push({
                            type: typeLabel,
                            title: questionTitle + ' (Question)',
                            preview: getContextPreview(questionText, term),
                            element: question,
                            index: index + 1
                        });
                    }
                    
                    if (setupText.toLowerCase().includes(lowerTerm)) {
                        results.push({
                            type: typeLabel,
                            title: questionTitle + ' (Setup)',
                            preview: getContextPreview(setupText, term),
                            element: question,
                            index: index + 1
                        });
                    }
                    
                    if (guideAnswer.toLowerCase().includes(lowerTerm)) {
                        results.push({
                            type: typeLabel,
                            title: questionTitle + ' (Answer)',
                            preview: getContextPreview(guideAnswer, term),
                            element: question,
                            index: index + 1
                        });
                    }
                    
                    if (guideAnswerNotes && guideAnswerNotes.toLowerCase().includes(lowerTerm)) {
                        results.push({
                            type: typeLabel,
                            title: questionTitle + ' (Answer Notes)',
                            preview: getContextPreview(guideAnswerNotes, term),
                            element: question,
                            index: index + 1
                        });
                    }
                    
                    // Check each choice individually - only for MCQ and Checkbox questions
                    if (qType === 'multiple_choice' || qType === 'checkbox') {
                        const choiceTextareas = question.querySelectorAll('.choice-text');
                        choiceTextareas.forEach((choiceTextarea, choiceIndex) => {
                            const choiceText = choiceTextarea.value || '';
                            if (choiceText.toLowerCase().includes(lowerTerm)) {
                                // Get choice ID if available
                                const choiceItem = choiceTextarea.closest('.choice-item');
                                const choiceIdInput = choiceItem?.querySelector('.choice-id');
                                const choiceId = choiceIdInput?.value || String.fromCharCode(65 + choiceIndex); // A, B, C, etc.
                                
                                results.push({
                                    type: typeLabel,
                                    title: questionTitle + ` (Choice ${choiceId})`,
                                    preview: getContextPreview(choiceText, term),
                                    element: question,
                                    index: index + 1
                                });
                            }
                        });
                    }
                    
                    // Check blank answers for fill-in-the-blanks questions
                    if (qType === 'fill_in_the_blanks') {
                        // Check guide answer (optional) for fill-in-the-blanks
                        const blanksContainer = question.querySelector('#blanks-container');
                        const blanksGuideAnswer = blanksContainer?.querySelector('.guide-answer-notes');
                        if (blanksGuideAnswer) {
                            const blanksGuideAnswerText = blanksGuideAnswer.value || '';
                            if (blanksGuideAnswerText.toLowerCase().includes(lowerTerm)) {
                                results.push({
                                    type: typeLabel,
                                    title: questionTitle + ' (Answer Notes)',
                                    preview: getContextPreview(blanksGuideAnswerText, term),
                                    element: question,
                                    index: index + 1
                                });
                            }
                        }
                        
                        // Check individual blank answers
                        const blankItems = question.querySelectorAll('.blank-answer-item');
                        blankItems.forEach((blankItem, blankIndex) => {
                            const blankInput = blankItem.querySelector('.blank-answer-input');
                            if (blankInput) {
                                const blankText = blankInput.value || '';
                                if (blankText.toLowerCase().includes(lowerTerm)) {
                                    results.push({
                                        type: typeLabel,
                                        title: questionTitle + ` (Blank ${blankIndex + 1})`,
                                        preview: getContextPreview(blankText, term),
                                        element: question,
                                        index: index + 1
                                    });
                                }
                            }
                        });
                    }
                    
                    // Check matching left and right items
                    if (qType === 'matching') {
                        // Check guide answer (optional) for matching questions
                        const matchingContainer = question.querySelector('#matching-container');
                        const matchingGuideAnswer = matchingContainer?.querySelector('.guide-answer-notes');
                        if (matchingGuideAnswer) {
                            const matchingGuideAnswerText = matchingGuideAnswer.value || '';
                            if (matchingGuideAnswerText.toLowerCase().includes(lowerTerm)) {
                                results.push({
                                    type: typeLabel,
                                    title: questionTitle + ' (Answer Notes)',
                                    preview: getContextPreview(matchingGuideAnswerText, term),
                                    element: question,
                                    index: index + 1
                                });
                            }
                        }
                        
                        const leftList = question.querySelector('[id^="matching-left-list-"]');
                        const rightList = question.querySelector('[id^="matching-right-list-"]');
                        
                        // Check left items
                        if (leftList) {
                            const leftItems = leftList.querySelectorAll('.matching-item');
                            leftItems.forEach((leftItem, leftIndex) => {
                                const leftTextarea = leftItem.querySelector('.matching-item-text');
                                if (leftTextarea) {
                                    const leftText = leftTextarea.value || '';
                                    if (leftText.toLowerCase().includes(lowerTerm)) {
                                        results.push({
                                            type: typeLabel,
                                            title: questionTitle + ` (Left ${leftIndex + 1})`,
                                            preview: getContextPreview(leftText, term),
                                            element: question,
                                            index: index + 1
                                        });
                                    }
                                }
                            });
                        }
                        
                        // Check right items
                        if (rightList) {
                            const rightItems = rightList.querySelectorAll('.matching-item');
                            rightItems.forEach((rightItem, rightIndex) => {
                                const rightTextarea = rightItem.querySelector('.matching-item-text');
                                if (rightTextarea) {
                                    const rightText = rightTextarea.value || '';
                                    if (rightText.toLowerCase().includes(lowerTerm)) {
                                        results.push({
                                            type: typeLabel,
                                            title: questionTitle + ` (Right ${rightIndex + 1})`,
                                            preview: getContextPreview(rightText, term),
                                            element: question,
                                            index: index + 1
                                        });
                                    }
                                }
                            });
                        }
                    }
                });
            }
            
            // Update results count
            if (resultsCount) {
                if (results.length > 0) {
                    resultsCount.textContent = `${results.length} result${results.length !== 1 ? 's' : ''}`;
                    resultsCount.style.display = 'block';
                } else {
                    resultsCount.style.display = 'none';
                    }
            }
            
            // Build dropdown HTML
            if (dropdown) {
                if (results.length === 0) {
                    dropdown.innerHTML = '<div class="search-result-empty">No results found</div>';
                    dropdown.style.display = 'block';
                } else {
                    dropdown.innerHTML = results.map((result, idx) => `
                        <div class="search-result-item" data-index="${idx}" onmousedown="event.preventDefault(); jumpToSearchResult(${idx})" onmouseenter="highlightSearchResult(${idx})">
                            <div class="search-result-header">
                                <span class="search-result-type">${escapeHtml(result.type)}</span>
                                <span>${escapeHtml(result.title)}</span>
                            </div>
                            <div class="search-result-preview">${result.preview}</div>
                        </div>
                    `).join('');
                    dropdown.style.display = 'block';
                    searchDropdownSelectedIndex = -1;
                }
            }
            
            // Store results globally for keyboard navigation
            window.searchResults = results;
            
            // Track search with results
            trackEvent('search_performed', { 
                search_term_length: term.length,
                results_count: results.length,
                content_sections: results.filter(r => r.type === 'Content Section').length,
                questions: results.filter(r => r.type !== 'Content Section').length
            });
        }
        
        function jumpToSearchResult(index) {
            if (window.searchResults && window.searchResults[index]) {
                const result = window.searchResults[index];
                jumpToElement(result.element);
                // Keep the search input focused, don't clear it, and keep dropdown open
                const searchInput = document.getElementById('searchFilter');
                const dropdown = document.getElementById('searchResultsDropdown');
                if (searchInput) {
                    // Use mousedown instead of click to prevent blur from firing first
                    setTimeout(() => {
                        searchInput.focus();
                        if (dropdown && searchInput.value.trim().length > 0) {
                            dropdown.style.display = 'block';
                        }
                    }, 100);
                }
            }
        }
        
        function highlightSearchResult(index) {
            const items = document.querySelectorAll('.search-result-item');
            items.forEach((item, idx) => {
                if (idx === index) {
                    item.classList.add('highlighted');
                } else {
                    item.classList.remove('highlighted');
                }
            });
            searchDropdownSelectedIndex = index;
        }
        
        function handleSearchFocus() {
            const searchInput = document.getElementById('searchFilter');
            const dropdown = document.getElementById('searchResultsDropdown');
            if (searchInput && searchInput.value.trim().length > 0 && dropdown) {
                dropdown.style.display = 'block';
            }
        }
        
        function handleSearchBlur() {
            // Delay hiding dropdown to allow clicks on results
            // Don't hide if clicking on a result item
            setTimeout(() => {
                const dropdown = document.getElementById('searchResultsDropdown');
                const searchInput = document.getElementById('searchFilter');
                if (dropdown && searchInput && document.activeElement !== searchInput) {
                    // Check if focus moved to a result item
                    const activeElement = document.activeElement;
                    if (!activeElement || !activeElement.closest('.search-results-dropdown')) {
                        dropdown.style.display = 'none';
                    }
                }
            }, 200);
        }
        
        function handleSearchKeydown(event) {
            const dropdown = document.getElementById('searchResultsDropdown');
            if (!dropdown || dropdown.style.display === 'none' || !window.searchResults) {
                return;
            }
            
            const items = document.querySelectorAll('.search-result-item');
            
            if (event.key === 'ArrowDown') {
                event.preventDefault();
                searchDropdownSelectedIndex = Math.min(searchDropdownSelectedIndex + 1, items.length - 1);
                highlightSearchResult(searchDropdownSelectedIndex);
                items[searchDropdownSelectedIndex]?.scrollIntoView({ block: 'nearest' });
            } else if (event.key === 'ArrowUp') {
                event.preventDefault();
                searchDropdownSelectedIndex = Math.max(searchDropdownSelectedIndex - 1, -1);
                if (searchDropdownSelectedIndex >= 0) {
                    highlightSearchResult(searchDropdownSelectedIndex);
                    items[searchDropdownSelectedIndex]?.scrollIntoView({ block: 'nearest' });
                } else {
                    items.forEach(item => item.classList.remove('highlighted'));
                }
            } else if (event.key === 'Enter' && searchDropdownSelectedIndex >= 0) {
                event.preventDefault();
                jumpToSearchResult(searchDropdownSelectedIndex);
            } else if (event.key === 'Escape') {
                dropdown.style.display = 'none';
                searchDropdownSelectedIndex = -1;
            }
        }

        function clearSearch() {
            const searchInput = document.getElementById('searchFilter');
            const clearBtn = document.getElementById('clearSearchBtn');
            const dropdown = document.getElementById('searchResultsDropdown');
            const resultsCount = document.getElementById('searchResultsCount');
            
            if (searchInput) {
                searchInput.value = '';
            }
            clearBtn.style.display = 'none';
            
            if (dropdown) {
                dropdown.style.display = 'none';
            }
            
            if (resultsCount) {
                resultsCount.style.display = 'none';
            }
            
            // Clear stored results
            window.searchResults = [];
            searchDropdownSelectedIndex = -1;
            
            // Remove highlighting and show all items
            const contentSections = document.querySelectorAll('#content_sections_container .array-item');
            contentSections.forEach(section => {
                section.style.display = '';
                section.style.border = '';
                section.style.borderRadius = '';
                section.style.padding = '';
                section.style.marginBottom = '';
                section.style.backgroundColor = '';
            });
            
            const questionsContainer = document.getElementById('questions_container');
            if (questionsContainer) {
                const questions = questionsContainer.querySelectorAll('.array-item');
                questions.forEach(question => {
                    question.style.display = '';
                    question.style.border = '';
                    question.style.borderRadius = '';
                    question.style.padding = '';
                    question.style.marginBottom = '';
                    question.style.backgroundColor = '';
                });
            }
        }
        
        // Scroll to top function
        function scrollToTop() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
            // Also scroll the left column (form section) to the top
            const leftColumn = document.querySelector('.form-section:not(.toggle-section)');
            if (leftColumn) {
                leftColumn.scrollTo({ top: 0, behavior: 'smooth' });
            }
        }

        // Update quick jump menu with dynamic content
        function updateQuickJumpMenu() {
            const contentGroup = document.getElementById('contentSectionsGroup');
            const questionsGroup = document.getElementById('questionsGroup');
            
            // Clear existing options
            contentGroup.innerHTML = '';
            questionsGroup.innerHTML = '';
            
            // Add content sections
            const contentSections = document.querySelectorAll('#content_sections_container > .array-item');
            contentSections.forEach((section, index) => {
                const title = section.querySelector('input')?.value || `Section ${index + 1}`;
                const option = document.createElement('option');
                option.value = `content-${index + 1}`;
                option.textContent = `${index + 1}. ${title.substring(0, 30)}${title.length > 30 ? '...' : ''}`;
                contentGroup.appendChild(option);
            });
            
            // Add questions
            const questions = document.querySelectorAll('#questions_container > .array-item');
            questions.forEach((question, index) => {
                const title = question.querySelector('input')?.value || `Question ${index + 1}`;
                const option = document.createElement('option');
                option.value = `question-${index + 1}`;
                option.textContent = `${index + 1}. ${title.substring(0, 30)}${title.length > 30 ? '...' : ''}`;
                questionsGroup.appendChild(option);
            });
        }

        // Field validation system
        function validateField(field) {
            const formGroup = field.closest('.form-group');
            const value = field.value.trim();
            const isRequired = formGroup.classList.contains('required');
            
            // Remove existing validation classes
            formGroup.classList.remove('valid', 'invalid');
            
            // Remove existing validation messages
            const existingMessage = formGroup.querySelector('.validation-message');
            if (existingMessage) {
                existingMessage.remove();
            }
            
            let isValid = true;
            let message = '';
            
            // Check if required field is empty
            if (isRequired && !value) {
                isValid = false;
                message = 'This field is required';
            }
            
            // Specific validation rules
            if (value) {
                // Number validation
                if (field.type === 'number' && isNaN(field.value)) {
                    isValid = false;
                    message = 'Please enter a valid number';
                }
                
                // Email validation (if applicable)
                if (field.type === 'email' && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value)) {
                    isValid = false;
                    message = 'Please enter a valid email address';
                }
            }
            
            // Apply validation state (green checkmark removed per user request)
            if (isValid && value) {
                // formGroup.classList.add('valid'); // Removed - no green checkmark
            } else if (!isValid) {
                formGroup.classList.add('invalid');
                
                // Add validation message
                const messageDiv = document.createElement('div');
                messageDiv.className = 'validation-message error';
                messageDiv.textContent = message;
                formGroup.appendChild(messageDiv);
            }
            
            return isValid;
        }


        // Initialize field validation
        function initializeFieldValidation() {
            // Mark required fields
            const requiredFields = [
                '#textbook_page',
                '#textbook_pdf_page',
                '#guidebook_start_page',
                '#guidebook_end_page',
                '#page_type'
            ];
            
            requiredFields.forEach(selector => {
                const field = document.querySelector(selector);
                if (field) {
                    const formGroup = field.closest('.form-group');
                    formGroup.classList.add('required');
                }
            });
            
            // Attach validation listeners
            document.querySelectorAll('input, textarea, select').forEach(field => {
                // Skip search input - it shouldn't trigger validation or auto-save
                if (field.id === 'searchFilter') return;
                
                field.addEventListener('blur', () => validateField(field));
                field.addEventListener('input', () => {
                    // Debounced validation for better performance
                    clearTimeout(field.validationTimeout);
                    field.validationTimeout = setTimeout(() => validateField(field), 500);
                });
            });
        }

        // Validate integer input and prevent invalid characters
        function validateInteger(input) {
            const value = input.value;
            
            // Remove any non-digit characters (except for empty string)
            if (value && !/^\d+$/.test(value)) {
                input.value = value.replace(/[^\d]/g, '');
            }
            
            // Add visual feedback (validation-success removed per user request)
            if (value && /^\d+$/.test(value)) {
                input.classList.remove('validation-error');
                // Green checkmark removed - no longer adding validation-success class
            } else if (value) {
                input.classList.add('validation-error');
            } else {
                input.classList.remove('validation-error');
            }
        }

        // Normalize and validate bbox coordinates to ensure top-right to bottom-left format
        // Format: [[x0, y0], [x1, y1]] where [x0, y0] is top-right and [x1, y1] is bottom-left
        // This means: x0 > x1 (right > left) and y0 < y1 (top < bottom)
        function normalizeBboxCoordinates(x0, y0, x1, y1) {
            // Parse as integers
            const x0Val = parseInt(x0);
            const y0Val = parseInt(y0);
            const x1Val = parseInt(x1);
            const y1Val = parseInt(y1);
            
            // Check if all values are valid numbers
            if (isNaN(x0Val) || isNaN(y0Val) || isNaN(x1Val) || isNaN(y1Val)) {
                return null; // Invalid input
            }
            
            // Determine the actual top, bottom, left, right values
            const top = Math.min(y0Val, y1Val);
            const bottom = Math.max(y0Val, y1Val);
            const left = Math.min(x0Val, x1Val);
            const right = Math.max(x0Val, x1Val);
            
            // Return in the correct format: [top-right, bottom-left]
            return {
                x0: right,  // top-right X (larger X)
                y0: top,    // top-right Y (smaller Y)
                x1: left,   // bottom-left X (smaller X)
                y1: bottom  // bottom-left Y (larger Y)
            };
        }

        // Validate and normalize bbox inputs when user finishes entering data
        function validateAndNormalizeBbox(bboxInputsContainer) {
            const inputs = bboxInputsContainer.querySelectorAll('.bbox-inputs input');
            if (inputs.length < 5) return;
            
            const page = inputs[0].value;
            const x0 = inputs[1].value;
            const y0 = inputs[2].value;
            const x1 = inputs[3].value;
            const y1 = inputs[4].value;
            
            // Only validate if all coordinate fields have values (page can be empty for some cases)
            if (!x0 || !y0 || !x1 || !y1) return;
            
            const normalized = normalizeBboxCoordinates(x0, y0, x1, y1);
            if (!normalized) return;
            
            // Check if normalization changed the values
            const changed = (
                parseInt(x0) !== normalized.x0 ||
                parseInt(y0) !== normalized.y0 ||
                parseInt(x1) !== normalized.x1 ||
                parseInt(y1) !== normalized.y1
            );
            
            if (changed) {
                // Update the input values with normalized coordinates
                inputs[1].value = normalized.x0;
                inputs[2].value = normalized.y0;
                inputs[3].value = normalized.x1;
                inputs[4].value = normalized.y1;
                
                // Provide visual feedback
                inputs[1].style.background = '#fff3cd';
                inputs[2].style.background = '#fff3cd';
                inputs[3].style.background = '#fff3cd';
                inputs[4].style.background = '#fff3cd';
                
                // Clear the highlight after 1 second
                setTimeout(() => {
                    inputs[1].style.background = '';
                    inputs[2].style.background = '';
                    inputs[3].style.background = '';
                    inputs[4].style.background = '';
                }, 1000);
                
            }
        }

        // Attach bbox validation to a container
        function attachBboxValidation(container) {
            const bboxContainers = container.querySelectorAll('.bbox-container');
            bboxContainers.forEach(bboxContainer => {
                const bboxItems = bboxContainer.querySelectorAll('.array-item');
                bboxItems.forEach(item => {
                    const coordinateInputs = item.querySelectorAll('.bbox-x0, .bbox-y0, .bbox-x1, .bbox-y1');
                    coordinateInputs.forEach(input => {
                        // Remove existing listener if any
                        input.removeEventListener('blur', input.__bboxValidationHandler);
                        
                        // Add new listener
                        const handler = function() {
                            validateAndNormalizeBbox(item);
                        };
                        input.addEventListener('blur', handler);
                        input.__bboxValidationHandler = handler;
                    });
                });
            });
        }



        function addQuestion() {
            const container = document.getElementById('questions_container');
            const questionCount = container.querySelectorAll(':scope > .array-item').length + 1;
            const newQuestion = document.createElement('div');
            newQuestion.className = 'array-item';
            newQuestion.innerHTML = getQuestionHTML(questionCount);
            
            container.appendChild(newQuestion);
            
            // Record action for undo/redo (after adding to DOM so we have the actual element)
            recordFormAction({
                type: ACTION_TYPES.ADD_ITEM,
                element: newQuestion,
                parent: container,
                nextSibling: null,
                containerId: 'questions_container',
                updateNumbers: true
            });
            // Ensure all textareas in the new question start with RTL (content is RTL)
            const newTextareas = newQuestion.querySelectorAll('textarea');
            newTextareas.forEach(ta => {
                ta.setAttribute('dir', 'rtl');
                // CSS will handle the styling (RTL by default)
            });
            // Ensure ID fields start with LTR (English text)
            const newIdInput = newQuestion.querySelector('input[placeholder*="e.g.,"]');
            if (newIdInput) {
                newIdInput.setAttribute('dir', 'ltr');
                // CSS will handle the styling based on data-ltr attribute
            }
            const newRelatedInput = newQuestion.querySelector('input[placeholder*="9a (for grouped questions)"]');
            if (newRelatedInput) {
                newRelatedInput.setAttribute('dir', 'ltr');
                // CSS will handle the styling based on data-ltr attribute
            }
            // attach previews for the three textareas in this new question
            attachPreviews(newQuestion);
            
            // Attach bbox validation to all bbox containers in this new question
            attachBboxValidation(newQuestion);
            
            // Ensure direction buttons show "LTR" since content is RTL by default
            const dirBtns = newQuestion.querySelectorAll('.dir-btn');
            dirBtns.forEach(btn => {
                btn.textContent = 'LTR';
            });
            
            // Update all question numbers to ensure they're sequential (skip if bulk operation)
            if (!isBulkOperation) {
                updateQuestionNumbers();
            }
            
            // Track question addition
            const stats = getFormStats();
            trackEvent('question_added', {
                question_type: 'free_form', // Default type for new questions
                total_questions: stats.totalQuestions,
                total_content_sections: stats.totalContentSections
            });
        }

        function toggleQuestionType(selectElement) {
            const questionEl = selectElement.closest('.array-item');
            const questionType = selectElement.value;
            const guideAnswerContainer = questionEl.querySelector('#guide-answer-container');
            const choicesContainer = questionEl.querySelector('#choices-container');
            
            // Save current guide answer value before switching
            let currentGuideAnswer = '';
            // Check main guide answer container (free_form, annotate, create_table)
            const guideAnswerTextareaMain = guideAnswerContainer?.querySelector('textarea');
            if (guideAnswerTextareaMain && guideAnswerTextareaMain.value) {
                currentGuideAnswer = guideAnswerTextareaMain.value;
            }
            // Check blanks container
            if (!currentGuideAnswer) {
                const blanksContainer = questionEl.querySelector('#blanks-container');
                const blanksGuideAnswer = blanksContainer?.querySelector('.guide-answer-notes');
                if (blanksGuideAnswer && blanksGuideAnswer.value) {
                    currentGuideAnswer = blanksGuideAnswer.value;
                }
            }
            // Check matching container
            if (!currentGuideAnswer) {
                const matchingContainer = questionEl.querySelector('#matching-container');
                const matchingGuideAnswer = matchingContainer?.querySelector('.guide-answer-notes');
                if (matchingGuideAnswer && matchingGuideAnswer.value) {
                    currentGuideAnswer = matchingGuideAnswer.value;
                }
            }
            // Check choices container
            if (!currentGuideAnswer) {
                const choicesGuideAnswer = choicesContainer?.querySelector('.guide-answer-notes');
                if (choicesGuideAnswer && choicesGuideAnswer.value) {
                    currentGuideAnswer = choicesGuideAnswer.value;
                }
            }
            
            // Find fields by label text
            const setupContainer = Array.from(questionEl.querySelectorAll('.form-group')).find(el => 
                el.querySelector('label')?.textContent.includes('Set-up Text'));
            const questionTextContainer = Array.from(questionEl.querySelectorAll('.form-group')).find(el => 
                el.querySelector('label')?.textContent.includes('Question Text'));
            const questionImagesContainer = Array.from(questionEl.querySelectorAll('.form-group')).find(el => 
                el.querySelector('label')?.textContent.includes('Question Images'));
            const answerImagesContainer = Array.from(questionEl.querySelectorAll('.form-group')).find(el => 
                el.querySelector('label')?.textContent.includes('Answer Images'));
            const guidePdfPageContainer = Array.from(questionEl.querySelectorAll('.form-group')).find(el => 
                el.querySelector('label')?.textContent.includes('Guide PDF Page'));
            const relatedQuestionContainer = Array.from(questionEl.querySelectorAll('.form-group')).find(el => 
                el.querySelector('label')?.textContent.includes('Related Question'));
            
            // Get special containers
            const blanksContainer = questionEl.querySelector('#blanks-container');
            const matchingContainer = questionEl.querySelector('#matching-container');
            
            // Hide/show fields based on question type
            if (questionType === 'fill_in_the_blanks') {
                // fill_in_the_blanks: Show question text, blanks, images, guide PDF, related question
                if (setupContainer) setupContainer.style.display = 'block';
                if (questionTextContainer) questionTextContainer.style.display = 'block';
                if (guideAnswerContainer) guideAnswerContainer.style.display = 'none';
                if (choicesContainer) choicesContainer.style.display = 'none';
                if (blanksContainer) blanksContainer.style.display = 'block';
                if (matchingContainer) matchingContainer.style.display = 'none';
                if (questionImagesContainer) questionImagesContainer.style.display = 'block';
                if (answerImagesContainer) answerImagesContainer.style.display = 'block';
                if (guidePdfPageContainer) guidePdfPageContainer.style.display = 'block';
                if (relatedQuestionContainer) relatedQuestionContainer.style.display = 'block';
                
                // Add listener to question text to update blanks UI
                const questionTextarea = questionEl.querySelector('textarea[placeholder*="Enter question text"]');
                if (questionTextarea && !questionTextarea.dataset.blanksListenerAttached) {
                    questionTextarea.addEventListener('input', () => {
                        updateBlankAnswersUI(questionEl);
                    });
                    questionTextarea.dataset.blanksListenerAttached = 'true';
                    // Initial update
                    updateBlankAnswersUI(questionEl);
                }
            } else if (questionType === 'matching') {
                // matching: Show question text, matching section, images, guide PDF, related question
                if (setupContainer) setupContainer.style.display = 'block';
                if (questionTextContainer) questionTextContainer.style.display = 'block';
                if (guideAnswerContainer) guideAnswerContainer.style.display = 'none';
                if (choicesContainer) choicesContainer.style.display = 'none';
                if (blanksContainer) blanksContainer.style.display = 'none';
                if (matchingContainer) matchingContainer.style.display = 'block';
                if (questionImagesContainer) questionImagesContainer.style.display = 'block';
                if (answerImagesContainer) answerImagesContainer.style.display = 'block';
                if (guidePdfPageContainer) guidePdfPageContainer.style.display = 'block';
                if (relatedQuestionContainer) relatedQuestionContainer.style.display = 'block';
                
                // Initialize with at least one item on each side if empty
                const leftList = questionEl.querySelector('[id^="matching-left-list-"]');
                const rightList = questionEl.querySelector('[id^="matching-right-list-"]');
                if (leftList && leftList.querySelectorAll('.matching-item').length === 0) {
                    const addLeftBtn = questionEl.querySelector('button[onclick*="addMatchingItem"][onclick*="left"]');
                    if (addLeftBtn) addMatchingItem(addLeftBtn, 'left');
                }
                if (rightList && rightList.querySelectorAll('.matching-item').length === 0) {
                    const addRightBtn = questionEl.querySelector('button[onclick*="addMatchingItem"][onclick*="right"]');
                    if (addRightBtn) addMatchingItem(addRightBtn, 'right');
                }
            } else {
                // Show all common fields for standard types (free_form, multiple_choice, checkbox, annotate, create_table)
                if (setupContainer) setupContainer.style.display = 'block';
                if (questionTextContainer) questionTextContainer.style.display = 'block';
                if (questionImagesContainer) questionImagesContainer.style.display = 'block';
                if (answerImagesContainer) answerImagesContainer.style.display = 'block';
                if (guidePdfPageContainer) guidePdfPageContainer.style.display = 'block';
                if (relatedQuestionContainer) relatedQuestionContainer.style.display = 'block';
                // Hide special containers
                if (blanksContainer) blanksContainer.style.display = 'none';
                if (matchingContainer) matchingContainer.style.display = 'none';
                
                // Hide "Insert Blank" button for non-fill_in_the_blanks types
                const blankBtn = questionTextContainer?.querySelector('.blank-btn');
                if (blankBtn) blankBtn.style.display = 'none';
                
                // Handle choices vs guide answer
                if (questionType === 'multiple_choice' || questionType === 'checkbox') {
                    if (guideAnswerContainer) guideAnswerContainer.style.display = 'none';
                    if (choicesContainer) {
                        choicesContainer.style.display = 'block';
                        // Update label based on type
                        const label = choicesContainer.querySelector('label');
                        if (label) {
                            label.textContent = questionType === 'checkbox' ? 'Checkbox Choices' : 'Multiple Choice Options';
                        }
                        
                        // Show/hide the radio button selector for multiple choice
                        const correctAnswerSelector = choicesContainer.querySelector('#correct-answer-selector');
                        if (correctAnswerSelector) {
                            correctAnswerSelector.style.display = questionType === 'multiple_choice' ? 'block' : 'none';
                        }
                        
                        // Show/hide the checkbox summary for checkbox
                        const checkboxSummary = choicesContainer.querySelector('#checkbox-summary');
                        if (checkboxSummary) {
                            checkboxSummary.style.display = questionType === 'checkbox' ? 'block' : 'none';
                        }
                        
                        // Update existing choices to add/remove correct checkbox field based on type
                        const choicesList = choicesContainer.querySelector('[id^="choices-list-"]');
                        if (choicesList) {
                            const existingChoices = choicesList.querySelectorAll('.choice-item');
                            existingChoices.forEach(choiceItem => {
                                const existingCorrectField = choiceItem.querySelector('.choice-correct');
                                const existingCorrectContainer = existingCorrectField?.closest('.form-group');
                                
                                if (questionType === 'checkbox' && !existingCorrectField) {
                                    // Add correct answer checkbox field for checkbox type
                                    const checkedFieldHTML = `
                                        <div class="form-group checkbox-group" style="align-items: center; margin-top: 10px;">
                                            <label for="choice-correct-${Date.now()}-${Math.random()}" style="font-weight: 600; color: #28a745;"> Correct Answer</label>
                                            <input type="checkbox" class="choice-correct" id="choice-correct-${Date.now()}-${Math.random()}" title="Mark this choice as a correct answer">
                                        </div>
                                    `;
                                    choiceItem.insertAdjacentHTML('beforeend', checkedFieldHTML);
                                    
                                    // Add change listener for real-time summary update
                                    const newCheckbox = choiceItem.querySelector('.choice-correct');
                                    if (newCheckbox) {
                                        newCheckbox.addEventListener('change', () => {
                                            updateCheckboxSummary(questionEl);
                                            markFormAsChanged();
                                            triggerAutoSave();
                                        });
                                    }
                                } else if (questionType === 'multiple_choice' && existingCorrectField) {
                                    // Remove correct field for multiple_choice type
                                    if (existingCorrectContainer) {
                                        existingCorrectContainer.remove();
                                    }
                                }
                            });
                            
                            // Initialize with at least one choice if empty
                            if (choicesList.children.length === 0) {
                                addChoice(choicesContainer.querySelector('.add-btn'), 'end', questionType);
                            }
                        }
                    }
                    // Update the correct answer UI after a small delay to ensure DOM is ready
                        setTimeout(() => {
                        if (questionType === 'multiple_choice') {
                            updateCorrectAnswerRadios(questionEl);
                        } else if (questionType === 'checkbox') {
                            updateCheckboxSummary(questionEl);
                            }
                        }, 50);
                } else {
                    if (guideAnswerContainer) guideAnswerContainer.style.display = 'block';
                    if (choicesContainer) choicesContainer.style.display = 'none';
                }
            }
            
            // Restore guide answer value to the appropriate field for the new question type
            if (currentGuideAnswer) {
                if (questionType === 'free_form' || questionType === 'annotate' || questionType === 'create_table') {
                    // Use the main guide answer container
                    const guideAnswerTextarea = guideAnswerContainer?.querySelector('textarea');
                    if (guideAnswerTextarea) {
                        guideAnswerTextarea.value = currentGuideAnswer;
                    }
                } else if (questionType === 'fill_in_the_blanks') {
                    // Use the blanks container guide answer
                    const blanksContainer = questionEl.querySelector('#blanks-container');
                    const guideAnswerNotes = blanksContainer?.querySelector('.guide-answer-notes');
                    if (guideAnswerNotes) {
                        guideAnswerNotes.value = currentGuideAnswer;
                    }
                } else if (questionType === 'matching') {
                    // Use the matching container guide answer
                    const matchingContainer = questionEl.querySelector('#matching-container');
                    const guideAnswerNotes = matchingContainer?.querySelector('.guide-answer-notes');
                    if (guideAnswerNotes) {
                        guideAnswerNotes.value = currentGuideAnswer;
                    }
                } else if (questionType === 'multiple_choice' || questionType === 'checkbox') {
                    // Use the choices container guide answer
                    const choicesGuideAnswer = choicesContainer?.querySelector('.guide-answer-notes');
                    if (choicesGuideAnswer) {
                        choicesGuideAnswer.value = currentGuideAnswer;
                    }
                }
            }
            
            // Reinitialize previews for all textareas in this question after type change
            // This ensures newly shown fields get previews and direction is properly set
            setTimeout(() => {
                attachPreviews(questionEl);
            }, 50);
            
            // Track question type change
            const stats = getFormStats();
            trackEvent('question_type_changed', {
                question_type: questionType,
                total_questions: stats.totalQuestions,
                total_content_sections: stats.totalContentSections
            });
        }

        function addChoice(button, position = 'end', questionType = null) {
            const choicesContainer = button.closest('#choices-container');
            const choicesList = choicesContainer.querySelector('[id^="choices-list-"]');
            
            // Determine question type if not provided
            if (!questionType) {
                const questionEl = button.closest('.array-item[data-type="question"]') || button.closest('.array-item');
                const questionTypeSelect = questionEl?.querySelector('select[onchange*="toggleQuestionType"]');
                questionType = questionTypeSelect?.value || 'multiple_choice';
            }
            
            console.log('addChoice - Received questionType:', questionType); // Debug
            
            // Add correct checkbox field for checkbox type
            const checkedField = questionType === 'checkbox' ? `
                <div class="form-group checkbox-group" style="align-items: center; margin-top: 10px;">
                    <label for="choice-correct-${Date.now()}" style="font-weight: 600; color: #28a745;"> Correct Answer</label>
                    <input type="checkbox" class="choice-correct" id="choice-correct-${Date.now()}" title="Mark this choice as a correct answer">
                </div>
            ` : '';
            
            const choiceItem = document.createElement('div');
            choiceItem.className = 'array-item choice-item';
            choiceItem.innerHTML = `
                <div class="array-item-header">
                    <h5>Choice</h5>
                    <div class="array-item-header-controls">
                        <button class="add-bbox-btn" onclick="addChoiceBefore(this)" title="Add Choice Before">
                            <i class="fas fa-plus"></i> Before
                        </button>
                        <button class="add-bbox-btn" onclick="addChoiceAfter(this)" title="Add Choice After">
                            <i class="fas fa-plus"></i> After
                        </button>
                        <button class="reorder-btn" onclick="moveChoiceUp(this)" title="Move Up">
                            <i class="fas fa-arrow-up"></i>
                        </button>
                        <button class="reorder-btn" onclick="moveChoiceDown(this)" title="Move Down">
                            <i class="fas fa-arrow-down"></i>
                        </button>
                        <button class="remove-btn" onclick="removeChoice(this)" title="Remove Choice"></button>
                    </div>
                </div>
                <div class="form-group">
                    <label>Choice ID <span style="opacity: 0.6; font-size: 0.85em;">(Optional)</span></label>
                    <input type="text" class="choice-id" value="" data-ltr="true" placeholder="Optional: A, B, C..." oninput="updateChoiceHeader(this)" title="Optional identifier for this choice (e.g., A, B, C, D)">
                </div>
                <div class="form-group required-field required">
                    <label>Choice Text</label>
                    <div class="text-field-container">
                        <span class="input-label">Input Markdown</span>
                        <textarea class="choice-text" placeholder="Enter choice text..." title="The text for this answer choice (supports markdown and LaTeX)"></textarea>
                        <button type="button" class="markdown-btn" onclick="insertBold(this.parentElement.querySelector('textarea'))" title="Make selected text bold (**text**)">
                            <i class="fas fa-bold"></i>
                        </button>
                        <button type="button" class="markdown-btn" onclick="insertItalic(this.parentElement.querySelector('textarea'))" title="Make selected text italic (*text*)">
                            <i class="fas fa-italic"></i>
                        </button>
                        <button type="button" class="markdown-btn" onclick="insertBulletList(this.parentElement.querySelector('textarea'))" title="Convert line(s) to bullet list (- item)">
                            <i class="fas fa-list-ul"></i>
                        </button>
                        <button type="button" class="markdown-btn" onclick="insertNumberedList(this.parentElement.querySelector('textarea'))" title="Convert line(s) to numbered list (1. item)">
                            <i class="fas fa-list-ol"></i>
                        </button>
                        <button type="button" class="markdown-btn" onclick="insertBlockquote(this.parentElement.querySelector('textarea'))" title="Convert line(s) to blockquote (> text)">
                            <i class="fas fa-quote-right"></i>
                        </button>
                        <button type="button" class="markdown-btn" onclick="insertInlineLatex(this.parentElement.querySelector('textarea'))" title="Wrap selection with $ or insert $$">
                            <i class="fas fa-dollar-sign"></i>
                        </button>
                        <button type="button" class="markdown-btn" onclick="insertBlockLatex(this.parentElement.querySelector('textarea'))" title="Wrap selection with block LaTeX ($$\\n...\\n$$) or insert $$\\n\\n$$">
                            <i class="fas fa-square-root-alt"></i>
                        </button>
                        <button type="button" class="markdown-btn" onclick="removeMarkdownFormatting(this)" title="Undo last markdown formatting operation">
                            <i class="fas fa-undo"></i>
                        </button>
                        <button type="button" class="markdown-btn" onclick="redoMarkdownFormatting(this)" title="Redo last undone markdown formatting operation">
                            <i class="fas fa-redo"></i>
                        </button>
                        <button type="button" class="table-btn" onclick="insertTable(this.parentElement.querySelector('textarea'))" title="Insert a markdown table template">
                            <i class="fas fa-table"></i> Insert Table
                        </button>
                        <button type="button" class="image-btn" onclick="insertImage(this.parentElement.querySelector('textarea'))" title="Insert an image placeholder">
                            <i class="fas fa-image"></i> Insert Image
                        </button>
                        <button type="button" class="dir-btn" onclick="toggleDirection(this.parentElement.querySelector('textarea'))" title="Toggle text direction (LTR/RTL)">LTR</button>
                    </div>
                </div>
                ${checkedField}
            `;
            
            // Add choice at the specified position
            if (position === 'end') {
                choicesList.appendChild(choiceItem);
            } else if (position.before) {
                choicesList.insertBefore(choiceItem, position.before);
            } else if (position.after) {
                if (position.after.nextElementSibling) {
                    choicesList.insertBefore(choiceItem, position.after.nextElementSibling);
                } else {
                    choicesList.appendChild(choiceItem);
                }
            }
            
            // Record action for undo/redo (after adding to DOM so we have the actual element)
            const nextSibling = choiceItem.nextSibling;
            recordFormAction({
                type: ACTION_TYPES.ADD_ITEM,
                element: choiceItem,
                parent: choicesList,
                nextSibling: nextSibling,
                containerId: null, // Choices don't have a container ID
                updateNumbers: false
            });
            
            // Attach previews and set RTL direction
            const textarea = choiceItem.querySelector('textarea');
            if (textarea) {
                textarea.setAttribute('dir', 'rtl');
            }
            attachPreviews(choiceItem);
            applyFontSettings(choiceItem);
            
            // Update correct answer UI (radio buttons or checkbox summary)
            const questionEl = choicesContainer.closest('.array-item');
            updateCorrectAnswerRadios(questionEl);
            updateCheckboxSummary(questionEl);
            
            // Add real-time listeners for UI updates
            if (questionType === 'checkbox') {
                const correctCheckbox = choiceItem.querySelector('.choice-correct');
                if (correctCheckbox) {
                    correctCheckbox.addEventListener('change', () => {
                        updateCheckboxSummary(questionEl);
                        markFormAsChanged();
                        triggerAutoSave();
                    });
                }
            } else if (questionType === 'multiple_choice') {
                // Add listener to choice text for real-time radio button updates
                const choiceTextArea = choiceItem.querySelector('.choice-text');
                if (choiceTextArea) {
                    // Clear any existing timeout for this textarea
                    if (choiceTextArea.__updateRadiosTimeout) {
                        clearTimeout(choiceTextArea.__updateRadiosTimeout);
                    }
                    choiceTextArea.addEventListener('input', () => {
                        // Ensure the live preview is rendered first
                        if (choiceTextArea.__livePreviewHandler) {
                            choiceTextArea.__livePreviewHandler();
                        } else {
                            renderLivePreview(choiceTextArea);
                        }
                        // Wait a moment for KaTeX to finish rendering, then update the radio previews
                        choiceTextArea.__updateRadiosTimeout = setTimeout(() => {
                            updateCorrectAnswerRadios(questionEl);
                        }, 100);
                    });
                }
                // Add listener to choice ID for real-time radio button updates
                const choiceIdInput = choiceItem.querySelector('.choice-id');
                if (choiceIdInput) {
                    choiceIdInput.addEventListener('input', () => {
                        updateCorrectAnswerRadios(questionEl);
                    });
                }
            }
        }

        function addChoiceBefore(button) {
            const choiceItem = button.closest('.choice-item');
            const choicesContainer = choiceItem.closest('#choices-container');
            // Get the question container (parent of choices container, not the choice item itself)
            const questionEl = choicesContainer.closest('.array-item');
            
            // Get question type from select element
            const questionTypeSelect = questionEl.querySelector('select[onchange*="toggleQuestionType"]');
            const questionType = questionTypeSelect ? questionTypeSelect.value : 'multiple_choice';
            
            console.log('addChoiceBefore - Question Type:', questionType); // Debug
            
            const addBtn = choicesContainer.querySelector('.add-btn');
            addChoice(addBtn, { before: choiceItem }, questionType);
        }

        function addChoiceAfter(button) {
            const choiceItem = button.closest('.choice-item');
            const choicesContainer = choiceItem.closest('#choices-container');
            // Get the question container (parent of choices container, not the choice item itself)
            const questionEl = choicesContainer.closest('.array-item');
            
            // Get question type from select element
            const questionTypeSelect = questionEl.querySelector('select[onchange*="toggleQuestionType"]');
            const questionType = questionTypeSelect ? questionTypeSelect.value : 'multiple_choice';
            
            console.log('addChoiceAfter - Question Type:', questionType); // Debug
            
            const addBtn = choicesContainer.querySelector('.add-btn');
            addChoice(addBtn, { after: choiceItem }, questionType);
        }

        function updateChoiceHeader(inputElement) {
            const choiceItem = inputElement.closest('.choice-item');
            const header = choiceItem.querySelector('h5');
            const choiceId = inputElement.value.trim();
            if (header) {
                header.textContent = choiceId ? `Choice ${choiceId}` : 'Choice';
            }
            // Update correct answer UI when ID changes
            const questionEl = choiceItem.parentElement?.closest('.array-item');
            if (questionEl) {
                updateCorrectAnswerRadios(questionEl);
            }
        }

        function removeChoice(button) {
            const choiceItem = button.closest('.choice-item');
            const choicesList = choiceItem.parentElement;
            
            if (confirm('Are you sure you want to remove this choice?')) {
                const questionEl = choicesList.closest('.array-item');
                choiceItem.remove();
                // Update correct answer UI after removal
                updateCorrectAnswerRadios(questionEl);
                updateCheckboxSummary(questionEl);
            }
        }

        function updateCorrectAnswerOptions(selectElement) {
            // This function is kept for backward compatibility but now delegates to updateCorrectAnswerRadios
            const questionEl = selectElement ? selectElement.closest('.array-item') : null;
            if (questionEl) {
                updateCorrectAnswerRadios(questionEl);
            }
        }

        function updateCorrectAnswerRadios(questionEl) {
            const choicesList = questionEl.querySelector('[id^="choices-list-"]');
            const radiosContainer = questionEl.querySelector('[id^="correct-answer-radios-"]');
            const questionTypeSelect = questionEl.querySelector('select[onchange*="toggleQuestionType"]');
            const questionType = questionTypeSelect ? questionTypeSelect.value : 'free_form';
            
            if (!radiosContainer || questionType !== 'multiple_choice') return;
            
            // Get currently selected value
            const currentlySelected = radiosContainer.querySelector('input[type="radio"]:checked');
            const currentValue = currentlySelected ? currentlySelected.value : null;
            
            // Get or create direction state for this radios container
            const containerId = radiosContainer.id;
            if (!radiosContainer.dataset.direction) {
                radiosContainer.dataset.direction = 'rtl'; // Default to RTL
            }
            const currentDirection = radiosContainer.dataset.direction;
            
            // Clear existing radio buttons
            radiosContainer.innerHTML = '';
            
            // Add LTR/RTL toggle button at the top
            const dirToggleBtn = document.createElement('button');
            dirToggleBtn.type = 'button';
            dirToggleBtn.className = 'dir-btn';
            dirToggleBtn.textContent = currentDirection === 'rtl' ? 'LTR' : 'RTL';
            dirToggleBtn.title = 'Toggle direction RTL/LTR for all previews';
            dirToggleBtn.style.cssText = 'margin-bottom: 10px; width: fit-content; display: inline-flex;';
            dirToggleBtn.onclick = () => {
                const newDirection = radiosContainer.dataset.direction === 'rtl' ? 'ltr' : 'rtl';
                radiosContainer.dataset.direction = newDirection;
                updateCorrectAnswerRadios(questionEl); // Refresh to apply new direction
            };
            radiosContainer.appendChild(dirToggleBtn);
            
            if (choicesList) {
                const choices = choicesList.querySelectorAll('.choice-item');
                choices.forEach((choice, index) => {
                    const choiceTextArea = choice.querySelector('.choice-text');
                    const choiceIdInput = choice.querySelector('.choice-id');
                    const choiceText = choiceTextArea ? choiceTextArea.value.trim() : '';
                    const choiceId = choiceIdInput ? choiceIdInput.value.trim() : '';
                    
                    // Create radio button for each choice (1-indexed position)
                    const position = index + 1;
                    const radioId = `correct-radio-${questionEl.querySelector('[id^="choices-list-"]').id}-${position}`;
                    
                    const radioWrapper = document.createElement('div');
                    radioWrapper.className = 'radio-choice-wrapper';
                    radioWrapper.style.cssText = 'display: flex; align-items: flex-start; gap: 10px; padding: 10px; border-radius: 6px; border: 1px solid var(--border-color); background: var(--bg-secondary); transition: all 0.2s ease;';
                    
                    // Add hover effect
                    radioWrapper.addEventListener('mouseenter', () => {
                        radioWrapper.style.background = 'var(--bg-tertiary)';
                        radioWrapper.style.borderColor = 'var(--accent)';
                    });
                    radioWrapper.addEventListener('mouseleave', () => {
                        radioWrapper.style.background = 'var(--bg-secondary)';
                        radioWrapper.style.borderColor = 'var(--border-color)';
                    });
                    
                    const radioInput = document.createElement('input');
                    radioInput.type = 'radio';
                    radioInput.name = `correct-answer-${questionEl.querySelector('[id^="choices-list-"]').id}`;
                    radioInput.value = position;
                    radioInput.id = radioId;
                    radioInput.className = 'choice-correct-radio';
                    radioInput.title = `Select this choice as the correct answer (Position ${position})`;
                    radioInput.style.cssText = 'cursor: pointer; width: 18px; height: 18px; accent-color: var(--accent); margin-top: 4px; flex-shrink: 0;';
                    if (currentValue && parseInt(currentValue) === position) {
                        radioInput.checked = true;
                    }
                    
                    // Add change listener to trigger auto-save when correct answer is selected
                    radioInput.addEventListener('change', () => {
                        if (radioInput.checked) {
                            markFormAsChanged();
                            triggerAutoSave();
                        }
                    });
                    
                    const radioLabel = document.createElement('label');
                    radioLabel.htmlFor = radioId;
                    radioLabel.style.cssText = 'cursor: pointer; flex: 1; margin: 0; color: var(--text-primary); display: flex; flex-direction: column; gap: 5px;';
                    
                    // Header with position and ID
                    const headerDiv = document.createElement('div');
                    headerDiv.style.cssText = 'display: flex; align-items: center; gap: 8px;';
                    
                    const positionBadge = document.createElement('strong');
                    positionBadge.textContent = `(${position})`;
                    positionBadge.style.cssText = 'color: var(--accent); margin-right: 0; font-size: 1em;';
                    
                    const idBadge = choiceId ? document.createElement('span') : null;
                    if (idBadge) {
                        idBadge.textContent = `[${choiceId}]`;
                        idBadge.style.cssText = 'color: var(--text-secondary); margin-right: 0; font-weight: 600;';
                    }
                    
                    headerDiv.appendChild(positionBadge);
                    if (idBadge) headerDiv.appendChild(idBadge);
                    
                    // Rendered preview (mini preview that follows the same LTR/RTL logic as choice previews)
                    const previewDiv = document.createElement('div');
                    previewDiv.className = 'choice-preview-mini';
                    previewDiv.style.cssText = 'padding: 8px; background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 4px; font-size: 0.9em; line-height: 1.4;';
                    // Match the same behavior as the main choice preview: use dir + textAlign based on direction
                    const isRTL = currentDirection === 'rtl';
                    previewDiv.setAttribute('dir', isRTL ? 'rtl' : 'ltr');
                    previewDiv.style.textAlign = isRTL ? 'right' : 'left';
                    
                    if (choiceText) {
                        // Copy the already-rendered preview from the choice text field's live preview
                        // Use the exact same logic as renderLivePreview to find the preview
                        let choiceLivePreview = null;
                        if (choiceTextArea) {
                            // Find preview box by walking through siblings (skip buttons and labels) - same as renderLivePreview
                            let nextSibling = choiceTextArea.nextElementSibling;
                            while (nextSibling) {
                                if (nextSibling.tagName === 'BUTTON') {
                                    // Skip buttons
                                    nextSibling = nextSibling.nextElementSibling;
                                } else if (nextSibling.classList && (
                                    nextSibling.classList.contains('preview-label') ||
                                    nextSibling.classList.contains('table-validation-errors') ||
                                    nextSibling.classList.contains('list-validation-errors') ||
                                    nextSibling.classList.contains('blockquote-validation-errors') ||
                                    nextSibling.classList.contains('latex-validation-errors') ||
                                    nextSibling.classList.contains('image-validation-errors') ||
                                    nextSibling.classList.contains('quote-validation-errors') ||
                                    nextSibling.classList.contains('br-validation-errors')
                                )) {
                                    // Skip labels and error validation divs, continue to preview
                                    nextSibling = nextSibling.nextElementSibling;
                                } else if (nextSibling.classList && nextSibling.classList.contains('live-preview')) {
                                    // Found preview!
                                    choiceLivePreview = nextSibling;
                                    break;
                                } else {
                                    // Unknown element, stop looking
                                    break;
                                }
                            }
                        }
                        
                        if (choiceLivePreview && choiceLivePreview.innerHTML.trim()) {
                            // Copy the exact rendered HTML from the live preview - don't modify structure
                            previewDiv.innerHTML = choiceLivePreview.innerHTML;
                            
                            // Only set direction to LTR for LaTeX elements - don't change display or text-align
                            // This preserves the exact inline/block structure from the original preview
                            const allMathElements = previewDiv.querySelectorAll('.__math_block, .__math_inline, .katex, .katex-display, .katex-html, .katex *');
                            allMathElements.forEach(mathEl => {
                                mathEl.setAttribute('dir', 'ltr');
                                mathEl.style.direction = 'ltr';
                                mathEl.style.unicodeBidi = 'isolate';
                                // Don't modify display, text-align, or any other properties
                                // Let the original structure be preserved
                            });
                            
                            // Only for block math, ensure centering (but don't force display)
                            const mathBlocks = previewDiv.querySelectorAll('.__math_block, .katex-display');
                            mathBlocks.forEach(mathEl => {
                                mathEl.style.textAlign = 'center';
                            });
                        } else {
                            // Fallback: if live preview doesn't exist yet, trigger render and wait
                            if (choiceTextArea) {
                                // Ensure the preview is rendered
                                renderLivePreview(choiceTextArea);
                                // Wait for KaTeX to finish rendering
                                setTimeout(() => {
                                    // Find preview using same logic as renderLivePreview
                                    let nextSibling = choiceTextArea.nextElementSibling;
                                    while (nextSibling) {
                                        if (nextSibling.tagName === 'BUTTON') {
                                            nextSibling = nextSibling.nextElementSibling;
                                        } else if (nextSibling.classList && nextSibling.classList.contains('preview-label')) {
                                            nextSibling = nextSibling.nextElementSibling;
                                        } else if (nextSibling.classList && nextSibling.classList.contains('live-preview')) {
                                            // Copy the exact rendered HTML - preserve structure exactly
                                            previewDiv.innerHTML = nextSibling.innerHTML;
                                            
                                            // Only set direction to LTR for all LaTeX elements
                                            const allMathElements = previewDiv.querySelectorAll('.__math_block, .__math_inline, .katex, .katex-display, .katex-html, .katex *');
                                            allMathElements.forEach(mathEl => {
                                                mathEl.setAttribute('dir', 'ltr');
                                                mathEl.style.direction = 'ltr';
                                                mathEl.style.unicodeBidi = 'isolate';
                                                // Don't modify display or other properties
                                            });
                                            
                                            // Only for block math, ensure centering
                                            const mathBlocks = previewDiv.querySelectorAll('.__math_block, .katex-display');
                                            mathBlocks.forEach(mathEl => {
                                                mathEl.style.textAlign = 'center';
                                            });
                                            break;
                                        } else {
                                            break;
                                        }
                                    }
                                }, 100);
                            } else {
                                previewDiv.textContent = '(empty)';
                                previewDiv.style.opacity = '0.5';
                                previewDiv.style.fontStyle = 'italic';
                            }
                        }
                    } else {
                        previewDiv.textContent = '(empty)';
                        previewDiv.style.opacity = '0.5';
                        previewDiv.style.fontStyle = 'italic';
                    }
                    
                    radioLabel.appendChild(headerDiv);
                    radioLabel.appendChild(previewDiv);
                    
                    radioWrapper.appendChild(radioInput);
                    radioWrapper.appendChild(radioLabel);
                    
                    radiosContainer.appendChild(radioWrapper);
                });
            }
        }

        function updateCheckboxSummary(questionEl) {
            const summaryContainer = questionEl.querySelector('#checkbox-summary-text');
            const choicesList = questionEl.querySelector('[id^="choices-list-"]');
            
            if (!summaryContainer || !choicesList) return;
            
            const choices = choicesList.querySelectorAll('.choice-item');
            const correctChoices = [];
            
            choices.forEach((choice, index) => {
                const correctCheckbox = choice.querySelector('.choice-correct');
                if (correctCheckbox && correctCheckbox.checked) {
                    const choiceIdInput = choice.querySelector('.choice-id');
                    const choiceId = choiceIdInput ? choiceIdInput.value.trim() : '';
                    correctChoices.push(choiceId || `Choice ${index + 1}`);
                }
            });
            
            if (correctChoices.length === 0) {
                summaryContainer.innerHTML = '<span style="opacity: 0.7; color: var(--text-secondary);">Check the " Correct Answer" boxes above to mark correct choices</span>';
            } else {
                summaryContainer.innerHTML = `<strong style="color: #28a745;">${correctChoices.length} of ${choices.length} marked correct:</strong> <span style="color: var(--text-primary);">${correctChoices.join(', ')}</span>`;
                            }
        }

        function attachChoiceListeners(questionEl) {
            const questionTypeSelect = questionEl.querySelector('select[onchange*="toggleQuestionType"]');
            const questionType = questionTypeSelect ? questionTypeSelect.value : 'free_form';
            const choicesList = questionEl.querySelector('[id^="choices-list-"]');
            
            if (!choicesList) return;
            
            const choiceItems = choicesList.querySelectorAll('.choice-item');
            choiceItems.forEach((choiceItem) => {
                if (questionType === 'multiple_choice') {
                    // Add listeners for multiple choice
                    const choiceTextArea = choiceItem.querySelector('.choice-text');
                    const choiceIdInput = choiceItem.querySelector('.choice-id');
                    
                    if (choiceTextArea && !choiceTextArea.dataset.listenerAttached) {
                        choiceTextArea.addEventListener('input', () => {
                            // Ensure the live preview is rendered first
                            if (choiceTextArea.__livePreviewHandler) {
                                choiceTextArea.__livePreviewHandler();
                            } else {
                                renderLivePreview(choiceTextArea);
                            }
                            // Wait a moment for KaTeX to finish rendering, then update the radio previews
                            if (choiceTextArea.__updateRadiosTimeout) {
                                clearTimeout(choiceTextArea.__updateRadiosTimeout);
                            }
                            choiceTextArea.__updateRadiosTimeout = setTimeout(() => {
                                updateCorrectAnswerRadios(questionEl);
                            }, 100);
                        });
                        choiceTextArea.dataset.listenerAttached = 'true';
                    }
                    
                    if (choiceIdInput && !choiceIdInput.dataset.listenerAttached) {
                        choiceIdInput.addEventListener('input', () => {
                            updateCorrectAnswerRadios(questionEl);
                        });
                        choiceIdInput.dataset.listenerAttached = 'true';
                    }
                } else if (questionType === 'checkbox') {
                    // Add listeners for checkbox
                    const correctCheckbox = choiceItem.querySelector('.choice-correct');
                    if (correctCheckbox && !correctCheckbox.dataset.listenerAttached) {
                        correctCheckbox.addEventListener('change', () => {
                            updateCheckboxSummary(questionEl);
                            markFormAsChanged();
                            triggerAutoSave();
                        });
                        correctCheckbox.dataset.listenerAttached = 'true';
                    }
                }
            });
        }

        function moveChoiceUp(button) {
            const choiceItem = button.closest('.choice-item');
            const choicesList = choiceItem.parentElement;
            const prevSibling = choiceItem.previousElementSibling;
            if (prevSibling) {
                choicesList.insertBefore(choiceItem, prevSibling);
                // Update correct answer UI after reordering (positions change!)
                const questionEl = choicesList.closest('.array-item');
                updateCorrectAnswerRadios(questionEl);
                updateCheckboxSummary(questionEl);
                markFormAsChanged();
                triggerAutoSave();
            }
        }

        function moveChoiceDown(button) {
            const choiceItem = button.closest('.choice-item');
            const choicesList = choiceItem.parentElement;
            const nextSibling = choiceItem.nextElementSibling;
            if (nextSibling) {
                choicesList.insertBefore(nextSibling, choiceItem);
                // Update correct answer UI after reordering (positions change!)
                const questionEl = choicesList.closest('.array-item');
                updateCorrectAnswerRadios(questionEl);
                updateCheckboxSummary(questionEl);
                markFormAsChanged();
                triggerAutoSave();
            }
        }

        function removeArrayItem(button) {
            // Check if this is a main array item (question or content section) or a nested item
            const parentArrayItem = button.closest('.array-item');
            if (parentArrayItem && (parentArrayItem.querySelector('.array-item-header') || parentArrayItem.closest('#questions_container, #content_sections_container'))) {
                // This is a main array item (question or content section), ask for confirmation
                const isQuestion = !!parentArrayItem.closest('#questions_container');
                const itemType = isQuestion ? 'question' : 'content section';
                const itemTitle = parentArrayItem.querySelector('h4')?.textContent || itemType;
                
                if (confirm(`Are you sure you want to remove this ${itemType}?\n\n"${itemTitle}"`)) {
                    // Record action for undo/redo
                    const container = isQuestion ? document.getElementById('questions_container') : document.getElementById('content_sections_container');
                    recordFormAction({
                        type: ACTION_TYPES.REMOVE_ITEM,
                        element: parentArrayItem.cloneNode(true), // Clone for restoration
                        parent: parentArrayItem.parentNode,
                        nextSibling: parentArrayItem.nextSibling,
                        containerId: isQuestion ? 'questions_container' : 'content_sections_container',
                        updateNumbers: true
                    });
                    
                    parentArrayItem.remove();
                    
                    // Update numbering after removal
                    if (isQuestion) {
                        updateQuestionNumbers();
                    } else {
                        updateContentSectionNumbers();
                    }
                    
                    // Mark form as changed
                    markFormAsChanged();
                }
            } else {
                // This is a nested item (terminology, standards, bbox, choice, etc.)
                // Determine the item type for the confirmation message
                let itemType = 'item';
                let itemPreview = '';
                
                if (parentArrayItem) {
                    // Check what type of item this is
                    if (parentArrayItem.closest('#lesson_standards')) {
                        itemType = 'standard';
                        const input = parentArrayItem.querySelector('input[type="text"]');
                        itemPreview = input?.value || '';
                    } else if (parentArrayItem.closest('#terminology')) {
                        itemType = 'term';
                        const input = parentArrayItem.querySelector('input[type="text"]');
                        itemPreview = input?.value || '';
                    } else if (parentArrayItem.closest('.bbox-container')) {
                        itemType = 'bbox';
                        const page = parentArrayItem.querySelector('.bbox-page')?.value || '';
                        const x0 = parentArrayItem.querySelector('.bbox-x0')?.value || '';
                        const y0 = parentArrayItem.querySelector('.bbox-y0')?.value || '';
                        if (page || x0 || y0) {
                            itemPreview = `Page ${page}, Position (${x0}, ${y0})`;
                        }
                    } else if (parentArrayItem.closest('[id^="choices-list-"]')) {
                        itemType = 'choice';
                        const choiceId = parentArrayItem.querySelector('.choice-id')?.value || '';
                        const choiceText = parentArrayItem.querySelector('.choice-text')?.value || '';
                        if (choiceId || choiceText) {
                            itemPreview = `${choiceId}: ${choiceText.substring(0, 30)}${choiceText.length > 30 ? '...' : ''}`;
                        }
                    }
                }
                
                // Show confirmation prompt
                const confirmMessage = itemPreview 
                    ? `Are you sure you want to remove this ${itemType}?\n\n"${itemPreview}"\n\nThis action cannot be undone.`
                    : `Are you sure you want to remove this ${itemType}?\n\nThis action cannot be undone.`;
                
                if (confirm(confirmMessage)) {
                    // Determine container for undo tracking
                    let containerId = null;
                    const questionsContainer = button.closest('#questions_container');
                    const contentContainer = button.closest('#content_sections_container');
                    if (questionsContainer) containerId = 'questions_container';
                    if (contentContainer) containerId = 'content_sections_container';
                    
                    // Remove the entire array-item or list-item
                    let elementToRemove = null;
                    if (parentArrayItem) {
                        elementToRemove = parentArrayItem;
                        // Record action for undo/redo
                        recordFormAction({
                            type: ACTION_TYPES.REMOVE_ITEM,
                            element: parentArrayItem.cloneNode(true), // Clone for restoration
                            parent: parentArrayItem.parentNode,
                            nextSibling: parentArrayItem.nextSibling,
                            containerId: containerId,
                            updateNumbers: false
                        });
                        parentArrayItem.remove();
                    } else {
                        // Fallback for items without .array-item class (like bbox-item)
                        const listItem = button.closest('.bbox-item, .choice-item');
                        if (listItem) {
                            elementToRemove = listItem;
                            recordFormAction({
                                type: ACTION_TYPES.REMOVE_ITEM,
                                element: listItem.cloneNode(true),
                                parent: listItem.parentNode,
                                nextSibling: listItem.nextSibling,
                                containerId: containerId,
                                updateNumbers: false
                            });
                            listItem.remove();
                        } else {
                            elementToRemove = button.parentElement;
                            recordFormAction({
                                type: ACTION_TYPES.REMOVE_ITEM,
                                element: button.parentElement.cloneNode(true),
                                parent: button.parentElement.parentNode,
                                nextSibling: button.parentElement.nextSibling,
                                containerId: containerId,
                                updateNumbers: false
                            });
                            button.parentElement.remove();
                        }
                    }
                    markFormAsChanged();
                }
            }
        }

        // Toggle section collapse/expand
        function toggleSectionCollapse(button) {
            const section = button.closest('.array-item');
            if (section) {
                section.classList.toggle('collapsed');
            }
        }

        // Move item up in the list
        function moveItemUp(button) {
            const item = button.closest('.array-item');
            const previousItem = item.previousElementSibling;
            
            if (previousItem) {
                // Save old position before move
                const oldParent = item.parentNode;
                const oldNextSibling = item.nextSibling;
                const container = item.closest('#questions_container') || item.closest('#content_sections_container');
                const containerId = container ? container.id : null;
                
                // Perform the move
                item.parentNode.insertBefore(item, previousItem);
                
                // Record action for undo/redo (after move, so we have correct newNextSibling)
                recordFormAction({
                    type: ACTION_TYPES.MOVE_ITEM,
                    element: item,
                    oldParent: oldParent,
                    oldNextSibling: oldNextSibling,
                    newParent: item.parentNode,
                    newNextSibling: item.nextSibling,
                    containerId: containerId,
                    updateNumbers: true
                });
                
                // Update numbering for sections/questions
                if (item.closest('#questions_container') && item.querySelector('.array-item-header')) {
                    updateQuestionNumbers();
                } else if (item.closest('#content_sections_container') && item.querySelector('.array-item-header')) {
                    updateContentSectionNumbers();
                }
                
                markFormAsChanged();
                triggerAutoSave();
            }
        }

        // Move item down in the list
        function moveItemDown(button) {
            const item = button.closest('.array-item');
            const nextItem = item.nextElementSibling;
            
            if (nextItem) {
                // Save old position before move
                const oldParent = item.parentNode;
                const oldNextSibling = item.nextSibling;
                const container = item.closest('#questions_container') || item.closest('#content_sections_container');
                const containerId = container ? container.id : null;
                
                // Perform the move
                item.parentNode.insertBefore(nextItem, item);
                
                // Record action for undo/redo (after move, so we have correct newNextSibling)
                recordFormAction({
                    type: ACTION_TYPES.MOVE_ITEM,
                    element: item,
                    oldParent: oldParent,
                    oldNextSibling: oldNextSibling,
                    newParent: item.parentNode,
                    newNextSibling: item.nextSibling,
                    containerId: containerId,
                    updateNumbers: true
                });
                
                // Update numbering for sections/questions
                if (item.closest('#questions_container') && item.querySelector('.array-item-header')) {
                    updateQuestionNumbers();
                } else if (item.closest('#content_sections_container') && item.querySelector('.array-item-header')) {
                    updateContentSectionNumbers();
                }
                
                markFormAsChanged();
                triggerAutoSave();
            }
        }

        // Update question numbers after reordering
        function updateQuestionNumbers() {
            const container = document.getElementById('questions_container');
            if (!container) {
                console.warn('Questions container not found');
                return;
            }
            
            // Get all direct children that are array-items (questions)
            // Use querySelectorAll with direct child selector to avoid nested items
            const questions = container.querySelectorAll(':scope > .array-item');
            
            questions.forEach((question, index) => {
                // Look for h4 in the array-item-header
                const header = question.querySelector('.array-item-header > h4');
                if (header) {
                    header.textContent = `Question ${index + 1}`;
                }
                
                // Don't auto-update question ID input anymore - let user set their own IDs
            });
        }

        // Update content section numbers after reordering
        function updateContentSectionNumbers() {
            const container = document.getElementById('content_sections_container');
            if (!container) return;
            
            // Get all direct children that are array-items (content sections)
            // Use querySelectorAll with direct child selector to avoid nested items
            const sections = container.querySelectorAll(':scope > .array-item');
            
            sections.forEach((section, index) => {
                // Look for h4 in the array-item-header
                const header = section.querySelector('.array-item-header > h4');
                if (header) {
                    header.textContent = `Content Section ${index + 1}`;
                }
            });
        }

        // Copy entire section (content section or question) as JSON
        function copySection(button) {
            try {
                const sectionEl = button.closest('.array-item');
                if (!sectionEl) {
                    alert('Could not find section to copy');
                    return;
                }
                
                // Determine if this is a content section or question
                const isQuestion = !!sectionEl.closest('#questions_container');
                
                let sectionData;
                
                if (isQuestion) {
                    // Collect question data using helper function
                    sectionData = {
                        type: 'question',
                        data: collectQuestionData(sectionEl)
                    };
                } else {
                    // Collect content section data using helper function
                    sectionData = {
                        type: 'content',
                        data: collectContentData(sectionEl)
                    };
                }
                
                // Copy to clipboard
                const jsonText = JSON.stringify(sectionData, null, 2);
                const textarea = document.createElement('textarea');
                textarea.value = jsonText;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                
                // Visual feedback
                const copyBtn = button;
                const originalIcon = copyBtn.innerHTML;
                copyBtn.innerHTML = '<i class="fas fa-check"></i>';
                copyBtn.style.background = '#28a745';
                setTimeout(() => {
                    copyBtn.innerHTML = originalIcon;
                    copyBtn.style.background = '';
                }, 1200);
                
                // Track section copy
                const questionType = isQuestion ? (sectionData.data.question_type || 'unknown') : null;
                trackEvent('section_copied', {
                    section_type: isQuestion ? 'question' : 'content',
                    question_type: questionType
                });
                
            } catch (e) {
                console.error('Failed to copy section:', e);
                alert('Failed to copy section: ' + e.message);
            }
        }

        // Duplicate entire section (copy and paste below immediately)
        function duplicateSection(button) {
            try {
                const sectionEl = button.closest('.array-item');
                if (!sectionEl) {
                    alert('Could not find section to duplicate');
                    return;
                }
                
                // Determine if this is a content section or question
                const isQuestion = !!sectionEl.closest('#questions_container');
                
                let sectionData;
                
                if (isQuestion) {
                    // Collect question data using helper function
                    sectionData = {
                        type: 'question',
                        data: collectQuestionData(sectionEl)
                    };
                } else {
                    // Collect content section data using helper function
                    sectionData = {
                        type: 'content',
                        data: collectContentData(sectionEl)
                    };
                }
                
                // Create new section below current one
                if (sectionData.type === 'question') {
                    const container = document.getElementById('questions_container');
                    if (!container) {
                        alert('Could not find questions container');
                        return;
                    }
                    
                    const questionCount = container.querySelectorAll(':scope > .array-item').length + 1;
                    const newQuestion = document.createElement('div');
                    newQuestion.className = 'array-item';
                    newQuestion.innerHTML = getQuestionHTML(questionCount);
                    container.insertBefore(newQuestion, sectionEl.nextSibling);
                    
                    // Fill in the duplicated data
                    const questionIdInput = findFieldByLabel(newQuestion, 'Question ID', 'input');
                    if (questionIdInput) {
                        questionIdInput.value = sectionData.data.id || '';
                    }
                    
                    const questionType = sectionData.data.question_type || 'free_form';
                    const questionTypeSelect = findFieldByLabel(newQuestion, 'Question Type', 'select');
                    if (questionTypeSelect) {
                        questionTypeSelect.value = questionType;
                        // Trigger toggle to show/hide appropriate fields
                        toggleQuestionType(questionTypeSelect);
                    }
                    
                    setFieldValue(newQuestion, 'Set-up Text', sectionData.data.set_up_text || '', 'textarea');
                    setFieldValue(newQuestion, 'Question Text', sectionData.data.question_text || '', 'textarea');
                    
                    // Handle different question types
                    if (questionType === 'fill_in_the_blanks') {
                        // Fill in the blanks: populate blank answers
                        updateBlankAnswersUI(newQuestion);
                        
                        if (sectionData.data.values && Array.isArray(sectionData.data.values)) {
                            const blankItems = newQuestion.querySelectorAll('.blank-answer-item');
                            blankItems.forEach((item, index) => {
                                const textarea = item.querySelector('.blank-answer-input');
                                if (textarea && sectionData.data.values[index] !== undefined) {
                                    textarea.value = sectionData.data.values[index];
                                }
                            });
                            
                            // Update the filled blanks preview after loading values
                            updateFilledBlanksPreview(newQuestion);
                        }
                        
                        // Query specifically within blanks container
                        const blanksContainer = newQuestion.querySelector('#blanks-container');
                        const guideAnswerNotesTextarea = blanksContainer?.querySelector('.guide-answer-notes');
                        if (guideAnswerNotesTextarea) {
                            guideAnswerNotesTextarea.value = sectionData.data.guide_answer || '';
                        }
                    } else if (questionType === 'matching') {
                        // Matching: populate left items, right items, and relationships
                        const leftList = newQuestion.querySelector('[id^="matching-left-list-"]');
                        const rightList = newQuestion.querySelector('[id^="matching-right-list-"]');
                        
                        if (leftList && sectionData.data.left && Array.isArray(sectionData.data.left)) {
                            leftList.innerHTML = '';
                            sectionData.data.left.forEach((itemText) => {
                                const addLeftBtn = newQuestion.querySelector('button[onclick*="addMatchingItem"][onclick*="left"]');
                                if (addLeftBtn) {
                                    addMatchingItem(addLeftBtn, 'left');
                                    const lastItem = leftList.lastElementChild;
                                    if (lastItem) {
                                        const textarea = lastItem.querySelector('.matching-item-text');
                                        if (textarea) textarea.value = itemText;
                                    }
                                }
                            });
                        }
                        
                        if (rightList && sectionData.data.right && Array.isArray(sectionData.data.right)) {
                            rightList.innerHTML = '';
                            sectionData.data.right.forEach((itemText) => {
                                const addRightBtn = newQuestion.querySelector('button[onclick*="addMatchingItem"][onclick*="right"]');
                                if (addRightBtn) {
                                    addMatchingItem(addRightBtn, 'right');
                                    const lastItem = rightList.lastElementChild;
                                    if (lastItem) {
                                        const textarea = lastItem.querySelector('.matching-item-text');
                                        if (textarea) textarea.value = itemText;
                                    }
                                }
                            });
                        }
                        
                        const relationshipsList = newQuestion.querySelector('[id^="relationships-list-"]');
                        if (relationshipsList && sectionData.data.relationship && Array.isArray(sectionData.data.relationship)) {
                            relationshipsList.innerHTML = '';
                            sectionData.data.relationship.forEach(([leftIdx, rightIdx]) => {
                                const addRelBtn = newQuestion.querySelector('button[onclick*="addRelationship"]');
                                if (addRelBtn) {
                                    addRelationship(addRelBtn);
                                    const lastRel = relationshipsList.lastElementChild;
                                    if (lastRel) {
                                        const leftSelect = lastRel.querySelector('.relationship-left');
                                        const rightSelect = lastRel.querySelector('.relationship-right');
                                        if (leftSelect) leftSelect.value = leftIdx;
                                        if (rightSelect) rightSelect.value = rightIdx;
                                    }
                                }
                            });
                        }
                        
                        // Fill guide answer in matching container
                        const matchingContainer = newQuestion.querySelector('#matching-container');
                        const matchingGuideAnswerTextarea = matchingContainer?.querySelector('.guide-answer-notes');
                        if (matchingGuideAnswerTextarea) {
                            matchingGuideAnswerTextarea.value = sectionData.data.guide_answer || '';
                        }
                    } else if ((questionType === 'multiple_choice' || questionType === 'checkbox') && sectionData.data.choices) {
                        // Fill choices
                        const choicesContainer = newQuestion.querySelector('#choices-container');
                        const choicesList = newQuestion.querySelector('[id^="choices-list-"]');
                        if (choicesList) {
                            choicesList.innerHTML = '';
                            sectionData.data.choices.forEach((choice) => {
                                addChoice(choicesList.parentElement.querySelector('.add-btn'), 'end', questionType);
                                const lastChoice = choicesList.lastElementChild;
                                if (lastChoice) {
                                    const choiceIdInput = lastChoice.querySelector('.choice-id');
                                    const choiceTextArea = lastChoice.querySelector('.choice-text');
                                    const choiceCorrectInput = lastChoice.querySelector('.choice-correct');
                                    if (choiceIdInput) {
                                        choiceIdInput.value = choice.id || '';
                                        // Update header to reflect the ID
                                        updateChoiceHeader(choiceIdInput);
                                    }
                                    if (choiceTextArea) {
                                        choiceTextArea.value = choice.text || '';
                                    }
                                    if (choiceCorrectInput && choice.checked !== undefined) {
                                        choiceCorrectInput.checked = choice.checked;
                                    }
                                }
                            });
                        }
                        
                        // Set guide answer notes (optional) - in choices container
                        const choicesGuideAnswer = choicesContainer?.querySelector('.guide-answer-notes');
                        if (choicesGuideAnswer) {
                            choicesGuideAnswer.value = sectionData.data.guide_answer || '';
                        }
                        
                        // Set correct answer based on question type
                        setTimeout(() => {
                            // Attach listeners for real-time updates
                            attachChoiceListeners(newQuestion);
                            
                            if (questionType === 'multiple_choice') {
                                // Update radio buttons first
                                updateCorrectAnswerRadios(newQuestion);
                                // Then set the value from new 'value' field
                                if (sectionData.data.value !== undefined) {
                                    const correctRadio = newQuestion.querySelector(`.choice-correct-radio[value="${sectionData.data.value}"]`);
                                    if (correctRadio) {
                                        correctRadio.checked = true;
                                    }
                                }
                            } else if (questionType === 'checkbox') {
                                // Restore from new 'values' array
                                if (sectionData.data.values && Array.isArray(sectionData.data.values)) {
                                    const choicesListCheckbox = newQuestion.querySelector('[id^="choices-list-"]');
                                    if (choicesListCheckbox) {
                                        const choiceItems = choicesListCheckbox.querySelectorAll('.choice-item');
                                        choiceItems.forEach((choiceItem, index) => {
                                            const correctCheckbox = choiceItem.querySelector('.choice-correct');
                                            if (correctCheckbox && sectionData.data.values[index] !== undefined) {
                                                correctCheckbox.checked = sectionData.data.values[index];
                                            }
                                        });
                                    }
                                }
                                updateCheckboxSummary(newQuestion);
                            }
                        }, 50);
                    } else {
                        // Free form and other types - fill guide answer
                        const guideAnswerTextarea = newQuestion.querySelector('#guide-answer-container textarea');
                        if (guideAnswerTextarea) {
                            guideAnswerTextarea.value = sectionData.data.guide_answer || '';
                        }
                    }
                    
                    // Find Guide PDF Page field by label
                    setFieldValue(newQuestion, 'Guide PDF Page', sectionData.data.guide_pdf_page || '');
                    setFieldValue(newQuestion, 'Related Question', sectionData.data.related_question || '');
                    
                    // Fill question images
                    const questionImagesGroup = findFormGroupByLabel(newQuestion, 'Question Images');
                    if (questionImagesGroup) {
                        fillBboxGroup(questionImagesGroup, sectionData.data.question_images || []);
                    }
                    
                    // Fill answer images
                    const answerImagesGroup = findFormGroupByLabel(newQuestion, 'Answer Images');
                    if (answerImagesGroup) {
                        fillBboxGroup(answerImagesGroup, sectionData.data.guide_answer_images || []);
                    }
                    
                    // Initialize the new question
                    attachPreviews(newQuestion);
                    applyFontSettings(newQuestion);
                    attachBboxValidation(newQuestion);
                    
                    // Record action for undo/redo (after element is fully populated and added to DOM)
                    recordFormAction({
                        type: ACTION_TYPES.DUPLICATE_ITEM,
                        originalElement: sectionEl,
                        duplicatedElement: newQuestion,
                        parent: container,
                        nextSibling: newQuestion.nextSibling,
                        containerId: 'questions_container',
                        updateNumbers: true
                    });
                    
                    updateQuestionNumbers();
                    
                } else {
                    // Content section
                    const container = document.getElementById('content_sections_container');
                    if (!container) {
                        alert('Could not find content sections container');
                        return;
                    }
                    
                    const sectionCount = container.querySelectorAll(':scope > .array-item').length + 1;
                    const newSection = document.createElement('div');
                    newSection.className = 'array-item';
                    newSection.innerHTML = getContentSectionHTML(sectionCount);
                    container.insertBefore(newSection, sectionEl.nextSibling);
                    
                    // Fill in the duplicated data
                    const sectionTitleInput = findFieldByLabel(newSection, 'Section Title', 'input');
                    if (sectionTitleInput) {
                        sectionTitleInput.value = sectionData.data.section_title || '';
                    }
                    
                    const sectionTextTextarea = findFieldByLabel(newSection, 'Content (Markdown + LaTeX)', 'textarea');
                    if (sectionTextTextarea) {
                        sectionTextTextarea.value = sectionData.data.text || '';
                    }
                    
                    // Fill images using label-based selector
                    const imagesGroup = findFormGroupByLabel(newSection, 'Section Images');
                    if (imagesGroup) {
                        fillBboxGroup(imagesGroup, sectionData.data.images || []);
                    }
                    
                    // Initialize the new section
                    attachPreviews(newSection);
                    applyFontSettings(newSection);
                    attachBboxValidation(newSection);
                    
                    // Record action for undo/redo (after element is fully populated and added to DOM)
                    recordFormAction({
                        type: ACTION_TYPES.DUPLICATE_ITEM,
                        originalElement: sectionEl,
                        duplicatedElement: newSection,
                        parent: container,
                        nextSibling: newSection.nextSibling,
                        containerId: 'content_sections_container',
                        updateNumbers: true
                    });
                    
                    updateContentSectionNumbers();
                }
                
                // Visual feedback
                const duplicateBtn = button;
                const originalIcon = duplicateBtn.innerHTML;
                duplicateBtn.innerHTML = '<i class="fas fa-check"></i>';
                duplicateBtn.style.background = '#28a745';
                setTimeout(() => {
                    duplicateBtn.innerHTML = originalIcon;
                    duplicateBtn.style.background = '';
                }, 1200);
                
                // Mark form as changed and trigger auto-save
                markFormAsChanged();
                triggerAutoSave();
                
                // Track section duplication
                const questionType = sectionData.type === 'question' ? (sectionData.data.question_type || 'unknown') : null;
                trackEvent('section_duplicated', {
                    section_type: sectionData.type,
                    question_type: questionType
                });
                
            } catch (e) {
                console.error('Failed to duplicate section:', e);
                alert('Failed to duplicate section: ' + e.message);
            }
        }

        // Paste and replace current section content
        function pasteIntoSection(button) {
            try {
                const sectionEl = button.closest('.array-item');
                if (!sectionEl) {
                    alert('Could not find section to paste into');
                    return;
                }
                
                const text = prompt('Paste section JSON here to replace current content:');
                if (!text || !text.trim()) return;
                
                let sectionData;
                try {
                    sectionData = JSON.parse(text);
                } catch (e) {
                    alert('Pasted content is not valid JSON.');
                    return;
                }
                
                if (!sectionData.type || !sectionData.data) {
                    alert('Invalid section JSON format. Please copy from a section copy button.');
                    return;
                }
                
                // Determine current section type
                const isQuestion = !!sectionEl.closest('#questions_container');
                
                // Verify type matches
                if (isQuestion && sectionData.type !== 'question') {
                    alert('Cannot paste a content section into a question. Types must match.');
                    return;
                }
                if (!isQuestion && sectionData.type !== 'content') {
                    alert('Cannot paste a question into a content section. Types must match.');
                    return;
                }
                
                // Confirm replacement
                if (!confirm('This will replace all content in this section. Continue?')) {
                    return;
                }
                
                // Save old section state for undo
                const oldSectionState = sectionEl.cloneNode(true);
                const container = sectionEl.parentNode;
                const nextSibling = sectionEl.nextSibling;
                const containerId = isQuestion ? 'questions_container' : 'content_sections_container';
                
                if (sectionData.type === 'question') {
                    // Replace question data - use label-based selectors
                    const questionIdInput = findFieldByLabel(sectionEl, 'Question ID');
                    if (questionIdInput) {
                        questionIdInput.value = sectionData.data.id || '';
                    }
                    
                    
                    const questionTypeSelect = findFieldByLabel(sectionEl, 'Question Type', 'select');
                    const questionType = sectionData.data.question_type || 'free_form';
                    if (questionTypeSelect) {
                        questionTypeSelect.value = questionType;
                        // Trigger toggle to show/hide appropriate fields
                        toggleQuestionType(questionTypeSelect);
                    }
                    
                    setFieldValue(sectionEl, 'Set-up Text', sectionData.data.set_up_text || '', 'textarea');
                    setFieldValue(sectionEl, 'Question Text', sectionData.data.question_text || '', 'textarea');
                    
                    // Handle different question types
                    if (questionType === 'fill_in_the_blanks') {
                        // Fill in the blanks: populate blank answers
                        updateBlankAnswersUI(sectionEl);
                        
                        if (sectionData.data.values && Array.isArray(sectionData.data.values)) {
                            const blankItems = sectionEl.querySelectorAll('.blank-answer-item');
                            blankItems.forEach((item, index) => {
                                const textarea = item.querySelector('.blank-answer-input');
                                if (textarea && sectionData.data.values[index] !== undefined) {
                                    textarea.value = sectionData.data.values[index];
                                }
                            });
                            
                            // Update the filled blanks preview after loading values
                            updateFilledBlanksPreview(sectionEl);
                        }
                        
                        // Query specifically within blanks container
                        const blanksContainer = sectionEl.querySelector('#blanks-container');
                        const guideAnswerNotesTextarea = blanksContainer?.querySelector('.guide-answer-notes');
                        if (guideAnswerNotesTextarea) {
                            guideAnswerNotesTextarea.value = sectionData.data.guide_answer || '';
                        }
                    } else if (questionType === 'matching') {
                        // Matching: populate left items, right items, and relationships
                        const leftList = sectionEl.querySelector('[id^="matching-left-list-"]');
                        const rightList = sectionEl.querySelector('[id^="matching-right-list-"]');
                        
                        if (leftList && sectionData.data.left && Array.isArray(sectionData.data.left)) {
                            leftList.innerHTML = '';
                            sectionData.data.left.forEach((itemText) => {
                                const addLeftBtn = sectionEl.querySelector('button[onclick*="addMatchingItem"][onclick*="left"]');
                                if (addLeftBtn) {
                                    addMatchingItem(addLeftBtn, 'left');
                                    const lastItem = leftList.lastElementChild;
                                    if (lastItem) {
                                        const textarea = lastItem.querySelector('.matching-item-text');
                                        if (textarea) textarea.value = itemText;
                                    }
                                }
                            });
                        }
                        
                        if (rightList && sectionData.data.right && Array.isArray(sectionData.data.right)) {
                            rightList.innerHTML = '';
                            sectionData.data.right.forEach((itemText) => {
                                const addRightBtn = sectionEl.querySelector('button[onclick*="addMatchingItem"][onclick*="right"]');
                                if (addRightBtn) {
                                    addMatchingItem(addRightBtn, 'right');
                                    const lastItem = rightList.lastElementChild;
                                    if (lastItem) {
                                        const textarea = lastItem.querySelector('.matching-item-text');
                                        if (textarea) textarea.value = itemText;
                                    }
                                }
                            });
                        }
                        
                        const relationshipsList = sectionEl.querySelector('[id^="relationships-list-"]');
                        if (relationshipsList && sectionData.data.relationship && Array.isArray(sectionData.data.relationship)) {
                            relationshipsList.innerHTML = '';
                            sectionData.data.relationship.forEach(([leftIdx, rightIdx]) => {
                                const addRelBtn = sectionEl.querySelector('button[onclick*="addRelationship"]');
                                if (addRelBtn) {
                                    addRelationship(addRelBtn);
                                    const lastRel = relationshipsList.lastElementChild;
                                    if (lastRel) {
                                        const leftSelect = lastRel.querySelector('.relationship-left');
                                        const rightSelect = lastRel.querySelector('.relationship-right');
                                        if (leftSelect) leftSelect.value = leftIdx;
                                        if (rightSelect) rightSelect.value = rightIdx;
                                    }
                                }
                            });
                        }
                        
                        const guideAnswerNotesTextarea = sectionEl.querySelector('.guide-answer-notes');
                        if (guideAnswerNotesTextarea) {
                            guideAnswerNotesTextarea.value = sectionData.data.guide_answer || '';
                        }
                    } else if ((questionType === 'multiple_choice' || questionType === 'checkbox') && sectionData.data.choices) {
                        // Fill choices
                        const choicesList = sectionEl.querySelector('[id^="choices-list-"]');
                        if (choicesList) {
                            choicesList.innerHTML = '';
                            sectionData.data.choices.forEach((choice) => {
                                addChoice(choicesList.parentElement.querySelector('.add-btn'), 'end', questionType);
                                const lastChoice = choicesList.lastElementChild;
                                if (lastChoice) {
                                    const choiceIdInput = lastChoice.querySelector('.choice-id');
                                    const choiceTextArea = lastChoice.querySelector('.choice-text');
                                    const choiceCorrectInput = lastChoice.querySelector('.choice-correct');
                                    if (choiceIdInput) {
                                        choiceIdInput.value = choice.id || '';
                                        // Update header to reflect the ID
                                        updateChoiceHeader(choiceIdInput);
                                    }
                                    if (choiceTextArea) {
                                        choiceTextArea.value = choice.text || '';
                                    }
                                    if (choiceCorrectInput && choice.checked !== undefined) {
                                        choiceCorrectInput.checked = choice.checked;
                                    }
                                }
                            });
                        }
                        
                        // Set guide answer notes (optional)
                        const guideAnswerNotesTextarea = sectionEl.querySelector('.guide-answer-notes');
                        if (guideAnswerNotesTextarea) {
                            guideAnswerNotesTextarea.value = sectionData.data.guide_answer || '';
                        }
                        
                        // Set correct answer based on question type
                        setTimeout(() => {
                            // Attach listeners for real-time updates
                            attachChoiceListeners(sectionEl);
                            
                            if (questionType === 'multiple_choice') {
                                // Update radio buttons first
                                updateCorrectAnswerRadios(sectionEl);
                                // Then set the value from new 'value' field or old 'guide_answer' field
                                if (sectionData.data.value !== undefined) {
                                    const correctRadio = sectionEl.querySelector(`.choice-correct-radio[value="${sectionData.data.value}"]`);
                                    if (correctRadio) {
                                        correctRadio.checked = true;
                                    }
                                } else if (sectionData.data.guide_answer) {
                                    // Backward compatibility: old guide_answer with choice ID
                            const correctAnswerSelect = sectionEl.querySelector('.correct-answer-select');
                                    if (correctAnswerSelect) {
                                updateCorrectAnswerOptions(correctAnswerSelect);
                                correctAnswerSelect.value = sectionData.data.guide_answer;
                                    }
                                }
                            } else if (questionType === 'checkbox') {
                                // Restore from new 'values' array
                                if (sectionData.data.values && Array.isArray(sectionData.data.values)) {
                                    const choicesList = sectionEl.querySelector('[id^="choices-list-"]');
                                    if (choicesList) {
                                        const choiceItems = choicesList.querySelectorAll('.choice-item');
                                        choiceItems.forEach((choiceItem, index) => {
                                            const correctCheckbox = choiceItem.querySelector('.choice-correct');
                                            if (correctCheckbox && sectionData.data.values[index] !== undefined) {
                                                correctCheckbox.checked = sectionData.data.values[index];
                                            }
                                        });
                                    }
                                }
                                updateCheckboxSummary(sectionEl);
                            }
                        }, 50);
                    } else {
                        // Free form - fill guide answer
                        const guideAnswerTextarea = sectionEl.querySelector('#guide-answer-container textarea');
                        if (guideAnswerTextarea) {
                            guideAnswerTextarea.value = sectionData.data.guide_answer || '';
                        }
                    }
                    
                    // Find Guide PDF Page field by label
                    setFieldValue(sectionEl, 'Guide PDF Page', sectionData.data.guide_pdf_page || '');
                    setFieldValue(sectionEl, 'Related Question', sectionData.data.related_question || '');
                    
                    // Fill images using label-based selectors
                    const questionImagesGroup = findFormGroupByLabel(sectionEl, 'Question Images');
                    const answerImagesGroup = findFormGroupByLabel(sectionEl, 'Answer Images');
                    if (questionImagesGroup) {
                        fillBboxGroup(questionImagesGroup, sectionData.data.question_images || []);
                    }
                    if (answerImagesGroup) {
                        fillBboxGroup(answerImagesGroup, sectionData.data.guide_answer_images || []);
                    }
                    
                    // Re-attach previews and ensure proper direction
                    setTimeout(() => {
                        attachPreviews(sectionEl);
                        applyFontSettings(sectionEl);
                        attachBboxValidation(sectionEl);
                        
                        // Update direction buttons
                        const dirBtns = sectionEl.querySelectorAll('.dir-btn');
                        dirBtns.forEach(btn => {
                            const textarea = btn.closest('.text-field-container')?.querySelector('textarea');
                            if (textarea) {
                                const isLTR = textarea.hasAttribute('data-ltr');
                                btn.textContent = isLTR ? 'RTL' : 'LTR';
                            }
                        });
                    }, 100);
                    
                } else if (sectionData.type === 'content') {
                    // Replace content section data using label-based selectors
                    const sectionTitleInput = findFieldByLabel(sectionEl, 'Section Title');
                    if (sectionTitleInput) {
                        sectionTitleInput.value = sectionData.data.section_title || '';
                    }
                    
                    const sectionTextTextarea = findFieldByLabel(sectionEl, 'Content', 'textarea');
                    if (sectionTextTextarea) {
                        sectionTextTextarea.value = sectionData.data.text || '';
                    }
                    
                    // Fill images using label-based selector
                    const imagesGroup = findFormGroupByLabel(sectionEl, 'Section Images');
                    if (imagesGroup) {
                        fillBboxGroup(imagesGroup, sectionData.data.images || []);
                    }
                    
                    // Re-attach previews and ensure proper direction
                    setTimeout(() => {
                        attachPreviews(sectionEl);
                        applyFontSettings(sectionEl);
                        attachBboxValidation(sectionEl);
                        
                        // Update direction buttons
                        const dirBtns = sectionEl.querySelectorAll('.dir-btn');
                        dirBtns.forEach(btn => {
                            const textarea = btn.closest('.text-field-container')?.querySelector('textarea');
                            if (textarea) {
                                const isLTR = textarea.hasAttribute('data-ltr');
                                btn.textContent = isLTR ? 'RTL' : 'LTR';
                            }
                        });
                    }, 100);
                }
                
                // Record action for undo/redo (after section is replaced)
                // Save the pasted state (current state after pasting) for redo
                const pastedState = sectionEl.cloneNode(true);
                // Record the actual sectionEl element, not a clone
                recordFormAction({
                    type: ACTION_TYPES.PASTE,
                    pastedElement: sectionEl,
                    pastedState: pastedState, // Save the pasted content state for redo
                    oldElement: oldSectionState, // Save the old content state for undo
                    parent: container,
                    nextSibling: nextSibling,
                    containerId: containerId,
                    updateNumbers: false
                });
                
                markFormAsChanged();
                triggerAutoSave();
                
                // Visual feedback
                const pasteBtn = button;
                const originalIcon = pasteBtn.innerHTML;
                pasteBtn.innerHTML = '<i class="fas fa-check"></i>';
                pasteBtn.classList.remove('paste-replace-btn');
                pasteBtn.style.background = '#28a745';
                setTimeout(() => {
                    pasteBtn.innerHTML = originalIcon;
                    pasteBtn.classList.add('paste-replace-btn');
                    pasteBtn.style.background = '';
                }, 1200);
                
                
            } catch (e) {
                console.error('Failed to paste into section:', e);
                alert('Failed to paste into section: ' + e.message);
            }
        }

        // Paste section at the end of the list
        function pasteSectionAtEnd(expectedType) {
            try {
                const text = prompt('Paste section JSON here:');
                if (!text || !text.trim()) return;
                
                let sectionData;
                try {
                    sectionData = JSON.parse(text);
                } catch (e) {
                    alert('Pasted content is not valid JSON.');
                    return;
                }
                
                if (!sectionData.type || !sectionData.data) {
                    alert('Invalid section JSON format. Please copy from a section copy button.');
                    return;
                }
                
                // Verify we're pasting to the right place
                if (expectedType === 'content' && sectionData.type !== 'content') {
                    alert('This appears to be a question. Please paste it in the Questions tab.');
                    return;
                }
                if (expectedType === 'question' && sectionData.type !== 'question') {
                    alert('This appears to be a content section. Please paste it in the Content tab.');
                    return;
                }
                
                if (sectionData.type === 'question') {
                    // Create new question and populate it - use label-based selectors
                    const container = document.getElementById('questions_container');
                    addQuestion();
                    const newQuestion = container.lastElementChild;
                    
                    // Fill in the data using label-based selectors
                    const questionIdInput = findFieldByLabel(newQuestion, 'Question ID');
                    if (questionIdInput) {
                        questionIdInput.value = sectionData.data.id || '';
                    }
                    
                    
                    const questionTypeSelect = findFieldByLabel(newQuestion, 'Question Type', 'select');
                    const questionType = sectionData.data.question_type || 'free_form';
                    if (questionTypeSelect) {
                        questionTypeSelect.value = questionType;
                        // Trigger toggle to show/hide appropriate fields
                        toggleQuestionType(questionTypeSelect);
                    }
                    
                    const setupTextTextarea = findFieldByLabel(newQuestion, 'Set-up Text', 'textarea');
                    if (setupTextTextarea) {
                        setupTextTextarea.value = sectionData.data.set_up_text || '';
                    }
                    
                    const questionTextTextarea = findFieldByLabel(newQuestion, 'Question Text', 'textarea');
                    if (questionTextTextarea) {
                        questionTextTextarea.value = sectionData.data.question_text || '';
                    }
                    
                    // Handle guide answer or choices based on question type
                    if ((questionType === 'multiple_choice' || questionType === 'checkbox') && sectionData.data.choices) {
                        // Fill choices
                        const choicesList = newQuestion.querySelector('[id^="choices-list-"]');
                        if (choicesList) {
                            choicesList.innerHTML = '';
                            sectionData.data.choices.forEach((choice) => {
                                addChoice(choicesList.parentElement.querySelector('.add-btn'), 'end', questionType);
                                const lastChoice = choicesList.lastElementChild;
                                if (lastChoice) {
                                    const choiceIdInput = lastChoice.querySelector('.choice-id');
                                    const choiceTextArea = lastChoice.querySelector('.choice-text');
                                    const choiceCorrectInput = lastChoice.querySelector('.choice-correct');
                                    if (choiceIdInput) {
                                        choiceIdInput.value = choice.id || '';
                                        // Update header to reflect the ID
                                        updateChoiceHeader(choiceIdInput);
                                    }
                                    if (choiceTextArea) {
                                        choiceTextArea.value = choice.text || '';
                                    }
                                    if (choiceCorrectInput && choice.checked !== undefined) {
                                        choiceCorrectInput.checked = choice.checked;
                                    }
                                }
                            });
                        }
                        // Set correct answer AFTER choices are populated and dropdown is updated
                        setTimeout(() => {
                            const correctAnswerSelect = newQuestion.querySelector('.correct-answer-select');
                            if (correctAnswerSelect && sectionData.data.guide_answer) {
                                // Update dropdown options first
                                updateCorrectAnswerOptions(correctAnswerSelect);
                                // Then set the value
                                correctAnswerSelect.value = sectionData.data.guide_answer;
                            }
                        }, 50);
                    } else {
                        // Free form - fill guide answer
                        const guideAnswerTextarea = newQuestion.querySelector('#guide-answer-container textarea');
                        if (guideAnswerTextarea) {
                            guideAnswerTextarea.value = sectionData.data.guide_answer || '';
                        }
                    }
                    
                    // Find Guide PDF Page field by label
                    const guidePdfPageInput = findFieldByLabel(newQuestion, 'Guide PDF Page');
                    if (guidePdfPageInput) {
                        guidePdfPageInput.value = sectionData.data.guide_pdf_page || '';
                    }
                    
                    // Find related question field by label
                    const relatedQuestionInput = findFieldByLabel(newQuestion, 'Related Question');
                    if (relatedQuestionInput) {
                        relatedQuestionInput.value = sectionData.data.related_question || '';
                    }
                    
                    // Fill images using label-based selectors
                    const questionImagesGroup = findFormGroupByLabel(newQuestion, 'Question Images');
                    const answerImagesGroup = findFormGroupByLabel(newQuestion, 'Answer Images');
                    if (questionImagesGroup) {
                        fillBboxGroup(questionImagesGroup, sectionData.data.question_images || []);
                    }
                    if (answerImagesGroup) {
                        fillBboxGroup(answerImagesGroup, sectionData.data.guide_answer_images || []);
                    }
                    
                    // Re-attach previews and ensure proper direction
                    setTimeout(() => {
                        attachPreviews(newQuestion);
                        attachBboxValidation(newQuestion);
                        
                        // Update direction buttons
                        const dirBtns = newQuestion.querySelectorAll('.dir-btn');
                        dirBtns.forEach(btn => {
                            const textarea = btn.closest('.text-field-container')?.querySelector('textarea');
                            if (textarea) {
                                const isLTR = textarea.hasAttribute('data-ltr');
                                btn.textContent = isLTR ? 'RTL' : 'LTR';
                            }
                        });
                    }, 100);
                    
                    // Record action for undo/redo (after element is fully populated and added to DOM)
                    recordFormAction({
                        type: ACTION_TYPES.PASTE_QUESTION,
                        pastedElement: newQuestion,
                        parent: container,
                        nextSibling: null,
                        containerId: 'questions_container',
                        updateNumbers: true
                    });
                    
                } else if (sectionData.type === 'content') {
                    // Create new content section and populate it using label-based selectors
                    addContentSection();
                    const container = document.getElementById('content_sections_container');
                    const newSection = container.lastElementChild;
                    
                    // Fill in the data using label-based selectors
                    const sectionTitleInput = findFieldByLabel(newSection, 'Section Title');
                    if (sectionTitleInput) {
                        sectionTitleInput.value = sectionData.data.section_title || '';
                    }
                    
                    const sectionTextTextarea = findFieldByLabel(newSection, 'Content', 'textarea');
                    if (sectionTextTextarea) {
                        sectionTextTextarea.value = sectionData.data.text || '';
                    }
                    
                    // Fill images using label-based selector
                    const imagesGroup = findFormGroupByLabel(newSection, 'Section Images');
                    if (imagesGroup) {
                        fillBboxGroup(imagesGroup, sectionData.data.images || []);
                    }
                    
                    // Re-attach previews and ensure proper direction
                    setTimeout(() => {
                        attachPreviews(newSection);
                        attachBboxValidation(newSection);
                        
                        // Update direction buttons
                        const dirBtns = newSection.querySelectorAll('.dir-btn');
                        dirBtns.forEach(btn => {
                            const textarea = btn.closest('.text-field-container')?.querySelector('textarea');
                            if (textarea) {
                                const isLTR = textarea.hasAttribute('data-ltr');
                                btn.textContent = isLTR ? 'RTL' : 'LTR';
                            }
                        });
                    }, 100);
                    
                    // Record action for undo/redo (after element is fully populated and added to DOM)
                    recordFormAction({
                        type: ACTION_TYPES.PASTE_SECTION,
                        pastedElement: newSection,
                        parent: container,
                        nextSibling: null,
                        containerId: 'content_sections_container',
                        updateNumbers: true
                    });
                }
                
                markFormAsChanged();
                triggerAutoSave();
                
            } catch (e) {
                console.error('Failed to paste section:', e);
                alert('Failed to paste section: ' + e.message);
            }
        }

        function addLessonStandard() {
            const container = document.getElementById('lesson_standards');
            const newItem = document.createElement('div');
            newItem.className = 'array-item';
            newItem.innerHTML = `
                <input type="text" placeholder="e.g., CCSS.MATH.CONTENT.8.G.A.1" data-ltr="true">
                <div class="row-actions">
                    <button class="add-bbox-btn" onclick="addLessonStandardBefore(this)" title="Add Standard Before">
                        <i class="fas fa-plus"></i> Before
                    </button>
                    <button class="add-bbox-btn" onclick="addLessonStandardAfter(this)" title="Add Standard After">
                        <i class="fas fa-plus"></i> After
                    </button>
                    <button class="reorder-btn" onclick="moveItemUp(this)" title="Move Up"><i class="fas fa-arrow-up"></i></button>
                    <button class="reorder-btn" onclick="moveItemDown(this)" title="Move Down"><i class="fas fa-arrow-down"></i></button>
                    <button class="remove-btn" onclick="removeArrayItem(this)" title="Remove this standard"></button>
                </div>
            `;
            
            container.appendChild(newItem);
            
            // Record action for undo/redo (after adding to DOM so we have the actual element)
            recordFormAction({
                type: ACTION_TYPES.ADD_ITEM,
                element: newItem,
                parent: container,
                nextSibling: null,
                containerId: 'lesson_standards',
                updateNumbers: false
            });
            // Ensure the new lesson standard field starts with LTR (English text)
            const newInput = newItem.querySelector('input');
            if (newInput) {
                newInput.setAttribute('dir', 'ltr');
                // CSS will handle the styling based on data-ltr attribute
            }
        }

        function addTerminology() {
            const container = document.getElementById('terminology');
            const newItem = document.createElement('div');
            newItem.className = 'array-item';
            newItem.innerHTML = `
                <span class="input-label">Input Markdown</span>
                <input type="text" placeholder="e.g., Parallel Lines">
                <div class="row-actions">
                    <button class="add-bbox-btn" onclick="addTerminologyBefore(this)" title="Add Term Before">
                        <i class="fas fa-plus"></i> Before
                    </button>
                    <button class="add-bbox-btn" onclick="addTerminologyAfter(this)" title="Add Term After">
                        <i class="fas fa-plus"></i> After
                    </button>
                    <button class="reorder-btn" onclick="moveItemUp(this)" title="Move Up"><i class="fas fa-arrow-up"></i></button>
                    <button class="reorder-btn" onclick="moveItemDown(this)" title="Move Down"><i class="fas fa-arrow-down"></i></button>
                    <button class="remove-btn" onclick="removeArrayItem(this)" title="Remove this term"></button>
                </div>
            `;
            
            container.appendChild(newItem);
            
            // Record action for undo/redo (after adding to DOM so we have the actual element)
            recordFormAction({
                type: ACTION_TYPES.ADD_ITEM,
                element: newItem,
                parent: container,
                nextSibling: null,
                containerId: 'terminology',
                updateNumbers: false
            });
            // Ensure the new terminology field starts with RTL
            const newInput = newItem.querySelector('input');
            if (newInput) {
                newInput.setAttribute('dir', 'rtl');
                // CSS will handle the styling (RTL by default)
            }
            // Attach preview to the new terminology input
            attachPreviews(newItem);
            applyFontSettings(newItem);
        }

        // Functions to add lesson standards before/after current item
        function addLessonStandardBefore(button) {
            const currentItem = button.closest('.array-item');
            const container = currentItem ? currentItem.parentElement : null;
            if (!currentItem || !container) return;
            
            const newItem = document.createElement('div');
            newItem.className = 'array-item';
            newItem.innerHTML = `
                <input type="text" placeholder="e.g., CCSS.MATH.CONTENT.8.G.A.1" data-ltr="true">
                <div class="row-actions">
                    <button class="add-bbox-btn" onclick="addLessonStandardBefore(this)" title="Add Standard Before">
                        <i class="fas fa-plus"></i> Before
                    </button>
                    <button class="add-bbox-btn" onclick="addLessonStandardAfter(this)" title="Add Standard After">
                        <i class="fas fa-plus"></i> After
                    </button>
                    <button class="reorder-btn" onclick="moveItemUp(this)" title="Move Up"><i class="fas fa-arrow-up"></i></button>
                    <button class="reorder-btn" onclick="moveItemDown(this)" title="Move Down"><i class="fas fa-arrow-down"></i></button>
                    <button class="remove-btn" onclick="removeArrayItem(this)" title="Remove this standard"></button>
                </div>
            `;
            
            container.insertBefore(newItem, currentItem);
            
            // Record action for undo/redo (after adding to DOM so we have the actual element)
            // Record newItem.nextSibling (what comes after the new item) for correct redo placement
            recordFormAction({
                type: ACTION_TYPES.ADD_ITEM,
                element: newItem,
                parent: container,
                nextSibling: newItem.nextSibling,
                containerId: 'lesson_standards',
                updateNumbers: false
            });
            // Ensure the new lesson standard field starts with LTR (English text)
            const newInput = newItem.querySelector('input');
            if (newInput) {
                newInput.setAttribute('dir', 'ltr');
            }
        }

        function addLessonStandardAfter(button) {
            const currentItem = button.closest('.array-item');
            const container = currentItem ? currentItem.parentElement : null;
            if (!currentItem || !container) return;
            
            const newItem = document.createElement('div');
            newItem.className = 'array-item';
            newItem.innerHTML = `
                <input type="text" placeholder="e.g., CCSS.MATH.CONTENT.8.G.A.1" data-ltr="true">
                <div class="row-actions">
                    <button class="add-bbox-btn" onclick="addLessonStandardBefore(this)" title="Add Standard Before">
                        <i class="fas fa-plus"></i> Before
                    </button>
                    <button class="add-bbox-btn" onclick="addLessonStandardAfter(this)" title="Add Standard After">
                        <i class="fas fa-plus"></i> After
                    </button>
                    <button class="reorder-btn" onclick="moveItemUp(this)" title="Move Up"><i class="fas fa-arrow-up"></i></button>
                    <button class="reorder-btn" onclick="moveItemDown(this)" title="Move Down"><i class="fas fa-arrow-down"></i></button>
                    <button class="remove-btn" onclick="removeArrayItem(this)" title="Remove this standard"></button>
                </div>
            `;
            
            container.insertBefore(newItem, currentItem.nextSibling);
            
            // Record action for undo/redo (after adding to DOM so we have the actual element)
            // Record newItem.nextSibling (what comes after the new item) for correct redo placement
            recordFormAction({
                type: ACTION_TYPES.ADD_ITEM,
                element: newItem,
                parent: container,
                nextSibling: newItem.nextSibling,
                containerId: 'lesson_standards',
                updateNumbers: false
            });
            // Ensure the new lesson standard field starts with LTR (English text)
            const newInput = newItem.querySelector('input');
            if (newInput) {
                newInput.setAttribute('dir', 'ltr');
            }
        }

        // Functions to add terminology before/after current item
        function addTerminologyBefore(button) {
            const currentItem = button.closest('.array-item');
            const container = currentItem ? currentItem.parentElement : null;
            if (!currentItem || !container) return;
            
            const newItem = document.createElement('div');
            newItem.className = 'array-item';
            newItem.innerHTML = `
                <span class="input-label">Input Markdown</span>
                <input type="text" placeholder="e.g., Parallel Lines">
                <div class="row-actions">
                    <button class="add-bbox-btn" onclick="addTerminologyBefore(this)" title="Add Term Before">
                        <i class="fas fa-plus"></i> Before
                    </button>
                    <button class="add-bbox-btn" onclick="addTerminologyAfter(this)" title="Add Term After">
                        <i class="fas fa-plus"></i> After
                    </button>
                    <button class="reorder-btn" onclick="moveItemUp(this)" title="Move Up"><i class="fas fa-arrow-up"></i></button>
                    <button class="reorder-btn" onclick="moveItemDown(this)" title="Move Down"><i class="fas fa-arrow-down"></i></button>
                    <button class="remove-btn" onclick="removeArrayItem(this)" title="Remove this term"></button>
                </div>
            `;
            
            container.insertBefore(newItem, currentItem);
            
            // Record action for undo/redo (after adding to DOM so we have the actual element)
            // Record newItem.nextSibling (what comes after the new item) for correct redo placement
            recordFormAction({
                type: ACTION_TYPES.ADD_ITEM,
                element: newItem,
                parent: container,
                nextSibling: newItem.nextSibling,
                containerId: 'terminology',
                updateNumbers: false
            });
            // Ensure the new terminology field starts with RTL
            const newInput = newItem.querySelector('input');
            if (newInput) {
                newInput.setAttribute('dir', 'rtl');
            }
            // Attach preview to the new terminology input
            attachPreviews(newItem);
            applyFontSettings(newItem);
        }

        function addTerminologyAfter(button) {
            const currentItem = button.closest('.array-item');
            const container = currentItem ? currentItem.parentElement : null;
            if (!currentItem || !container) return;
            
            const newItem = document.createElement('div');
            newItem.className = 'array-item';
            newItem.innerHTML = `
                <span class="input-label">Input Markdown</span>
                <input type="text" placeholder="e.g., Parallel Lines">
                <div class="row-actions">
                    <button class="add-bbox-btn" onclick="addTerminologyBefore(this)" title="Add Term Before">
                        <i class="fas fa-plus"></i> Before
                    </button>
                    <button class="add-bbox-btn" onclick="addTerminologyAfter(this)" title="Add Term After">
                        <i class="fas fa-plus"></i> After
                    </button>
                    <button class="reorder-btn" onclick="moveItemUp(this)" title="Move Up"><i class="fas fa-arrow-up"></i></button>
                    <button class="reorder-btn" onclick="moveItemDown(this)" title="Move Down"><i class="fas fa-arrow-down"></i></button>
                    <button class="remove-btn" onclick="removeArrayItem(this)" title="Remove this term"></button>
                </div>
            `;
            
            container.insertBefore(newItem, currentItem.nextSibling);
            
            // Record action for undo/redo (after adding to DOM so we have the actual element)
            // Record newItem.nextSibling (what comes after the new item) for correct redo placement
            recordFormAction({
                type: ACTION_TYPES.ADD_ITEM,
                element: newItem,
                parent: container,
                nextSibling: newItem.nextSibling,
                containerId: 'terminology',
                updateNumbers: false
            });
            // Ensure the new terminology field starts with RTL
            const newInput = newItem.querySelector('input');
            if (newInput) {
                newInput.setAttribute('dir', 'rtl');
            }
            // Attach preview to the new terminology input
            attachPreviews(newItem);
            applyFontSettings(newItem);
        }


        // Flag to prevent redundant updates during bulk operations
        let isBulkOperation = false;

        function addContentSection() {
            const container = document.getElementById('content_sections_container');
            const sectionCount = container.querySelectorAll(':scope > .array-item').length + 1;
            const newSection = document.createElement('div');
            newSection.className = 'array-item';
            newSection.innerHTML = getContentSectionHTML(sectionCount);
            
            container.appendChild(newSection);
            
            // Record action for undo/redo (after adding to DOM so we have the actual element)
            recordFormAction({
                type: ACTION_TYPES.ADD_ITEM,
                element: newSection,
                parent: container,
                nextSibling: null,
                containerId: 'content_sections_container',
                updateNumbers: true
            });
            // Ensure the new section textarea starts with RTL (content is RTL)
            const newTextarea = newSection.querySelector('textarea');
            if (newTextarea) {
                newTextarea.setAttribute('dir', 'rtl');
                // CSS will handle the styling (RTL by default)
            }
            // Ensure the section title starts with RTL (Arabic content)
            const newTitleInput = newSection.querySelector('input[placeholder="Section title"]');
            if (newTitleInput) {
                newTitleInput.setAttribute('dir', 'rtl');
                // CSS will handle the styling (RTL by default)
            }
            attachPreviews(newSection);
            
            // Apply font settings to new section
            applyFontSettings(newSection);
            
            // Attach bbox validation to all bbox containers in this new section
            attachBboxValidation(newSection);
            
            // Ensure the direction button shows "LTR" since content is RTL by default
            const dirBtn = newSection.querySelector('.dir-btn');
            if (dirBtn) {
                dirBtn.textContent = 'LTR';
            }
            
            // Update all section numbers to ensure they're sequential (skip if bulk operation)
            if (!isBulkOperation) {
                updateContentSectionNumbers();
            }
            
            // Track content section addition
            const stats = getFormStats();
            trackEvent('content_section_added', {
                total_questions: stats.totalQuestions,
                total_content_sections: stats.totalContentSections
            });
        }

        function addContentBbox(button) {
            const container = button.previousElementSibling;
            const newItem = document.createElement('div');
            newItem.className = 'array-item';
            newItem.innerHTML = `
                <div class="bbox-inputs">
                    <input type="number" placeholder="Page" class="bbox-page" min="1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    <input type="number" placeholder="X0" class="bbox-x0" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    <input type="number" placeholder="Y0" class="bbox-y0" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    <input type="number" placeholder="X1" class="bbox-x1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    <input type="number" placeholder="Y1" class="bbox-y1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                </div>
                <div class="row-actions">
                    <button class="add-bbox-btn" onclick="addContentBboxBefore(this)" title="Add BBox Before">
                        <i class="fas fa-plus"></i> Before
                    </button>
                    <button class="add-bbox-btn" onclick="addContentBboxAfter(this)" title="Add BBox After">
                        <i class="fas fa-plus"></i> After
                    </button>
                    <button class="reorder-btn" onclick="moveItemUp(this)" title="Move Up"><i class="fas fa-arrow-up"></i></button>
                    <button class="reorder-btn" onclick="moveItemDown(this)" title="Move Down"><i class="fas fa-arrow-down"></i></button>
                    <button class="add-btn" onclick="openBboxDrawer(this)" title="Open PDF viewer to draw bounding box"><i class="fas fa-pen-square"></i> Draw</button>
                    <button class="add-btn" onclick="pasteBboxJson(this)" title="Paste bounding box coordinates from clipboard"><i class="fas fa-paste"></i> Paste</button>
                    <button class="add-btn" onclick="copyBboxJson(this)" title="Copy bounding box coordinates to clipboard"><i class="fas fa-copy"></i> Copy</button>
                    <button class="duplicate-btn" onclick="duplicateBbox(this)" title="Duplicate BBox"><i class="fas fa-clone"></i></button>
                    <button class="remove-btn" onclick="removeArrayItem(this)"></button>
                </div>
            `;
            container.appendChild(newItem);
            
            // Record action for undo/redo (after adding to DOM so we have the actual element)
            recordFormAction({
                type: ACTION_TYPES.ADD_ITEM,
                element: newItem,
                parent: container,
                nextSibling: null,
                containerId: null,
                updateNumbers: false
            });
            
            // Attach bbox validation to the new item
            const coordinateInputs = newItem.querySelectorAll('.bbox-x0, .bbox-y0, .bbox-x1, .bbox-y1');
            coordinateInputs.forEach(input => {
                const handler = function() {
                    validateAndNormalizeBbox(newItem);
                };
                input.addEventListener('blur', handler);
                input.__bboxValidationHandler = handler;
            });
            
            // Track content image addition
            trackEvent('image_added', {
                image_type: 'content_section'
            });
        }

        function addContentImage(button) {
            const container = button.previousElementSibling;
            const newItem = document.createElement('div');
            newItem.className = 'array-item';
            newItem.innerHTML = `
                <div class="bbox-inputs">
                    <input type="number" placeholder="Page" class="bbox-page" min="1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    <input type="number" placeholder="X0" class="bbox-x0" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    <input type="number" placeholder="Y0" class="bbox-y0" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    <input type="number" placeholder="X1" class="bbox-x1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    <input type="number" placeholder="Y1" class="bbox-y1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                </div>
                <div class="row-actions">
                    <button class="reorder-btn" onclick="moveItemUp(this)" title="Move Up"><i class="fas fa-arrow-up"></i></button>
                    <button class="reorder-btn" onclick="moveItemDown(this)" title="Move Down"><i class="fas fa-arrow-down"></i></button>
                    <button class="add-bbox-btn" onclick="addContentImageBefore(this)" title="Add Image Before">
                        <i class="fas fa-plus"></i> Before
                    </button>
                    <button class="add-bbox-btn" onclick="addContentImageAfter(this)" title="Add Image After">
                        <i class="fas fa-plus"></i> After
                    </button>
                    <button class="add-btn" onclick="openBboxDrawer(this)" title="Open PDF viewer to draw bounding box"><i class="fas fa-pen-square"></i> Draw</button>
                    <button class="add-btn" onclick="pasteBboxJson(this)" title="Paste bounding box coordinates from clipboard"><i class="fas fa-paste"></i> Paste</button>
                    <button class="add-btn" onclick="copyBboxJson(this)" title="Copy bounding box coordinates to clipboard"><i class="fas fa-copy"></i> Copy</button>
                    <button class="duplicate-btn" onclick="duplicateBbox(this)" title="Duplicate Image"><i class="fas fa-clone"></i></button>
                    <button class="remove-btn" onclick="removeArrayItem(this)"></button>
                </div>
            `;
            container.appendChild(newItem);
            
            // Record action for undo/redo (after adding to DOM so we have the actual element)
            recordFormAction({
                type: ACTION_TYPES.ADD_ITEM,
                element: newItem,
                parent: container,
                nextSibling: null,
                containerId: null,
                updateNumbers: false
            });
            
            // Attach bbox validation to the new item
            const coordinateInputs = newItem.querySelectorAll('.bbox-x0, .bbox-y0, .bbox-x1, .bbox-y1');
            coordinateInputs.forEach(input => {
                const handler = function() {
                    validateAndNormalizeBbox(newItem);
                };
                input.addEventListener('blur', handler);
                input.__bboxValidationHandler = handler;
            });
        }


        function addQuestionImage(button) {
            const container = button.previousElementSibling;
            const newItem = document.createElement('div');
            newItem.className = 'array-item';
            newItem.innerHTML = `
                <div class="bbox-inputs">
                    <input type="number" placeholder="Page" class="bbox-page" min="1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    <input type="number" placeholder="X0" class="bbox-x0" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    <input type="number" placeholder="Y0" class="bbox-y0" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    <input type="number" placeholder="X1" class="bbox-x1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    <input type="number" placeholder="Y1" class="bbox-y1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                </div>
                <div class="row-actions">
                    <button class="reorder-btn" onclick="moveItemUp(this)" title="Move Up"><i class="fas fa-arrow-up"></i></button>
                    <button class="reorder-btn" onclick="moveItemDown(this)" title="Move Down"><i class="fas fa-arrow-down"></i></button>
                    <button class="add-bbox-btn" onclick="addQuestionImageBefore(this)" title="Add Image Before">
                        <i class="fas fa-plus"></i> Before
                    </button>
                    <button class="add-bbox-btn" onclick="addQuestionImageAfter(this)" title="Add Image After">
                        <i class="fas fa-plus"></i> After
                    </button>
                    <button class="add-btn" onclick="openBboxDrawer(this)" title="Open PDF viewer to draw bounding box"><i class="fas fa-pen-square"></i> Draw</button>
                    <button class="add-btn" onclick="pasteBboxJson(this)" title="Paste bounding box coordinates from clipboard"><i class="fas fa-paste"></i> Paste</button>
                    <button class="add-btn" onclick="copyBboxJson(this)" title="Copy bounding box coordinates to clipboard"><i class="fas fa-copy"></i> Copy</button>
                    <button class="duplicate-btn" onclick="duplicateBbox(this)" title="Duplicate Image"><i class="fas fa-clone"></i></button>
                    <button class="remove-btn" onclick="removeArrayItem(this)"></button>
                </div>
            `;
            container.appendChild(newItem);
            
            // Record action for undo/redo (after adding to DOM so we have the actual element)
            recordFormAction({
                type: ACTION_TYPES.ADD_ITEM,
                element: newItem,
                parent: container,
                nextSibling: null,
                containerId: null,
                updateNumbers: false
            });
            
            // Attach bbox validation to the new item
            const coordinateInputs = newItem.querySelectorAll('.bbox-x0, .bbox-y0, .bbox-x1, .bbox-y1');
            coordinateInputs.forEach(input => {
                const handler = function() {
                    validateAndNormalizeBbox(newItem);
                };
                input.addEventListener('blur', handler);
                input.__bboxValidationHandler = handler;
            });
            
            // Track question image addition
            trackEvent('image_added', {
                image_type: 'question'
            });
        }

        function addAnswerBbox(button) {
            const container = button.previousElementSibling;
            const newItem = document.createElement('div');
            newItem.className = 'array-item';
            newItem.innerHTML = `
                <div class="bbox-inputs">
                    <input type="number" placeholder="Page" class="bbox-page" min="1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    <input type="number" placeholder="X0" class="bbox-x0" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    <input type="number" placeholder="Y0" class="bbox-y0" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    <input type="number" placeholder="X1" class="bbox-x1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    <input type="number" placeholder="Y1" class="bbox-y1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                </div>
                <div class="row-actions">
                    <button class="add-bbox-btn" onclick="addAnswerBboxBefore(this)" title="Add BBox Before">
                        <i class="fas fa-plus"></i> Before
                    </button>
                    <button class="add-bbox-btn" onclick="addAnswerBboxAfter(this)" title="Add BBox After">
                        <i class="fas fa-plus"></i> After
                    </button>
                    <button class="reorder-btn" onclick="moveItemUp(this)" title="Move Up"><i class="fas fa-arrow-up"></i></button>
                    <button class="reorder-btn" onclick="moveItemDown(this)" title="Move Down"><i class="fas fa-arrow-down"></i></button>
                    <button class="add-btn" onclick="openBboxDrawer(this)" title="Open PDF viewer to draw bounding box"><i class="fas fa-pen-square"></i> Draw</button>
                    <button class="add-btn" onclick="pasteBboxJson(this)" title="Paste bounding box coordinates from clipboard"><i class="fas fa-paste"></i> Paste</button>
                    <button class="add-btn" onclick="copyBboxJson(this)" title="Copy bounding box coordinates to clipboard"><i class="fas fa-copy"></i> Copy</button>
                    <button class="duplicate-btn" onclick="duplicateBbox(this)" title="Duplicate BBox"><i class="fas fa-clone"></i></button>
                    <button class="remove-btn" onclick="removeArrayItem(this)"></button>
                </div>
            `;
            container.appendChild(newItem);
            
            // Record action for undo/redo (after adding to DOM so we have the actual element)
            recordFormAction({
                type: ACTION_TYPES.ADD_ITEM,
                element: newItem,
                parent: container,
                nextSibling: null,
                containerId: null,
                updateNumbers: false
            });
            
            // Attach bbox validation to the new item
            const coordinateInputs = newItem.querySelectorAll('.bbox-x0, .bbox-y0, .bbox-x1, .bbox-y1');
            coordinateInputs.forEach(input => {
                const handler = function() {
                    validateAndNormalizeBbox(newItem);
                };
                input.addEventListener('blur', handler);
                input.__bboxValidationHandler = handler;
            });
            
            // Track answer image addition
            trackEvent('image_added', {
                image_type: 'answer'
            });
        }

        function addAnswerImage(button) {
            const container = button.previousElementSibling;
            const newItem = document.createElement('div');
            newItem.className = 'array-item';
            newItem.innerHTML = `
                <div class="bbox-inputs">
                    <input type="number" placeholder="Page" class="bbox-page" min="1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    <input type="number" placeholder="X0" class="bbox-x0" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    <input type="number" placeholder="Y0" class="bbox-y0" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    <input type="number" placeholder="X1" class="bbox-x1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    <input type="number" placeholder="Y1" class="bbox-y1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                </div>
                <div class="row-actions">
                    <button class="reorder-btn" onclick="moveItemUp(this)" title="Move Up"><i class="fas fa-arrow-up"></i></button>
                    <button class="reorder-btn" onclick="moveItemDown(this)" title="Move Down"><i class="fas fa-arrow-down"></i></button>
                    <button class="add-bbox-btn" onclick="addAnswerImageBefore(this)" title="Add Image Before">
                        <i class="fas fa-plus"></i> Before
                    </button>
                    <button class="add-bbox-btn" onclick="addAnswerImageAfter(this)" title="Add Image After">
                        <i class="fas fa-plus"></i> After
                    </button>
                    <button class="add-btn" onclick="openBboxDrawer(this)" title="Open PDF viewer to draw bounding box"><i class="fas fa-pen-square"></i> Draw</button>
                    <button class="add-btn" onclick="pasteBboxJson(this)" title="Paste bounding box coordinates from clipboard"><i class="fas fa-paste"></i> Paste</button>
                    <button class="add-btn" onclick="copyBboxJson(this)" title="Copy bounding box coordinates to clipboard"><i class="fas fa-copy"></i> Copy</button>
                    <button class="duplicate-btn" onclick="duplicateBbox(this)" title="Duplicate Image"><i class="fas fa-clone"></i></button>
                    <button class="remove-btn" onclick="removeArrayItem(this)"></button>
                </div>
            `;
            container.appendChild(newItem);
            
            // Record action for undo/redo (after adding to DOM so we have the actual element)
            recordFormAction({
                type: ACTION_TYPES.ADD_ITEM,
                element: newItem,
                parent: container,
                nextSibling: null,
                containerId: null,
                updateNumbers: false
            });
            
            // Attach bbox validation to the new item
            const coordinateInputs = newItem.querySelectorAll('.bbox-x0, .bbox-y0, .bbox-x1, .bbox-y1');
            coordinateInputs.forEach(input => {
                const handler = function() {
                    validateAndNormalizeBbox(newItem);
                };
                input.addEventListener('blur', handler);
                input.__bboxValidationHandler = handler;
            });
            
            // Track answer image addition
            trackEvent('image_added', {
                image_type: 'answer'
            });
        }

        // Functions to add sections before/after current section
        function addContentSectionBefore(button) {
            const currentSection = button.closest('.array-item');
            const container = document.getElementById('content_sections_container');
            if (!currentSection || !container) return;
            
            const sectionCount = container.querySelectorAll(':scope > .array-item').length + 1;
            const newSection = document.createElement('div');
            newSection.className = 'array-item';
            newSection.innerHTML = getContentSectionHTML(sectionCount);
            
            container.insertBefore(newSection, currentSection);
            
            // Record action for undo/redo (after adding to DOM so we have the actual element)
            // Record newSection.nextSibling (what comes after the new section) for correct redo placement
            recordFormAction({
                type: ACTION_TYPES.ADD_ITEM,
                element: newSection,
                parent: container,
                nextSibling: newSection.nextSibling,
                containerId: 'content_sections_container',
                updateNumbers: true
            });
            
            // Initialize the new section
            attachPreviews(newSection);
            applyFontSettings(newSection);
            attachBboxValidation(newSection);
            updateContentSectionNumbers();
        }

        function addContentSectionAfter(button) {
            const currentSection = button.closest('.array-item');
            const container = document.getElementById('content_sections_container');
            if (!currentSection || !container) return;
            
            const sectionCount = container.querySelectorAll(':scope > .array-item').length + 1;
            const newSection = document.createElement('div');
            newSection.className = 'array-item';
            newSection.innerHTML = getContentSectionHTML(sectionCount);
            
            container.insertBefore(newSection, currentSection.nextSibling);
            
            // Record action for undo/redo (after adding to DOM so we have the actual element)
            // Record newSection.nextSibling (what comes after the new section) for correct redo placement
            recordFormAction({
                type: ACTION_TYPES.ADD_ITEM,
                element: newSection,
                parent: container,
                nextSibling: newSection.nextSibling,
                containerId: 'content_sections_container',
                updateNumbers: true
            });
            
            // Initialize the new section
            attachPreviews(newSection);
            applyFontSettings(newSection);
            attachBboxValidation(newSection);
            updateContentSectionNumbers();
        }

        function addQuestionBefore(button) {
            const currentQuestion = button.closest('.array-item');
            const container = document.getElementById('questions_container');
            if (!currentQuestion || !container) return;
            
            const questionCount = container.querySelectorAll(':scope > .array-item').length + 1;
            const newQuestion = document.createElement('div');
            newQuestion.className = 'array-item';
            newQuestion.innerHTML = getQuestionHTML(questionCount);
            
            container.insertBefore(newQuestion, currentQuestion);
            
            // Record action for undo/redo (after adding to DOM so we have the actual element)
            // Record newQuestion.nextSibling (what comes after the new question) for correct redo placement
            recordFormAction({
                type: ACTION_TYPES.ADD_ITEM,
                element: newQuestion,
                parent: container,
                nextSibling: newQuestion.nextSibling,
                containerId: 'questions_container',
                updateNumbers: true
            });
            
            // Initialize the new question
            attachPreviews(newQuestion);
            applyFontSettings(newQuestion);
            attachBboxValidation(newQuestion);
            updateQuestionNumbers();
        }

        function addQuestionAfter(button) {
            const currentQuestion = button.closest('.array-item');
            const container = document.getElementById('questions_container');
            if (!currentQuestion || !container) return;
            
            const questionCount = container.querySelectorAll(':scope > .array-item').length + 1;
            const newQuestion = document.createElement('div');
            newQuestion.className = 'array-item';
            newQuestion.innerHTML = getQuestionHTML(questionCount);
            
            container.insertBefore(newQuestion, currentQuestion.nextSibling);
            
            // Record action for undo/redo (after adding to DOM so we have the actual element)
            // Record newQuestion.nextSibling (what comes after the new question) for correct redo placement
            recordFormAction({
                type: ACTION_TYPES.ADD_ITEM,
                element: newQuestion,
                parent: container,
                nextSibling: newQuestion.nextSibling,
                containerId: 'questions_container',
                updateNumbers: true
            });
            
            // Initialize the new question
            attachPreviews(newQuestion);
            applyFontSettings(newQuestion);
            attachBboxValidation(newQuestion);
            updateQuestionNumbers();
        }

        // Helper function to get HTML for content section (extracted from addContentSection)
        function getContentSectionHTML(sectionCount) {
            return `
                <div class="array-item-header">
                    <h4>Content Section ${sectionCount}</h4>
                    <div class="array-item-header-controls">
                        <button class="add-section-btn" onclick="addContentSectionBefore(this)" title="Add Section Before">
                            <i class="fas fa-plus"></i> Before
                        </button>
                        <button class="add-section-btn" onclick="addContentSectionAfter(this)" title="Add Section After">
                            <i class="fas fa-plus"></i> After
                        </button>
                        <button class="copy-section-btn" onclick="copySection(this)" title="Copy Section">
                            <i class="fas fa-copy"></i>
                        </button>
                        <button class="copy-section-btn paste-replace-btn" onclick="pasteIntoSection(this)" title="Paste & Replace Section">
                            <i class="fas fa-paste"></i>
                        </button>
                        <button class="duplicate-btn" onclick="duplicateSection(this)" title="Duplicate Section">
                            <i class="fas fa-clone"></i>
                        </button>
                        <button class="reorder-btn" onclick="moveItemUp(this)" title="Move Up">
                            <i class="fas fa-arrow-up"></i>
                        </button>
                        <button class="reorder-btn" onclick="moveItemDown(this)" title="Move Down">
                            <i class="fas fa-arrow-down"></i>
                        </button>
                        <button class="collapse-btn" onclick="toggleSectionCollapse(this)" title="Collapse/Expand Section">
                            <i class="fas fa-chevron-down"></i>
                        </button>
                        <button class="remove-btn" onclick="removeArrayItem(this)" title="Remove Section"></button>
                    </div>
                </div>
                
                <div class="section-content">
                <div class="form-group">
                    <label>Section Title</label>
                    <span class="input-label">Input Markdown</span>
                    <div class="text-field-container">
                        <input type="text" placeholder="Section title" title="Optional title for this content section (supports markdown formatting)">
                        <button type="button" class="markdown-btn" onclick="insertBold(this.parentElement.querySelector('input'))" title="Make selected text bold (**text**)">
                            <i class="fas fa-bold"></i>
                        </button>
                        <button type="button" class="markdown-btn" onclick="insertItalic(this.parentElement.querySelector('input'))" title="Make selected text italic (*text*)">
                            <i class="fas fa-italic"></i>
                        </button>
                        <button type="button" class="markdown-btn" onclick="insertInlineLatex(this.parentElement.querySelector('input'))" title="Wrap selection with $ or insert $$">
                            <i class="fas fa-dollar-sign"></i>
                        </button>
                        <button type="button" class="markdown-btn" onclick="removeMarkdownFormatting(this)" title="Undo last markdown formatting operation">
                            <i class="fas fa-undo"></i>
                        </button>
                        <button type="button" class="markdown-btn" onclick="redoMarkdownFormatting(this)" title="Redo last undone markdown formatting operation">
                            <i class="fas fa-redo"></i>
                        </button>
                    </div>
                </div>
                
                <div class="form-group required-field required">
                    <label>Content (Markdown + LaTeX)</label>
                    <div class="text-field-container">
                        <span class="input-label">Input Markdown</span>
                        <textarea placeholder="Enter content with markdown formatting and LaTeX..." title="Main content text supporting markdown and LaTeX math expressions"></textarea>
                        <button type="button" class="markdown-btn" onclick="insertBold(this.parentElement.querySelector('textarea'))" title="Make selected text bold (**text**)">
                            <i class="fas fa-bold"></i>
                        </button>
                        <button type="button" class="markdown-btn" onclick="insertItalic(this.parentElement.querySelector('textarea'))" title="Make selected text italic (*text*)">
                            <i class="fas fa-italic"></i>
                        </button>
                        <button type="button" class="markdown-btn" onclick="insertBulletList(this.parentElement.querySelector('textarea'))" title="Convert line(s) to bullet list (- item)">
                            <i class="fas fa-list-ul"></i>
                        </button>
                        <button type="button" class="markdown-btn" onclick="insertNumberedList(this.parentElement.querySelector('textarea'))" title="Convert line(s) to numbered list (1. item)">
                            <i class="fas fa-list-ol"></i>
                        </button>
                        <button type="button" class="markdown-btn" onclick="insertBlockquote(this.parentElement.querySelector('textarea'))" title="Convert line(s) to blockquote (> text)">
                            <i class="fas fa-quote-right"></i>
                        </button>
                        <button type="button" class="markdown-btn" onclick="insertInlineLatex(this.parentElement.querySelector('textarea'))" title="Wrap selection with $ or insert $$">
                            <i class="fas fa-dollar-sign"></i>
                        </button>
                        <button type="button" class="markdown-btn" onclick="insertBlockLatex(this.parentElement.querySelector('textarea'))" title="Wrap selection with block LaTeX ($$\\n...\\n$$) or insert $$\\n\\n$$">
                            <i class="fas fa-square-root-alt"></i>
                        </button>
                        <button type="button" class="markdown-btn" onclick="removeMarkdownFormatting(this)" title="Undo last markdown formatting operation">
                            <i class="fas fa-undo"></i>
                        </button>
                        <button type="button" class="markdown-btn" onclick="redoMarkdownFormatting(this)" title="Redo last undone markdown formatting operation">
                            <i class="fas fa-redo"></i>
                        </button>
                        <button type="button" class="table-btn" onclick="insertTable(this.parentElement.querySelector('textarea'))" title="Insert a markdown table template">
                            <i class="fas fa-table"></i> Insert Table
                        </button>
                        <button type="button" class="image-btn" onclick="insertImage(this.parentElement.querySelector('textarea'))" title="Insert an image placeholder">
                            <i class="fas fa-image"></i> Insert Image
                        </button>
                        <button type="button" class="dir-btn" onclick="toggleDirection(this.parentElement.querySelector('textarea'))" title="Toggle text direction (LTR/RTL)">LTR</button>
                    </div>
                </div>
                
                <div class="form-group">
                    <label>Section Images</label>
                    <div class="bbox-container">
                        <div class="array-item">
                            <div class="bbox-inputs">
                                <input type="number" placeholder="Page" class="bbox-page" min="1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57" title="PDF page number where this image appears">
                                <input type="number" placeholder="X0" class="bbox-x0" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57" title="Right X coordinate (top-right corner)">
                                <input type="number" placeholder="Y0" class="bbox-y0" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57" title="Top Y coordinate (top-right corner)">
                                <input type="number" placeholder="X1" class="bbox-x1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57" title="Left X coordinate (bottom-left corner)">
                                <input type="number" placeholder="Y1" class="bbox-y1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57" title="Bottom Y coordinate (bottom-left corner)">
                            </div>
                            <div class="row-actions">
                                <button class="reorder-btn" onclick="moveItemUp(this)" title="Move Up"><i class="fas fa-arrow-up"></i></button>
                                <button class="reorder-btn" onclick="moveItemDown(this)" title="Move Down"><i class="fas fa-arrow-down"></i></button>
                                <button class="add-bbox-btn" onclick="addContentImageBefore(this)" title="Add Image Before">
                                    <i class="fas fa-plus"></i> Before
                                </button>
                                <button class="add-bbox-btn" onclick="addContentImageAfter(this)" title="Add Image After">
                                    <i class="fas fa-plus"></i> After
                                </button>
                                <button class="add-btn" onclick="openBboxDrawer(this)" title="Open PDF viewer to draw bounding box"><i class="fas fa-pen-square"></i> Draw</button>
                                <button class="add-btn" onclick="pasteBboxJson(this)" title="Paste bounding box coordinates from clipboard"><i class="fas fa-paste"></i> Paste</button>
                                <button class="add-btn" onclick="copyBboxJson(this)" title="Copy bounding box coordinates to clipboard"><i class="fas fa-copy"></i> Copy</button>
                                <button class="duplicate-btn" onclick="duplicateBbox(this)" title="Duplicate Image"><i class="fas fa-clone"></i></button>
                                <button class="remove-btn" onclick="removeArrayItem(this)"></button>
                            </div>
                        </div>
                    </div>
                    <button class="add-btn" onclick="addContentImage(this)" title="Add a new image bounding box for this content section">
                        <i class="fas fa-plus"></i> Add Image
                    </button>
                </div>
                </div>
            `;
        }

        // Helper function to get HTML for question (extracted from addQuestion)
        function getQuestionHTML(questionCount) {
            return `
                <div class="array-item-header">
                    <h4>Question ${questionCount}</h4>
                    <div class="array-item-header-controls">
                        <button class="add-section-btn" onclick="addQuestionBefore(this)" title="Add Question Before">
                            <i class="fas fa-plus"></i> Before
                        </button>
                        <button class="add-section-btn" onclick="addQuestionAfter(this)" title="Add Question After">
                            <i class="fas fa-plus"></i> After
                        </button>
                        <button class="copy-section-btn" onclick="copySection(this)" title="Copy Question">
                            <i class="fas fa-copy"></i>
                        </button>
                        <button class="copy-section-btn paste-replace-btn" onclick="pasteIntoSection(this)" title="Paste & Replace Question">
                            <i class="fas fa-paste"></i>
                        </button>
                        <button class="duplicate-btn" onclick="duplicateSection(this)" title="Duplicate Question">
                            <i class="fas fa-clone"></i>
                        </button>
                        <button class="reorder-btn" onclick="moveItemUp(this)" title="Move Up">
                            <i class="fas fa-arrow-up"></i>
                        </button>
                        <button class="reorder-btn" onclick="moveItemDown(this)" title="Move Down">
                            <i class="fas fa-arrow-down"></i>
                        </button>
                        <button class="collapse-btn" onclick="toggleSectionCollapse(this)" title="Collapse/Expand Question">
                            <i class="fas fa-chevron-down"></i>
                        </button>
                        <button class="remove-btn" onclick="removeArrayItem(this)" title="Remove Question"></button>
                    </div>
                </div>
                
                <div class="section-content">
                <div class="form-group required-field required">
                    <label>Question ID</label>
                    <input type="text" placeholder="e.g., 1" data-ltr="true" title="Unique identifier for this question (e.g., 1, 2, 3)">
                </div>
                
                <div class="form-group">
                    <label>Question Type</label>
                    <select onchange="toggleQuestionType(this)" title="Select the type of question (affects available fields and validation)">
                        <option value="free_form" selected>Free Form</option>
                        <option value="multiple_choice">Multiple Choice</option>
                        <option value="checkbox">Checkbox</option>
                        <option value="fill_in_the_blanks">Fill in the Blanks</option>
                        <option value="matching">Matching</option>
                        <option value="annotate">Annotate</option>
                        <option value="create_table">Create Table</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label>Set-up Text (Shared across questions)</label>
                    <div class="text-field-container">
                        <span class="input-label">Input Markdown</span>
                        <textarea placeholder="Text shared across multiple questions or required to answer..." title="Context or information shared across multiple questions (supports markdown and LaTeX)"></textarea>
                        <button type="button" class="markdown-btn" onclick="insertBold(this.parentElement.querySelector('textarea'))" title="Make selected text bold (**text**)">
                            <i class="fas fa-bold"></i>
                        </button>
                        <button type="button" class="markdown-btn" onclick="insertItalic(this.parentElement.querySelector('textarea'))" title="Make selected text italic (*text*)">
                            <i class="fas fa-italic"></i>
                        </button>
                        <button type="button" class="markdown-btn" onclick="insertBulletList(this.parentElement.querySelector('textarea'))" title="Convert line(s) to bullet list (- item)">
                            <i class="fas fa-list-ul"></i>
                        </button>
                        <button type="button" class="markdown-btn" onclick="insertNumberedList(this.parentElement.querySelector('textarea'))" title="Convert line(s) to numbered list (1. item)">
                            <i class="fas fa-list-ol"></i>
                        </button>
                        <button type="button" class="markdown-btn" onclick="insertBlockquote(this.parentElement.querySelector('textarea'))" title="Convert line(s) to blockquote (> text)">
                            <i class="fas fa-quote-right"></i>
                        </button>
                        <button type="button" class="markdown-btn" onclick="insertInlineLatex(this.parentElement.querySelector('textarea'))" title="Wrap selection with $ or insert $$">
                            <i class="fas fa-dollar-sign"></i>
                        </button>
                        <button type="button" class="markdown-btn" onclick="insertBlockLatex(this.parentElement.querySelector('textarea'))" title="Wrap selection with block LaTeX ($$\\n...\\n$$) or insert $$\\n\\n$$">
                            <i class="fas fa-square-root-alt"></i>
                        </button>
                        <button type="button" class="markdown-btn" onclick="removeMarkdownFormatting(this)" title="Undo last markdown formatting operation">
                            <i class="fas fa-undo"></i>
                        </button>
                        <button type="button" class="markdown-btn" onclick="redoMarkdownFormatting(this)" title="Redo last undone markdown formatting operation">
                            <i class="fas fa-redo"></i>
                        </button>
                        <button type="button" class="table-btn" onclick="insertTable(this.parentElement.querySelector('textarea'))" title="Insert a markdown table template">
                            <i class="fas fa-table"></i> Insert Table
                        </button>
                        <button type="button" class="image-btn" onclick="insertImage(this.parentElement.querySelector('textarea'))" title="Insert an image placeholder">
                            <i class="fas fa-image"></i> Insert Image
                        </button>
                        <button type="button" class="dir-btn" onclick="toggleDirection(this.parentElement.querySelector('textarea'))" title="Toggle text direction (LTR/RTL)">LTR</button>
                    </div>
                </div>
                
                <div class="form-group required-field required">
                    <label>Question Text</label>
                    <div class="text-field-container">
                        <span class="input-label">Input Markdown</span>
                        <textarea placeholder="Enter question text..." title="The main question text that students need to answer (supports markdown and LaTeX)"></textarea>
                        <button type="button" class="markdown-btn" onclick="insertBold(this.parentElement.querySelector('textarea'))" title="Make selected text bold (**text**)">
                            <i class="fas fa-bold"></i>
                        </button>
                        <button type="button" class="markdown-btn" onclick="insertItalic(this.parentElement.querySelector('textarea'))" title="Make selected text italic (*text*)">
                            <i class="fas fa-italic"></i>
                        </button>
                        <button type="button" class="markdown-btn" onclick="insertBulletList(this.parentElement.querySelector('textarea'))" title="Convert line(s) to bullet list (- item)">
                            <i class="fas fa-list-ul"></i>
                        </button>
                        <button type="button" class="markdown-btn" onclick="insertNumberedList(this.parentElement.querySelector('textarea'))" title="Convert line(s) to numbered list (1. item)">
                            <i class="fas fa-list-ol"></i>
                        </button>
                        <button type="button" class="markdown-btn" onclick="insertBlockquote(this.parentElement.querySelector('textarea'))" title="Convert line(s) to blockquote (> text)">
                            <i class="fas fa-quote-right"></i>
                        </button>
                        <button type="button" class="markdown-btn" onclick="insertInlineLatex(this.parentElement.querySelector('textarea'))" title="Wrap selection with $ or insert $$">
                            <i class="fas fa-dollar-sign"></i>
                        </button>
                        <button type="button" class="markdown-btn" onclick="insertBlockLatex(this.parentElement.querySelector('textarea'))" title="Wrap selection with block LaTeX ($$\\n...\\n$$) or insert $$\\n\\n$$">
                            <i class="fas fa-square-root-alt"></i>
                        </button>
                        <button type="button" class="markdown-btn" onclick="removeMarkdownFormatting(this)" title="Undo last markdown formatting operation">
                            <i class="fas fa-undo"></i>
                        </button>
                        <button type="button" class="markdown-btn" onclick="redoMarkdownFormatting(this)" title="Redo last undone markdown formatting operation">
                            <i class="fas fa-redo"></i>
                        </button>
                        <button type="button" class="table-btn" onclick="insertTable(this.parentElement.querySelector('textarea'))" title="Insert a markdown table template">
                            <i class="fas fa-table"></i> Insert Table
                        </button>
                        <button type="button" class="image-btn" onclick="insertImage(this.parentElement.querySelector('textarea'))" title="Insert an image placeholder">
                            <i class="fas fa-image"></i> Insert Image
                        </button>
                        <button type="button" class="blank-btn" onclick="insertBlankAtCursor(this.parentElement.querySelector('textarea'))" style="display: none;" title="Insert a fill-in-the-blank placeholder">
                            <i class="fas fa-square"></i> Insert Blank
                        </button>
                        <button type="button" class="dir-btn" onclick="toggleDirection(this.parentElement.querySelector('textarea'))" title="Toggle text direction (LTR/RTL)">LTR</button>
                    </div>
                </div>
                
                <div class="form-group required-field required free-form-answer" id="guide-answer-container">
                    <label>Guide Answer</label>
                    <div class="text-field-container">
                        <span class="input-label">Input Markdown</span>
                        <textarea placeholder="Enter guide answer..." title="Step-by-step solution or answer key for teachers (supports markdown and LaTeX)"></textarea>
                        <button type="button" class="markdown-btn" onclick="insertBold(this.parentElement.querySelector('textarea'))" title="Make selected text bold (**text**)">
                            <i class="fas fa-bold"></i>
                        </button>
                        <button type="button" class="markdown-btn" onclick="insertItalic(this.parentElement.querySelector('textarea'))" title="Make selected text italic (*text*)">
                            <i class="fas fa-italic"></i>
                        </button>
                        <button type="button" class="markdown-btn" onclick="insertBulletList(this.parentElement.querySelector('textarea'))" title="Convert line(s) to bullet list (- item)">
                            <i class="fas fa-list-ul"></i>
                        </button>
                        <button type="button" class="markdown-btn" onclick="insertNumberedList(this.parentElement.querySelector('textarea'))" title="Convert line(s) to numbered list (1. item)">
                            <i class="fas fa-list-ol"></i>
                        </button>
                        <button type="button" class="markdown-btn" onclick="insertBlockquote(this.parentElement.querySelector('textarea'))" title="Convert line(s) to blockquote (> text)">
                            <i class="fas fa-quote-right"></i>
                        </button>
                        <button type="button" class="markdown-btn" onclick="insertInlineLatex(this.parentElement.querySelector('textarea'))" title="Wrap selection with $ or insert $$">
                            <i class="fas fa-dollar-sign"></i>
                        </button>
                        <button type="button" class="markdown-btn" onclick="insertBlockLatex(this.parentElement.querySelector('textarea'))" title="Wrap selection with block LaTeX ($$\\n...\\n$$) or insert $$\\n\\n$$">
                            <i class="fas fa-square-root-alt"></i>
                        </button>
                        <button type="button" class="markdown-btn" onclick="removeMarkdownFormatting(this)" title="Undo last markdown formatting operation">
                            <i class="fas fa-undo"></i>
                        </button>
                        <button type="button" class="markdown-btn" onclick="redoMarkdownFormatting(this)" title="Redo last undone markdown formatting operation">
                            <i class="fas fa-redo"></i>
                        </button>
                        <button type="button" class="table-btn" onclick="insertTable(this.parentElement.querySelector('textarea'))" title="Insert a markdown table template">
                            <i class="fas fa-table"></i> Insert Table
                        </button>
                        <button type="button" class="image-btn" onclick="insertImage(this.parentElement.querySelector('textarea'))" title="Insert an image placeholder">
                            <i class="fas fa-image"></i> Insert Image
                        </button>
                        <button type="button" class="dir-btn" onclick="toggleDirection(this.parentElement.querySelector('textarea'))" title="Toggle text direction (LTR/RTL)">LTR</button>
                    </div>
                </div>
                
                <div class="form-group mcq-choices" id="choices-container" style="display: none;">
                    <label>Multiple Choice Options</label>
                    <div id="choices-list-${questionCount}">
                        <!-- Choices will be added here -->
                </div>
                    <button class="add-btn" onclick="addChoice(this)" title="Add a new answer choice">
                        <i class="fas fa-plus"></i> Add Choice
                                </button>
                    <div class="form-group" id="correct-answer-selector" style="margin-top: 15px; display: none;">
                        <label style="font-weight: 600;">Correct Answer Position</label>
                        <div id="correct-answer-radios-${questionCount}" style="display: flex; flex-direction: column; gap: 8px; margin-top: 8px;">
                            <!-- Radio buttons will be generated dynamically based on choices -->
                        </div>
                    </div>
                    <div class="form-group" style="margin-top: 15px; display: none;" id="checkbox-summary">
                        <label style="font-weight: 600; color: #28a745;">Correct Answers Summary</label>
                        <div id="checkbox-summary-text" style="padding: 10px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 6px; font-size: 0.9em;">
                            <span style="opacity: 0.7; color: var(--text-secondary);">Check the " Correct Answer" boxes above to mark correct choices</span>
                        </div>
                    </div>
                    <div class="form-group" style="margin-top: 15px;">
                        <label>Guide Answer <span style="opacity: 0.6; font-size: 0.85em;">(Optional)</span></label>
                        <div class="text-field-container">
                            <span class="input-label">Input Markdown</span>
                            <textarea class="guide-answer-notes" placeholder="Optional: Enter guide answer..." title="Optional guide answer or notes for teachers (supports markdown and LaTeX)"></textarea>
                            <button type="button" class="markdown-btn" onclick="insertBold(this.parentElement.querySelector('textarea'))" title="Make selected text bold (**text**)">
                                <i class="fas fa-bold"></i>
                            </button>
                            <button type="button" class="markdown-btn" onclick="insertItalic(this.parentElement.querySelector('textarea'))" title="Make selected text italic (*text*)">
                                <i class="fas fa-italic"></i>
                            </button>
                            <button type="button" class="markdown-btn" onclick="insertBulletList(this.parentElement.querySelector('textarea'))" title="Convert line(s) to bullet list (- item)">
                                <i class="fas fa-list-ul"></i>
                            </button>
                            <button type="button" class="markdown-btn" onclick="insertNumberedList(this.parentElement.querySelector('textarea'))" title="Convert line(s) to numbered list (1. item)">
                                <i class="fas fa-list-ol"></i>
                            </button>
                            <button type="button" class="markdown-btn" onclick="insertBlockquote(this.parentElement.querySelector('textarea'))" title="Convert line(s) to blockquote (> text)">
                                <i class="fas fa-quote-right"></i>
                            </button>
                            <button type="button" class="table-btn" onclick="insertTable(this.parentElement.querySelector('textarea'))" title="Insert a markdown table template">
                                <i class="fas fa-table"></i> Insert Table
                            </button>
                            <button type="button" class="image-btn" onclick="insertImage(this.parentElement.querySelector('textarea'))" title="Insert an image placeholder">
                                <i class="fas fa-image"></i> Insert Image
                            </button>
                            <button type="button" class="dir-btn" onclick="toggleDirection(this.parentElement.querySelector('textarea'))" title="Toggle text direction (LTR/RTL)">LTR</button>
                        </div>
                    </div>
                </div>
                
                <!-- Fill in the Blanks Section -->
                <div class="form-group" id="blanks-container" style="display: none;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <label style="font-weight: 600; margin: 0;">Blank Answers</label>
                        <button type="button" class="add-btn" style="padding: 4px 10px; font-size: 0.85em;" onclick="insertBlankAtCursor(this.closest('.array-item').querySelector('textarea[placeholder*=\\'Enter question text\\']'))" title="Insert the next numbered blank placeholder in the question text">
                            <i class="fas fa-plus"></i> Insert Next Blank
                        </button>
                    </div>
                    <div id="blanks-validation-errors" style="display: none; margin-bottom: 10px;"></div>
                    <div id="blanks-answers-container" style="padding: 15px; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 8px;">
                        <p style="color: var(--text-secondary); font-style: italic;">No blanks detected. Use ___1___, ___2___, etc. in your question text.</p>
                    </div>
                    
                    <!-- Preview of Question with Filled Blanks -->
                    <div class="form-group" style="margin-top: 15px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <label style="font-weight: 600; margin: 0;">Preview with Answers</label>
                        <button type="button" class="dir-btn" onclick="toggleFilledBlanksDirection(this)" style="margin: 0;" title="Toggle text direction (LTR/RTL)">LTR</button>
                        </div>
                        <div id="filled-blanks-preview" class="live-preview" style="min-height: 80px; max-height: 400px;" dir="rtl" title="Preview of the question with blank answers filled in">
                            <p style="color: var(--text-secondary); font-style: italic;">Preview will appear here when blanks are filled</p>
                        </div>
                    </div>
                    
                    <div class="form-group" style="margin-top: 15px;">
                        <label>Guide Answer <span style="opacity: 0.6; font-size: 0.85em;">(Optional)</span></label>
                        <div class="text-field-container">
                            <span class="input-label">Input Markdown</span>
                            <textarea class="guide-answer-notes" placeholder="Optional: Enter guide answer..." title="Optional guide answer or notes for teachers (supports markdown and LaTeX)"></textarea>
                            <button type="button" class="markdown-btn" onclick="insertBold(this.parentElement.querySelector('textarea'))" title="Make selected text bold (**text**)">
                                <i class="fas fa-bold"></i>
                            </button>
                            <button type="button" class="markdown-btn" onclick="insertItalic(this.parentElement.querySelector('textarea'))" title="Make selected text italic (*text*)">
                                <i class="fas fa-italic"></i>
                            </button>
                            <button type="button" class="markdown-btn" onclick="insertBulletList(this.parentElement.querySelector('textarea'))" title="Convert line(s) to bullet list (- item)">
                                <i class="fas fa-list-ul"></i>
                            </button>
                            <button type="button" class="markdown-btn" onclick="insertNumberedList(this.parentElement.querySelector('textarea'))" title="Convert line(s) to numbered list (1. item)">
                                <i class="fas fa-list-ol"></i>
                            </button>
                            <button type="button" class="markdown-btn" onclick="insertBlockquote(this.parentElement.querySelector('textarea'))" title="Convert line(s) to blockquote (> text)">
                                <i class="fas fa-quote-right"></i>
                            </button>
                            <button type="button" class="table-btn" onclick="insertTable(this.parentElement.querySelector('textarea'))" title="Insert a markdown table template">
                                <i class="fas fa-table"></i> Insert Table
                            </button>
                            <button type="button" class="image-btn" onclick="insertImage(this.parentElement.querySelector('textarea'))" title="Insert an image placeholder">
                                <i class="fas fa-image"></i> Insert Image
                            </button>
                            <button type="button" class="dir-btn" onclick="toggleDirection(this.parentElement.querySelector('textarea'))" title="Toggle text direction (LTR/RTL)">LTR</button>
                        </div>
                    </div>
                </div>
                
                <!-- Matching Section -->
                <div class="form-group" id="matching-container" style="display: none;">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                        <!-- Left Column -->
                        <div>
                            <label style="font-weight: 600; margin: 0 0 10px 0; display: block;">Left Items</label>
                            <div id="matching-left-list-${questionCount}" class="matching-list" style="display: flex; flex-direction: column; gap: 10px; margin-bottom: 10px;">
                                <!-- Left items will be added here -->
                            </div>
                            <button type="button" class="add-btn" onclick="addMatchingItem(this, 'left')" title="Add a new item to the left column">
                                <i class="fas fa-plus"></i> Add Left Item
                            </button>
                        </div>
                        
                        <!-- Right Column -->
                        <div>
                            <label style="font-weight: 600; margin: 0 0 10px 0; display: block;">Right Items</label>
                            <div id="matching-right-list-${questionCount}" class="matching-list" style="display: flex; flex-direction: column; gap: 10px; margin-bottom: 10px;">
                                <!-- Right items will be added here -->
                            </div>
                            <button type="button" class="add-btn" onclick="addMatchingItem(this, 'right')" title="Add a new item to the right column">
                                <i class="fas fa-plus"></i> Add Right Item
                            </button>
                        </div>
                    </div>
                    
                    <!-- Relationships Section -->
                    <div style="margin-top: 20px; padding: 15px; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 8px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                            <label style="font-weight: 600; margin: 0;">Relationships</label>
                            <button type="button" class="add-btn" onclick="addRelationship(this)" title="Add a new relationship connecting a left item to a right item">
                                <i class="fas fa-link"></i> Add Relationship
                            </button>
                        </div>
                        <div id="relationships-list-${questionCount}" style="display: flex; flex-direction: column; gap: 8px;">
                            <p style="color: var(--text-secondary); font-style: italic; margin: 0;">No relationships added yet. Click "Add Relationship" to connect items.</p>
                        </div>
                    </div>
                    
                    <div class="form-group" style="margin-top: 15px;">
                        <label>Guide Answer <span style="opacity: 0.6; font-size: 0.85em;">(Optional)</span></label>
                        <div class="text-field-container">
                            <span class="input-label">Input Markdown</span>
                            <textarea class="guide-answer-notes" placeholder="Optional: Enter guide answer..." title="Optional guide answer or notes for teachers (supports markdown and LaTeX)"></textarea>
                            <button type="button" class="table-btn" onclick="insertTable(this.parentElement.querySelector('textarea'))" title="Insert a markdown table template">
                                <i class="fas fa-table"></i> Insert Table
                            </button>
                            <button type="button" class="image-btn" onclick="insertImage(this.parentElement.querySelector('textarea'))" title="Insert an image placeholder">
                                <i class="fas fa-image"></i> Insert Image
                            </button>
                            <button type="button" class="dir-btn" onclick="toggleDirection(this.parentElement.querySelector('textarea'))" title="Toggle text direction (LTR/RTL)">LTR</button>
                        </div>
                            </div>
                        </div>
                
                <div class="form-group required-field required">
                    <label>Guide PDF Page</label>
                    <input type="number" placeholder="e.g., 78" min="1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57" title="Page number in the guidebook PDF where the answer appears (must be within the guidebook page range)">
                </div>
                
                <div class="form-group">
                    <label>Question Images</label>
                    <div class="bbox-container">
                        <div class="array-item">
                            <div class="bbox-inputs">
                                <input type="number" placeholder="Page" class="bbox-page" min="1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57" title="PDF page number where this image appears">
                                <input type="number" placeholder="X0" class="bbox-x0" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57" title="Right X coordinate (top-right corner)">
                                <input type="number" placeholder="Y0" class="bbox-y0" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57" title="Top Y coordinate (top-right corner)">
                                <input type="number" placeholder="X1" class="bbox-x1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57" title="Left X coordinate (bottom-left corner)">
                                <input type="number" placeholder="Y1" class="bbox-y1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57" title="Bottom Y coordinate (bottom-left corner)">
                            </div>
                            <div class="row-actions">
                                <button class="reorder-btn" onclick="moveItemUp(this)" title="Move Up"><i class="fas fa-arrow-up"></i></button>
                                <button class="reorder-btn" onclick="moveItemDown(this)" title="Move Down"><i class="fas fa-arrow-down"></i></button>
                                <button class="add-bbox-btn" onclick="addQuestionImageBefore(this)" title="Add Image Before">
                                    <i class="fas fa-plus"></i> Before
                                </button>
                                <button class="add-bbox-btn" onclick="addQuestionImageAfter(this)" title="Add Image After">
                                    <i class="fas fa-plus"></i> After
                                </button>
                                <button class="add-btn" onclick="openBboxDrawer(this)" title="Open PDF viewer to draw bounding box"><i class="fas fa-pen-square"></i> Draw</button>
                                <button class="add-btn" onclick="pasteBboxJson(this)" title="Paste bounding box coordinates from clipboard"><i class="fas fa-paste"></i> Paste</button>
                                <button class="add-btn" onclick="copyBboxJson(this)" title="Copy bounding box coordinates to clipboard"><i class="fas fa-copy"></i> Copy</button>
                                <button class="duplicate-btn" onclick="duplicateBbox(this)" title="Duplicate Image"><i class="fas fa-clone"></i></button>
                                <button class="remove-btn" onclick="removeArrayItem(this)"></button>
                            </div>
                        </div>
                    </div>
                    <button class="add-btn" onclick="addQuestionImage(this)" title="Add a new image bounding box for question images">
                        <i class="fas fa-plus"></i> Add Image
                    </button>
                </div>
                
                <div class="form-group">
                    <label>Answer Images</label>
                    <div class="bbox-container">
                        <div class="array-item">
                            <div class="bbox-inputs">
                                <input type="number" placeholder="Page" class="bbox-page" min="1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57" title="PDF page number where this image appears">
                                <input type="number" placeholder="X0" class="bbox-x0" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57" title="Right X coordinate (top-right corner)">
                                <input type="number" placeholder="Y0" class="bbox-y0" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57" title="Top Y coordinate (top-right corner)">
                                <input type="number" placeholder="X1" class="bbox-x1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57" title="Left X coordinate (bottom-left corner)">
                                <input type="number" placeholder="Y1" class="bbox-y1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57" title="Bottom Y coordinate (bottom-left corner)">
                            </div>
                            <div class="row-actions">
                                <button class="reorder-btn" onclick="moveItemUp(this)" title="Move Up"><i class="fas fa-arrow-up"></i></button>
                                <button class="reorder-btn" onclick="moveItemDown(this)" title="Move Down"><i class="fas fa-arrow-down"></i></button>
                                <button class="add-bbox-btn" onclick="addAnswerImageBefore(this)" title="Add Image Before">
                                    <i class="fas fa-plus"></i> Before
                                </button>
                                <button class="add-bbox-btn" onclick="addAnswerImageAfter(this)" title="Add Image After">
                                    <i class="fas fa-plus"></i> After
                                </button>
                                <button class="add-btn" onclick="openBboxDrawer(this)" title="Open PDF viewer to draw bounding box"><i class="fas fa-pen-square"></i> Draw</button>
                                <button class="add-btn" onclick="pasteBboxJson(this)" title="Paste bounding box coordinates from clipboard"><i class="fas fa-paste"></i> Paste</button>
                                <button class="add-btn" onclick="copyBboxJson(this)" title="Copy bounding box coordinates to clipboard"><i class="fas fa-copy"></i> Copy</button>
                                <button class="duplicate-btn" onclick="duplicateBbox(this)" title="Duplicate Image"><i class="fas fa-clone"></i></button>
                                <button class="remove-btn" onclick="removeArrayItem(this)"></button>
                            </div>
                        </div>
                    </div>
                    <button class="add-btn" onclick="addAnswerImage(this)" title="Add a new image bounding box for answer images">
                        <i class="fas fa-plus"></i> Add Image
                    </button>
                </div>
                
                <div class="form-group">
                    <label>Related Question</label>
                    <input type="text" placeholder="Leave empty if no related questions" data-ltr="true" title="Optional reference to related questions (e.g., 3)">
                </div>
                </div>
            `;
        }

        // Functions to add bboxes/images before/after current item
        function addContentBboxBefore(button) {
            const currentItem = button.closest('.array-item');
            const container = currentItem ? currentItem.parentElement : null;
            if (!currentItem || !container) return;
            
            const newItem = document.createElement('div');
            newItem.className = 'array-item';
            newItem.innerHTML = `
                <div class="bbox-inputs">
                    <input type="number" placeholder="Page" class="bbox-page" min="1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    <input type="number" placeholder="X0" class="bbox-x0" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    <input type="number" placeholder="Y0" class="bbox-y0" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    <input type="number" placeholder="X1" class="bbox-x1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    <input type="number" placeholder="Y1" class="bbox-y1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                </div>
                <div class="row-actions">
                    <button class="add-bbox-btn" onclick="addContentBboxBefore(this)" title="Add BBox Before">
                        <i class="fas fa-plus"></i> Before
                    </button>
                    <button class="add-bbox-btn" onclick="addContentBboxAfter(this)" title="Add BBox After">
                        <i class="fas fa-plus"></i> After
                    </button>
                    <button class="reorder-btn" onclick="moveItemUp(this)" title="Move Up"><i class="fas fa-arrow-up"></i></button>
                    <button class="reorder-btn" onclick="moveItemDown(this)" title="Move Down"><i class="fas fa-arrow-down"></i></button>
                    <button class="add-btn" onclick="openBboxDrawer(this)" title="Open PDF viewer to draw bounding box"><i class="fas fa-pen-square"></i> Draw</button>
                    <button class="add-btn" onclick="pasteBboxJson(this)" title="Paste bounding box coordinates from clipboard"><i class="fas fa-paste"></i> Paste</button>
                    <button class="add-btn" onclick="copyBboxJson(this)" title="Copy bounding box coordinates to clipboard"><i class="fas fa-copy"></i> Copy</button>
                    <button class="duplicate-btn" onclick="duplicateBbox(this)" title="Duplicate BBox"><i class="fas fa-clone"></i></button>
                    <button class="remove-btn" onclick="removeArrayItem(this)"></button>
                </div>
            `;
            container.insertBefore(newItem, currentItem);
            
            // Record action for undo/redo (after adding to DOM so we have the actual element)
            recordFormAction({
                type: ACTION_TYPES.ADD_ITEM,
                element: newItem,
                parent: container,
                nextSibling: newItem.nextSibling,
                containerId: null,
                updateNumbers: false
            });
            
            attachBboxValidationToItem(newItem);
        }

        function addContentBboxAfter(button) {
            const currentItem = button.closest('.array-item');
            const container = currentItem ? currentItem.parentElement : null;
            if (!currentItem || !container) return;
            
            const newItem = document.createElement('div');
            newItem.className = 'array-item';
            newItem.innerHTML = `
                <div class="bbox-inputs">
                    <input type="number" placeholder="Page" class="bbox-page" min="1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    <input type="number" placeholder="X0" class="bbox-x0" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    <input type="number" placeholder="Y0" class="bbox-y0" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    <input type="number" placeholder="X1" class="bbox-x1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    <input type="number" placeholder="Y1" class="bbox-y1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                </div>
                <div class="row-actions">
                    <button class="add-bbox-btn" onclick="addContentBboxBefore(this)" title="Add BBox Before">
                        <i class="fas fa-plus"></i> Before
                    </button>
                    <button class="add-bbox-btn" onclick="addContentBboxAfter(this)" title="Add BBox After">
                        <i class="fas fa-plus"></i> After
                    </button>
                    <button class="reorder-btn" onclick="moveItemUp(this)" title="Move Up"><i class="fas fa-arrow-up"></i></button>
                    <button class="reorder-btn" onclick="moveItemDown(this)" title="Move Down"><i class="fas fa-arrow-down"></i></button>
                    <button class="add-btn" onclick="openBboxDrawer(this)" title="Open PDF viewer to draw bounding box"><i class="fas fa-pen-square"></i> Draw</button>
                    <button class="add-btn" onclick="pasteBboxJson(this)" title="Paste bounding box coordinates from clipboard"><i class="fas fa-paste"></i> Paste</button>
                    <button class="add-btn" onclick="copyBboxJson(this)" title="Copy bounding box coordinates to clipboard"><i class="fas fa-copy"></i> Copy</button>
                    <button class="duplicate-btn" onclick="duplicateBbox(this)" title="Duplicate BBox"><i class="fas fa-clone"></i></button>
                    <button class="remove-btn" onclick="removeArrayItem(this)"></button>
                </div>
            `;
            container.insertBefore(newItem, currentItem.nextSibling);
            
            // Record action for undo/redo (after adding to DOM so we have the actual element)
            recordFormAction({
                type: ACTION_TYPES.ADD_ITEM,
                element: newItem,
                parent: container,
                nextSibling: newItem.nextSibling,
                containerId: null,
                updateNumbers: false
            });
            
            attachBboxValidationToItem(newItem);
        }

        function addContentImageBefore(button) {
            const currentItem = button.closest('.array-item');
            const container = currentItem ? currentItem.parentElement : null;
            if (!currentItem || !container) return;
            
            const newItem = document.createElement('div');
            newItem.className = 'array-item';
            newItem.innerHTML = `
                <div class="bbox-inputs">
                    <input type="number" placeholder="Page" class="bbox-page" min="1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    <input type="number" placeholder="X0" class="bbox-x0" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    <input type="number" placeholder="Y0" class="bbox-y0" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    <input type="number" placeholder="X1" class="bbox-x1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    <input type="number" placeholder="Y1" class="bbox-y1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                </div>
                <div class="row-actions">
                    <button class="reorder-btn" onclick="moveItemUp(this)" title="Move Up"><i class="fas fa-arrow-up"></i></button>
                    <button class="reorder-btn" onclick="moveItemDown(this)" title="Move Down"><i class="fas fa-arrow-down"></i></button>
                    <button class="add-bbox-btn" onclick="addContentImageBefore(this)" title="Add Image Before">
                        <i class="fas fa-plus"></i> Before
                    </button>
                    <button class="add-bbox-btn" onclick="addContentImageAfter(this)" title="Add Image After">
                        <i class="fas fa-plus"></i> After
                    </button>
                    <button class="add-btn" onclick="openBboxDrawer(this)" title="Open PDF viewer to draw bounding box"><i class="fas fa-pen-square"></i> Draw</button>
                    <button class="add-btn" onclick="pasteBboxJson(this)" title="Paste bounding box coordinates from clipboard"><i class="fas fa-paste"></i> Paste</button>
                    <button class="add-btn" onclick="copyBboxJson(this)" title="Copy bounding box coordinates to clipboard"><i class="fas fa-copy"></i> Copy</button>
                    <button class="duplicate-btn" onclick="duplicateBbox(this)" title="Duplicate Image"><i class="fas fa-clone"></i></button>
                    <button class="remove-btn" onclick="removeArrayItem(this)"></button>
                </div>
            `;
            container.insertBefore(newItem, currentItem);
            
            // Record action for undo/redo (after adding to DOM so we have the actual element)
            recordFormAction({
                type: ACTION_TYPES.ADD_ITEM,
                element: newItem,
                parent: container,
                nextSibling: newItem.nextSibling,
                containerId: null,
                updateNumbers: false
            });
            
            attachBboxValidationToItem(newItem);
        }

        function addContentImageAfter(button) {
            const currentItem = button.closest('.array-item');
            const container = currentItem ? currentItem.parentElement : null;
            if (!currentItem || !container) return;
            
            const newItem = document.createElement('div');
            newItem.className = 'array-item';
            newItem.innerHTML = `
                <div class="bbox-inputs">
                    <input type="number" placeholder="Page" class="bbox-page" min="1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    <input type="number" placeholder="X0" class="bbox-x0" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    <input type="number" placeholder="Y0" class="bbox-y0" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    <input type="number" placeholder="X1" class="bbox-x1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    <input type="number" placeholder="Y1" class="bbox-y1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                </div>
                <div class="row-actions">
                    <button class="reorder-btn" onclick="moveItemUp(this)" title="Move Up"><i class="fas fa-arrow-up"></i></button>
                    <button class="reorder-btn" onclick="moveItemDown(this)" title="Move Down"><i class="fas fa-arrow-down"></i></button>
                    <button class="add-bbox-btn" onclick="addContentImageBefore(this)" title="Add Image Before">
                        <i class="fas fa-plus"></i> Before
                    </button>
                    <button class="add-bbox-btn" onclick="addContentImageAfter(this)" title="Add Image After">
                        <i class="fas fa-plus"></i> After
                    </button>
                    <button class="add-btn" onclick="openBboxDrawer(this)" title="Open PDF viewer to draw bounding box"><i class="fas fa-pen-square"></i> Draw</button>
                    <button class="add-btn" onclick="pasteBboxJson(this)" title="Paste bounding box coordinates from clipboard"><i class="fas fa-paste"></i> Paste</button>
                    <button class="add-btn" onclick="copyBboxJson(this)" title="Copy bounding box coordinates to clipboard"><i class="fas fa-copy"></i> Copy</button>
                    <button class="duplicate-btn" onclick="duplicateBbox(this)" title="Duplicate Image"><i class="fas fa-clone"></i></button>
                    <button class="remove-btn" onclick="removeArrayItem(this)"></button>
                </div>
            `;
            container.insertBefore(newItem, currentItem.nextSibling);
            
            // Record action for undo/redo (after adding to DOM so we have the actual element)
            recordFormAction({
                type: ACTION_TYPES.ADD_ITEM,
                element: newItem,
                parent: container,
                nextSibling: newItem.nextSibling,
                containerId: null,
                updateNumbers: false
            });
            
            attachBboxValidationToItem(newItem);
        }


        function addQuestionImageBefore(button) {
            const currentItem = button.closest('.array-item');
            const container = currentItem ? currentItem.parentElement : null;
            if (!currentItem || !container) return;
            
            const newItem = document.createElement('div');
            newItem.className = 'array-item';
            newItem.innerHTML = `
                <div class="bbox-inputs">
                    <input type="number" placeholder="Page" class="bbox-page" min="1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    <input type="number" placeholder="X0" class="bbox-x0" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    <input type="number" placeholder="Y0" class="bbox-y0" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    <input type="number" placeholder="X1" class="bbox-x1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    <input type="number" placeholder="Y1" class="bbox-y1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                </div>
                <div class="row-actions">
                    <button class="reorder-btn" onclick="moveItemUp(this)" title="Move Up"><i class="fas fa-arrow-up"></i></button>
                    <button class="reorder-btn" onclick="moveItemDown(this)" title="Move Down"><i class="fas fa-arrow-down"></i></button>
                    <button class="add-bbox-btn" onclick="addQuestionImageBefore(this)" title="Add Image Before">
                        <i class="fas fa-plus"></i> Before
                    </button>
                    <button class="add-bbox-btn" onclick="addQuestionImageAfter(this)" title="Add Image After">
                        <i class="fas fa-plus"></i> After
                    </button>
                    <button class="add-btn" onclick="openBboxDrawer(this)" title="Open PDF viewer to draw bounding box"><i class="fas fa-pen-square"></i> Draw</button>
                    <button class="add-btn" onclick="pasteBboxJson(this)" title="Paste bounding box coordinates from clipboard"><i class="fas fa-paste"></i> Paste</button>
                    <button class="add-btn" onclick="copyBboxJson(this)" title="Copy bounding box coordinates to clipboard"><i class="fas fa-copy"></i> Copy</button>
                    <button class="duplicate-btn" onclick="duplicateBbox(this)" title="Duplicate Image"><i class="fas fa-clone"></i></button>
                    <button class="remove-btn" onclick="removeArrayItem(this)"></button>
                </div>
            `;
            container.insertBefore(newItem, currentItem);
            
            // Record action for undo/redo (after adding to DOM so we have the actual element)
            recordFormAction({
                type: ACTION_TYPES.ADD_ITEM,
                element: newItem,
                parent: container,
                nextSibling: newItem.nextSibling,
                containerId: null,
                updateNumbers: false
            });
            
            attachBboxValidationToItem(newItem);
        }

        function addQuestionImageAfter(button) {
            const currentItem = button.closest('.array-item');
            const container = currentItem ? currentItem.parentElement : null;
            if (!currentItem || !container) return;
            
            const newItem = document.createElement('div');
            newItem.className = 'array-item';
            newItem.innerHTML = `
                <div class="bbox-inputs">
                    <input type="number" placeholder="Page" class="bbox-page" min="1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    <input type="number" placeholder="X0" class="bbox-x0" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    <input type="number" placeholder="Y0" class="bbox-y0" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    <input type="number" placeholder="X1" class="bbox-x1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    <input type="number" placeholder="Y1" class="bbox-y1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                </div>
                <div class="row-actions">
                    <button class="reorder-btn" onclick="moveItemUp(this)" title="Move Up"><i class="fas fa-arrow-up"></i></button>
                    <button class="reorder-btn" onclick="moveItemDown(this)" title="Move Down"><i class="fas fa-arrow-down"></i></button>
                    <button class="add-bbox-btn" onclick="addQuestionImageBefore(this)" title="Add Image Before">
                        <i class="fas fa-plus"></i> Before
                    </button>
                    <button class="add-bbox-btn" onclick="addQuestionImageAfter(this)" title="Add Image After">
                        <i class="fas fa-plus"></i> After
                    </button>
                    <button class="add-btn" onclick="openBboxDrawer(this)" title="Open PDF viewer to draw bounding box"><i class="fas fa-pen-square"></i> Draw</button>
                    <button class="add-btn" onclick="pasteBboxJson(this)" title="Paste bounding box coordinates from clipboard"><i class="fas fa-paste"></i> Paste</button>
                    <button class="add-btn" onclick="copyBboxJson(this)" title="Copy bounding box coordinates to clipboard"><i class="fas fa-copy"></i> Copy</button>
                    <button class="duplicate-btn" onclick="duplicateBbox(this)" title="Duplicate Image"><i class="fas fa-clone"></i></button>
                    <button class="remove-btn" onclick="removeArrayItem(this)"></button>
                </div>
            `;
            container.insertBefore(newItem, currentItem.nextSibling);
            
            // Record action for undo/redo (after adding to DOM so we have the actual element)
            recordFormAction({
                type: ACTION_TYPES.ADD_ITEM,
                element: newItem,
                parent: container,
                nextSibling: newItem.nextSibling,
                containerId: null,
                updateNumbers: false
            });
            
            attachBboxValidationToItem(newItem);
        }


        function addAnswerImageBefore(button) {
            const currentItem = button.closest('.array-item');
            const container = currentItem ? currentItem.parentElement : null;
            if (!currentItem || !container) return;
            
            const newItem = document.createElement('div');
            newItem.className = 'array-item';
            newItem.innerHTML = `
                <div class="bbox-inputs">
                    <input type="number" placeholder="Page" class="bbox-page" min="1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    <input type="number" placeholder="X0" class="bbox-x0" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    <input type="number" placeholder="Y0" class="bbox-y0" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    <input type="number" placeholder="X1" class="bbox-x1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    <input type="number" placeholder="Y1" class="bbox-y1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                </div>
                <div class="row-actions">
                    <button class="reorder-btn" onclick="moveItemUp(this)" title="Move Up"><i class="fas fa-arrow-up"></i></button>
                    <button class="reorder-btn" onclick="moveItemDown(this)" title="Move Down"><i class="fas fa-arrow-down"></i></button>
                    <button class="add-bbox-btn" onclick="addAnswerImageBefore(this)" title="Add Image Before">
                        <i class="fas fa-plus"></i> Before
                    </button>
                    <button class="add-bbox-btn" onclick="addAnswerImageAfter(this)" title="Add Image After">
                        <i class="fas fa-plus"></i> After
                    </button>
                    <button class="add-btn" onclick="openBboxDrawer(this)" title="Open PDF viewer to draw bounding box"><i class="fas fa-pen-square"></i> Draw</button>
                    <button class="add-btn" onclick="pasteBboxJson(this)" title="Paste bounding box coordinates from clipboard"><i class="fas fa-paste"></i> Paste</button>
                    <button class="add-btn" onclick="copyBboxJson(this)" title="Copy bounding box coordinates to clipboard"><i class="fas fa-copy"></i> Copy</button>
                    <button class="duplicate-btn" onclick="duplicateBbox(this)" title="Duplicate Image"><i class="fas fa-clone"></i></button>
                    <button class="remove-btn" onclick="removeArrayItem(this)"></button>
                </div>
            `;
            container.insertBefore(newItem, currentItem);
            
            // Record action for undo/redo (after adding to DOM so we have the actual element)
            recordFormAction({
                type: ACTION_TYPES.ADD_ITEM,
                element: newItem,
                parent: container,
                nextSibling: newItem.nextSibling,
                containerId: null,
                updateNumbers: false
            });
            
            attachBboxValidationToItem(newItem);
        }

        function addAnswerImageAfter(button) {
            const currentItem = button.closest('.array-item');
            const container = currentItem ? currentItem.parentElement : null;
            if (!currentItem || !container) return;
            
            const newItem = document.createElement('div');
            newItem.className = 'array-item';
            newItem.innerHTML = `
                <div class="bbox-inputs">
                    <input type="number" placeholder="Page" class="bbox-page" min="1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    <input type="number" placeholder="X0" class="bbox-x0" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    <input type="number" placeholder="Y0" class="bbox-y0" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    <input type="number" placeholder="X1" class="bbox-x1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    <input type="number" placeholder="Y1" class="bbox-y1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                </div>
                <div class="row-actions">
                    <button class="reorder-btn" onclick="moveItemUp(this)" title="Move Up"><i class="fas fa-arrow-up"></i></button>
                    <button class="reorder-btn" onclick="moveItemDown(this)" title="Move Down"><i class="fas fa-arrow-down"></i></button>
                    <button class="add-bbox-btn" onclick="addAnswerImageBefore(this)" title="Add Image Before">
                        <i class="fas fa-plus"></i> Before
                    </button>
                    <button class="add-bbox-btn" onclick="addAnswerImageAfter(this)" title="Add Image After">
                        <i class="fas fa-plus"></i> After
                    </button>
                    <button class="add-btn" onclick="openBboxDrawer(this)" title="Open PDF viewer to draw bounding box"><i class="fas fa-pen-square"></i> Draw</button>
                    <button class="add-btn" onclick="pasteBboxJson(this)" title="Paste bounding box coordinates from clipboard"><i class="fas fa-paste"></i> Paste</button>
                    <button class="add-btn" onclick="copyBboxJson(this)" title="Copy bounding box coordinates to clipboard"><i class="fas fa-copy"></i> Copy</button>
                    <button class="duplicate-btn" onclick="duplicateBbox(this)" title="Duplicate Image"><i class="fas fa-clone"></i></button>
                    <button class="remove-btn" onclick="removeArrayItem(this)"></button>
                </div>
            `;
            container.insertBefore(newItem, currentItem.nextSibling);
            
            // Record action for undo/redo (after adding to DOM so we have the actual element)
            recordFormAction({
                type: ACTION_TYPES.ADD_ITEM,
                element: newItem,
                parent: container,
                nextSibling: newItem.nextSibling,
                containerId: null,
                updateNumbers: false
            });
            
            attachBboxValidationToItem(newItem);
        }

        // Helper function to attach bbox validation to a single item
        function attachBboxValidationToItem(item) {
            const coordinateInputs = item.querySelectorAll('.bbox-x0, .bbox-y0, .bbox-x1, .bbox-y1');
            coordinateInputs.forEach(input => {
                const handler = function() {
                    validateAndNormalizeBbox(item);
                };
                input.addEventListener('blur', handler);
                input.__bboxValidationHandler = handler;
            });
        }

        // Render Markdown + LaTeX into preview container
        function renderLivePreview(textarea) {
            // Find preview box by walking through siblings (skip buttons, error divs, and labels)
            let nextSibling = textarea.nextElementSibling;
            let preview = null;
            
            // Skip over buttons, error divs, and labels to find preview label or preview
            while (nextSibling) {
                if (nextSibling.tagName === 'BUTTON') {
                    // Skip buttons
                    nextSibling = nextSibling.nextElementSibling;
                } else if (nextSibling.classList && (
                    nextSibling.classList.contains('preview-label') ||
                    nextSibling.classList.contains('table-validation-errors') ||
                    nextSibling.classList.contains('list-validation-errors') ||
                    nextSibling.classList.contains('blockquote-validation-errors') ||
                    nextSibling.classList.contains('latex-validation-errors') ||
                    nextSibling.classList.contains('image-validation-errors') ||
                    nextSibling.classList.contains('quote-validation-errors') ||
                    nextSibling.classList.contains('br-validation-errors')
                )) {
                    // Skip labels and error validation divs, continue to preview
                    nextSibling = nextSibling.nextElementSibling;
                } else if (nextSibling.classList && nextSibling.classList.contains('live-preview')) {
                    // Found preview!
                    preview = nextSibling;
                    break;
                } else {
                    // Unknown element, stop looking
                    break;
                }
            }
            
            if (!preview) return;
            
            // Always sync preview direction with textarea direction
            const isLTR = textarea.hasAttribute('data-ltr');
            const direction = isLTR ? 'ltr' : 'rtl';
            const textAlign = isLTR ? 'left' : 'right';
            preview.setAttribute('dir', direction);
            preview.style.textAlign = textAlign;
            
            try {
                // Normalize CRLF
                let md = (textarea.value || '').replace(/\r\n?/g, '\n');
                // Extract $$\n...\n$$ or $$ \n...\n $$ blocks to protect content from Markdown munging
                const mathBlocks = [];
                const mathBlockErrors = [];
                const imageDescriptionErrors = [];
                const quoteValidationErrors = [];
                const brTagErrors = [];
                
                // Validate quotes and dollar signs before processing markdown
                const rawValue = textarea.value || '';
                const quoteErrors = validateQuotes(rawValue);
                if (quoteErrors.length > 0) {
                    quoteValidationErrors.push(...quoteErrors);
                }
                
                const dollarErrors = validateDollarSigns(rawValue);
                if (dollarErrors.length > 0) {
                    quoteValidationErrors.push(...dollarErrors);
                }
                
                // Validate <br> tags
                const brErrors = validateBrTags(rawValue);
                if (brErrors.length > 0) {
                    brTagErrors.push(...brErrors);
                }
                
                // Protect LaTeX math expressions inside image descriptions before validation
                // This prevents false positives when descriptions contain LaTeX like $...$ or $\sqrt[3]{3}$
                const latexPlaceholders = [];
                let placeholderIndex = 0;
                
                // First, protect ALL inline math $...$ in the entire text
                // This must happen BEFORE we try to match image patterns, because LaTeX can contain brackets
                // that would confuse the image pattern matching (e.g., $\sqrt[3]{16}$)
                md = md.replace(/\$([^$\n]{1,200}?)\$/g, (mathMatch, mathContent) => {
                    // Only protect if it looks like actual math (has some content and isn't just $$)
                    if (mathContent.trim().length > 0) {
                        const placeholder = `@@LATEX_INLINE_IMG_${placeholderIndex}@@`;
                        latexPlaceholders[placeholderIndex] = mathMatch;
                        placeholderIndex++;
                        return placeholder;
                    }
                    return mathMatch; // Don't protect if it's malformed
                });
                
                // Check for malformed image syntax patterns before markdown parsing
                const malformedPatterns = [
                    { regex: /!\[([^\]]*?)\]\s+\(\d+\)/g, message: 'Space between ] and (' },
                    { regex: /!\s+\[([^\]]*?)\]\(\d+\)/g, message: 'Space between ! and [' },
                    { regex: /!\[([^\]]*?)\]\[\d+\]/g, message: 'Square brackets used instead of parentheses for index' },
                    { regex: /!\(([^)]*?)\)\(\d+\)/g, message: 'Parentheses used instead of square brackets for description' },
                    { regex: /!\{([^}]*?)\}\(\d+\)/g, message: 'Curly braces used for description' },
                    { regex: /!\[([^\]]*?)\]\{\d+\}/g, message: 'Curly braces used for index' },
                    { regex: /!\[([^\]]*?)\]\(\s+\d+\)/g, message: 'Space after opening ( in image index' },
                    { regex: /!\[([^\]]*?)\]\(\d+\s+\)/g, message: 'Space before closing ) in image index' },
                    // Removed: { regex: /!\[([^\]\n]{1,100})\(\d+\)/g, message: 'Missing closing ] bracket' },
                    // This pattern caused false positives when descriptions contained patterns like "f(0)" or "g(1)"
                    { regex: /!([a-zA-Z][^\[\]\n]{0,100})\]\(\d+\)/g, message: 'Missing opening [ bracket' },
                    { regex: /!\[([^\]]*?)\]\d+\)/g, message: 'Missing opening ( parenthesis' },
                    { regex: /!\[([^\]]*?)\]\(\d+[^\)\s]/g, message: 'Missing closing ) or extra characters' },
                    { regex: /!\[([^\]]*?)\]\(\d+$/gm, message: 'Missing closing ) parenthesis' },
                    { regex: /(?<![!\w])\[([^\]]{1,100})\]\(\d+\)/g, message: 'Missing ! at the beginning' }
                ];
                
                malformedPatterns.forEach(pattern => {
                    md = md.replace(pattern.regex, (match) => {
                        const errorIdx = imageDescriptionErrors.push({
                            type: 'malformed_syntax',
                            message: pattern.message,
                            match: match
                        }) - 1;
                        return `@@IMAGE_DESCRIPTION_ERROR_${errorIdx}@@`;
                    });
                });
                
                // Restore LaTeX math expressions after validation
                latexPlaceholders.forEach((latex, idx) => {
                    md = md.replace(`@@LATEX_INLINE_IMG_${idx}@@`, latex);
                });
                
                // Check for newlines in image descriptions before markdown parsing
                // Use the protected version to check for newlines (LaTeX is already protected)
                md = md.replace(/!\[([\s\S]*?)\]\((\d+)\)/g, (m, desc, idx) => {
                    // Restore LaTeX in description to check for actual newlines
                    let descToCheck = desc;
                    latexPlaceholders.forEach((latex, idx) => {
                        descToCheck = descToCheck.replace(`@@LATEX_INLINE_IMG_${idx}@@`, latex);
                    });
                    
                    // Check for block LaTeX ($$\n...\n$$) in image description - not allowed
                    if (descToCheck.includes('$$')) {
                        const errorIdx = imageDescriptionErrors.push({
                            type: 'block_latex_in_description',
                            message: 'Block LaTeX ($$\\n...\\n$$) is not allowed in image descriptions. Use inline LaTeX ($...$) instead',
                            description: descToCheck,
                            index: idx
                        }) - 1;
                        // Replace with placeholder that will show error
                        return `@@IMAGE_DESCRIPTION_ERROR_${errorIdx}@@`;
                    }
                    
                    // Remove all LaTeX expressions (inline and block) before checking for newlines
                    // This ensures LaTeX commands like \neq or \right( don't trigger false positives
                    const descWithoutMath = removeMathExpressions(descToCheck);
                    // Check if description contains newlines (both literal \n and actual newlines)
                    // Only check the parts outside of LaTeX expressions
                    if (descWithoutMath.includes('\n') || descWithoutMath.includes('\r') || descWithoutMath.includes('\\n') || descWithoutMath.includes('\\r')) {
                        const errorIdx = imageDescriptionErrors.push({
                            type: 'newline_in_description',
                            message: 'Image description cannot contain newline characters',
                            description: descToCheck,
                            index: idx
                        }) - 1;
                        // Replace with placeholder that will show error
                        return `@@IMAGE_DESCRIPTION_ERROR_${errorIdx}@@`;
                    }
                    return m;
                });
                
                // First, check for old format $$...$$ (without newlines) and show error
                md = md.replace(/\$\$([\s\S]*?)\$\$/g, (m, inner) => {
                    // Skip if this is already a valid newline format
                    if (m.match(/^\$\$\s*\\n[\s\S]*?\\n\s*\$\$$/)) {
                        return m; // Let the main regex handle it
                    }
                    // This is the old format without newlines - show error
                    const errorIdx = mathBlockErrors.push({
                        type: 'incorrect_delimiters',
                        message: 'Block latex must use newline delimiters: $$\\n...\\n$$ or $$ \\n...\\n $$',
                        content: inner
                    }) - 1;
                    return `@@MATH_BLOCK_ERROR_${errorIdx}@@`;
                });
                
                md = md.replace(/\$\$\s*\\n([\s\S]*?)\\n\s*\$\$/g, (m, inner) => {
                    // Check for extra newlines inside the block latex content (both literal \n and actual newlines)
                    if (inner.includes('\\n') || inner.includes('\n')) {
                        const errorIdx = mathBlockErrors.push({
                            type: 'extra_newlines',
                            message: 'Block latex cannot contain extra newline characters inside the content',
                            content: inner
                        }) - 1;
                        return `@@MATH_BLOCK_ERROR_${errorIdx}@@`;
                    }
                    // Check for empty content
                    if (inner.trim().length === 0) {
                        const errorIdx = mathBlockErrors.push({
                            type: 'empty_content',
                            message: 'Block latex cannot be empty',
                            content: inner
                        }) - 1;
                        return `@@MATH_BLOCK_ERROR_${errorIdx}@@`;
                    }
                    let fixed = inner.replace(/\\n/g, '\n').trim();
                    // Escape < and > symbols to prevent HTML interpretation issues
                    fixed = fixed.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                    const hasEnv = /\\begin\{(aligned|align\*?|gather\*?)\}/.test(fixed);
                    const hasLineBreaks = /\\\\/.test(fixed); // contains \\
                    if (hasLineBreaks && !hasEnv) {
                        fixed = `\\begin{aligned}\n${fixed}\n\\end{aligned}`;
                    }
                    const idx = mathBlocks.push(fixed) - 1;
                    return `@@MATH_BLOCK_${idx}@@`;
                });
                if (window.marked?.setOptions) {
                    window.marked.setOptions({ gfm: true, breaks: true });
                }
                // Protect inline math $...$ before markdown parsing to avoid backslash escapes like \, turning into commas
                // Increased limit to handle long expressions like arrays (was 200, now 5000)
                const inlineMath = [];
                md = md.replace(/(^|[^$])\$\s*([^$\n]{1,5000}?)\s*\$(?!\$)/g, (m, pre, inner) => {
                    // Only process if we have a valid closing $ and reasonable content length
                    if (inner.trim().length === 0) return m; // Don't process empty math
                    // Escape < and > symbols to prevent HTML interpretation issues
                    const escapedInner = inner.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                    return `${pre}@@INLINE_MATH_${inlineMath.push(escapedInner)-1}@@`;
                });
                
                // Fix blockquotes: join consecutive lines unless separated by blank ">"
                // Process blockquotes line by line
                const lines = md.split('\n');
                let processedLines = [];
                let inBlockquotePre = false;
                let blockquoteBuffer = [];
                
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    const isBlockquoteLine = /^>($| )/.test(line);
                    const isBlankBlockquote = line.trim() === '>';
                    const isBlankLine = line.trim() === '';
                    const nextLine = i < lines.length - 1 ? lines[i + 1] : '';
                    const nextIsBlockquote = /^>($| )/.test(nextLine);
                    
                    if (isBlockquoteLine) {
                        if (!inBlockquotePre) {
                            // Start of blockquote section
                            inBlockquotePre = true;
                            blockquoteBuffer = [];
                        }
                        
                        if (isBlankBlockquote) {
                            // Blank ">" creates a paragraph break
                            // Flush current buffer
                            if (blockquoteBuffer.length > 0) {
                                processedLines.push('> ' + blockquoteBuffer.join(' '));
                                blockquoteBuffer = [];
                            }
                            // Add blank line in blockquote
                            processedLines.push('> ');
                        } else {
                            // Regular blockquote line - extract text after "> "
                            const text = line.substring(1).trim();
                            if (text) {
                                blockquoteBuffer.push(text);
                            }
                            
                            // If next line is not a blockquote or is blank ">", flush buffer
                            if (!nextIsBlockquote || nextLine.trim() === '>') {
                                if (blockquoteBuffer.length > 0) {
                                    processedLines.push('> ' + blockquoteBuffer.join(' '));
                                    blockquoteBuffer = [];
                                }
                            }
                        }
                    } else if (isBlankLine) {
                        // Blank line ends blockquote - flush buffer
                        if (blockquoteBuffer.length > 0) {
                            processedLines.push('> ' + blockquoteBuffer.join(' '));
                            blockquoteBuffer = [];
                        }
                        inBlockquotePre = false;
                        processedLines.push(line);
                    } else {
                        // Non-blockquote line - flush buffer and add line
                        if (blockquoteBuffer.length > 0) {
                            processedLines.push('> ' + blockquoteBuffer.join(' '));
                            blockquoteBuffer = [];
                        }
                        inBlockquotePre = false;
                        processedLines.push(line);
                    }
                }
                
                // Flush any remaining buffer
                if (blockquoteBuffer.length > 0) {
                    processedLines.push('> ' + blockquoteBuffer.join(' '));
                }
                
                md = processedLines.join('\n');
                
                // Fix horizontal rules: only allow them if they have blank lines before AND after
                // Escape horizontal rules that don't meet this requirement
                const hrLines = md.split('\n');
                const hrProcessed = [];
                for (let i = 0; i < hrLines.length; i++) {
                    const line = hrLines[i];
                    const trimmed = line.trim();
                    const isHorizontalRule = /^[-*_]{3,}$/.test(trimmed);
                    
                    if (isHorizontalRule) {
                        const prevLine = i > 0 ? hrLines[i - 1] : '';
                        const nextLine = i < hrLines.length - 1 ? hrLines[i + 1] : '';
                        const prevIsBlank = prevLine.trim() === '';
                        const nextIsBlank = nextLine.trim() === '';
                        
                        // Only allow horizontal rule if both prev and next lines are blank
                        if (prevIsBlank && nextIsBlank) {
                            hrProcessed.push(line);
                        } else {
                            // Escape it by adding a backslash or converting to text
                            hrProcessed.push('\\' + line);
                        }
                    } else {
                        hrProcessed.push(line);
                    }
                }
                
                md = hrProcessed.join('\n');
                
                // Merge multi-line table rows before markdown processing
                // This allows cells to contain newlines while still being valid markdown tables
                const mdLinesForTableMerge = md.split('\n');
                const mergedTableLines = [];
                let currentTableRow = null;
                let inTable = false; // Track if we're currently inside a table
                
                for (let i = 0; i < mdLinesForTableMerge.length; i++) {
                    const line = mdLinesForTableMerge[i];
                    const trimmed = line.trim();
                    
                    // Remove math expressions for detection
                    let lineWithoutMath = removeMathExpressions(trimmed);
                    
                    // Check if line is a table row
                    const startsWithPipe = lineWithoutMath.startsWith('|');
                    const hasPipes = lineWithoutMath.includes('|') && lineWithoutMath.split('|').length >= 3;
                    const endsWithPipe = lineWithoutMath.endsWith('|');
                    const isSeparator = /^[\s|:-]+$/.test(lineWithoutMath) && lineWithoutMath.includes('-');
                    
                    // Check if original line (before removing math) starts with pipe
                    // This is used for continuation detection - a line starting with LaTeX should still be a continuation
                    const originalStartsWithPipe = trimmed.startsWith('|');
                    
                    // If we have an incomplete row and this line doesn't start with pipe in original,
                    // it's a continuation even if it has pipes after removing math
                    // Can only be a continuation if currentTableRow exists and doesn't end with |
                    const isContinuation = currentTableRow !== null && 
                        !originalStartsWithPipe && 
                        currentTableRow.trim() !== '' && 
                        !currentTableRow.trim().endsWith('|');
                    
                    // Empty lines always end tables
                    const isEmptyLine = trimmed.length === 0;
                    
                    // Determine if this line is part of a table
                    // If it's a continuation, treat it as part of the table
                    // Empty lines are NEVER table lines
                    const isTableLine = !isEmptyLine && ((hasPipes || (startsWithPipe && inTable)) && !isContinuation);
                    
                    if ((isTableLine || isSeparator || isContinuation) && !isEmptyLine) {
                        // We're in a table
                        inTable = true;
                        
                        if (isSeparator) {
                            // Separator row - finish any incomplete row first
                            if (currentTableRow !== null) {
                                mergedTableLines.push(currentTableRow);
                                currentTableRow = null;
                            }
                            mergedTableLines.push(line);
                        } else if (isContinuation) {
                            // Continuation of incomplete row (doesn't start with pipe, even if it has pipes)
                            currentTableRow = currentTableRow + '\n' + line;
                        } else if (startsWithPipe) {
                            // Table row starting with pipe
                            if (endsWithPipe) {
                                // Complete row
                                if (currentTableRow !== null) {
                                    // Finish previous incomplete row
                                    mergedTableLines.push(currentTableRow);
                                    currentTableRow = null;
                                }
                                mergedTableLines.push(line);
                            } else {
                                // Incomplete row - start or continue
                                if (currentTableRow === null) {
                                    currentTableRow = line;
                                } else {
                                    // Continue previous row
                                    currentTableRow = currentTableRow + '\n' + line;
                                }
                            }
                        } else {
                            // Shouldn't happen, but handle it
                            mergedTableLines.push(line);
                        }
                    } else {
                        // Not a table line - always end table mode
                        if (currentTableRow !== null) {
                            // Finish incomplete row
                            mergedTableLines.push(currentTableRow);
                            currentTableRow = null;
                        }
                        // Always exit table mode when we encounter non-table content
                        inTable = false;
                        mergedTableLines.push(line);
                    }
                }
                
                // Finish any remaining incomplete row
                if (currentTableRow !== null) {
                    mergedTableLines.push(currentTableRow);
                }
                
                // Convert newlines within merged table rows to <br> tags
                // This preserves line breaks within cells for proper rendering
                // We need to be careful: only convert newlines that are within cells, not between rows
                for (let i = 0; i < mergedTableLines.length; i++) {
                    let line = mergedTableLines[i];
                    // Check if this line contains newlines (from merging multi-line cells)
                    if (line.includes('\n')) {
                        // This is a merged table row with newlines - convert them to <br>
                        // The newlines are within the row content (cell content), so convert them
                        // This will create: | Cell 1<br>continued | Cell 2 |
                        line = line.replace(/\n/g, '<br>');
                        mergedTableLines[i] = line;
                    }
                }
                
                md = mergedTableLines.join('\n');
                
                // Preserve multiple consecutive newlines by converting them to <br> tags
                // BUT preserve markdown block syntax boundaries (blockquotes, horizontal rules, headers, lists, code blocks)
                // Find all markdown block sections and mark their boundaries
                const mdLines = md.split('\n');
                let markedMd = [];
                let inBlockquote = false;
                let inCodeBlock = false;
                
                // Helper function to check if a line is a markdown block element
                const isMarkdownBlockElement = (line) => {
                    const trimmed = line.trim();
                    return (
                        /^#{1,6}\s/.test(trimmed) ||  // Headers: # ## ### etc
                        /^[-*_]{3,}$/.test(trimmed) ||  // Horizontal rules: --- *** ___
                        /^[*+-]\s/.test(trimmed) ||  // Unordered lists: - * +
                        /^\d+\.\s/.test(trimmed) ||  // Ordered lists: 1. 2.
                        /^```/.test(trimmed) ||  // Code blocks: ```
                        /^>($| )/.test(line) ||  // Blockquotes: > or > text
                        /^\|.*\|/.test(trimmed)  // Tables: | cell | cell |
                    );
                };
                
                for (let i = 0; i < mdLines.length; i++) {
                    const line = mdLines[i];
                    const trimmed = line.trim();
                    const isBlockquoteLine = /^>($| )/.test(line);
                    const isBlankLine = trimmed === '';
                    const isCodeBlockDelimiter = /^```/.test(trimmed);
                    const nextLine = i < mdLines.length - 1 ? mdLines[i + 1] : '';
                    const nextIsBlockquote = /^>($| )/.test(nextLine);
                    const nextIsBlank = nextLine.trim() === '';
                    const nextIsMarkdownBlock = isMarkdownBlockElement(nextLine);
                    const prevLine = i > 0 ? mdLines[i - 1] : '';
                    const prevIsBlank = prevLine.trim() === '';
                    const prevIsMarkdownBlock = isMarkdownBlockElement(prevLine);
                    
                    // Track code block state
                    if (isCodeBlockDelimiter) {
                        inCodeBlock = !inCodeBlock;
                        markedMd.push(line);
                        continue;
                    }
                    
                    // Don't process anything inside code blocks
                    if (inCodeBlock) {
                        markedMd.push(line);
                        continue;
                    }
                    
                    if (isBlockquoteLine) {
                        inBlockquote = true;
                        markedMd.push(line);
                    } else if (isBlankLine) {
                        // Check if this blank line is adjacent to any markdown block element
                        if (nextIsMarkdownBlock && !inBlockquote) {
                            // Blank line before markdown block - mark it to preserve
                            markedMd.push('@@MARKDOWN_BOUNDARY@@');
                        } else if (prevIsMarkdownBlock) {
                            // Blank line after markdown block - mark it to preserve
                            markedMd.push('@@MARKDOWN_BOUNDARY@@');
                            if (inBlockquote && !nextIsBlockquote) {
                                inBlockquote = false;
                            }
                        } else if (inBlockquote) {
                            // Blank line inside or after blockquote
                            if (!nextIsBlank && !nextIsBlockquote) {
                                markedMd.push('@@MARKDOWN_BOUNDARY@@');
                                inBlockquote = false;
                            } else if (nextIsBlank) {
                                markedMd.push('@@MARKDOWN_BOUNDARY@@');
                                inBlockquote = false;
                            } else {
                                markedMd.push(line);
                            }
                        } else {
                            // Regular blank line not near markdown blocks
                            markedMd.push(line);
                        }
                    } else {
                        if (inBlockquote && !isBlockquoteLine) {
                            inBlockquote = false;
                        }
                        markedMd.push(line);
                    }
                }
                
                md = markedMd.join('\n');
                
                // Now convert 2+ newlines to <br> tags, but skip markdown boundary markers
                md = md.replace(/\n{2,}/g, (match) => {
                    const count = match.length;
                    return '<br>'.repeat(count);
                });
                
                // Restore markdown boundary markers as \n\n for proper markdown parsing
                md = md.replace(/@@MARKDOWN_BOUNDARY@@/g, '\n\n');
                
                // Preserve multiple consecutive spaces (2 or more) by converting to &nbsp;
                md = md.replace(/ {2,}/g, (match) => {
                    return '&nbsp;'.repeat(match.length);
                });

                // Protect fill-in-the-blank placeholders from markdown processing
                const blankPlaceholders = [];
                md = md.replace(/___(\d+)___/g, (match, num) => {
                    const idx = blankPlaceholders.push(num) - 1;
                    return `@@BLANK_PLACEHOLDER_${idx}@@`;
                });

                let html = window.marked?.parse ? window.marked.parse(md) : md;
                // Re-inject math placeholders as elements for KaTeX to render (block math first via string replace)
                mathBlocks.forEach((content, i) => {
                    const token = `@@MATH_BLOCK_${i}@@`;
                    const holder = `<div class="__math_block" data-math-idx="${i}" style="text-align: center; margin: 1em auto; display: block;"></div>`;
                    html = html.split(token).join(holder);
                });
                
                // Remove math block error tokens (errors now shown below preview)
                mathBlockErrors.forEach((error, i) => {
                    const token = `@@MATH_BLOCK_ERROR_${i}@@`;
                    html = html.split(token).join('');
                });
                
                // Unescape HTML entities that were escaped during math processing
                html = html.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
                
                // Fix blockquotes to end properly at blank lines
                // Check original text to determine where blockquotes should actually end
                const originalText = textarea.value || '';
                const originalLines = originalText.replace(/\r\n?/g, '\n').split('\n');
                
                // Find where blockquotes should end (at blank lines followed by non-blockquote text)
                let blockquoteShouldEndAt = [];
                let inBlockquoteCheck = false;
                
                for (let i = 0; i < originalLines.length; i++) {
                    const line = originalLines[i];
                    const isBlockquoteLine = /^>($| )/.test(line);
                    const isBlankLine = line.trim() === '';
                    const nextLine = i < originalLines.length - 1 ? originalLines[i + 1] : '';
                    const nextIsBlockquote = /^>($| )/.test(nextLine);
                    const nextIsBlank = nextLine.trim() === '';
                    
                    if (isBlockquoteLine) {
                        inBlockquoteCheck = true;
                    } else if (isBlankLine && inBlockquoteCheck && !nextIsBlank && !nextIsBlockquote) {
                        // Blank line after blockquote, followed by regular text - blockquote should end here
                        blockquoteShouldEndAt.push(i);
                        inBlockquoteCheck = false;
                    } else if (!isBlankLine && !isBlockquoteLine && inBlockquoteCheck) {
                        // Regular text immediately after blockquote (no blank line) - mark previous line as end
                        if (i > 0) {
                            blockquoteShouldEndAt.push(i - 1);
                        }
                        inBlockquoteCheck = false;
                    }
                }
                
                // Fix blockquote HTML by splitting at positions where blockquotes should end
                // Match blockquote tags and split them at the correct positions
                let blockquoteIndex = 0;
                html = html.replace(/<blockquote>([\s\S]*?)<\/blockquote>/g, (match, content) => {
                    // Check if this blockquote should be split based on original text structure
                    // Look for double <br> tags (representing blank lines) followed by content
                    // Split the blockquote at those points
                    const doubleBrRegex = /(<br\s*\/?>\s*){2,}/;
                    if (doubleBrRegex.test(content)) {
                        // Split at double <br> (blank lines)
                        const parts = content.split(doubleBrRegex);
                        if (parts.length > 1) {
                            // First part is blockquote content, rest should be outside
                            const blockquotePart = parts[0];
                            const outsidePart = parts.slice(1).filter(p => p.trim()).join('');
                            if (outsidePart.trim()) {
                                return '<blockquote>' + blockquotePart + '</blockquote><p>' + outsidePart + '</p>';
                            }
                        }
                    }
                    return match;
                });
                
                // Remove image description error tokens (errors now shown below preview)
                imageDescriptionErrors.forEach((error, i) => {
                    const token = `@@IMAGE_DESCRIPTION_ERROR_${i}@@`;
                    html = html.split(token).join('');
                });
                
                // Quote, dollar sign, and <br> tag errors are now shown below preview (not in preview HTML)
                
                // Restore fill-in-the-blank placeholders with styled HTML
                html = html.replace(/@@BLANK_PLACEHOLDER_(\d+)@@/g, (match, idx) => {
                    const blankNum = blankPlaceholders[parseInt(idx)];
                    return `<span style="display: inline-block; padding: 2px 8px; margin: 0 2px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border-radius: 4px; font-weight: 600; font-size: 0.9em; box-shadow: 0 2px 4px rgba(0,0,0,0.2);">Blank #${blankNum}</span>`;
                });
                
                // Don't add label here - it's already outside the preview box
                preview.innerHTML = html;
                // Handle all images - replace with styled placeholder and show description
                const imgs = preview.querySelectorAll('img[alt]');
                imgs.forEach(img => {
                    const alt = img.getAttribute('alt') || '';
                    
                    // Create a container div to wrap the image and description
                    const container = document.createElement('div');
                    container.style.display = 'block';
                    container.style.textAlign = 'center';
                    container.style.margin = '0 auto';
                    
                    // Create a span to hold the image description (caption)
                    const captionSpan = document.createElement('span');
                    captionSpan.className = 'image-description-math';
                    captionSpan.style.display = 'block';
                    captionSpan.style.marginTop = '4px';
                    captionSpan.style.direction = 'ltr';
                    
                    // Replace the broken image with a styled placeholder div
                    const placeholder = document.createElement('div');
                    placeholder.style.width = '200px';
                    placeholder.style.height = '150px';
                    placeholder.style.backgroundColor = '#f0f0f0';
                    placeholder.style.border = '2px dashed #ccc';
                    placeholder.style.borderRadius = '4px';
                    placeholder.style.display = 'flex';
                    placeholder.style.alignItems = 'center';
                    placeholder.style.justifyContent = 'center';
                    placeholder.style.margin = '0 auto';
                    placeholder.innerHTML = '<span style="color: #999; font-size: 14px;"> Image</span>';
                    
                    // Process the alt text
                    if (alt.includes('@@INLINE_MATH_')) {
                        // Handle LaTeX in alt text
                        const parts = alt.split(/@@INLINE_MATH_(\d+)@@/);
                        parts.forEach((part, idx) => {
                            if (idx % 2 === 0) {
                                if (part) captionSpan.appendChild(document.createTextNode(part));
                            } else {
                                const span = document.createElement('span');
                                span.className = '__math_inline';
                                span.setAttribute('data-im', part);
                                captionSpan.appendChild(span);
                            }
                        });
                    } else {
                        // Plain text description
                        if (alt) captionSpan.appendChild(document.createTextNode(alt));
                    }
                    
                    // Wrap in the container
                    img.parentElement.replaceChild(container, img);
                    container.appendChild(placeholder);
                    if (captionSpan.firstChild) {
                        container.appendChild(captionSpan);
                    }
                });
                // Replace inline math placeholders only in text nodes (avoid attributes)
                const walker = document.createTreeWalker(preview, NodeFilter.SHOW_TEXT, null);
                const textNodes = [];
                while (walker.nextNode()) textNodes.push(walker.currentNode);
                const inlineRe = /@@INLINE_MATH_(\d+)@@/g;
                textNodes.forEach(node => {
                    const text = node.nodeValue;
                    if (!inlineRe.test(text)) return;
                    inlineRe.lastIndex = 0;
                    const frag = document.createDocumentFragment();
                    let lastIndex = 0;
                    let match;
                    while ((match = inlineRe.exec(text)) !== null) {
                        const before = text.slice(lastIndex, match.index);
                        if (before) frag.appendChild(document.createTextNode(before));
                        const idx = parseInt(match[1], 10);
                        const span = document.createElement('span');
                        span.className = '__math_inline';
                        span.setAttribute('data-im', String(idx));
                        frag.appendChild(span);
                        lastIndex = match.index + match[0].length;
                    }
                    const after = text.slice(lastIndex);
                    if (after) frag.appendChild(document.createTextNode(after));
                    node.parentNode.replaceChild(frag, node);
                });
                
                // Also unescape any remaining HTML entities in text nodes that weren't part of math
                textNodes.forEach(node => {
                    if (node.parentNode && node.parentNode.classList.contains('__math_inline')) {
                        // Skip math nodes as they'll be handled by KaTeX
                        return;
                    }
                    const text = node.nodeValue;
                    if (text.includes('&lt;') || text.includes('&gt;')) {
                        const unescaped = text.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
                        if (unescaped !== text) {
                            node.nodeValue = unescaped;
                        }
                    }
                });
                // Render block math explicitly with KaTeX (displayMode)
                if (window.katex) {
                    const nodes = preview.querySelectorAll('.__math_block');
                    nodes.forEach(node => {
                        const i = parseInt(node.getAttribute('data-math-idx'), 10);
                        const originalTex = mathBlocks[i] || '';
                        const isBold = !!(node.closest('strong, b'));
                        const isItalic = !!(node.closest('em, i'));
                        let texToRender = originalTex;
                        // Avoid wrapping environments like aligned/align in macros
                        if (texToRender && !/\\begin\{[\s\S]*?\}/.test(texToRender)) {
                            if (isBold && isItalic) texToRender = `\\boldsymbol{\\mathit{${texToRender}}}`;
                            else if (isBold) texToRender = `\\boldsymbol{${texToRender}}`;
                            else if (isItalic) texToRender = `\\mathit{${texToRender}}`;
                        }
                        try { 
                            // Unescape HTML entities back to original symbols for KaTeX
                            texToRender = texToRender.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
                            window.katex.render(texToRender, node, { 
                                displayMode: true,
                                throwOnError: false,
                                output: 'html'
                            }); 
                            // Force centering after rendering
                            node.style.textAlign = 'center';
                            node.style.margin = '1em auto';
                        } catch {}
                    });
                    const inlines = preview.querySelectorAll('.__math_inline');
                    inlines.forEach(node => {
                        const i = parseInt(node.getAttribute('data-im'), 10);
                        const originalTex = inlineMath[i] || '';
                        const isBold = !!(node.closest('strong, b'));
                        const isItalic = !!(node.closest('em, i'));
                        let texToRender = originalTex;
                        if (texToRender) {
                            if (isBold && isItalic) texToRender = `\\boldsymbol{\\mathit{${texToRender}}}`;
                            else if (isBold) texToRender = `\\boldsymbol{${texToRender}}`;
                            else if (isItalic) texToRender = `\\mathit{${texToRender}}`;
                        }
                        try { 
                            // Unescape HTML entities back to original symbols for KaTeX
                            texToRender = texToRender.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
                            window.katex.render(texToRender, node, { displayMode: false }); 
                        } catch {}
                    });
                }
                // Skip auto-render for $...$ since we handled it; still support \( ... \) and \[ ... ]
                if (window.renderMathInElement) {
                    window.renderMathInElement(preview, {
                        delimiters: [
                            { left: '\\(', right: '\\)', display: false },
                            { left: '\\[', right: '\\]', display: true }
                        ]
                    });
                }
                
                // Force all LaTeX elements to be LTR regardless of parent direction
                // This ensures math expressions are always read left-to-right
                const allMathElements = preview.querySelectorAll('.__math_block, .__math_inline, .katex, .katex-display, .katex-html, .katex *');
                allMathElements.forEach(mathEl => {
                    mathEl.setAttribute('dir', 'ltr');
                    mathEl.style.direction = 'ltr';
                    mathEl.style.unicodeBidi = 'isolate';
                });
            } catch (e) {
                // fail silent to avoid blocking typing
            }
        }

        // Attach preview under each textarea and bind listeners
        function attachPreviews(root=document) {
            const nodes = [
                ...root.querySelectorAll('.text-field-container textarea, #lesson_text'),
                ...root.querySelectorAll('#lesson_title'),
                ...root.querySelectorAll('.form-group input[placeholder="Section title"]'),
                ...root.querySelectorAll('#terminology input[type="text"]')
            ];
            nodes.forEach(ta => {
                // Find existing preview by looking through all siblings (skip buttons)
                let preview = null;
                let previewLabel = null;
                let sibling = ta.nextElementSibling;
                
                // Walk through siblings to find preview label and preview
                while (sibling) {
                    if (sibling.classList && sibling.classList.contains('preview-label')) {
                        previewLabel = sibling;
                    } else if (sibling.classList && sibling.classList.contains('live-preview')) {
                        preview = sibling;
                        break; // Found preview, stop looking
                    }
                    sibling = sibling.nextElementSibling;
                }
                
                if (!preview) {
                    // No preview exists, create new one
                    // Set direction based on the textarea's direction
                    const isLTR = ta.hasAttribute('data-ltr');
                    const direction = isLTR ? 'ltr' : 'rtl';
                    const textAlign = isLTR ? 'left' : 'right';
                    const buttonText = isLTR ? 'RTL' : 'LTR';
                    
                    // Direction toggle: add if none exists in this container (for input fields)
                    const existingDirBtn = ta.parentElement.querySelector('.dir-btn');
                    if (!existingDirBtn) {
                        const dirBtn = document.createElement('button');
                        dirBtn.type = 'button';
                        dirBtn.className = 'dir-btn';
                        dirBtn.textContent = buttonText;
                        dirBtn.title = 'Toggle direction RTL/LTR';
                        dirBtn.onclick = () => toggleDirection(ta);
                        dirBtn.style.marginTop = '8px';
                        dirBtn.style.marginBottom = '8px';
                        ta.parentElement.insertBefore(dirBtn, ta.nextSibling);
                    }
                    
                    // Create preview label
                    previewLabel = document.createElement('label');
                    previewLabel.className = 'preview-label';
                    previewLabel.textContent = 'Output Preview';
                    
                    // Create preview element
                    const previewEl = document.createElement('div');
                    previewEl.className = 'live-preview';
                    previewEl.setAttribute('dir', direction);
                    previewEl.style.textAlign = textAlign;
                    
                    // Find insertion point after all buttons
                    let insertPoint = ta.nextSibling;
                    while (insertPoint && (insertPoint.nodeType === 3 || (insertPoint.tagName && insertPoint.tagName === 'BUTTON'))) {
                        insertPoint = insertPoint.nextSibling;
                    }
                    
                    // Insert preview label after buttons
                    ta.parentElement.insertBefore(previewLabel, insertPoint);
                    
                    // Insert preview element after label
                    ta.parentElement.insertBefore(previewEl, previewLabel.nextSibling);
                    
                    preview = previewEl;
                } else {
                    // Preview exists, just update its properties
                    const isLTR = ta.hasAttribute('data-ltr');
                    const direction = isLTR ? 'ltr' : 'rtl';
                    const textAlign = isLTR ? 'left' : 'right';
                    
                    preview.setAttribute('dir', direction);
                    preview.style.textAlign = textAlign;
                    
                    // Ensure preview label exists before preview
                    if (!previewLabel) {
                        previewLabel = document.createElement('label');
                        previewLabel.className = 'preview-label';
                        previewLabel.textContent = 'Output Preview';
                        preview.parentElement.insertBefore(previewLabel, preview);
                    }
                }
                
                // Ensure textarea direction matches its data-ltr attribute
                const isLTR = ta.hasAttribute('data-ltr');
                const direction = isLTR ? 'ltr' : 'rtl';
                ta.setAttribute('dir', direction);
                
                // Initial render and event binding
                renderLivePreview(ta);
                ta.removeEventListener('input', ta.__livePreviewHandler || (()=>{}));
                const handler = () => {
                    renderLivePreview(ta);
                    // Show validation errors for all types
                    showTableValidationErrors(ta);
                    showListValidationErrors(ta);
                    showBlockquoteValidationErrors(ta);
                    showLatexValidationErrors(ta);
                    showImageValidationErrors(ta);
                    showQuoteValidationErrors(ta);
                    showBrTagValidationErrors(ta);
                };
                ta.addEventListener('input', handler);
                ta.__livePreviewHandler = handler;
                
                // Show validation errors on initial load
                showTableValidationErrors(ta);
                showListValidationErrors(ta);
                showBlockquoteValidationErrors(ta);
                showLatexValidationErrors(ta);
                showImageValidationErrors(ta);
                showQuoteValidationErrors(ta);
                showBrTagValidationErrors(ta);
                
                // Add auto-resize functionality to textareas
                autoResizeTextarea(ta);
            });
        }

        // Global state for auto-resize feature
        let autoResizeEnabled = true; // Default to enabled
        
        // Auto-resize textarea to fit content
        function autoResizeTextarea(textarea) {
            if (!textarea || textarea.tagName !== 'TEXTAREA') return;
            
            // Skip JSON input textarea (used for loading JSON)
            if (textarea.id === 'json_input') return;
            
            // If auto-resize is disabled, remove handlers if they exist and return
            if (!autoResizeEnabled) {
                if (textarea.__autoResizeHandler) {
                    textarea.removeEventListener('input', textarea.__autoResizeHandler);
                    textarea.removeEventListener('focus', textarea.__autoResizeHandler);
                    textarea.__autoResizeHandler = null;
                }
                // Set a fixed minimum height but allow manual resizing
                if (!textarea.style.height || textarea.style.height === 'auto') {
                    textarea.style.height = '80px'; // Default min-height
                }
                return;
            }
            
            // Set initial height based on content
            const resize = () => {
                // Only auto-resize if the textarea hasn't been manually resized below its content
                // Check if current height is less than scrollHeight (user manually made it smaller)
                const currentHeight = textarea.offsetHeight;
                const scrollHeight = textarea.scrollHeight;
                
                // Always update to fit content (scrollbar will show if manually resized smaller)
                textarea.style.height = 'auto';
                textarea.style.height = scrollHeight + 'px';
            };
            
            // Resize on input
            if (!textarea.__autoResizeHandler) {
                textarea.__autoResizeHandler = resize;
                textarea.addEventListener('input', resize);
                // Also resize on focus (in case value was set programmatically)
                textarea.addEventListener('focus', resize);
                // Initial resize
                setTimeout(resize, 0);
            } else {
                // If handler already exists, just trigger a resize
                resize();
            }
        }
        
        // Auto-resize all textareas in a container
        function autoResizeAllTextareas(container = document) {
            const textareas = container.querySelectorAll('textarea');
            textareas.forEach(ta => {
                autoResizeTextarea(ta);
            });
        }
        
        // Toggle auto-resize feature
        function toggleAutoResize() {
            autoResizeEnabled = !autoResizeEnabled;
            const toggle = document.getElementById('autoResizeToggle');
            const icon = toggle.querySelector('i');
            
            // Keep original icon, just change background color
            if (autoResizeEnabled) {
                // ON state: Green background
                toggle.title = 'Auto-Resize: ON (Click to disable)';
                toggle.style.background = 'rgba(40, 167, 69, 0.8)'; // Green background
                toggle.style.borderColor = 'rgba(255, 255, 255, 0.9)';
            } else {
                // OFF state: Red background
                toggle.title = 'Auto-Resize: OFF (Click to enable)';
                toggle.style.background = 'rgba(220, 53, 69, 0.8)'; // Red background
                toggle.style.borderColor = 'rgba(255, 255, 255, 0.9)';
            }
            
            trackEvent('feature_toggled', { feature: 'auto_resize', enabled: autoResizeEnabled });
            
            // Save preference to localStorage
            localStorage.setItem('autoResizeEnabled', autoResizeEnabled ? 'true' : 'false');
            
            // Apply to all existing textareas
            autoResizeAllTextareas();
        }
        
        // Initialize auto-resize state from localStorage
        function initializeAutoResize() {
            const saved = localStorage.getItem('autoResizeEnabled');
            if (saved !== null) {
                autoResizeEnabled = saved === 'true';
            } else {
                autoResizeEnabled = true; // Default to enabled
            }
            
            const toggle = document.getElementById('autoResizeToggle');
            if (toggle) {
                const icon = toggle.querySelector('i');
                // Keep original icon, just change background color
                if (autoResizeEnabled) {
                    // ON state: Green background
                    toggle.title = 'Auto-Resize: ON (Click to disable)';
                    toggle.style.background = 'rgba(40, 167, 69, 0.8)'; // Green background
                    toggle.style.borderColor = 'rgba(255, 255, 255, 0.9)';
                } else {
                    // OFF state: Red background
                    toggle.title = 'Auto-Resize: OFF (Click to enable)';
                    toggle.style.background = 'rgba(220, 53, 69, 0.8)'; // Red background
                    toggle.style.borderColor = 'rgba(255, 255, 255, 0.9)';
                }
            }
        }

        function toggleDirection(textarea) {
            // Toggle the data-ltr attribute to switch between RTL and LTR
            const isLTR = textarea.hasAttribute('data-ltr');
            if (isLTR) {
                // Currently LTR, switch to RTL
                textarea.removeAttribute('data-ltr');
                textarea.setAttribute('dir', 'rtl');
            } else {
                // Currently RTL, switch to LTR
                textarea.setAttribute('data-ltr', 'true');
                textarea.setAttribute('dir', 'ltr');
            }
            
            // Find preview box by walking through siblings (skip buttons, labels, and error divs)
            let nextSibling = textarea.nextElementSibling;
            let preview = null;
            
            // Skip over buttons, error divs, and labels to find preview
            while (nextSibling) {
                if (nextSibling.tagName === 'BUTTON') {
                    // Skip buttons
                    nextSibling = nextSibling.nextElementSibling;
                } else if (nextSibling.classList && (
                    nextSibling.classList.contains('table-validation-errors') ||
                    nextSibling.classList.contains('list-validation-errors') ||
                    nextSibling.classList.contains('blockquote-validation-errors') ||
                    nextSibling.classList.contains('latex-validation-errors') ||
                    nextSibling.classList.contains('image-validation-errors') ||
                    nextSibling.classList.contains('quote-validation-errors') ||
                    nextSibling.classList.contains('br-validation-errors')
                )) {
                    // Skip validation error divs
                    nextSibling = nextSibling.nextElementSibling;
                } else if (nextSibling.classList && nextSibling.classList.contains('preview-label')) {
                    // Skip label, continue to preview
                    nextSibling = nextSibling.nextElementSibling;
                } else if (nextSibling.classList && nextSibling.classList.contains('live-preview')) {
                    // Found preview!
                    preview = nextSibling;
                    break;
                } else {
                    // Unknown element, stop looking
                    break;
                }
            }
            
            if (preview) {
                const newDir = textarea.hasAttribute('data-ltr') ? 'ltr' : 'rtl';
                preview.setAttribute('dir', newDir);
                preview.style.textAlign = newDir === 'rtl' ? 'right' : 'left';
                // Re-render preview to ensure direction is applied to content
                renderLivePreview(textarea);
            }
            
            // Update button label: find the dir button in this container
            const container = textarea.closest('.text-field-container') || textarea.parentElement;
            const btn = container ? container.querySelector('.dir-btn') : null;
            if (btn) {
                // Button shows what clicking it will do
                btn.textContent = textarea.hasAttribute('data-ltr') ? 'RTL' : 'LTR';
            }
        }

        // Font Settings Functions
        // Apply font settings to specific elements or all elements
        function applyFontSettings(container) {
            const savedFontSize = localStorage.getItem('fontSize') || '14';
            const savedLineHeight = localStorage.getItem('lineHeight') || '1.5';
            const fontSize = savedFontSize + 'px';
            const lineHeight = savedLineHeight;
            
            // Get elements from container or entire document
            const scope = container || document;
            
            // Apply to all textareas and inputs in scope, but exclude search bar and JSON input
            scope.querySelectorAll('.form-group textarea, .form-group input[type="text"], textarea, input[type="text"]').forEach(el => {
                // Exclude search bar and JSON input from font settings
                if (el.id === 'searchFilter' || el.id === 'json_input') {
                    return; // Skip these elements
                }
                el.style.fontSize = fontSize;
                el.style.lineHeight = lineHeight;
            });
            
            // Apply to all preview boxes in scope
            scope.querySelectorAll('.live-preview').forEach(el => {
                el.style.fontSize = fontSize;
                el.style.lineHeight = lineHeight;
            });
        }
        
        function changeFontSize(size) {
            // Ensure size is a string
            const sizeStr = String(size);
            const fontSize = sizeStr + 'px';
            
            // Apply to all textareas and inputs, but exclude search bar and JSON input
            document.querySelectorAll('.form-group textarea, .form-group input[type="text"], textarea, input[type="text"]').forEach(el => {
                // Exclude search bar and JSON input from font size changes
                if (el.id === 'searchFilter' || el.id === 'json_input') {
                    return; // Skip these elements
                }
                el.style.fontSize = fontSize;
            });
            // Apply to all preview boxes
            document.querySelectorAll('.live-preview').forEach(el => {
                el.style.fontSize = fontSize;
            });
            
            // If final preview tab is active, regenerate it to apply font size
            const finalPreviewTab = document.getElementById('final-preview');
            if (finalPreviewTab && finalPreviewTab.classList.contains('active')) {
                generateFinalPreview();
            }
            
            // Save to localStorage (save as string)
            localStorage.setItem('fontSize', sizeStr);
        }
        
        function changeLineHeight(height) {
            // Ensure height is a string
            const heightStr = String(height);
            const lineHeight = heightStr;
            
            // Apply to all textareas and inputs, but exclude search bar and JSON input
            document.querySelectorAll('.form-group textarea, .form-group input[type="text"], textarea, input[type="text"]').forEach(el => {
                // Exclude search bar and JSON input from line height changes
                if (el.id === 'searchFilter' || el.id === 'json_input') {
                    return; // Skip these elements
                }
                el.style.lineHeight = lineHeight;
            });
            // Apply to all preview boxes
            document.querySelectorAll('.live-preview').forEach(el => {
                el.style.lineHeight = lineHeight;
            });
            
            // If final preview tab is active, regenerate it to apply line height
            const finalPreviewTab = document.getElementById('final-preview');
            if (finalPreviewTab && finalPreviewTab.classList.contains('active')) {
                generateFinalPreview();
            }
            
            // Save to localStorage (save as string)
            localStorage.setItem('lineHeight', heightStr);
        }
        
        // Initialize font settings from localStorage
        function initializeFontSettings() {
            const savedFontSize = localStorage.getItem('fontSize');
            const savedLineHeight = localStorage.getItem('lineHeight');
            
            // Set and apply font size (use saved value or default)
            const fontSizeToApply = savedFontSize || '14'; // Default to 14px if not saved
            const fontSizeSelect = document.getElementById('fontSizeSelect');
            if (fontSizeSelect) {
                fontSizeSelect.value = fontSizeToApply;
                // Use setTimeout to ensure all elements are loaded
                setTimeout(() => {
                    changeFontSize(fontSizeToApply);
                }, 0);
            }
            
            // Set and apply line height (use saved value or default)
            const lineHeightToApply = savedLineHeight || '1.5'; // Default to 1.5 if not saved
            const lineHeightSelect = document.getElementById('lineHeightSelect');
            if (lineHeightSelect) {
                lineHeightSelect.value = lineHeightToApply;
                // Use setTimeout to ensure all elements are loaded
                setTimeout(() => {
                    changeLineHeight(lineHeightToApply);
                }, 0);
            }
        }

        function toggleDarkMode() {
            const body = document.body;
            const toggle = document.getElementById('darkModeToggle');
            const icon = toggle.querySelector('i');
            
            // Toggle the data-theme attribute
            const isDark = body.getAttribute('data-theme') !== 'dark';
            if (body.getAttribute('data-theme') === 'dark') {
                body.removeAttribute('data-theme');
                icon.className = 'fas fa-moon';
                localStorage.setItem('darkMode', 'light');
            } else {
                body.setAttribute('data-theme', 'dark');
                icon.className = 'fas fa-sun';
                localStorage.setItem('darkMode', 'dark');
            }
            
            trackEvent('feature_toggled', { feature: 'dark_mode', enabled: isDark });
        }

        // Initialize dark mode from localStorage
        function initializeDarkMode() {
            const savedTheme = localStorage.getItem('darkMode');
            const body = document.body;
            const toggle = document.getElementById('darkModeToggle');
            const icon = toggle.querySelector('i');
            
            if (savedTheme === 'dark') {
                body.setAttribute('data-theme', 'dark');
                icon.className = 'fas fa-sun';
            } else {
                body.removeAttribute('data-theme');
                icon.className = 'fas fa-moon';
            }
        }

        // Ensure preview updates after helper insertions
        function refreshPreviewFor(textarea) {
            if (textarea) renderLivePreview(textarea);
        }

        // Paste a bbox/image JSON snippet copied from the bbox tool (no permission dialog)
        function pasteBboxJson(button) {
            try {
                const text = prompt('Paste bbox/image JSON here:\n{"page": 1, "position": [[xRight, yTop], [xLeft, yBottom]]}');
                if (!text) { return; }
                let obj;
                try {
                    obj = JSON.parse(text);
                } catch (e) {
                    alert('Pasted content is not valid JSON.');
                    return;
                }
                if (typeof obj !== 'object' || !obj.position || !Array.isArray(obj.position) || obj.position.length !== 2) {
                    alert('JSON must be of the form {"page": N, "position": [[xRight, yTop], [xLeft, yBottom]]}.');
                    return;
                }
                const pageVal = parseInt(obj.page ?? obj.Page ?? obj.page_index ?? 0, 10);
                let [[xRight, yTop], [xLeft, yBottom]] = obj.position;
                
                // Normalize coordinates to ensure correct format (top-right to bottom-left)
                const normalized = normalizeBboxCoordinates(xRight, yTop, xLeft, yBottom);
                if (normalized) {
                    xRight = normalized.x0;
                    yTop = normalized.y0;
                    xLeft = normalized.x1;
                    yBottom = normalized.y1;
                }
                
                // Determine target container relative to where the Paste button is
                let arrContainer = null;
                const parentArrayItem = button.closest('.array-item');
                if (parentArrayItem && parentArrayItem.parentElement && parentArrayItem.parentElement.classList.contains('bbox-container')) {
                    // Row-level paste: use this row's container
                    arrContainer = parentArrayItem.parentElement;
                } else {
                    // Group-level paste: use the previous sibling container
                    arrContainer = button.previousElementSibling;
                }
                if (!arrContainer || !arrContainer.classList.contains('bbox-container')) {
                    alert('Could not find target container to paste into.');
                    return;
                }
                // Target row logic: overwrite current row if invoked from row; otherwise use first row or create one
                let targetRow = (parentArrayItem && parentArrayItem.parentElement === arrContainer) ? parentArrayItem : null;
                let wasNewRow = false;
                if (!targetRow) {
                    targetRow = arrContainer.querySelector('.array-item');
                    if (!targetRow) {
                        wasNewRow = true;
                        targetRow = document.createElement('div');
                        targetRow.className = 'array-item';
                        targetRow.innerHTML = `
                            <div class="bbox-inputs">
                                <input type="number" placeholder="Page" class="bbox-page" min="1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57" title="PDF page number where this image appears">
                                <input type="number" placeholder="X0" class="bbox-x0" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57" title="Right X coordinate (top-right corner)">
                                <input type="number" placeholder="Y0" class="bbox-y0" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57" title="Top Y coordinate (top-right corner)">
                                <input type="number" placeholder="X1" class="bbox-x1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57" title="Left X coordinate (bottom-left corner)">
                                <input type="number" placeholder="Y1" class="bbox-y1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57" title="Bottom Y coordinate (bottom-left corner)">
                            </div>
                            <div class="row-actions">
                                <button class="reorder-btn" onclick="moveItemUp(this)" title="Move Up"><i class="fas fa-arrow-up"></i></button>
                                <button class="reorder-btn" onclick="moveItemDown(this)" title="Move Down"><i class="fas fa-arrow-down"></i></button>
                                <button class="add-btn" onclick="openBboxDrawer(this)"><i class="fas fa-pen-square"></i> Draw</button>
                                <button class="add-btn" onclick="pasteBboxJson(this)"><i class="fas fa-paste"></i> Paste</button>
                                <button class="add-btn" onclick="copyBboxJson(this)"><i class="fas fa-copy"></i> Copy</button>
                                <button class="duplicate-btn" onclick="duplicateBbox(this)" title="Duplicate"><i class="fas fa-clone"></i></button>
                                <button class="remove-btn" onclick="removeArrayItem(this)"></button>
                            </div>
                        `;
                        arrContainer.appendChild(targetRow);
                        // Attach bbox validation to the new item
                        attachBboxValidationToItem(targetRow);
                    }
                }
                
                // Save old state before pasting (for undo)
                const oldState = {
                    page: targetRow.querySelector('.bbox-page')?.value || '',
                    x0: targetRow.querySelector('.bbox-x0')?.value || '',
                    y0: targetRow.querySelector('.bbox-y0')?.value || '',
                    x1: targetRow.querySelector('.bbox-x1')?.value || '',
                    y1: targetRow.querySelector('.bbox-y1')?.value || ''
                };
                
                const inputs = targetRow.querySelectorAll('input');
                if (inputs.length >= 5) {
                    inputs[0].value = Number.isFinite(pageVal) ? pageVal : '';
                    inputs[1].value = Math.round(xRight) || 0; // X0 (top-right x)
                    inputs[2].value = Math.round(yTop) || 0;   // Y0 (top-right y)
                    inputs[3].value = Math.round(xLeft) || 0;  // X1 (bottom-left x)
                    inputs[4].value = Math.round(yBottom) || 0;// Y1 (bottom-left y)
                }
                
                // Save pasted state (for redo)
                const pastedState = {
                    page: inputs[0].value,
                    x0: inputs[1].value,
                    y0: inputs[2].value,
                    x1: inputs[3].value,
                    y1: inputs[4].value
                };
                
                // Record action for undo/redo
                recordFormAction({
                    type: ACTION_TYPES.PASTE_BBOX,
                    targetRow: targetRow,
                    oldState: oldState,
                    pastedState: pastedState,
                    wasNewRow: wasNewRow
                });
                
                // Mark form as changed and trigger auto-save after pasting coordinates
                markFormAsChanged();
                triggerAutoSave();
            } catch (err) {
                console.error(err);
                alert('Failed to paste.');
            }
        }

        // Copy the current row's bbox/image as JSON for the Paste button format
        function copyBboxJson(button) {
            try {
                const parentArrayItem = button.closest('.array-item');
                const inputs = parentArrayItem ? parentArrayItem.querySelectorAll('.bbox-inputs input') : null;
                if (!inputs || inputs.length < 5) { alert('Could not locate bbox inputs'); return; }
                const page = parseInt(inputs[0].value, 10);
                const x0 = parseInt(inputs[1].value, 10);
                const y0 = parseInt(inputs[2].value, 10);
                const x1 = parseInt(inputs[3].value, 10);
                const y1 = parseInt(inputs[4].value, 10);
                if (![page, x0, y0, x1, y1].every(Number.isFinite)) {
                    alert('Please fill Page, X0, Y0, X1, Y1 with integers before copying.');
                    return;
                }
                const obj = { page: page, position: [[x0, y0], [x1, y1]] };
                const text = JSON.stringify(obj);
                const ta = document.createElement('textarea');
                ta.value = text;
                document.body.appendChild(ta);
                ta.select();
                try { document.execCommand('copy'); } catch {}
                document.body.removeChild(ta);
                const copyBtn = button;
                const original = copyBtn.innerHTML;
                copyBtn.innerHTML = '<i class="fas fa-check"></i> Copied!';
                copyBtn.style.background = '#28a745';
                setTimeout(() => { copyBtn.innerHTML = original; copyBtn.style.background = ''; }, 1200);
            } catch (e) {
                alert('Failed to copy.');
            }
        }

        // Duplicate the current bbox/image row (create a copy right below)
        function duplicateBbox(button) {
            try {
                const parentArrayItem = button.closest('.array-item');
                if (!parentArrayItem) {
                    alert('Could not find bbox item to duplicate');
                    return;
                }
                
                const inputs = parentArrayItem.querySelectorAll('.bbox-inputs input');
                if (!inputs || inputs.length < 5) {
                    alert('Could not locate bbox inputs');
                    return;
                }
                
                const page = inputs[0].value || '';
                const x0 = inputs[1].value || '';
                const y0 = inputs[2].value || '';
                const x1 = inputs[3].value || '';
                const y1 = inputs[4].value || '';
                
                // Find the parent container
                const container = parentArrayItem.parentElement;
                if (!container) {
                    alert('Could not find container');
                    return;
                }
                
                // Determine the type of image based on the label of parent form-group
                const formGroup = container.closest('.form-group');
                const label = formGroup ? formGroup.querySelector('label') : null;
                const labelText = label ? label.textContent : '';
                
                let beforeFunc = 'addContentImageBefore';
                let afterFunc = 'addContentImageAfter';
                
                if (labelText.includes('Question Images')) {
                    beforeFunc = 'addQuestionImageBefore';
                    afterFunc = 'addQuestionImageAfter';
                } else if (labelText.includes('Answer Images')) {
                    beforeFunc = 'addAnswerImageBefore';
                    afterFunc = 'addAnswerImageAfter';
                } else if (labelText.includes('Section Images')) {
                    beforeFunc = 'addContentImageBefore';
                    afterFunc = 'addContentImageAfter';
                }
                
                // Create new item below current one
                const newItem = document.createElement('div');
                newItem.className = 'array-item';
                newItem.innerHTML = `
                    <div class="bbox-inputs">
                        <input type="number" placeholder="Page" class="bbox-page" min="1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57" value="${page}">
                        <input type="number" placeholder="X0" class="bbox-x0" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57" value="${x0}">
                        <input type="number" placeholder="Y0" class="bbox-y0" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57" value="${y0}">
                        <input type="number" placeholder="X1" class="bbox-x1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57" value="${x1}">
                        <input type="number" placeholder="Y1" class="bbox-y1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57" value="${y1}">
                    </div>
                    <div class="row-actions">
                        <button class="reorder-btn" onclick="moveItemUp(this)" title="Move Up"><i class="fas fa-arrow-up"></i></button>
                        <button class="reorder-btn" onclick="moveItemDown(this)" title="Move Down"><i class="fas fa-arrow-down"></i></button>
                        <button class="add-bbox-btn" onclick="${beforeFunc}(this)" title="Add Image Before">
                            <i class="fas fa-plus"></i> Before
                        </button>
                        <button class="add-bbox-btn" onclick="${afterFunc}(this)" title="Add Image After">
                            <i class="fas fa-plus"></i> After
                        </button>
                        <button class="add-btn" onclick="openBboxDrawer(this)"><i class="fas fa-pen-square"></i> Draw</button>
                        <button class="add-btn" onclick="pasteBboxJson(this)"><i class="fas fa-paste"></i> Paste</button>
                        <button class="add-btn" onclick="copyBboxJson(this)"><i class="fas fa-copy"></i> Copy</button>
                        <button class="duplicate-btn" onclick="duplicateBbox(this)" title="Duplicate Image"><i class="fas fa-clone"></i></button>
                        <button class="remove-btn" onclick="removeArrayItem(this)"></button>
                    </div>
                `;
                
                // Insert after current item
                container.insertBefore(newItem, parentArrayItem.nextSibling);
                
                // Record action for undo/redo (after adding to DOM so we have the actual element)
                recordFormAction({
                    type: ACTION_TYPES.DUPLICATE_ITEM,
                    originalElement: parentArrayItem,
                    duplicatedElement: newItem,
                    parent: container,
                    nextSibling: newItem.nextSibling,
                    containerId: null,
                    updateNumbers: false
                });
                
                // Attach bbox validation to the new item
                attachBboxValidationToItem(newItem);
                
                // Visual feedback
                const duplicateBtn = button;
                const originalIcon = duplicateBtn.innerHTML;
                duplicateBtn.innerHTML = '<i class="fas fa-check"></i>';
                duplicateBtn.style.background = '#28a745';
                setTimeout(() => {
                    duplicateBtn.innerHTML = originalIcon;
                    duplicateBtn.style.background = '';
                }, 1200);
                
                // Mark form as changed and trigger auto-save
                markFormAsChanged();
                triggerAutoSave();
                
            } catch (e) {
                console.error('Failed to duplicate bbox:', e);
                alert('Failed to duplicate: ' + e.message);
            }
        }

        // Open bbox drawer in picker mode and fill the current row on selection
        function openBboxDrawer(button) {
            // Identify the row to fill
            const parentArrayItem = button.closest('.array-item');
            const inputs = parentArrayItem ? parentArrayItem.querySelectorAll('.bbox-inputs input') : null;
            if (!inputs || inputs.length < 5) { alert('Could not locate bbox inputs'); return; }
            // Decide which PDF to use based on section type (answers vs non-answers)
            const group = button.closest('.form-group');
            const isGuide = !!(group && /Answer\s+Images/i.test(group.querySelector('label')?.textContent||''));
            // Pass current page as hint (prefer row page; else fallback to textbook or guidebook start page)
            let hintPage = inputs[0].value && String(inputs[0].value).trim()
                ? String(inputs[0].value).trim()
                : '';
            if (!hintPage) {
                if (isGuide) {
                    const gStart = document.getElementById('guidebook_start_page');
                    hintPage = (gStart && gStart.value) ? String(gStart.value).trim() : '';
                } else {
                    const tPdf = document.getElementById('textbook_pdf_page');
                    hintPage = (tPdf && tPdf.value) ? String(tPdf.value).trim() : '';
                }
            }
            // Save active target
            window.__embeddedBboxTarget = { inputs, isGuide: isGuide };
            // Open embedded modal and init viewer
            openEmbeddedBboxModal(hintPage);
        }

        // Helper functions for PDF persistence in IndexedDB
        async function savePdfToStorage(key, arrayBuffer) {
            try {
                return new Promise((resolve) => {
                    const request = indexedDB.open('bboxPdfStorage', 1);
                    
                    request.onerror = () => resolve(false);
                    
                    request.onsuccess = () => {
                        const db = request.result;
                        const transaction = db.transaction(['pdfs'], 'readwrite');
                        const store = transaction.objectStore('pdfs');
                        const putRequest = store.put(arrayBuffer, key);
                        
                        putRequest.onsuccess = () => resolve(true);
                        putRequest.onerror = () => resolve(false);
                    };
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains('pdfs')) {
                            db.createObjectStore('pdfs');
                        }
                    };
                });
            } catch (error) {
                return false;
            }
        }

        async function loadPdfFromStorage(key) {
            try {
                return new Promise((resolve) => {
                    const request = indexedDB.open('bboxPdfStorage', 1);
                    
                    request.onerror = () => resolve(null);
                    
                    request.onsuccess = () => {
                        const db = request.result;
                        if (!db.objectStoreNames.contains('pdfs')) {
                            resolve(null);
                            return;
                        }
                        
                        const transaction = db.transaction(['pdfs'], 'readonly');
                        const store = transaction.objectStore('pdfs');
                        const getRequest = store.get(key);
                        
                        getRequest.onsuccess = () => resolve(getRequest.result || null);
                        getRequest.onerror = () => resolve(null);
                    };
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains('pdfs')) {
                            db.createObjectStore('pdfs');
                        }
                    };
                });
            } catch (error) {
                return null;
            }
        }

        // Auto-load PDFs from IndexedDB on page load (for both bbox modal and main PDF viewer)
        async function initializePdfStore() {
            try {
                // Initialize the store if it doesn't exist
                const store = (window.__bboxStore = window.__bboxStore || {});
                // Preserve existing docs if they exist, otherwise initialize with defaults
                if (!store.docs) {
                    store.docs = { 
                        text: { 
                            pdfDoc: null, currentPage: 1, totalPages: 0, scale: 1.2, 
                            scrollLeft: 0, scrollTop: 0, 
                            mainViewerScale: 1.0, mainViewerScrollLeft: 0, mainViewerScrollTop: 0 
                        }, 
                        guide: { 
                            pdfDoc: null, currentPage: 1, totalPages: 0, scale: 1.2, 
                            scrollLeft: 0, scrollTop: 0,
                            mainViewerScale: 1.0, mainViewerScrollLeft: 0, mainViewerScrollTop: 0 
                        } 
                    };
                } else {
                    // Ensure both text and guide objects exist, but preserve existing data
                    if (!store.docs.text) {
                        store.docs.text = { 
                            pdfDoc: null, currentPage: 1, totalPages: 0, scale: 1.2, 
                            scrollLeft: 0, scrollTop: 0, 
                            mainViewerScale: 1.0, mainViewerScrollLeft: 0, mainViewerScrollTop: 0 
                        };
                    }
                    if (!store.docs.guide) {
                        store.docs.guide = { 
                            pdfDoc: null, currentPage: 1, totalPages: 0, scale: 1.2, 
                            scrollLeft: 0, scrollTop: 0,
                            mainViewerScale: 1.0, mainViewerScrollLeft: 0, mainViewerScrollTop: 0 
                        };
                    }
                }

                const pdfjs = await import('https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.4.168/pdf.min.mjs');
                pdfjs.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.4.168/pdf.worker.min.mjs';
                
                // Load both text and guide PDFs from IndexedDB (load them in parallel for better performance)
                const loadPromises = ['text', 'guide'].map(async (key) => {
                    try {
                        const pdfData = await loadPdfFromStorage(key);
                        if (pdfData && pdfData.byteLength > 0) {
                            const doc = await pdfjs.getDocument({ data: pdfData }).promise;
                            store.docs[key].pdfDoc = doc;
                            store.docs[key].totalPages = doc.numPages;
                            
                            // Restore saved page/scale if available, otherwise use defaults
                            if (!store.docs[key].currentPage || store.docs[key].currentPage > doc.numPages) {
                                store.docs[key].currentPage = 1;
                            }
                            if (!store.docs[key].scale) {
                                store.docs[key].scale = 1.2;
                            }
                            return { key, success: true };
                        }
                        return { key, success: false, reason: 'No PDF data found' };
                    } catch (error) {
                        // Fail silently - just don't load this PDF
                        return { key, success: false, reason: error.message };
                    }
                });
                
                // Wait for both PDFs to finish loading (use allSettled to ensure both attempts complete)
                await Promise.allSettled(loadPromises);
            } catch (error) {
                // Fail silently
            }
        }

        // Embedded BBox Drawer implementation
        async function openEmbeddedBboxModal(hintPage) {
            const modal = document.getElementById('bboxModal');
            if (!modal) return;
            modal.classList.add('show');
            
            // Set flag to prevent auto-navigation from switching sources when modal is open from Draw button
            const isMainFormUpload = (window.__embeddedBboxTarget && window.__embeddedBboxTarget.isMainFormUpload) || false;
            if (!isMainFormUpload) {
                window.__bboxModalOpen = true;
            }

            const pdfCanvas = document.getElementById('em-pdf');
            const drawCanvas = document.getElementById('em-draw');
            const canvasWrap = document.getElementById('em-canvas-wrap');
            const pdfCtx = pdfCanvas.getContext('2d', { alpha: false });
            const drawCtx = drawCanvas.getContext('2d');

            const textFileInput = document.getElementById('em-text-pdf-file');
            const guideFileInput = document.getElementById('em-guide-pdf-file');
            const docLabel = document.getElementById('em-doc-label');
            const prevBtn = document.getElementById('em-prev');
            const nextBtn = document.getElementById('em-next');
            const pageNumEl = document.getElementById('em-page-num');
            const pageCountEl = document.getElementById('em-page-count');
            const zoomInBtn = document.getElementById('em-zoom-in');
            const zoomOutBtn = document.getElementById('em-zoom-out');
            const zoomResetBtn = document.getElementById('em-zoom-reset');
            const zoomDisplay = document.getElementById('em-zoom-display');
            const gotoInput = document.getElementById('em-goto');
            const gotoBtn = document.getElementById('em-goto-btn');
            const clearBtn = document.getElementById('em-clear');
            const undoBtn = document.getElementById('em-undo');
            const coordsDisplay = document.getElementById('em-coords');
            const listEl = document.getElementById('em-list');
            const confirmBtn = document.getElementById('em-confirm');
            const cancelBtn = document.getElementById('em-cancel');

            // Save main PDF viewer scroll position before opening bbox modal
            const mainPdfContainer = document.getElementById('pdf-canvas-container');
            if (mainPdfContainer && !window.__mainPdfScrollSaved) {
                window.__mainPdfScroll = {
                    scrollLeft: mainPdfContainer.scrollLeft,
                    scrollTop: mainPdfContainer.scrollTop
                };
                window.__mainPdfScrollSaved = true;
            }
            
            // Persist two PDFs and view states between openings
            const store = (window.__bboxStore = window.__bboxStore || {});
            // Initialize docs object if it doesn't exist
            if (!store.docs) {
                store.docs = {};
            }
            // Initialize each PDF's state separately, preserving existing values
            if (!store.docs.text) {
                store.docs.text = { 
                    pdfDoc: null, currentPage: 1, totalPages: 0, scale: 1.2, 
                    scrollLeft: 0, scrollTop: 0, scrollLeftPercent: 0, scrollTopPercent: 0,
                    mainViewerScale: 1.0, mainViewerScrollLeft: 0, mainViewerScrollTop: 0 
                };
            }
            if (!store.docs.guide) {
                store.docs.guide = { 
                    pdfDoc: null, currentPage: 1, totalPages: 0, scale: 1.2, 
                    scrollLeft: 0, scrollTop: 0, scrollLeftPercent: 0, scrollTopPercent: 0,
                    mainViewerScale: 1.0, mainViewerScrollLeft: 0, mainViewerScrollTop: 0 
                };
            }
            const wantGuide = !!(window.__embeddedBboxTarget && window.__embeddedBboxTarget.isGuide);
            // Set activeKey based on which button was clicked - this determines which PDF's state to load
            // IMPORTANT: This is the LOCKED key for this modal session - all state saves go here
            const MODAL_SESSION_KEY = wantGuide ? 'guide' : 'text';
            // activeKey tracks which PDF is currently displayed (can change on upload)
            let activeKey = MODAL_SESSION_KEY;
            if (docLabel) docLabel.textContent = activeKey === 'guide' ? 'Answers' : 'Textbook';
            
            // Save main viewer's state before opening modal (only if not a main form upload)
            // isMainFormUpload was already declared above
            let savedMainViewerState = null;
            if (!isMainFormUpload) {
                const mainState = window.__mainPdfViewer;
                if (mainState) {
                    const mainKey = mainState.source === 'textbook' ? 'text' : 'guide';
                    // First, save current main viewer state to store (if visible)
                    if (mainState.visible && mainState.pdfDoc) {
                        updatePdfStore();
                    }
                    // Save the main viewer's current state before modal opens
                    // This includes source, page, scale, and scroll position
                    savedMainViewerState = {
                        source: mainState.source || 'textbook',
                        key: mainKey,
                        currentPage: mainState.currentPage || (store.docs[mainKey] ? store.docs[mainKey].currentPage : 1),
                        scale: mainState.scale || (store.docs[mainKey] ? store.docs[mainKey].mainViewerScale : 1.0),
                        scrollLeft: store.docs[mainKey] ? store.docs[mainKey].mainViewerScrollLeft : 0,
                        scrollTop: store.docs[mainKey] ? store.docs[mainKey].mainViewerScrollTop : 0,
                        // Also save the store values for both keys to restore them later
                        textCurrentPage: store.docs.text ? store.docs.text.currentPage : 1,
                        textScale: store.docs.text ? store.docs.text.mainViewerScale : 1.0,
                        textScrollLeft: store.docs.text ? store.docs.text.mainViewerScrollLeft : 0,
                        textScrollTop: store.docs.text ? store.docs.text.mainViewerScrollTop : 0,
                        guideCurrentPage: store.docs.guide ? store.docs.guide.currentPage : 1,
                        guideScale: store.docs.guide ? store.docs.guide.mainViewerScale : 1.0,
                        guideScrollLeft: store.docs.guide ? store.docs.guide.mainViewerScrollLeft : 0,
                        guideScrollTop: store.docs.guide ? store.docs.guide.mainViewerScrollTop : 0
                    };
                }
            }
            
            // Load PDF and state for the MODAL_SESSION_KEY (the PDF that was requested to open)
            let pdfDoc = store.docs[MODAL_SESSION_KEY].pdfDoc;
            let totalPages = store.docs[MODAL_SESSION_KEY].totalPages || 0;
            // ALWAYS load saved state from the store for MODAL_SESSION_KEY
            let currentPage = store.docs[MODAL_SESSION_KEY].currentPage || 1;
            let scale = store.docs[MODAL_SESSION_KEY].scale || 1.2;
            let isDrawing = true;
            let dragStart = null;
            let currentViewportScale = 1;
            // Store CSS-space dimensions for clearRect operations (accounting for devicePixelRatio scaling)
            let canvasCssWidth = 0;
            let canvasCssHeight = 0;
            // Edit state for moving/resizing an existing bbox
            let isEditing = false;      // true while dragging an existing rect
            let editMode = null;        // 'move' or one of 'nw','ne','se','sw','n','s','e','w'
            let editStart = null;       // {x,y} in canvas coords
            let editStartBBox = null;   // snapshot of lastDrawn at drag start
            // Always start fresh when Draw is pressed (clear old bbox)
            const activeInputs = (window.__embeddedBboxTarget && window.__embeddedBboxTarget.inputs) || null;
            let lastDrawn = null;
            let collected = [];
            
            // If this is opened from main form for PDF upload, don't show drawing tools
            if (isMainFormUpload) {
                // Hide drawing-related buttons
                const drawButtons = document.querySelectorAll('#em-add, #em-clear, #em-undo');
                drawButtons.forEach(btn => btn.style.display = 'none');
                
                // Hide the sidebar since it's not needed for PDF upload
                const sidebar = document.querySelector('.bbox-sidebar');
                if (sidebar) {
                    sidebar.style.display = 'none';
                }
                
                // Adjust the grid layout to use full width when sidebar is hidden
                const content = document.querySelector('.bbox-content');
                if (content) {
                    content.style.gridTemplateColumns = '1fr';
                }
                
                // Change modal title to indicate PDF upload mode
                const docLabel = document.getElementById('em-doc-label');
                if (docLabel) {
                    docLabel.textContent = activeKey === 'guide' ? 'Answers' : 'Textbook';
                }
                
                // Change confirm button text
                if (confirmBtn) {
                    confirmBtn.textContent = 'Close';
                }
            }
            
            // If the current row already has values, seed the preview/page to them
            if (activeInputs) {
                const p = parseInt(activeInputs[0].value, 10);
                const xr = parseInt(activeInputs[1].value, 10);
                const yt = parseInt(activeInputs[2].value, 10);
                const xl = parseInt(activeInputs[3].value, 10);
                const yb = parseInt(activeInputs[4].value, 10);
                if ([p, xr, yt, xl, yb].every(v => Number.isFinite(v))) {
                    lastDrawn = { page: p, position: [[xr, yt], [xl, yb]] };
                    currentPage = p;
                }
            }
            // Clear any previous temp preview immediately (from prior open)
            try { (() => { const dims = getCanvasCssDimensions(); drawCtx.clearRect(0, 0, dims.width, dims.height); })(); listEl.innerHTML = ''; } catch {}
            collected = [];

            async function loadPdfFromFile(file, key){
                const buf = await file.arrayBuffer();
                // Save PDF to IndexedDB for persistence (await to ensure it completes)
                await savePdfToStorage(key, buf);
                
                const pdfjs = await import('https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.4.168/pdf.min.mjs');
                pdfjs.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.4.168/pdf.worker.min.mjs';
                const doc = await pdfjs.getDocument({ data: buf }).promise;
                store.docs[key].pdfDoc = doc;
                store.docs[key].totalPages = doc.numPages;
                // Preserve saved state if it exists and is valid, otherwise use hint or default
                if (!store.docs[key].currentPage || store.docs[key].currentPage < 1 || store.docs[key].currentPage > doc.numPages) {
                    store.docs[key].currentPage = Math.min(Math.max((lastDrawn?.page) || (parseInt(hintPage,10)||1),1), doc.numPages);
                }
                // Preserve saved scale if it exists and is valid, otherwise use default
                if (!store.docs[key].scale || store.docs[key].scale <= 0) {
                    store.docs[key].scale = 1.2;
                }
                // Preserve saved scroll positions if they exist
                // (scroll positions are preserved automatically since we don't overwrite them here)
                
                // Update main viewer if it exists (regardless of visibility or source)
                const state = window.__mainPdfViewer;
                if (state) {
                    const sourceKey = key === 'text' ? 'textbook' : 'guide';
                    
                    // If this is a main form upload (from PDF viewer buttons), ensure we update
                    const isMainFormUpload = (window.__embeddedBboxTarget && window.__embeddedBboxTarget.isMainFormUpload) || false;
                    
                    // Only update the main viewer if this is a main form upload
                    // When opened from Draw button, don't affect the main viewer at all
                    if (isMainFormUpload) {
                        console.log('PDF Upload: Syncing to main viewer', { 
                            sourceKey, 
                            currentSource: state.source, 
                            isMainFormUpload,
                            visible: state.visible 
                        });
                        
                        // If source doesn't match but it's a main form upload, switch source
                        if (isMainFormUpload && state.source !== sourceKey) {
                            console.log('PDF Upload: Switching source from', state.source, 'to', sourceKey);
                            state.source = sourceKey;
                            state.lastSyncedPage = null;
                            state.lastSyncedSource = null;
                            
                            // Update toggle button states
                            if (state.elements && state.elements.sourceToggle) {
                                if (state.elements.sourceToggle.textbook) {
                                    state.elements.sourceToggle.textbook.classList.toggle('active', sourceKey === 'textbook');
                                }
                                if (state.elements.sourceToggle.guide) {
                                    state.elements.sourceToggle.guide.classList.toggle('active', sourceKey === 'guide');
                                }
                            }
                        }
                        
                        state.pdfDoc = doc;
                        state.totalPages = doc.numPages;
                        state.currentPage = store.docs[key].currentPage || 1;
                        state.scale = scale || 1.0;
                        // Clear last rendered state when PDF document changes to force render
                        state._lastRenderedState = null;
                        
                        console.log('PDF Upload: State updated', {
                            totalPages: state.totalPages,
                            currentPage: state.currentPage,
                            hasCanvas: !!state.canvas,
                            hasContext: !!state.context,
                            visible: state.visible
                        });
                        
                        // Always try to render if viewer is visible
                        if (state.visible) {
                            if (state.canvas && state.context) {
                                console.log('PDF Upload: Rendering immediately');
                                updatePdfControls();
                                renderMainPdfPage();
                            } else {
                                console.log('PDF Upload: Canvas not ready, waiting...');
                                // Canvas not ready yet, wait a bit
                                setTimeout(() => {
                                    if (state.canvas && state.context) {
                                        console.log('PDF Upload: Rendering after delay');
                                        updatePdfControls();
                                        renderMainPdfPage();
                                    } else {
                                        console.warn('PDF Upload: Canvas still not ready after delay');
                                    }
                                }, 200);
                            }
                        } else {
                            console.log('PDF Upload: Viewer not visible, will render when shown');
                        }
                    } else {
                        console.log('PDF Upload: Source mismatch, not updating', {
                            stateSource: state.source,
                            uploadSource: sourceKey,
                            isMainFormUpload
                        });
                    }
                }
                
                return doc;
            }
            textFileInput.onchange = async (e) => { 
                const f=e.target.files&&e.target.files[0]; 
                if(!f) return; 
                
                if ((collected.length > 0 || lastDrawn) && !confirm('You have unsaved bounding boxes. Loading a new PDF will clear them. Are you sure?')) {
                    e.target.value = ''; // Reset file input
                    return;
                }
                
                // NOTE: We don't save state here - the scroll listener and persistView handle all saves
                // State is always saved to MODAL_SESSION_KEY, not the uploaded PDF
                
                // Clear any existing work
                if (collected.length > 0 || lastDrawn) {
                    collected = [];
                    lastDrawn = null;
                    (() => { const dims = getCanvasCssDimensions(); drawCtx.clearRect(0, 0, dims.width, dims.height); })();
                    listEl.innerHTML = '';
                }
                
                const uploadedDoc = await loadPdfFromFile(f,'text'); 
                // Update activeKey to 'text' when text PDF is loaded
                activeKey = 'text';
                if (docLabel) docLabel.textContent = 'Textbook';
                pdfDoc=store.docs.text.pdfDoc; 
                totalPages=store.docs.text.totalPages; 
                // Always use the saved values from the store for the target PDF
                currentPage=store.docs.text.currentPage || 1; 
                scale=store.docs.text.scale || 1.2; 
                if (zoomDisplay) zoomDisplay.textContent = `${Math.round(scale * 100)}%`;
                await renderPage();
                
                // If this is a main form upload, ensure main viewer refreshes
                if (uploadedDoc && isMainFormUpload) {
                    setTimeout(() => {
                        const state = window.__mainPdfViewer;
                        if (state && state.visible) {
                            console.log('PDF Upload: File loaded, refreshing main viewer');
                            loadPdfFromStore();
                        }
                    }, 100);
                }
            };
            guideFileInput.onchange = async (e) => { 
                const f=e.target.files&&e.target.files[0]; 
                if(!f) return; 
                
                if ((collected.length > 0 || lastDrawn) && !confirm('You have unsaved bounding boxes. Loading a new PDF will clear them. Are you sure?')) {
                    e.target.value = ''; // Reset file input
                    return;
                }
                
                // NOTE: We don't save state here - the scroll listener and persistView handle all saves
                // State is always saved to MODAL_SESSION_KEY, not the uploaded PDF
                
                // Clear any existing work
                if (collected.length > 0 || lastDrawn) {
                    collected = [];
                    lastDrawn = null;
                    (() => { const dims = getCanvasCssDimensions(); drawCtx.clearRect(0, 0, dims.width, dims.height); })();
                    listEl.innerHTML = '';
                }
                
                const uploadedDoc = await loadPdfFromFile(f,'guide'); 
                // Update activeKey to 'guide' when guide PDF is loaded
                activeKey = 'guide';
                if (docLabel) docLabel.textContent = 'Answers';
                pdfDoc=store.docs.guide.pdfDoc; 
                totalPages=store.docs.guide.totalPages; 
                // Always use the saved values from the store for the target PDF
                currentPage=store.docs.guide.currentPage || 1; 
                scale=store.docs.guide.scale || 1.2; 
                updateZoomDisplay();
                await renderPage();
                
                // If this is a main form upload, ensure main viewer refreshes
                if (uploadedDoc && isMainFormUpload) {
                    setTimeout(() => {
                        const state = window.__mainPdfViewer;
                        if (state && state.visible) {
                            console.log('PDF Upload: File loaded, refreshing main viewer');
                            loadPdfFromStore();
                        }
                    }, 100);
                }
            };

            function getCanvasPoint(evt) {
                const rect = drawCanvas.getBoundingClientRect();
                // Get device pixel ratio (must match the one used in renderPage)
                const dpr = window.devicePixelRatio || 1;
                // Canvas internal dimensions are multiplied by dpr, but we want CSS-space coordinates
                // since the context is scaled by dpr
                const scaleX = (drawCanvas.width / dpr) / rect.width;
                const scaleY = (drawCanvas.height / dpr) / rect.height;
                // account for scroll inside container
                const wrapRect = canvasWrap.getBoundingClientRect();
                const offsetX = rect.left - wrapRect.left;
                const offsetY = rect.top - wrapRect.top;
                const x = (evt.clientX - rect.left) * scaleX;
                const y = (evt.clientY - rect.top) * scaleY;
                return { x, y };
            }

            function getCanvasCssDimensions() {
                // Return stored CSS dimensions if available, otherwise calculate from canvas
                if (canvasCssWidth > 0 && canvasCssHeight > 0) {
                    return { width: canvasCssWidth, height: canvasCssHeight };
                }
                // Fallback: calculate from canvas dimensions and devicePixelRatio
                const dpr = window.devicePixelRatio || 1;
                return {
                    width: drawCanvas.width / dpr,
                    height: drawCanvas.height / dpr
                };
            }

            async function renderPage() {
                    const page = await pdfDoc.getPage(currentPage);
                    const viewport = page.getViewport({ scale });
                const width = Math.floor(viewport.width);
                const height = Math.floor(viewport.height);
                
                // Get device pixel ratio for high-DPI rendering (ensures 100% quality at all zoom levels)
                const dpr = window.devicePixelRatio || 1;
                
                // Set canvas internal dimensions with devicePixelRatio for crisp rendering
                pdfCanvas.width = width * dpr;
                pdfCanvas.height = height * dpr;
                drawCanvas.width = width * dpr;
                drawCanvas.height = height * dpr;
                
                // Reset transform and scale the context to account for devicePixelRatio
                pdfCtx.setTransform(1, 0, 0, 1, 0, 0);
                pdfCtx.scale(dpr, dpr);
                drawCtx.setTransform(1, 0, 0, 1, 0, 0);
                drawCtx.scale(dpr, dpr);
                
                    drawCanvas.style.left = '0px';
                    drawCanvas.style.top = '0px';
                // Set CSS size so the wrapper can scroll (use actual display dimensions, not multiplied)
                pdfCanvas.style.width = width + 'px';
                pdfCanvas.style.height = height + 'px';
                drawCanvas.style.width = width + 'px';
                drawCanvas.style.height = height + 'px';
                    currentViewportScale = viewport.scale || scale;
                    
                // Store CSS-space dimensions for use in clearRect operations
                canvasCssWidth = width;
                canvasCssHeight = height;
                
                // Create scaled viewport for rendering (viewport is already at the correct scale)
                const renderContext = { canvasContext: pdfCtx, viewport };
                await page.render(renderContext).promise;
                    pageNumEl.textContent = String(currentPage);
                    pageCountEl.textContent = String(totalPages);
                    gotoInput.value = String(currentPage);
                    if (zoomDisplay) zoomDisplay.textContent = `${Math.round(scale * 100)}%`;
                // Clear using CSS-space dimensions since context is scaled by dpr
                drawCtx.clearRect(0, 0, canvasCssWidth, canvasCssHeight);
                    listEl.innerHTML = '';
                    if (lastDrawn) paintTemp(lastDrawn);
                    // Re-list any collected boxes for this page
                    (collected || []).filter(b=>b.page===currentPage).forEach(b=> appendListItem(b));
                
                // Restore scroll position after rendering
                // Use percentage-based restoration to work correctly across different zoom levels
                // CRITICAL: Restore from MODAL_SESSION_KEY, not activeKey
                // Use double requestAnimationFrame to ensure layout is complete
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        if (canvasWrap && store.docs[MODAL_SESSION_KEY]) {
                            // Priority 1: If there's an existing bbox to jump to, scroll to it (overrides saved state)
                            if (store.docs[MODAL_SESSION_KEY]._jumpToBbox) {
                                const bbox = store.docs[MODAL_SESSION_KEY]._jumpToBbox;
                                // Bbox coordinates are in PDF space: x0,y0 is top-right, x1,y1 is bottom-left
                                // Convert to canvas coordinates using currentViewportScale
                                const x0Canvas = bbox.x0 * currentViewportScale;
                                const y0Canvas = bbox.y0 * currentViewportScale;
                                const x1Canvas = bbox.x1 * currentViewportScale;
                                const y1Canvas = bbox.y1 * currentViewportScale;
                                
                                // Calculate center of bbox in canvas coordinates
                                const centerX = (x0Canvas + x1Canvas) / 2;
                                const centerY = (y0Canvas + y1Canvas) / 2;
                                
                                // Calculate scroll position to center the bbox in viewport
                                const viewportWidth = canvasWrap.clientWidth;
                                const viewportHeight = canvasWrap.clientHeight;
                                const scrollLeft = Math.max(0, centerX - viewportWidth / 2);
                                const scrollTop = Math.max(0, centerY - viewportHeight / 2);
                                
                                canvasWrap.scrollLeft = scrollLeft;
                                canvasWrap.scrollTop = scrollTop;
                                
                                // Update saved scroll position to match the bbox location
                                const scrollWidth = canvasWrap.scrollWidth - canvasWrap.clientWidth;
                                const scrollHeight = canvasWrap.scrollHeight - canvasWrap.clientHeight;
                                if (scrollWidth > 0) {
                                    store.docs[MODAL_SESSION_KEY].scrollLeftPercent = scrollLeft / scrollWidth;
                                }
                                if (scrollHeight > 0) {
                                    store.docs[MODAL_SESSION_KEY].scrollTopPercent = scrollTop / scrollHeight;
                                }
                                store.docs[MODAL_SESSION_KEY].scrollLeft = scrollLeft;
                                store.docs[MODAL_SESSION_KEY].scrollTop = scrollTop;
                                
                                // Clear the jump flag
                                delete store.docs[MODAL_SESSION_KEY]._jumpToBbox;
                            } else {
                                // Priority 2: Try to restore using percentage first (zoom-independent)
                                if (store.docs[MODAL_SESSION_KEY].scrollLeftPercent !== undefined || store.docs[MODAL_SESSION_KEY].scrollTopPercent !== undefined) {
                                    const scrollWidth = canvasWrap.scrollWidth - canvasWrap.clientWidth;
                                    const scrollHeight = canvasWrap.scrollHeight - canvasWrap.clientHeight;
                                    if (scrollWidth > 0 && store.docs[MODAL_SESSION_KEY].scrollLeftPercent !== undefined) {
                                        canvasWrap.scrollLeft = store.docs[MODAL_SESSION_KEY].scrollLeftPercent * scrollWidth;
                                    }
                                    if (scrollHeight > 0 && store.docs[MODAL_SESSION_KEY].scrollTopPercent !== undefined) {
                                        canvasWrap.scrollTop = store.docs[MODAL_SESSION_KEY].scrollTopPercent * scrollHeight;
                                    }
                                } else if (store.docs[MODAL_SESSION_KEY].scrollLeft !== undefined || store.docs[MODAL_SESSION_KEY].scrollTop !== undefined) {
                                    // Fallback to absolute values if percentages not available
                                    canvasWrap.scrollLeft = store.docs[MODAL_SESSION_KEY].scrollLeft || 0;
                                    canvasWrap.scrollTop = store.docs[MODAL_SESSION_KEY].scrollTop || 0;
                                }
                            }
                        }
                    });
                });
            }

            function normalizeToTRBL(x1,y1,x2,y2){
                const top=Math.min(y1,y2); const bottom=Math.max(y1,y2);
                const right=Math.max(x1,x2); const left=Math.min(x1,x2);
                return { top:Math.round(top), bottom:Math.round(bottom), right:Math.round(right), left:Math.round(left) };
            }

            function getCanvasRectFromLastDrawn(){
                if (!lastDrawn) return null;
                const [[xRight,yTop],[xLeft,yBottom]] = lastDrawn.position;
                const sx = currentViewportScale;
                const left = xLeft*sx, right = xRight*sx, top = yTop*sx, bottom = yBottom*sx;
                return normalizeToTRBL(right, top, left, bottom);
            }

            function hitTestHandles(cx, cy){
                const r = getCanvasRectFromLastDrawn();
                if (!r) return null;
                const size = 10, half = size/2;
                const handles = [
                    {name:'nw', x:r.left, y:r.top},
                    {name:'ne', x:r.right, y:r.top},
                    {name:'se', x:r.right, y:r.bottom},
                    {name:'sw', x:r.left, y:r.bottom}
                ];
                for (const h of handles) {
                    if (Math.abs(cx-h.x)<=half && Math.abs(cy-h.y)<=half) return h.name;
                }
                const tol=6;
                if (Math.abs(cy-r.top)<=tol && cx>=r.left && cx<=r.right) return 'n';
                if (Math.abs(cx-r.right)<=tol && cy>=r.top && cy<=r.bottom) return 'e';
                if (Math.abs(cy-r.bottom)<=tol && cx>=r.left && cx<=r.right) return 's';
                if (Math.abs(cx-r.left)<=tol && cy>=r.top && cy<=r.bottom) return 'w';
                return null;
            }

            function pointInBody(cx, cy){
                const r = getCanvasRectFromLastDrawn();
                if (!r) return false;
                return cx>=r.left && cx<=r.right && cy>=r.top && cy<=r.bottom;
            }

            function updateCursor(e){
                const {x,y}=getCanvasPoint(e);
                let cursor = 'crosshair';
                if (lastDrawn){
                    const h = hitTestHandles(x,y);
                    if (h){
                        const map={nw:'nwse-resize', se:'nwse-resize', ne:'nesw-resize', sw:'nesw-resize', n:'ns-resize', s:'ns-resize', e:'ew-resize', w:'ew-resize'};
                        cursor = map[h] || cursor;
                    } else if (pointInBody(x,y)) {
                        cursor = 'move';
                    }
                }
                drawCanvas.style.cursor = cursor;
            }

            function startDrawing(e){
                // Begin edit if clicking on existing rect
                if (lastDrawn){
                    const {x,y}=getCanvasPoint(e);
                    const h = hitTestHandles(x,y);
                    if (h){ isEditing=true; editMode=h; editStart={x,y}; editStartBBox=JSON.parse(JSON.stringify(lastDrawn)); return; }
                    if (pointInBody(x,y)){ isEditing=true; editMode='move'; editStart={x,y}; editStartBBox=JSON.parse(JSON.stringify(lastDrawn)); return; }
                }
                if (!isDrawing) return; const {x,y}=getCanvasPoint(e); dragStart={x,y};
            }
            function drawMove(e){
                updateCursor(e);
                if (isEditing && lastDrawn && editStart && editMode){
                    const {x,y}=getCanvasPoint(e);
                    const dx=(x-editStart.x)/currentViewportScale;
                    const dy=(y-editStart.y)/currentViewportScale;
                    const src=editStartBBox;
                    let [xr, yt] = src.position[0];
                    let [xl, yb] = src.position[1];
                    const minSize=10; // Minimum bbox size in PDF units
                    
                    if (editMode==='move'){
                        xr=Math.round(xr+dx); xl=Math.round(xl+dx);
                        yt=Math.round(yt+dy); yb=Math.round(yb+dy);
                    } else {
                        // Apply deltas based on which handle is being dragged
                        if (editMode.includes('n')) yt=Math.round(yt+dy);
                        if (editMode.includes('s')) yb=Math.round(yb+dy);
                        if (editMode.includes('e')) xr=Math.round(xr+dx);
                        if (editMode.includes('w')) xl=Math.round(xl+dx);
                        
                        // Prevent horizontal inversion: ensure xr (right) > xl (left) with minimum size
                        if (xr <= xl + minSize) {
                            if (editMode.includes('e')) {
                                xr = xl + minSize; // Don't let right edge go past left + minSize
                            } else if (editMode.includes('w')) {
                                xl = xr - minSize; // Don't let left edge go past right - minSize
                            }
                        }
                        
                        // Prevent vertical inversion: ensure yb (bottom) > yt (top) with minimum size
                        if (yb <= yt + minSize) {
                            if (editMode.includes('s')) {
                                yb = yt + minSize; // Don't let bottom edge go above top + minSize
                            } else if (editMode.includes('n')) {
                                yt = yb - minSize; // Don't let top edge go below bottom - minSize
                            }
                        }
                        
                        // Additional safety: normalize coordinates to ensure correct format
                        // This catches any edge cases where corners might still cross
                        const normalized = normalizeBboxCoordinates(xr, yt, xl, yb);
                        if (normalized) {
                            xr = normalized.x0;
                            yt = normalized.y0;
                            xl = normalized.x1;
                            yb = normalized.y1;
                        }
                    }
                    lastDrawn = { page: currentPage, position: [[xr, yt], [xl, yb]] };
                    paintTemp(lastDrawn);
                    return;
                }
                if (!isDrawing || !dragStart) return; const {x,y}=getCanvasPoint(e); const dims = getCanvasCssDimensions(); drawCtx.clearRect(0,0,dims.width, dims.height); const n=normalizeToTRBL(dragStart.x,dragStart.y,x,y); const left=n.left, top=n.top, right=n.right, bottom=n.bottom; drawCtx.setLineDash([6,4]); drawCtx.strokeStyle='#a78bfa'; drawCtx.lineWidth=2; drawCtx.strokeRect(left,top,right-left,bottom-top); drawCtx.setLineDash([]);
            }
            function endDrawing(e){ 
                if (isEditing){ 
                    isEditing=false; 
                    editMode=null; 
                    editStart=null; 
                    editStartBBox=null; 
                    return; 
                } 
                if (!isDrawing || !dragStart) return; 
                const {x,y}=getCanvasPoint(e); 
                const n=normalizeToTRBL(dragStart.x,dragStart.y,x,y); 
                dragStart=null; 
                
                // Enforce minimum bbox size (10 pixels in canvas space)
                const minCanvasSize = 10;
                if ((n.right-n.left)<minCanvasSize || (n.bottom-n.top)<minCanvasSize) {
                    return;
                }
                
                const inv=1/currentViewportScale; 
                const xr = Math.round(n.right*inv);
                const yt = Math.round(n.top*inv);
                const xl = Math.round(n.left*inv);
                const yb = Math.round(n.bottom*inv);
                
                // Ensure minimum size in PDF units (at least 10 units)
                const minPdfSize = 10;
                if ((xr - xl) < minPdfSize || (yb - yt) < minPdfSize) {
                    return;
                }
                
                lastDrawn = { page: currentPage, position: [[xr, yt], [xl, yb]] }; 
                paintTemp(lastDrawn);
                
                // Track bounding box drawing
                trackEvent('bbox_drawn', {
                    page: currentPage,
                    width: Math.abs(xr - xl),
                    height: Math.abs(yb - yt)
                }); 
            }

            function paintTemp(bbox){
                const dims = getCanvasCssDimensions();
                drawCtx.clearRect(0, 0, dims.width, dims.height);
                const sx = currentViewportScale;
                const left = Math.round(bbox.position[1][0] * sx);
                const top = Math.round(bbox.position[0][1] * sx);
                const right = Math.round(bbox.position[0][0] * sx);
                const bottom = Math.round(bbox.position[1][1] * sx);
                // Main rect
                drawCtx.strokeStyle = '#22c55e';
                drawCtx.lineWidth = 2;
                drawCtx.strokeRect(left, top, right-left, bottom-top);
                drawCtx.fillStyle = '#22c55e33';
                drawCtx.fillRect(left, top, right-left, bottom-top);
                // Corner handles
                const size=10, half=size/2;
                drawCtx.fillStyle = '#22c55e';
                const corners=[{x:left,y:top},{x:right,y:top},{x:right,y:bottom},{x:left,y:bottom}];
                corners.forEach(c=> drawCtx.fillRect(c.x-half, c.y-half, size, size));
                // list
                listEl.innerHTML = '';
                const item = document.createElement('div');
                item.className = 'bbox-item';
                const code = document.createElement('code');
                code.textContent = JSON.stringify(bbox);
                item.appendChild(code);
                listEl.appendChild(item);
            }

            function setCoords(xBase,yBase){ if (!Number.isFinite(xBase)||!Number.isFinite(yBase)) { coordsDisplay.textContent=''; return; } coordsDisplay.textContent = `(${Math.round(xBase)}, ${Math.round(yBase)})`; }

            // Rebind handlers fresh each time (avoid duplicates across openings)
            drawCanvas.onmousedown = startDrawing;
            drawCanvas.onmousemove = (e)=>{ drawMove(e); const {x,y}=getCanvasPoint(e); const inv=1/currentViewportScale; setCoords(x*inv, y*inv); };
            if (window.__bboxMouseUp) window.removeEventListener('mouseup', window.__bboxMouseUp);
            window.__bboxMouseUp = endDrawing;
            window.addEventListener('mouseup', window.__bboxMouseUp);
            drawCanvas.onmouseleave = ()=> setCoords();
            pdfCanvas.onmousemove = (e)=>{ const rect=pdfCanvas.getBoundingClientRect(); const dpr = window.devicePixelRatio || 1; const scaleX=(pdfCanvas.width/dpr)/rect.width; const scaleY=(pdfCanvas.height/dpr)/rect.height; const cx=(e.clientX-rect.left)*scaleX; const cy=(e.clientY-rect.top)*scaleY; const inv=1/currentViewportScale; setCoords(cx*inv, cy*inv); };
            pdfCanvas.onmouseleave = ()=> setCoords();

            function persistView(){ 
                // CRITICAL: Save to MODAL_SESSION_KEY, not activeKey
                // When opened from Draw button (not main form upload), we need to preserve the main viewer's state
                // So we save the modal's state but don't overwrite the main viewer's saved state
                if (!isMainFormUpload && savedMainViewerState) {
                    // Save modal state to a temporary location, not the main store
                    // We'll restore the main viewer's state when closing
                    if (!store.docs[MODAL_SESSION_KEY]._modalState) {
                        store.docs[MODAL_SESSION_KEY]._modalState = {};
                    }
                    store.docs[MODAL_SESSION_KEY]._modalState.currentPage = currentPage;
                    store.docs[MODAL_SESSION_KEY]._modalState.scale = scale;
                    if (canvasWrap) {
                        const scrollWidth = canvasWrap.scrollWidth - canvasWrap.clientWidth;
                        const scrollHeight = canvasWrap.scrollHeight - canvasWrap.clientHeight;
                        if (scrollWidth > 0) {
                            store.docs[MODAL_SESSION_KEY]._modalState.scrollLeftPercent = canvasWrap.scrollLeft / scrollWidth;
                        }
                        if (scrollHeight > 0) {
                            store.docs[MODAL_SESSION_KEY]._modalState.scrollTopPercent = canvasWrap.scrollTop / scrollHeight;
                        }
                        store.docs[MODAL_SESSION_KEY]._modalState.scrollLeft = canvasWrap.scrollLeft;
                        store.docs[MODAL_SESSION_KEY]._modalState.scrollTop = canvasWrap.scrollTop;
                    }
                } else {
                    // Normal save for main form uploads - save directly to store
                    store.docs[MODAL_SESSION_KEY].currentPage=currentPage; 
                    store.docs[MODAL_SESSION_KEY].scale=scale; 
                    // Save scroll position as percentage for zoom-independent restoration
                    if (canvasWrap) {
                        const scrollWidth = canvasWrap.scrollWidth - canvasWrap.clientWidth;
                        const scrollHeight = canvasWrap.scrollHeight - canvasWrap.clientHeight;
                        if (scrollWidth > 0) {
                            store.docs[MODAL_SESSION_KEY].scrollLeftPercent = canvasWrap.scrollLeft / scrollWidth;
                        }
                        if (scrollHeight > 0) {
                            store.docs[MODAL_SESSION_KEY].scrollTopPercent = canvasWrap.scrollTop / scrollHeight;
                        }
                        // Also save absolute values as backup
                        store.docs[MODAL_SESSION_KEY].scrollLeft = canvasWrap.scrollLeft;
                        store.docs[MODAL_SESSION_KEY].scrollTop = canvasWrap.scrollTop;
                    }
                }
            }
            prevBtn.onclick = async ()=>{ 
                if(!pdfDoc) return; 
                if(currentPage>1){ 
                    if (lastDrawn && !confirm('You have an unsaved bounding box. Are you sure you want to navigate away and lose it?')) {
                        return;
                    }
                    lastDrawn=null; 
                    try{ const dims = getCanvasCssDimensions(); drawCtx.clearRect(0,0,dims.width,dims.height); listEl.innerHTML=''; }catch{} 
                    currentPage--; 
                    persistView(); 
                    await renderPage(); 
                } 
            };
            nextBtn.onclick = async ()=>{ 
                if(!pdfDoc) return; 
                if(currentPage<totalPages){ 
                    if (lastDrawn && !confirm('You have an unsaved bounding box. Are you sure you want to navigate away and lose it?')) {
                        return;
                    }
                    lastDrawn=null; 
                    try{ const dims = getCanvasCssDimensions(); drawCtx.clearRect(0,0,dims.width,dims.height); listEl.innerHTML=''; }catch{} 
                    currentPage++; 
                    persistView(); 
                    await renderPage(); 
                } 
            };
            const updateZoomDisplay = () => {
                if (zoomDisplay) zoomDisplay.textContent = `${Math.round(scale * 100)}%`;
            };
            zoomInBtn.onclick = async ()=>{ if(!pdfDoc) return; scale = Math.min(scale*1.1, 8); persistView(); updateZoomDisplay(); await renderPage(); };
            zoomOutBtn.onclick = async ()=>{ if(!pdfDoc) return; scale = Math.max(scale/1.1, 0.2); persistView(); updateZoomDisplay(); await renderPage(); };
            zoomResetBtn.onclick = async ()=>{ 
                if(!pdfDoc) return; 
                if (lastDrawn && !confirm('You have an unsaved bounding box. Resetting zoom will clear it. Are you sure?')) {
                    return;
                }
                if (lastDrawn) {
                    lastDrawn = null;
                    (() => { const dims = getCanvasCssDimensions(); drawCtx.clearRect(0, 0, dims.width, dims.height); })();
                    listEl.innerHTML = '';
                }
                scale = 1.2;
                persistView();
                updateZoomDisplay();
                await renderPage(); 
            };
            function appendListItem(bbox){ const item=document.createElement('div'); item.className='bbox-item'; const code=document.createElement('code'); code.textContent=JSON.stringify(bbox); item.appendChild(code); listEl.appendChild(item); }
            clearBtn.onclick = ()=>{ 
                lastDrawn = null; 
                (() => { const dims = getCanvasCssDimensions(); drawCtx.clearRect(0, 0, dims.width, dims.height); })(); 
                listEl.innerHTML = ''; 
                collected = collected.filter(b=>b.page!==currentPage); 
            };
            undoBtn.onclick = ()=>{ 
                if (confirm('Are you sure you want to undo the last drawing? This will clear the current bounding box.')) {
                    lastDrawn = null; 
                    (() => { const dims = getCanvasCssDimensions(); drawCtx.clearRect(0, 0, dims.width, dims.height); })(); 
                    listEl.innerHTML = ''; 
                    collected = collected.filter(b=>b.page!==currentPage); 
                }
            };
            document.getElementById('em-add').onclick = ()=>{ 
                if(!lastDrawn) return; 
                collected.push(JSON.parse(JSON.stringify(lastDrawn))); 
                appendListItem(lastDrawn); 
                lastDrawn = null; 
                (() => { const dims = getCanvasCssDimensions(); drawCtx.clearRect(0, 0, dims.width, dims.height); })(); 
            };
            gotoBtn.onclick = async ()=>{ 
                if(!pdfDoc) return; 
                const n=parseInt(gotoInput.value,10); 
                if(!Number.isInteger(n)) return; 
                const target=Math.min(Math.max(n,1), totalPages); 
                if(target!==currentPage){ 
                    if (lastDrawn && !confirm('You have an unsaved bounding box. Are you sure you want to navigate away and lose it?')) {
                        return;
                    }
                    lastDrawn=null; 
                    try{ const dims = getCanvasCssDimensions(); drawCtx.clearRect(0,0,dims.width,dims.height); listEl.innerHTML=''; }catch{} 
                    currentPage=target; 
                    store.currentPage=currentPage; 
                    await renderPage(); 
                } 
            };
            gotoInput.addEventListener('keypress', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); gotoBtn.click(); } });
            
            // Add scroll listener to save bbox modal scroll position automatically
            // Save as percentage to work correctly across different zoom levels
            // CRITICAL: Always save to MODAL_SESSION_KEY, not activeKey (which can change)
            let scrollSaveTimeout;
            const scrollHandler = () => {
                clearTimeout(scrollSaveTimeout);
                scrollSaveTimeout = setTimeout(() => {
                    if (store.docs[MODAL_SESSION_KEY] && canvasWrap) {
                        const scrollWidth = canvasWrap.scrollWidth - canvasWrap.clientWidth;
                        const scrollHeight = canvasWrap.scrollHeight - canvasWrap.clientHeight;
                        
                        // Save as percentage of total scrollable area
                        if (scrollWidth > 0) {
                            store.docs[MODAL_SESSION_KEY].scrollLeftPercent = canvasWrap.scrollLeft / scrollWidth;
                        }
                        if (scrollHeight > 0) {
                            store.docs[MODAL_SESSION_KEY].scrollTopPercent = canvasWrap.scrollTop / scrollHeight;
                        }
                        // Also save absolute values as backup
                        store.docs[MODAL_SESSION_KEY].scrollLeft = canvasWrap.scrollLeft;
                        store.docs[MODAL_SESSION_KEY].scrollTop = canvasWrap.scrollTop;
                    }
                }, 100);
            };
            
            canvasWrap.addEventListener('scroll', scrollHandler);
            
            // Store reference for cleanup
            modal._scrollHandler = scrollHandler;
            modal._canvasWrap = canvasWrap;

            const closeModal = () => {
                // CRITICAL: Save current state to MODAL_SESSION_KEY (not activeKey which may have changed)
                // This ensures state is saved to the original PDF that opened this modal
                // When opened from Draw button, save to temporary location to avoid affecting main viewer
                if (pdfDoc && MODAL_SESSION_KEY) {
                    if (!isMainFormUpload && savedMainViewerState) {
                        // Save modal state to temporary location
                        if (!store.docs[MODAL_SESSION_KEY]._modalState) {
                            store.docs[MODAL_SESSION_KEY]._modalState = {};
                        }
                        store.docs[MODAL_SESSION_KEY]._modalState.currentPage = currentPage;
                        store.docs[MODAL_SESSION_KEY]._modalState.scale = scale;
                        if (canvasWrap) {
                            const scrollWidth = canvasWrap.scrollWidth - canvasWrap.clientWidth;
                            const scrollHeight = canvasWrap.scrollHeight - canvasWrap.clientHeight;
                            if (scrollWidth > 0) {
                                store.docs[MODAL_SESSION_KEY]._modalState.scrollLeftPercent = canvasWrap.scrollLeft / scrollWidth;
                            }
                            if (scrollHeight > 0) {
                                store.docs[MODAL_SESSION_KEY]._modalState.scrollTopPercent = canvasWrap.scrollTop / scrollHeight;
                            }
                            store.docs[MODAL_SESSION_KEY]._modalState.scrollLeft = canvasWrap.scrollLeft;
                            store.docs[MODAL_SESSION_KEY]._modalState.scrollTop = canvasWrap.scrollTop;
                        }
                    } else {
                        // Normal save for main form uploads
                        store.docs[MODAL_SESSION_KEY].currentPage = currentPage;
                        store.docs[MODAL_SESSION_KEY].scale = scale;
                        if (canvasWrap) {
                            // Save as percentage for zoom-independent restoration
                            const scrollWidth = canvasWrap.scrollWidth - canvasWrap.clientWidth;
                            const scrollHeight = canvasWrap.scrollHeight - canvasWrap.clientHeight;
                            if (scrollWidth > 0) {
                                store.docs[MODAL_SESSION_KEY].scrollLeftPercent = canvasWrap.scrollLeft / scrollWidth;
                            }
                            if (scrollHeight > 0) {
                                store.docs[MODAL_SESSION_KEY].scrollTopPercent = canvasWrap.scrollTop / scrollHeight;
                            }
                            // Also save absolute values as backup
                            store.docs[MODAL_SESSION_KEY].scrollLeft = canvasWrap.scrollLeft;
                            store.docs[MODAL_SESSION_KEY].scrollTop = canvasWrap.scrollTop;
                        }
                    }
                }
                
                // Restore main viewer's state if it was saved (only for Draw button, not main form upload)
                if (savedMainViewerState && !isMainFormUpload) {
                    const mainState = window.__mainPdfViewer;
                    if (mainState) {
                        // First, restore the store values for both textbook and guidebook to prevent cross-contamination
                        // This must be done BEFORE any source switching or loading
                        if (store.docs.text) {
                            store.docs.text.currentPage = savedMainViewerState.textCurrentPage;
                            store.docs.text.mainViewerScale = savedMainViewerState.textScale;
                            store.docs.text.mainViewerScrollLeft = savedMainViewerState.textScrollLeft;
                            store.docs.text.mainViewerScrollTop = savedMainViewerState.textScrollTop;
                        }
                        if (store.docs.guide) {
                            store.docs.guide.currentPage = savedMainViewerState.guideCurrentPage;
                            store.docs.guide.mainViewerScale = savedMainViewerState.guideScale;
                            store.docs.guide.mainViewerScrollLeft = savedMainViewerState.guideScrollLeft;
                            store.docs.guide.mainViewerScrollTop = savedMainViewerState.guideScrollTop;
                        }
                        
                        // Restore the main viewer's source if it was changed
                        // Do this after restoring store values, but use a direct approach to avoid overwriting
                        if (mainState.source !== savedMainViewerState.source) {
                            console.log('Restoring main viewer source from', mainState.source, 'to', savedMainViewerState.source);
                            
                            // Directly set the source without using switchPdfSource to avoid saving current state
                            const oldSource = mainState.source;
                            mainState.source = savedMainViewerState.source;
                            mainState.lastSyncedPage = null;
                            mainState.lastSyncedSource = null;
                            
                            // Update toggle button states
                            if (mainState.elements && mainState.elements.sourceToggle) {
                                if (mainState.elements.sourceToggle.textbook) {
                                    mainState.elements.sourceToggle.textbook.classList.toggle('active', savedMainViewerState.source === 'textbook');
                                }
                                if (mainState.elements.sourceToggle.guide) {
                                    mainState.elements.sourceToggle.guide.classList.toggle('active', savedMainViewerState.source === 'guide');
                                }
                            }
                            
                            // Load PDF from store for the restored source (this will use our restored values)
                            if (typeof loadPdfFromStore === 'function') {
                                loadPdfFromStore();
                            }
                        }
                        
                        // Update main viewer state to match saved values
                        // Do this after a short delay to ensure loadPdfFromStore has completed
                        setTimeout(() => {
                            if (mainState.visible) {
                                const restoredKey = savedMainViewerState.key;
                                if (mainState.source === (restoredKey === 'text' ? 'textbook' : 'guide')) {
                                    // Only update and render if values actually changed
                                    const pageChanged = mainState.currentPage !== savedMainViewerState.currentPage;
                                    const scaleChanged = mainState.scale !== savedMainViewerState.scale;
                                    
                                    if (pageChanged || scaleChanged) {
                                        mainState.currentPage = savedMainViewerState.currentPage;
                                        mainState.scale = savedMainViewerState.scale;
                                        // Render the page to reflect the restored state
                                        if (mainState.canvas && mainState.context) {
                                            renderMainPdfPage();
                                            updatePdfControls();
                                        }
                                    }
                                }
                            }
                        }, 100);
                    }
                }
                
                restoreBboxModalLayout();
                window.__embeddedBboxTarget = null;
                // Clear flag to allow auto-navigation to work again
                window.__bboxModalOpen = false;
                modal.classList.remove('show');
                
                // Restore main PDF viewer scroll position
                if (window.__mainPdfScroll) {
                    const mainPdfContainer = document.getElementById('pdf-canvas-container');
                    if (mainPdfContainer) {
                        requestAnimationFrame(() => {
                            mainPdfContainer.scrollLeft = window.__mainPdfScroll.scrollLeft || 0;
                            mainPdfContainer.scrollTop = window.__mainPdfScroll.scrollTop || 0;
                        });
                    }
                    window.__mainPdfScrollSaved = false;
                }
                
                // Remove Escape and Enter key listeners when modal closes
                if (modal._escapeHandler) {
                    document.removeEventListener('keydown', modal._escapeHandler);
                    delete modal._escapeHandler;
                }
                if (modal._enterHandler) {
                    document.removeEventListener('keydown', modal._enterHandler);
                    delete modal._enterHandler;
                }
                
                // Remove scroll listener when modal closes
                if (modal._scrollHandler && modal._canvasWrap) {
                    modal._canvasWrap.removeEventListener('scroll', modal._scrollHandler);
                    delete modal._scrollHandler;
                    delete modal._canvasWrap;
                }
            };
            
            document.getElementById('em-close').onclick = closeModal;
            
            // Add Escape key handler to close modal
            const handleEscape = (e) => {
                if (e.key === 'Escape' && modal.classList.contains('show')) {
                    e.preventDefault();
                    e.stopPropagation();
                    closeModal();
                }
            };
            
            // Add Enter key handler to trigger "Use Selected" button
            const handleEnter = (e) => {
                if (e.key === 'Enter' && modal.classList.contains('show')) {
                    // Don't trigger if user is typing in an input field or textarea
                    const activeElement = document.activeElement;
                    if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA')) {
                        // Let the input handle Enter naturally
                        return;
                    }
                    // If not in an input field, trigger the confirm button
                    e.preventDefault();
                    e.stopPropagation();
                    confirmBtn.click();
                }
            };
            
            // Add event listeners when modal opens, remove when it closes
            document.addEventListener('keydown', handleEscape);
            document.addEventListener('keydown', handleEnter);
            
            // Store handler references for cleanup (will be removed when modal closes)
            modal._escapeHandler = handleEscape;
            modal._enterHandler = handleEnter;
            confirmBtn.onclick = ()=>{
                if (!window.__embeddedBboxTarget) { 
                    closeModal();
                    return; 
                }
                const target = window.__embeddedBboxTarget;
                
                // If this is opened from main form for PDF upload, refresh the main viewer and close
                if (target.isMainFormUpload) {
                    restoreBboxModalLayout();
                    window.__embeddedBboxTarget = null;
                    modal.classList.remove('show');
                    
                    // Clean up escape and enter handlers
                    if (modal._escapeHandler) {
                        document.removeEventListener('keydown', modal._escapeHandler);
                        delete modal._escapeHandler;
                    }
                    if (modal._enterHandler) {
                        document.removeEventListener('keydown', modal._enterHandler);
                        delete modal._enterHandler;
                    }
                    
                    // Refresh the main PDF viewer after upload
                    setTimeout(() => {
                        const state = window.__mainPdfViewer;
                        if (state) {
                            // Always try to load from store, even if not visible
                            const loaded = loadPdfFromStore();
                            console.log('PDF Upload: After modal close, loaded from store:', loaded);
                            
                            // If viewer is visible, ensure it renders
                            if (state.visible && loaded && state.canvas && state.context) {
                                console.log('PDF Upload: Rendering in main viewer');
                                renderMainPdfPage();
                            } else if (state.visible && loaded) {
                                // Wait a bit more for canvas
                                setTimeout(() => {
                                    if (state.canvas && state.context) {
                                        renderMainPdfPage();
                                    }
                                }, 300);
                            }
                        }
                    }, 300);
                    
                    return;
                }
                
                const targetRow = target.inputs && target.inputs[0] ? target.inputs[0].closest('.array-item') : null;
                const parentContainer = targetRow ? targetRow.parentElement : null;
                
                // Determine the type of bbox group to use appropriate before/after functions
                let beforeFunc = 'addContentBboxBefore';
                let afterFunc = 'addContentBboxAfter';
                let beforeTitle = 'Add BBox Before';
                let afterTitle = 'Add BBox After';
                
                // Check the form group label to determine bbox type (similar to fillBboxGroup)
                const formGroup = targetRow ? targetRow.closest('.form-group') : null;
                const labelEl = formGroup ? formGroup.querySelector('label') : null;
                const labelText = labelEl ? labelEl.textContent : '';
                
                if (labelText.includes('Question Images')) {
                    beforeFunc = 'addQuestionImageBefore';
                    afterFunc = 'addQuestionImageAfter';
                    beforeTitle = 'Add Image Before';
                    afterTitle = 'Add Image After';
                } else if (labelText.includes('Answer Images')) {
                    beforeFunc = 'addAnswerImageBefore';
                    afterFunc = 'addAnswerImageAfter';
                    beforeTitle = 'Add Image Before';
                    afterTitle = 'Add Image After';
                } else if (labelText.includes('Section Images')) {
                    beforeFunc = 'addContentImageBefore';
                    afterFunc = 'addContentImageAfter';
                    beforeTitle = 'Add Image Before';
                    afterTitle = 'Add Image After';
                }
                
                const boxes = [...(collected||[])];
                if (lastDrawn) boxes.push(lastDrawn);
                if (boxes.length === 0) { 
                    closeModal();
                    return; 
                }
                // Fill first into current row
                const first = boxes.shift();
                let [[fxr,fyt],[fxl,fyb]] = first.position;
                
                // Normalize coordinates before filling
                const normalized = normalizeBboxCoordinates(fxr, fyt, fxl, fyb);
                if (normalized) {
                    fxr = normalized.x0;
                    fyt = normalized.y0;
                    fxl = normalized.x1;
                    fyb = normalized.y1;
                }
                
                target.inputs[0].value = first.page || '';
                target.inputs[1].value = fxr; target.inputs[2].value = fyt; target.inputs[3].value = fxl; target.inputs[4].value = fyb;
                // For remaining, create new rows in same group and fill
                if (parentContainer) {
                    boxes.forEach(b => {
                        const newItem = document.createElement('div');
                        newItem.className = 'array-item';
                        newItem.innerHTML = `
                            <div class="bbox-inputs">
                                <input type="number" placeholder="Page" class="bbox-page" min="1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57" title="PDF page number where this image appears">
                                <input type="number" placeholder="X0" class="bbox-x0" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57" title="Right X coordinate (top-right corner)">
                                <input type="number" placeholder="Y0" class="bbox-y0" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57" title="Top Y coordinate (top-right corner)">
                                <input type="number" placeholder="X1" class="bbox-x1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57" title="Left X coordinate (bottom-left corner)">
                                <input type="number" placeholder="Y1" class="bbox-y1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57" title="Bottom Y coordinate (bottom-left corner)">
                            </div>
                            <div class="row-actions">
                                <button class="add-bbox-btn" onclick="${beforeFunc}(this)" title="${beforeTitle}">
                                    <i class="fas fa-plus"></i> Before
                                </button>
                                <button class="add-bbox-btn" onclick="${afterFunc}(this)" title="${afterTitle}">
                                    <i class="fas fa-plus"></i> After
                                </button>
                                <button class="reorder-btn" onclick="moveItemUp(this)" title="Move Up"><i class="fas fa-arrow-up"></i></button>
                                <button class="reorder-btn" onclick="moveItemDown(this)" title="Move Down"><i class="fas fa-arrow-down"></i></button>
                                <button class="add-btn" onclick="openBboxDrawer(this)"><i class="fas fa-pen-square"></i> Draw</button>
                                <button class="add-btn" onclick="pasteBboxJson(this)"><i class="fas fa-paste"></i> Paste</button>
                                <button class="add-btn" onclick="copyBboxJson(this)"><i class="fas fa-copy"></i> Copy</button>
                                <button class="remove-btn" onclick="removeArrayItem(this)"></button>
                            </div>
                        `;
                        parentContainer.appendChild(newItem);
                        const ins = newItem.querySelectorAll('.bbox-inputs input');
                        let [[xr,yt],[xl,yb]] = b.position;
                        
                        // Normalize coordinates before filling
                        const bNormalized = normalizeBboxCoordinates(xr, yt, xl, yb);
                        if (bNormalized) {
                            xr = bNormalized.x0;
                            yt = bNormalized.y0;
                            xl = bNormalized.x1;
                            yb = bNormalized.y1;
                        }
                        
                        ins[0].value=b.page||''; ins[1].value=xr; ins[2].value=yt; ins[3].value=xl; ins[4].value=yb;
                        
                        // Attach bbox validation to the new item
                        const coordinateInputs = newItem.querySelectorAll('.bbox-x0, .bbox-y0, .bbox-x1, .bbox-y1');
                        coordinateInputs.forEach(input => {
                            const handler = function() {
                                validateAndNormalizeBbox(newItem);
                            };
                            input.addEventListener('blur', handler);
                            input.__bboxValidationHandler = handler;
                        });
                    });
                }
                
                // Mark form as changed and trigger auto-save after coordinates are filled
                markFormAsChanged();
                triggerAutoSave();
                
                closeModal();
            };
            cancelBtn.onclick = ()=>{
                if (collected.length > 0 || lastDrawn) {
                    if (confirm('You have unsaved bounding boxes. Are you sure you want to cancel and lose your work?')) {
                        closeModal();
                    }
                } else {
                    closeModal();
                }
            };

            // PDFs should already be loaded from IndexedDB on page initialization
            // If a PDF is already loaded, render immediately (respect hint page if provided)
            if (!pdfDoc) { 
                // Use the PDF that matches MODAL_SESSION_KEY (the PDF that opened this modal)
                if (store.docs[MODAL_SESSION_KEY].pdfDoc) {
                    // Use the PDF that matches the requested MODAL_SESSION_KEY
                    pdfDoc = store.docs[MODAL_SESSION_KEY].pdfDoc; 
                    totalPages = store.docs[MODAL_SESSION_KEY].totalPages; 
                } else if (store.docs.text.pdfDoc && MODAL_SESSION_KEY === 'text') {
                    // Fallback: if text was requested but not found, use text if available
                    pdfDoc = store.docs.text.pdfDoc; 
                    totalPages = store.docs.text.totalPages; 
                } else if (store.docs.guide.pdfDoc && MODAL_SESSION_KEY === 'guide') {
                    // Fallback: if guide was requested but not found, use guide if available
                    pdfDoc = store.docs.guide.pdfDoc; 
                    totalPages = store.docs.guide.totalPages; 
                }
            }
            
            if (pdfDoc) {
                // Check if there are existing bbox values in the inputs - if so, jump to them
                let hasExistingBbox = false;
                let bboxPage = null;
                let bboxCoords = null;
                
                if (activeInputs && activeInputs.length >= 5) {
                    const pageVal = activeInputs[0].value ? parseInt(activeInputs[0].value, 10) : null;
                    const x0Val = activeInputs[1].value ? parseFloat(activeInputs[1].value) : null;
                    const y0Val = activeInputs[2].value ? parseFloat(activeInputs[2].value) : null;
                    const x1Val = activeInputs[3].value ? parseFloat(activeInputs[3].value) : null;
                    const y1Val = activeInputs[4].value ? parseFloat(activeInputs[4].value) : null;
                    
                    // Check if all bbox values are present and valid
                    if (Number.isFinite(pageVal) && pageVal > 0 && 
                        Number.isFinite(x0Val) && Number.isFinite(y0Val) && 
                        Number.isFinite(x1Val) && Number.isFinite(y1Val)) {
                        hasExistingBbox = true;
                        bboxPage = pageVal;
                        bboxCoords = { x0: x0Val, y0: y0Val, x1: x1Val, y1: y1Val };
                    }
                }
                
                if (hasExistingBbox && bboxPage && pdfDoc) {
                    // Override saved state with bbox values
                    currentPage = Math.min(Math.max(bboxPage, 1), totalPages || bboxPage);
                    store.docs[MODAL_SESSION_KEY].currentPage = currentPage;
                    
                    // Calculate optimal zoom to fit bbox in viewport
                    try {
                        const page = await pdfDoc.getPage(currentPage);
                        const defaultViewport = page.getViewport({ scale: 1.0 });
                        
                        // Bbox coordinates: x0,y0 is top-right, x1,y1 is bottom-left
                        // Calculate bbox dimensions in PDF space
                        const bboxWidth = Math.abs(bboxCoords.x0 - bboxCoords.x1);
                        const bboxHeight = Math.abs(bboxCoords.y0 - bboxCoords.y1);
                        
                        // Get viewport dimensions - use modal dimensions or reasonable defaults
                        // The modal is visible at this point, so we can get its dimensions
                        let viewportWidth = canvasWrap.clientWidth;
                        let viewportHeight = canvasWrap.clientHeight;
                        
                        // If dimensions aren't available yet, use modal container or defaults
                        if (!viewportWidth || !viewportHeight) {
                            const modalContent = document.querySelector('.bbox-content');
                            if (modalContent) {
                                viewportWidth = modalContent.clientWidth - 360; // Account for sidebar (340px + gap)
                                viewportHeight = window.innerHeight * 0.7; // Use 70% of viewport height
                            } else {
                                // Fallback to reasonable defaults
                                viewportWidth = 800;
                                viewportHeight = 600;
                            }
                        }
                        
                        const padding = 40; // Padding around bbox
                        const availableWidth = Math.max(viewportWidth - (padding * 2), 200);
                        const availableHeight = Math.max(viewportHeight - (padding * 2), 200);
                        
                        // Calculate optimal scale to fit bbox with padding
                        const scaleX = availableWidth / bboxWidth;
                        const scaleY = availableHeight / bboxHeight;
                        // Use the smaller scale to ensure bbox fits entirely
                        const optimalScale = Math.min(scaleX, scaleY, 8.0); // Cap at 8x zoom
                        // Ensure minimum zoom level
                        scale = Math.max(optimalScale, 0.5);
                        
                        // Store bbox coords for centering calculation after render
                        store.docs[MODAL_SESSION_KEY]._jumpToBbox = bboxCoords;
                        // Update scale in store
                        store.docs[MODAL_SESSION_KEY].scale = scale;
                    } catch (error) {
                        console.error('Error calculating optimal zoom:', error);
                        // Fallback to saved scale if calculation fails
                        scale = store.docs[MODAL_SESSION_KEY].scale || 1.2;
                        store.docs[MODAL_SESSION_KEY]._jumpToBbox = bboxCoords;
                    }
                    
                    // Render page with optimal zoom, then center bbox
                    await renderPage();
                    // Centering will be handled in renderPage after canvas is rendered
                } else {
                    // ALWAYS load saved state from the store for MODAL_SESSION_KEY
                    // This ensures we get the correct zoom/scroll for the PDF that opened this modal
                    currentPage = store.docs[MODAL_SESSION_KEY].currentPage || 1;
                    scale = store.docs[MODAL_SESSION_KEY].scale || 1.2;
                    
                    // Only override saved page if we have a hint or lastDrawn (for navigation purposes)
                    const desiredOpen = (lastDrawn?.page) || (hintPage ? parseInt(hintPage,10) : null);
                    if (Number.isFinite(desiredOpen)) {
                        const bounded = Math.min(Math.max(desiredOpen||1,1), totalPages||desiredOpen||1);
                        currentPage = bounded;
                        // Update store with the new page, but keep the saved scale/scroll
                        store.docs[MODAL_SESSION_KEY].currentPage = currentPage;
                    }
                    // Render with the loaded state (saved zoom/scroll will be restored in renderPage)
                    renderPage();
                }
            }
        }

        // Helper function to find duplicate values in an array
        function findDuplicates(arr) {
            const duplicates = [];
            const seen = new Set();
            
            arr.forEach(item => {
                if (seen.has(item)) {
                    if (!duplicates.includes(item)) {
                        duplicates.push(item);
                    }
                } else {
                    seen.add(item);
                }
            });
            
            return duplicates;
        }

        // Validate that tables have matching image bbox entries
        function validateTableImageReferences(jsonData) {
            const errors = [];
            
            // Check for tables in content sections
            if (jsonData.instructional_content) {
                jsonData.instructional_content.forEach((content, index) => {
                    
                    if (content.text && content.text.includes('|')) {
                        const tableImageIndices = extractTableImageIndices(content.text);
                        
                        const contentImageIndices = new Set();
                        
                        // Get image indices from this content section's image bboxes
                        if (content.images && content.images.length > 0) {
                            content.images.forEach(bbox => {
                                contentImageIndices.add(bbox.page.toString());
                            });
                        }
                        
                        
                        // Check if table images match content section images (by array index)
                        tableImageIndices.forEach(imgIndex => {
                            const arrayIndex = parseInt(imgIndex);
                            
                            if (arrayIndex < 0 || arrayIndex >= content.images.length) {
                                // Check if there are any image bboxes in this section
                                if (content.images.length === 0) {
                                    errors.push(ErrorMessages.missingTableImageContent(index, imgIndex));
                                } else {
                                    errors.push(ErrorMessages.outOfRangeContent(index, imgIndex, content.images.length - 1));
                                }
                            }
                        });
                    }
                });
            }
            
            // Check for tables in questions
            if (jsonData.practice_questions) {
                jsonData.practice_questions.forEach((question, qIndex) => {
                    const questionText = question.question_text || '';
                    const guideAnswer = question.guide_answer || '';
                    const setupText = question.set_up_text || '';
                    const questionType = question.question_type || 'free_form';
                    const choices = question.choices || [];
                    
                                            // Check for duplicate indices within each image array separately
                        
                        // Setup text and question text share question_images array
                        const sharedQuestionIndices = [];
                        if (questionText.includes('|')) {
                            sharedQuestionIndices.push(...extractTableImageIndices(questionText));
                        }
                        if (setupText.includes('|')) {
                            sharedQuestionIndices.push(...extractTableImageIndices(setupText));
                        }
                        
                        // NOTE: Duplicate checking removed - handled by validateImageConsistency()
                        
                    // For MCQ: Check choices for table image references (choices share question_images)
                    // For free_form: Check guide answer for table image references
                    if ((questionType === 'multiple_choice' || questionType === 'checkbox') && choices.length > 0) {
                        // Choices share question_images with setup and question text
                        // Collect choice table indices and combine with setup/question indices
                        const allChoiceTableIndices = [];
                        choices.forEach((choice, choiceIndex) => {
                            const choiceText = choice.text || '';
                            if (choiceText.includes('|')) {
                                const choiceTableIndices = extractTableImageIndices(choiceText);
                                allChoiceTableIndices.push(...choiceTableIndices);
                            }
                        });
                        
                        // Combine with setup and question text indices
                        const combinedQuestionIndices = [...sharedQuestionIndices, ...allChoiceTableIndices];
                        
                        // NOTE: Duplicate checking removed - handled by validateImageConsistency()
                        
                        // Validate choice table indices against question_images array
                        allChoiceTableIndices.forEach(imgIndex => {
                            const arrayIndex = parseInt(imgIndex);
                            if (arrayIndex < 0 || arrayIndex >= question.question_images.length) {
                                if (question.question_images.length === 0) {
                                    errors.push(ErrorMessages.missingImageChoice(qIndex, imgIndex));
                                } else {
                                    errors.push(ErrorMessages.outOfRangeQuestion(qIndex, imgIndex, question.question_images.length - 1, true));
                                }
                            }
                        });
                    } else {
                        // Free form: Guide answer has its own guide_answer_images array
                        if (guideAnswer.includes('|')) {
                            const guideAnswerIndices = extractTableImageIndices(guideAnswer);
                            
                            // NOTE: Duplicate checking removed - handled by validateImageConsistency()
                            
                            // Validate guide answer table indices
                            guideAnswerIndices.forEach(imgIndex => {
                                const arrayIndex = parseInt(imgIndex);
                                if (arrayIndex < 0 || arrayIndex >= question.guide_answer_images.length) {
                                    if (question.guide_answer_images.length === 0) {
                                        errors.push(ErrorMessages.missingTableImageAnswer(qIndex, imgIndex));
                                    } else {
                                        errors.push(ErrorMessages.outOfRangeAnswer(qIndex, imgIndex, question.guide_answer_images.length - 1));
                                    }
                                }
                            });
                        }
                    }
                    
                    // Validate indices against their respective arrays
                    sharedQuestionIndices.forEach(imgIndex => {
                        const arrayIndex = parseInt(imgIndex);
                        if (arrayIndex < 0 || arrayIndex >= question.question_images.length) {
                            if (question.question_images.length === 0) {
                                errors.push(ErrorMessages.missingTableImageQuestion(qIndex, imgIndex));
                            } else {
                                errors.push(ErrorMessages.outOfRangeQuestion(qIndex, imgIndex, question.question_images.length - 1, false));
                            }
                        }
                    });
                });
            }
            
            return errors;
        }

        // Validate that image references in text have corresponding image bboxes
        function validateImageReferences(jsonData) {
            const errors = [];
            
            // Check content sections
            if (jsonData.instructional_content) {
                jsonData.instructional_content.forEach((content, index) => {
                    const text = content.text || '';
                    const images = content.images || [];
                    
                    if (text) {
                        // Check for both image references and table references (tables are images)
                        const { uniqueIndices } = getContentTextIndices(content);
                        
                        uniqueIndices.forEach(imgIndex => {
                            const arrayIndex = parseInt(imgIndex);
                            if (arrayIndex < 0 || arrayIndex >= images.length) {
                                // Only flag if there are no images at all, otherwise count mismatch will handle it
                                if (images.length === 0) {
                                    errors.push(ErrorMessages.missingImageContent(index, imgIndex));
                                }
                                // Skip out-of-range errors when images exist - count mismatch will handle it
                            }
                        });
                    }
                });
            }
            
            // Check practice questions
            if (jsonData.practice_questions) {
                jsonData.practice_questions.forEach((question, qIndex) => {
                    const questionImages = question.question_images || [];
                    const guideAnswerImages = question.guide_answer_images || [];
                    
                    const { uniqueQuestionIndices, uniqueGuideIndices } = getQuestionTextIndices(question);
                    
                    uniqueQuestionIndices.forEach(imgIndex => {
                        const arrayIndex = parseInt(imgIndex);
                        if (arrayIndex < 0 || arrayIndex >= questionImages.length) {
                            // Only flag if there are no images at all, otherwise count mismatch will handle it
                            if (questionImages.length === 0) {
                                errors.push(ErrorMessages.missingImageQuestion(qIndex, imgIndex));
                            }
                            // Skip out-of-range errors when images exist - count mismatch will handle it
                        }
                    });
                    
                    // Check guide answer (for both MCQ and free_form, guide_answer uses guide_answer_images)
                    {
                        // Free form: Check guide answer against guide_answer_images (including table references)
                    uniqueGuideIndices.forEach(imgIndex => {
                        const arrayIndex = parseInt(imgIndex);
                        if (arrayIndex < 0 || arrayIndex >= guideAnswerImages.length) {
                            // Only flag if there are no images at all, otherwise count mismatch will handle it
                            if (guideAnswerImages.length === 0) {
                                errors.push(ErrorMessages.missingImageAnswer(qIndex, imgIndex));
                            }
                            // Skip out-of-range errors when images exist - count mismatch will handle it
                        }
                    });
                    }
                });
            }
            
            return errors;
        }

        // Helper function to extract image indices from text
        function extractImageIndices(text) {
            const imageIndices = [];
            if (!text) return imageIndices;
            
            // Look for both formats: ![description](index) and ![]()(index)
            const regex1 = /!\[.*?\]\((\d+)\)/g;  // Standard markdown
            const regex2 = /!\[\]\((\d+)\)/g;      // Empty description
            
            let match;
            while ((match = regex1.exec(text)) !== null) {
                imageIndices.push(match[1]);
            }
            while ((match = regex2.exec(text)) !== null) {
                imageIndices.push(match[1]);
            }
            
            return imageIndices;
        }

        // Validate that image bboxes have corresponding image references in text
        function validateImageBboxes(jsonData) {
            const errors = [];
            
            // Check content sections
            if (jsonData.instructional_content) {
                jsonData.instructional_content.forEach((content, index) => {
                    const images = content.images || [];
                    
                    if (images.length > 0) {
                        const { uniqueIndices } = getContentTextIndices(content);
                        const referencedIndices = new Set(uniqueIndices);
                        
                        // Check if there are image bboxes that don't have corresponding references
                        for (let i = 0; i < images.length; i++) {
                            if (!referencedIndices.has(i)) {
                                errors.push(ErrorMessages.unusedImageContent(index, i));
                            }
                        }
                    }
                });
            }
            
            // Check practice questions
            if (jsonData.practice_questions) {
                jsonData.practice_questions.forEach((question, qIndex) => {
                    const questionImages = question.question_images || [];
                    const guideAnswerImages = question.guide_answer_images || [];
                    const questionType = question.question_type || 'free_form';
                    
                    const { uniqueQuestionIndices, uniqueGuideIndices } = getQuestionTextIndices(question);
                    
                    // Check question images against setup text, question text, and choices (for MCQ)
                    // Setup text, question text, and choices share the same question_images array
                    if (questionImages.length > 0) {
                        const referencedIndices = new Set(uniqueQuestionIndices);
                        
                        for (let i = 0; i < questionImages.length; i++) {
                            if (!referencedIndices.has(i)) {
                                errors.push(ErrorMessages.unusedImageQuestion(qIndex, i, (questionType === 'multiple_choice' || questionType === 'checkbox')));
                            }
                        }
                    }
                    
                    // Check guide answer images against guide answer (for both MCQ and free_form)
                    {
                        // Free form: Check guide answer images against guide answer (including table references)
                    if (guideAnswerImages.length > 0) {
                        const referencedIndices = new Set(uniqueGuideIndices);
                        
                        for (let i = 0; i < guideAnswerImages.length; i++) {
                            if (!referencedIndices.has(i)) {
                                errors.push(ErrorMessages.unusedImageAnswer(qIndex, i));
                                }
                            }
                        }
                    }
                });
            }
            
            return errors;
        }

        // Validate image consistency (duplicate indices and mismatched counts)
        function validateImageConsistency(jsonData) {
            const errors = [];
            
            // Check content sections
            if (jsonData.instructional_content) {
                jsonData.instructional_content.forEach((content, index) => {
                    const images = content.images || [];
                    const text = content.text || '';
                    
                    if (text) {
                        const { allIndices, uniqueIndices } = getContentTextIndices(content);
                        
                        // Check for duplicate indices within the same text
                        const duplicateIndices = findDuplicates(allIndices);
                        if (duplicateIndices.length > 0) {
                            errors.push(ErrorMessages.duplicateImagesContent(index, duplicateIndices));
                        }
                        
                        // Check for mismatched image count
                        if (uniqueIndices.length !== images.length) {
                            errors.push(ErrorMessages.countMismatchContent(index, uniqueIndices.length, images.length));
                        }
                    }
                });
            }
            
            // Check practice questions
            if (jsonData.practice_questions) {
                jsonData.practice_questions.forEach((question, qIndex) => {
                    const questionImages = question.question_images || [];
                    const guideAnswerImages = question.guide_answer_images || [];
                    const questionType = question.question_type || 'free_form';
                    
                    const { allQuestionIndices, allGuideIndices, uniqueGuideIndices } = getQuestionTextIndices(question);
                    
                    // Check for duplicates and mismatched counts based on question type
                    if (questionType === 'multiple_choice' || questionType === 'checkbox') {
                        // Get unique indices from the already extracted allQuestionIndices
                        const uniqueQuestionIndices = getUniqueIndices(allQuestionIndices);
                        
                        // Check for duplicate indices across setup, question, and choices
                        const duplicateQuestionIndices = findDuplicates(allQuestionIndices);
                        if (duplicateQuestionIndices.length > 0) {
                            errors.push(ErrorMessages.duplicateImagesQuestion(qIndex, duplicateQuestionIndices, true));
                        }
                        
                        // Check for mismatched question image count (compare unique indices with bbox count)
                        if (uniqueQuestionIndices.length !== questionImages.length) {
                            errors.push(ErrorMessages.countMismatchQuestion(qIndex, uniqueQuestionIndices.length, questionImages.length, true));
                        }
                    } else {
                        // Free form: Check setup and question text for duplicates and mismatched counts
                        const uniqueQuestionIndices = getUniqueIndices(allQuestionIndices);
                        
                        // Check for duplicate indices between setup text and question text
                        const duplicateQuestionIndices = findDuplicates(allQuestionIndices);
                        if (duplicateQuestionIndices.length > 0) {
                            errors.push(ErrorMessages.duplicateImagesQuestion(qIndex, duplicateQuestionIndices, false));
                        }
                        
                        // Check for mismatched question image count (compare unique indices with bbox count)
                        if (uniqueQuestionIndices.length !== questionImages.length) {
                            errors.push(ErrorMessages.countMismatchQuestion(qIndex, uniqueQuestionIndices.length, questionImages.length, false));
                        }
                    }
                    
                    // Check guide answer for duplicates and mismatched counts (both MCQ and free_form)
                    // Guide answer has its own guide_answer_images array
                    
                    // Check for duplicate indices within guide answer
                    const duplicateGuideAnswerIndices = findDuplicates(allGuideIndices);
                    if (duplicateGuideAnswerIndices.length > 0) {
                        errors.push(ErrorMessages.duplicateImagesAnswer(qIndex, duplicateGuideAnswerIndices));
                    }
                    
                    // Check for mismatched guide answer image count
                    if (allGuideIndices.length !== guideAnswerImages.length) {
                        errors.push(ErrorMessages.countMismatchAnswer(qIndex, allGuideIndices.length, guideAnswerImages.length));
                    }
                });
            }
            
            return errors;
        }

        // Validate image index ordering (must start from 0 and be sequential)
        function validateImageOrdering(jsonData) {
            const errors = [];
            
            // Check content sections
            if (jsonData.instructional_content) {
                jsonData.instructional_content.forEach((content, index) => {
                    const text = content.text || '';
                    const images = content.images || [];
                    
                    if (text && images.length > 0) {
                        const { allIndices, uniqueIndices } = getContentTextIndices(content);
                        const sortedIndices = [...uniqueIndices].sort((a, b) => a - b);
                        
                        // Check if indices start from 0
                        if (uniqueIndices.length > 0) {
                            if (sortedIndices[0] !== 0) {
                                errors.push(ErrorMessages.mustStartFromZeroContent(index, sortedIndices[0]));
                            }
                            
                            // Check for gaps in sequence
                            for (let i = 1; i < sortedIndices.length; i++) {
                                if (sortedIndices[i] !== sortedIndices[i-1] + 1) {
                                    errors.push(ErrorMessages.gapInSequenceContent(index, sortedIndices[i-1], sortedIndices[i]));
                                }
                            }
                            
                            // Check if indices appear in correct order in text
                            const orderedIndices = allIndices.map(idx => parseInt(idx));
                            const expectedOrder = Array.from({length: uniqueIndices.length}, (_, i) => i);
                            if (JSON.stringify(orderedIndices) !== JSON.stringify(expectedOrder)) {
                                errors.push(ErrorMessages.wrongOrderContent(index, orderedIndices));
                            }
                        }
                    }
                });
            }
            
            // Check practice questions
            if (jsonData.practice_questions) {
                jsonData.practice_questions.forEach((question, qIndex) => {
                    const questionImages = question.question_images || [];
                    const guideAnswerImages = question.guide_answer_images || [];
                    const questionType = question.question_type || 'free_form';
                    
                    const { allQuestionIndices, uniqueQuestionIndices, allGuideIndices, uniqueGuideIndices } = getQuestionTextIndices(question);
                    
                    // Check setup text, question text, and choices indices (share question_images array)
                    // For MCQ: Order is setup  question  choice1  choice2  ...
                    // For free_form: Order is setup  question
                    if (allQuestionIndices.length > 0 && questionImages.length > 0) {
                        const sortedQuestionIndices = [...uniqueQuestionIndices].sort((a, b) => a - b);
                        
                        // Check if indices start from 0 and are sequential
                        if (uniqueQuestionIndices.length > 0) {
                            if (sortedQuestionIndices[0] !== 0) {
                                errors.push(ErrorMessages.mustStartFromZeroQuestion(qIndex, sortedQuestionIndices[0]));
                            }
                            
                            // Check for gaps in sequence
                            for (let i = 1; i < sortedQuestionIndices.length; i++) {
                                if (sortedQuestionIndices[i] !== sortedQuestionIndices[i-1] + 1) {
                                    errors.push(ErrorMessages.gapInSequenceQuestion(qIndex, sortedQuestionIndices[i-1], sortedQuestionIndices[i]));
                                }
                            }
                            
                            // Check if indices appear in correct order in text (setup  question  choices)
                            const orderedQuestionIndices = allQuestionIndices.map(idx => parseInt(idx));
                            const expectedQuestionOrder = Array.from({length: uniqueQuestionIndices.length}, (_, i) => i);
                            if (JSON.stringify(orderedQuestionIndices) !== JSON.stringify(expectedQuestionOrder)) {
                                errors.push(ErrorMessages.wrongOrderQuestion(qIndex, orderedQuestionIndices, (questionType === 'multiple_choice' || questionType === 'checkbox')));
                            }
                        }
                    }
                    
                    // Check guide answer indices (has its own guide_answer_images array)
                    if (allGuideIndices.length > 0 && guideAnswerImages.length > 0) {
                        const sortedGuideAnswerIndices = [...uniqueGuideIndices].sort((a, b) => a - b);
                        
                        // Check if indices start from 0 and are sequential
                        if (uniqueGuideIndices.length > 0) {
                            if (sortedGuideAnswerIndices[0] !== 0) {
                                errors.push(ErrorMessages.mustStartFromZeroAnswer(qIndex, sortedGuideAnswerIndices[0]));
                            }
                            
                            // Check for gaps in sequence
                            for (let i = 1; i < sortedGuideAnswerIndices.length; i++) {
                                if (sortedGuideAnswerIndices[i] !== sortedGuideAnswerIndices[i-1] + 1) {
                                    errors.push(ErrorMessages.gapInSequenceAnswer(qIndex, sortedGuideAnswerIndices[i-1], sortedGuideAnswerIndices[i]));
                                }
                            }
                            
                            // Check if indices appear in correct order in text
                            const orderedGuideAnswerIndices = allGuideIndices.map(idx => parseInt(idx));
                            const expectedGuideAnswerOrder = Array.from({length: uniqueGuideIndices.length}, (_, i) => i);
                            if (JSON.stringify(orderedGuideAnswerIndices) !== JSON.stringify(expectedGuideAnswerOrder)) {
                                errors.push(ErrorMessages.wrongOrderAnswer(qIndex, orderedGuideAnswerIndices));
                            }
                        }
                    }
                });
            }
            
            return errors;
        }

        // Extract image indices from table markdown
        function extractTableImageIndices(text) {
            const imageIndices = [];
            
            // Only look for table-specific image references
            // Tables don't have their own image format - they use the same as regular images
            // This function should return empty array since tables use regular image markdown
            // The regular extractImageIndices function already handles both regular images and table images
            
            return imageIndices;
        }

        // ========== CATEGORY 1 REFACTORING: Image Index Extraction Helpers ==========
        
        /**
         * Extract all image indices from one or more text fields
         * Combines both regular image and table image extraction
         * @param {string|string[]} texts - Single text or array of texts to extract from
         * @returns {string[]} Array of all image indices (as strings)
         */
        function extractAllImageIndices(texts) {
            const allIndices = [];
            const textArray = Array.isArray(texts) ? texts : [texts];
            
            textArray.forEach(text => {
                if (text) {
                    allIndices.push(...extractImageIndices(text));
                    allIndices.push(...extractTableImageIndices(text));
                }
            });
            
            return allIndices;
        }

        /**
         * Get unique indices as integers
         * @param {string[]|number[]} indices - Array of indices (strings or numbers)
         * @returns {number[]} Sorted array of unique integer indices
         */
        function getUniqueIndices(indices) {
            const numericIndices = indices
                .map(idx => parseInt(idx, 10))
                .filter(idx => !isNaN(idx));
            return [...new Set(numericIndices)].sort((a, b) => a - b);
        }

        // ========== END CATEGORY 1 REFACTORING ==========

        // ========== CATEGORY 2 REFACTORING: Question Container Resolution ==========
        
        /**
         * Get the question container for a given element
         * Handles special case where element is inside a choice item or matching item
         * @param {HTMLElement} element - The element to find the question container for
         * @returns {HTMLElement|null} The question container element
         */
        function getQuestionContainer(element) {
            const isChoiceText = element.classList.contains('choice-text') || element.closest('.choice-item');
            const isMatchingItem = element.classList.contains('matching-item-text') || element.closest('.matching-item');
            
            if (isChoiceText) {
                // For choice texts, we need to go up to the question container, skipping the choice-item
                return element.closest('.choice-item')?.parentElement?.closest('.array-item');
            }
            
            if (isMatchingItem) {
                // For matching items, we need to go up to the question container, skipping the matching-item
                return element.closest('.matching-item')?.parentElement?.parentElement?.closest('.array-item');
            }
            
            return element.closest('.array-item');
        }

        // ========== END CATEGORY 2 REFACTORING ==========

        // ========== CATEGORY 5: CHOICE COLLECTION LOGIC ==========

        /**
         * Collects choices data from a question container
         * Replaces duplicate logic in copySection, generateJSON, saveProgress, and validation functions
         * @param {HTMLElement} questionContainer - The question container element
         * @returns {Array} Array of choice objects with {id, text} properties
         */
        function collectChoicesData(questionContainer) {
            const choices = [];
            const choicesList = questionContainer.querySelector('[id^="choices-list-"]');
            if (choicesList) {
                const choiceItems = choicesList.querySelectorAll('.choice-item');
                choiceItems.forEach((choiceItem) => {
                    const choiceIdInput = choiceItem.querySelector('.choice-id');
                    const choiceTextArea = choiceItem.querySelector('.choice-text');
                    if (choiceTextArea) {
                        const id = choiceIdInput ? choiceIdInput.value.trim() : '';
                        const text = choiceTextArea.value.trim();
                        // Only require text, ID is optional now
                        if (text) {
                            const choice = {};
                            // Add ID first if provided (to maintain order: id, then text)
                            if (id) {
                                choice.id = id;
                            }
                            choice.text = text;
                            choices.push(choice);
                        }
                    }
                });
            }
            return choices;
        }

        // ========== END CATEGORY 5 REFACTORING ==========

        // ========== CATEGORY 7: DATA COLLECTION FROM FORM ==========

        /**
         * Collects choices or guide answer based on question type
         * @param {HTMLElement} questionEl - The question container element
         * @returns {Object} Object with either {choices, value/values, guide_answer} or {guide_answer}
         */
        function collectChoicesOrAnswer(questionEl) {
            const questionType = getFieldValue(questionEl, 'Question Type', 'select');
            if (questionType === 'multiple_choice' || questionType === 'checkbox') {
                const choices = collectChoicesData(questionEl);
                
                // Get optional guide answer notes (now a textarea for both types)
                const guideAnswerNotesTextarea = questionEl.querySelector('.guide-answer-notes');
                const guideAnswer = guideAnswerNotesTextarea ? guideAnswerNotesTextarea.value.trim() : '';
                
                const result = {
                    choices: choices,
                    guide_answer: guideAnswer
                };
                
                if (questionType === 'multiple_choice') {
                    // Get the selected radio button position (1-indexed)
                    const selectedRadio = questionEl.querySelector('.choice-correct-radio:checked');
                    if (selectedRadio) {
                        result.value = parseInt(selectedRadio.value, 10);
                    }
                } else if (questionType === 'checkbox') {
                    // Build values array from checkbox states
                    const choicesList = questionEl.querySelector('[id^="choices-list-"]');
                    const values = [];
                    if (choicesList) {
                        const choiceItems = choicesList.querySelectorAll('.choice-item');
                        choiceItems.forEach((choiceItem) => {
                            const correctCheckbox = choiceItem.querySelector('.choice-correct');
                            // Only include if choice has text (matches collectChoicesData logic)
                            const choiceTextArea = choiceItem.querySelector('.choice-text');
                            if (choiceTextArea && choiceTextArea.value.trim()) {
                                values.push(correctCheckbox ? correctCheckbox.checked : false);
                            }
                        });
                    }
                    result.values = values;
                }
                
                return result;
            }
            // Free form
            const guideAnswerTextarea = questionEl.querySelector('#guide-answer-container textarea');
            const guideAnswer = guideAnswerTextarea ? guideAnswerTextarea.value.trim() : '';
            return {
                guide_answer: guideAnswer
            };
        }

        /**
         * Collects all data from a question element
         * @param {HTMLElement} questionEl - The question container element
         * @returns {Object} Complete question data object
         */
        function collectQuestionData(questionEl) {
            const questionId = getFieldValue(questionEl, 'Question ID');
            const questionType = getFieldValue(questionEl, 'Question Type', 'select');
            
            // Collect all fields for all types (annotate and create_table are like free_form)
            const setupText = getFieldValue(questionEl, 'Set-up Text', 'textarea') || null;
            const questionText = getFieldValue(questionEl, 'Question Text', 'textarea');
            const relatedQuestion = getFieldValue(questionEl, 'Related Question') || null;
            
            // Collect choices or answer based on question type
            let choicesOrAnswer;
            if (questionType === 'fill_in_the_blanks') {
                // For fill_in_the_blanks, collect blank answers
                const values = collectBlankAnswers(questionEl);
                // Query specifically within blanks container to avoid conflicts with other guide_answer textareas
                const blanksContainer = questionEl.querySelector('#blanks-container');
                const guideAnswerNotesTextarea = blanksContainer?.querySelector('.guide-answer-notes');
                const guideAnswer = guideAnswerNotesTextarea ? guideAnswerNotesTextarea.value.trim() : '';
                choicesOrAnswer = { values, guide_answer: guideAnswer };
            } else if (questionType === 'matching') {
                // For matching, collect left, right, and relationship
                const matchingData = collectMatchingData(questionEl);
                // Query specifically within matching container to avoid conflicts
                const matchingContainer = questionEl.querySelector('#matching-container');
                const guideAnswerNotesTextarea = matchingContainer?.querySelector('.guide-answer-notes');
                const guideAnswer = guideAnswerNotesTextarea ? guideAnswerNotesTextarea.value.trim() : '';
                choicesOrAnswer = { ...matchingData, guide_answer: guideAnswer };
            } else {
                // For standard types (free_form, multiple_choice, checkbox)
                choicesOrAnswer = collectChoicesOrAnswer(questionEl);
            }
            
            // Collect question images (bbox data)
            const questionImages = collectBboxData(questionEl, 'question_images', false);
            
            // Collect guide answer images (bbox data)
            const guideAnswerImages = collectBboxData(questionEl, 'answer_images', false);
            
            // Get guide PDF page
            const guidePdfPageInput = questionEl.querySelector('input[placeholder*="e.g., 78"]') || 
                                     Array.from(questionEl.querySelectorAll('input[type="number"]')).find(
                                         input => input.placeholder && input.placeholder.includes('78')
                                     );
            const guidePdfPage = guidePdfPageInput ? parseInt(guidePdfPageInput.value, 10) : null;
            
            // Build the question object
            const questionData = {
                id: questionId,
                question_type: questionType,
                set_up_text: setupText,
                question_text: questionText
            };
            
            // Add type-specific fields
            if (questionType === 'fill_in_the_blanks') {
                // Fill in the blanks: add values array
                questionData.values = choicesOrAnswer.values || [];
                questionData.guide_answer = choicesOrAnswer.guide_answer;
            } else if (questionType === 'matching') {
                // Matching: add left, right, relationship
                questionData.left = choicesOrAnswer.left || [];
                questionData.right = choicesOrAnswer.right || [];
                questionData.relationship = choicesOrAnswer.relationship || [];
                questionData.guide_answer = choicesOrAnswer.guide_answer;
            } else if ((questionType === 'multiple_choice' || questionType === 'checkbox') && choicesOrAnswer.choices) {
                // Multiple choice or checkbox: add choices
                questionData.choices = choicesOrAnswer.choices;
                
                // Add value (for multiple_choice) or values (for checkbox)
                if (questionType === 'multiple_choice' && choicesOrAnswer.value !== undefined) {
                    questionData.value = choicesOrAnswer.value;
                } else if (questionType === 'checkbox' && choicesOrAnswer.values !== undefined) {
                    questionData.values = choicesOrAnswer.values;
                }
                questionData.guide_answer = choicesOrAnswer.guide_answer;
            } else {
                // Free form: add guide_answer normally
                questionData.guide_answer = choicesOrAnswer.guide_answer;
            }
            
            questionData.question_images = questionImages;
            questionData.guide_pdf_page = guidePdfPage;
            questionData.guide_answer_images = guideAnswerImages;
            questionData.related_question = relatedQuestion;
            
            return questionData;
        }

        /**
         * Collects all data from a content section element
         * @param {HTMLElement} sectionEl - The content section container element
         * @returns {Object} Complete content section data object
         */
        function collectContentData(sectionEl) {
            const sectionTitle = getFieldValue(sectionEl, 'Section Title');
            const text = getFieldValue(sectionEl, 'Content (Markdown + LaTeX)', 'textarea');
            const images = collectBboxData(sectionEl, 'images', true);
            
            return {
                section_title: sectionTitle,
                text: text,
                images: images
            };
        }

        // ========== END CATEGORY 7 REFACTORING ==========

        // ========== CATEGORY 8: BBOX DATA COLLECTION CONSOLIDATION ==========

        /**
         * Unified function to collect bbox data from any container
         * Consolidates collectContentBboxData and collectQuestionBboxData
         * @param {HTMLElement} container - The container element (content or question)
         * @param {string} type - Type of bbox: 'images', 'question_images', or 'answer_images'
         * @param {boolean} allowDefaultPage - Whether to use default page for content images
         * @returns {Array} Array of bbox objects with page and position
         */
        function collectBboxData(container, type, allowDefaultPage = false) {
            let bboxContainer;
            
            // Select the appropriate bbox container
            if (type === 'images') {
                bboxContainer = container.querySelectorAll('.bbox-container')[0];
            } else if (type === 'question_images') {
                bboxContainer = container.querySelectorAll('.bbox-container')[0];
            } else if (type === 'answer_images') {
                bboxContainer = container.querySelectorAll('.bbox-container')[1];
            }
            
            if (!bboxContainer) return [];
            
            // Get default page for content images if needed
            let defaultPageForImages = 0;
            if (allowDefaultPage && type === 'images') {
                const defaultTextbookPdfPage = parseInt(document.getElementById('textbook_pdf_page')?.value || '0', 10) || 0;
                const fallbackTextbookPage = parseInt(document.getElementById('textbook_page')?.value || '0', 10) || 0;
                defaultPageForImages = defaultTextbookPdfPage || fallbackTextbookPage || 0;
            }
            
            const bboxItems = bboxContainer.querySelectorAll('.array-item');
            const contextName = type === 'images' ? 'Content' : 'Question';
            
            return Array.from(bboxItems).map(item => {
                const inputs = item.querySelectorAll('.bbox-inputs input');
                const page = inputs[0].value;
                const x0 = inputs[1].value;
                const y0 = inputs[2].value;
                const x1 = inputs[3].value;
                const y1 = inputs[4].value;
                
                // Validate all bbox values are integers
                if (page && !Number.isInteger(parseFloat(page))) {
                    throw new Error(`${contextName} bbox page must be a whole number`);
                }
                if (x0 && !Number.isInteger(parseFloat(x0))) {
                    throw new Error(`${contextName} bbox X0 coordinate must be a whole number`);
                }
                if (y0 && !Number.isInteger(parseFloat(y0))) {
                    throw new Error(`${contextName} bbox Y0 coordinate must be a whole number`);
                }
                if (x1 && !Number.isInteger(parseFloat(x1))) {
                    throw new Error(`${contextName} bbox X1 coordinate must be a whole number`);
                }
                if (y1 && !Number.isInteger(parseFloat(y1))) {
                    throw new Error(`${contextName} bbox Y1 coordinate must be a whole number`);
                }
                
                // Check required fields based on type
                if (allowDefaultPage && type === 'images') {
                    // Content images: coordinates required, page can be default
                    if (!x0 || !y0 || !x1 || !y1) {
                        return null; // Will be filtered out
                    }
                } else {
                    // Question/Answer images: all fields required including page
                    if (!page || !x0 || !y0 || !x1 || !y1) {
                        return null; // Will be filtered out
                    }
                }
                
                // Use default page if applicable and page is empty
                const pageNumber = page ? parseInt(page) : (allowDefaultPage && type === 'images' ? defaultPageForImages : 0);
                
                return {
                    page: pageNumber,
                    position: [
                        [parseInt(x0), parseInt(y0)],
                        [parseInt(x1), parseInt(y1)]
                    ]
                };
            }).filter(bbox => bbox !== null);
        }

        // ========== END CATEGORY 8 REFACTORING ==========

        // ========== CATEGORY 9: IMAGE INSERTION LOGIC CONSOLIDATION ==========

        /**
         * Get the next available image index for a textarea field
         * Handles question fields (setup, question, choice, guide answer) and content fields
         * For choice texts, follows strict order: setup  question  choice1  choice2  ...
         * @param {HTMLTextAreaElement} textarea - The textarea element
         * @returns {number} The next available image index
         */
        function getNextImageIndexForField(textarea) {
            // Get the base next index
            let nextIndex = getNextImageIndex(textarea);
            
            // For questions, check other text fields that share the same image array
            if (textarea.closest('#questions_container')) {
                // Get the question container (handles choice text special case)
                const questionContainer = getQuestionContainer(textarea);
                const isChoiceText = textarea.classList.contains('choice-text') || textarea.closest('.choice-item');
                const isMatchingItem = textarea.classList.contains('matching-item-text') || textarea.closest('.matching-item');
                
                if (isChoiceText && questionContainer) {
                    // Choice texts follow strict order: setup  question  choice1  choice2  ...
                    // Collect indices from setup, question, and choices UP TO AND INCLUDING current choice
                    let allQuestionIndices = [];
                    
                    // Get setup and question text indices first
                    const setupText = questionContainer.querySelector('textarea[placeholder*="Text shared across multiple questions"]')?.value || '';
                    const questionText = questionContainer.querySelector('textarea[placeholder*="Enter question text"]')?.value || '';
                    allQuestionIndices.push(...extractAllImageIndices([setupText, questionText]));
                    
                    // Get indices from choices in order, UP TO AND INCLUDING the current choice
                    const currentChoiceItem = textarea.closest('.choice-item');
                    const choicesList = questionContainer.querySelector('[id^="choices-list-"]');
                    if (choicesList && currentChoiceItem) {
                        const choiceItems = choicesList.querySelectorAll('.choice-item');
                        for (let i = 0; i < choiceItems.length; i++) {
                            const choiceItem = choiceItems[i];
                            const choiceTextArea = choiceItem.querySelector('.choice-text');
                            if (choiceTextArea) {
                                allQuestionIndices.push(...extractAllImageIndices(choiceTextArea.value || ''));
                            }
                            // Stop after processing the current choice
                            if (choiceItem === currentChoiceItem) {
                                break;
                            }
                        }
                    }
                    
                    // Remove duplicates and get next available index
                    const uniqueIndices = getUniqueIndices(allQuestionIndices);
                    nextIndex = uniqueIndices.length === 0 ? 0 : Math.max(...uniqueIndices) + 1;
                } else if (isMatchingItem && questionContainer) {
                    // For matching items: collect ALL existing image indices from the ENTIRE group
                    // (setup  question  ALL left items  ALL right items)
                    // Then return the next available index (max + 1)
                    let allQuestionIndices = [];
                    
                    // Get setup and question text indices
                    const setupText = questionContainer.querySelector('textarea[placeholder*="Text shared across multiple questions"]')?.value || '';
                    const questionText = questionContainer.querySelector('textarea[placeholder*="Enter question text"]')?.value || '';
                    allQuestionIndices.push(...extractAllImageIndices([setupText, questionText]));
                    
                    const matchingContainer = questionContainer.querySelector('#matching-container');
                    
                    if (matchingContainer) {
                        // Use more specific selectors for left and right lists
                        const leftList = matchingContainer.querySelector('[id^="matching-left-list-"]');
                        const rightList = matchingContainer.querySelector('[id^="matching-right-list-"]');
                        
                        // Collect ALL indices from ALL left items
                        if (leftList) {
                            const leftItems = leftList.querySelectorAll('.matching-item');
                            leftItems.forEach(item => {
                                const itemTextArea = item.querySelector('.matching-item-text');
                                if (itemTextArea) {
                                    allQuestionIndices.push(...extractAllImageIndices(itemTextArea.value || ''));
                                }
                            });
                        }
                        
                        // Collect ALL indices from ALL right items
                        if (rightList) {
                            const rightItems = rightList.querySelectorAll('.matching-item');
                            rightItems.forEach(item => {
                                const itemTextArea = item.querySelector('.matching-item-text');
                                if (itemTextArea) {
                                    allQuestionIndices.push(...extractAllImageIndices(itemTextArea.value || ''));
                                }
                            });
                        }
                    }
                    
                    // Remove duplicates and get next available index
                    const uniqueIndices = getUniqueIndices(allQuestionIndices);
                    nextIndex = uniqueIndices.length === 0 ? 0 : Math.max(...uniqueIndices) + 1;
                } else {
                    // Determine which image array this field uses
                    const isGuideAnswer = textarea.closest('textarea[placeholder*="guide answer"]');
                    
                    if (isGuideAnswer) {
                        // Guide answer uses guide_answer_images array - check only other guide answer fields
                        const otherGuideAnswers = questionContainer.querySelectorAll('textarea[placeholder*="guide answer"]');
                        let allGuideAnswerIndices = extractAllImageIndices(textarea.value);
                        otherGuideAnswers.forEach(field => {
                            if (field !== textarea) {
                                allGuideAnswerIndices.push(...extractAllImageIndices(field.value));
                            }
                        });
                        
                        // Remove duplicates and get next available index
                        const uniqueIndices = getUniqueIndices(allGuideAnswerIndices);
                        nextIndex = uniqueIndices.length === 0 ? 0 : Math.max(...uniqueIndices) + 1;
                    } else {
                        // Setup text and question text share question_images array - check both
                        const setupText = questionContainer.querySelector('textarea[placeholder*="Text shared across multiple questions"]')?.value || '';
                        const questionText = questionContainer.querySelector('textarea[placeholder*="Enter question text"]')?.value || '';
                        
                        let allQuestionIndices = extractAllImageIndices(textarea.value);
                        if (textarea.placeholder.includes('Text shared across multiple questions')) {
                            allQuestionIndices.push(...extractAllImageIndices(questionText));
                        } else if (textarea.placeholder.includes('Enter question text')) {
                            allQuestionIndices.push(...extractAllImageIndices(setupText));
                        }
                        
                        // Remove duplicates and get next available index
                        const uniqueIndices = getUniqueIndices(allQuestionIndices);
                        nextIndex = uniqueIndices.length === 0 ? 0 : Math.max(...uniqueIndices) + 1;
                    }
                }
            }
            
            return nextIndex;
        }

        // ========== END CATEGORY 9 REFACTORING ==========

        // ========== CATEGORY 9.5: TABLE VALIDATION HELPERS ==========
        
        /**
         * Check if text contains a valid markdown table
         * @param {string} text - The text to check
         * @returns {boolean} True if text contains a valid markdown table
         */
        function containsValidTable(text) {
            const result = validateTableMarkdown(text);
            return result.valid && result.hasTables;
        }
        
        /**
         * Remove math expressions from text to avoid detecting special characters inside them
         * @param {string} text - The text to process
         * @returns {string} Text with math expressions removed
         */
        function removeMathExpressions(text) {
            if (!text || typeof text !== 'string') {
                return text || '';
            }
            // Remove block math first ($$...$$) to avoid conflicts with inline math
            // Use [\s\S] instead of [^$] to match newlines and all characters except $ would miss newlines
            let result = text.replace(/\$\$[\s\S]*?\$\$/g, '');
            // Remove inline math ($...$)
            // Use [\s\S] to match any character including newlines
            result = result.replace(/\$[\s\S]*?\$/g, '');
            return result;
        }
        
        /**
         * Validate all markdown tables in text and return detailed errors
         * @param {string} text - The text to check
         * @returns {Object} { valid: boolean, errors: string[], hasTables: boolean }
         */
        function validateTableMarkdown(text) {
            if (!text || typeof text !== 'string') {
                return { valid: true, errors: [], hasTables: false };
            }
            
            const lines = text.split('\n');
            const errors = [];
            let hasTables = false;
            let inTable = false;
            let currentTableStart = -1;
            let currentTableEnd = -1;
            let currentTable = [];
            let separatorFound = false;
            let separatorLineNum = -1;
            let expectedColumnCount = null;
            let lastTableRowContent = null; // Track the last table row content for multi-line cells
            let lastTableRowLineNum = -1; // Track the line number of the last table row
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                const rawLine = lines[i]; // Keep original with whitespace
                
                // Remove math expressions to avoid detecting pipes inside them
                let lineWithoutMath = removeMathExpressions(line);
                
                // Check if line has pipes after removing math expressions
                // Require at least 2 pipes for a table (which creates 3 cells)
                const hasPipes = lineWithoutMath.includes('|') && lineWithoutMath.split('|').length >= 3;
                
                // Check if line starts with a pipe (even if it doesn't have enough pipes for a full row)
                // This handles multi-line cells where a row might start with | but continue on next line
                const startsWithPipe = lineWithoutMath.trim().startsWith('|');
                
                // Check if original line (before removing math) starts with pipe
                // This is used for continuation detection - a line starting with LaTeX should still be a continuation
                const originalStartsWithPipe = line.trim().startsWith('|');
                
                // Empty lines always end tables
                const isEmptyLine = line.length === 0;
                
                // Check if this could be a continuation of the previous table row
                // A continuation is a line that doesn't start with | in the original text but we're in a table
                // and the previous line was a table row that didn't end with a pipe (or had incomplete cells)
                // IMPORTANT: Can only be a continuation if lastTableRowContent exists and doesn't end with |
                const isContinuation = !isEmptyLine && inTable && !originalStartsWithPipe && lastTableRowContent !== null && 
                    lastTableRowContent.trim() !== '' && 
                    !lastTableRowContent.trim().endsWith('|');
                
                // A line is part of a table if:
                // 1. It has enough pipes (hasPipes), OR
                // 2. It starts with a pipe and we're already in a table (handles partial rows), OR
                // 3. It's a continuation of a previous table row
                // Empty lines are NEVER table rows
                const isTableRow = !isEmptyLine && (hasPipes || (startsWithPipe && inTable) || isContinuation);
                
                if (isTableRow) {
                    hasTables = true;
                    
                    if (!inTable) {
                        // Starting a new table
                        inTable = true;
                        currentTableStart = i + 1;
                        currentTable = [];
                        separatorFound = false;
                        separatorLineNum = -1;
                        expectedColumnCount = null;
                        lastTableRowContent = null;
                        lastTableRowLineNum = -1;
                    }
                    
                    // If this is a continuation line, merge it with the previous row
                    if (isContinuation && lastTableRowContent !== null) {
                        // Merge the continuation with the last row, preserving the newline
                        // Use newline to preserve line breaks in cells for proper rendering
                        const mergedRow = lastTableRowContent + '\n' + line;
                        // Update the last entry in currentTable
                        if (currentTable.length > 0) {
                            currentTable[currentTable.length - 1].content = mergedRow;
                        }
                        lastTableRowContent = mergedRow;
                        currentTableEnd = i;
                    } else if (!isContinuation) {
                        // New table row (not a continuation)
                    currentTable.push({ lineNum: i + 1, content: line });
                    currentTableEnd = i;
                        lastTableRowContent = line;
                        lastTableRowLineNum = i + 1;
                    }
                    
                    // Count columns (number of pipes) - use merged content if available
                    const contentToCheck = lastTableRowContent || line;
                    // Remove math expressions before counting pipes to ignore pipes inside LaTeX
                    const contentWithoutMath = removeMathExpressions(contentToCheck);
                    const pipeCount = (contentWithoutMath.match(/\|/g) || []).length;
                    
                    // Check if this is a separator row (only for lines that look like separators)
                    const isSeparator = /^[\s|:-]+$/.test(contentToCheck) && contentToCheck.includes('-');
                    
                    if (isSeparator) {
                        if (separatorFound) {
                            errors.push({
                                message: `Multiple separator rows found in the same table. Each table should have only one separator row (|---|---|).`,
                                content: contentToCheck
                            });
                        }
                        separatorFound = true;
                        separatorLineNum = i + 1;
                        
                        // Separator must have same pipe count as expected columns
                        if (expectedColumnCount !== null && pipeCount !== expectedColumnCount) {
                            errors.push({
                                message: `Separator row has ${pipeCount} pipes but expected ${expectedColumnCount} based on other rows. All rows including the separator must have the same number of columns.`,
                                content: contentToCheck
                            });
                        }
                        
                        // Separator sets the expected column count if not set
                        if (expectedColumnCount === null) {
                            expectedColumnCount = pipeCount;
                        }
                        // Reset last row tracking after separator
                        lastTableRowContent = null;
                        lastTableRowLineNum = -1;
                    } else {
                        // Regular row - check column count consistency
                        // CRITICAL: Only validate if we have a complete row (ends with |)
                        // Never validate incomplete rows that might continue on the next line
                        const rowEndsWithPipe = contentToCheck.trim().endsWith('|');
                        const rowStartsWithPipe = contentToCheck.trim().startsWith('|');
                        const isIncompleteRow = rowStartsWithPipe && !rowEndsWithPipe;
                        
                        // Only validate complete rows - never validate incomplete rows
                        if (rowEndsWithPipe && !isIncompleteRow) {
                            // Only validate complete rows
                        if (expectedColumnCount === null) {
                            expectedColumnCount = pipeCount;
                        } else if (pipeCount !== expectedColumnCount) {
                                errors.push({
                                    message: `Inconsistent column count. Expected ${expectedColumnCount} pipes but found ${pipeCount}. All rows in a table must have the same number of columns.`,
                                    content: contentToCheck
                                });
                        }
                            // Row is complete, reset tracking for next row
                            lastTableRowContent = null;
                            lastTableRowLineNum = -1;
                        } else if (isIncompleteRow) {
                            // This is an incomplete row that will continue on the next line
                            // Do NOT validate it - wait until it's complete
                            // Keep lastTableRowContent so next line can merge with it
                        }
                        // If row doesn't end with pipe, it might continue on next line
                        // Keep lastTableRowContent so next line can merge with it
                        // DO NOT validate incomplete rows - they will be validated when complete
                    }
                    
                } else if (inTable) {
                    // End of table (non-pipe line after table lines, and not a continuation)
                    // Note: Continuations are handled in the main branch above
                    if (currentTable.length > 0) {
                        // Validate the completed table
                        if (!separatorFound) {
                        const tableContent = currentTable.map(row => row.content).join('\n');
                        errors.push({
                            message: `Table is missing a separator row. Add a row like |---|---| after the header.`,
                            content: tableContent
                        });
                        }
                        if (currentTable.length < 2) {
                        const tableContent = currentTable.map(row => row.content).join('\n');
                        errors.push({
                            message: `Table has only ${currentTable.length} row(s). A valid table needs at least 2 rows (header + separator, or separator + data).`,
                            content: tableContent
                        });
                        }
                        
                        // Check if line after table is empty (when there's more content)
                        if (line.length > 0) {
                            // Get the last few table rows and the problematic content
                            const tableContent = currentTable.slice(-3).map(row => row.content).join('\n');
                            const problematicContent = line.length > 50 ? line.substring(0, 50) + '...' : line;
                            errors.push({
                                message: `Content immediately after table without an empty line. Add an empty line after the table before adding new content.`,
                                content: tableContent + '\n' + problematicContent
                            });
                        }
                    }
                    
                    inTable = false;
                    currentTable = [];
                    separatorFound = false;
                    separatorLineNum = -1;
                    expectedColumnCount = null;
                    lastTableRowContent = null;
                    lastTableRowLineNum = -1;
                }
            }
            
            // Check if we ended while still in a table
            if (inTable && currentTable.length > 0) {
                if (!separatorFound) {
                    const tableContent = currentTable.map(row => row.content).join('\n');
                    errors.push({
                        message: `Table is missing a separator row. Add a row like |---|---| after the header.`,
                        content: tableContent
                    });
                }
                if (currentTable.length < 2) {
                    const tableContent = currentTable.map(row => row.content).join('\n');
                    errors.push({
                        message: `Table has only ${currentTable.length} row(s). A valid table needs at least 2 rows (header + separator, or separator + data).`,
                        content: tableContent
                    });
                }
            }
            
            return {
                valid: errors.length === 0,
                errors: errors,
                hasTables: hasTables
            };
        }
        
        /**
         * Show table validation errors for a textarea
         * @param {HTMLTextAreaElement} textarea - The textarea element
         */
        function showTableValidationErrors(textarea) {
            if (!textarea) return;
            
            const text = textarea.value;
            const result = validateTableMarkdown(text);
            
            // Find or create error container - insert right after textarea
            const container = textarea.closest('.text-field-container') || textarea.parentElement;
            if (!container) return;
            
            let errorDiv = container.querySelector('.table-validation-errors');
            
            if (result.hasTables && !result.valid && result.errors.length > 0) {
                // Show errors
                if (!errorDiv) {
                    errorDiv = document.createElement('div');
                    errorDiv.className = 'table-validation-errors';
                    errorDiv.style.cssText = 'margin-top: 8px;';
                    // Insert right after the textarea
                    textarea.parentNode.insertBefore(errorDiv, textarea.nextSibling);
                }
                
                errorDiv.style.display = 'block';
                errorDiv.innerHTML = `
                    <div style="padding: 10px; background: #ffe6e6; border: 1px solid #ff4d4d; border-radius: 6px; color: #cc0000;">
                        <strong> Table Markdown Errors:</strong>
                        ${result.errors.map(err => {
                            const errorMsg = typeof err === 'string' ? err : err.message;
                            const errorContent = typeof err === 'object' && err.content ? err.content : '';
                            if (errorContent) {
                                return `
                                    <div style="margin: 8px 0; padding: 8px; background: #fff; border-left: 3px solid #ff4d4d; border-radius: 4px;">
                                        <div style="margin-bottom: 6px;">${errorMsg}</div>
                                        <div style="font-size: 0.9em; color: #666;">
                                            <strong>Your Code:</strong>
                                            <code style="display: block; margin-top: 4px; padding: 6px; background: #f5f5f5; border-radius: 3px; white-space: pre-wrap; font-family: monospace; font-size: 0.85em;">${escapeHtml(errorContent)}</code>
                                        </div>
                                    </div>
                                `;
                            } else {
                                return `<div style="margin: 4px 0;">${errorMsg}</div>`;
                            }
                        }).join('')}
                    </div>
                `;
                textarea.classList.add('validation-error');
            } else {
                // Clear errors
                if (errorDiv) {
                    errorDiv.style.display = 'none';
                    errorDiv.innerHTML = '';
                }
                textarea.classList.remove('validation-error');
            }
        }
        
        // ========== CATEGORY 9.6: LIST VALIDATION HELPERS ==========
        
        /**
         * Validate markdown lists and check for empty lines after lists
         * @param {string} text - The text to check
         * @returns {Object} { valid: boolean, errors: string[], hasLists: boolean }
         */
        function validateListMarkdown(text) {
            if (!text || typeof text !== 'string') {
                return { valid: true, errors: [], hasLists: false };
            }
            
            const lines = text.split('\n');
            const errors = [];
            let hasLists = false;
            let inList = false;
            let listStartLine = -1;
            let lastListLine = -1;
            let currentListItems = []; // Track the actual list items in the current list
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const trimmed = line.trim();
                
                // Remove math expressions to avoid detecting list markers inside them
                let lineWithoutMath = trimmed.replace(/\$[^$]+\$/g, '');
                lineWithoutMath = lineWithoutMath.replace(/\$\$[^$]+\$\$/g, '');
                
                // Check if line is a list item (bullet or numbered)
                // Bullet list: starts with -, *, or + followed by space (may be indented)
                // Numbered list: starts with number followed by . and space (may be indented)
                // Allow for indentation (spaces or tabs) before the list marker
                const isBulletList = /^\s*[-*+]\s/.test(lineWithoutMath);
                const isNumberedList = /^\s*\d+\.\s/.test(lineWithoutMath);
                const isListItem = isBulletList || isNumberedList;
                const isBlankLine = trimmed === '';
                
                if (isListItem) {
                    hasLists = true;
                    
                    if (!inList) {
                        // Starting a new list
                        inList = true;
                        listStartLine = i + 1;
                        currentListItems = []; // Reset list items
                    }
                    
                    // Add this list item to our tracking
                    currentListItems.push(line);
                    lastListLine = i + 1;
                } else if (inList) {
                    // We were in a list, check if this line ends the list
                    if (isBlankLine) {
                        // Blank line after list - this is correct, list ends here
                        inList = false;
                        listStartLine = -1;
                        lastListLine = -1;
                        currentListItems = []; // Clear tracked items
                    } else {
                        // Non-blank line immediately after list without empty line
                        // This is an error - content will be appended to the list
                        // Use the actual list items we tracked, not a filtered slice
                        const listContent = currentListItems.join('\n');
                        const problematicContent = line.length > 50 ? line.substring(0, 50) + '...' : line;
                        errors.push({
                            message: `Content immediately after list without an empty line. Add an empty line after the list before adding new content.`,
                            content: listContent + '\n' + problematicContent
                        });
                        // End the list here
                        inList = false;
                        listStartLine = -1;
                        lastListLine = -1;
                        currentListItems = []; // Clear tracked items
                    }
                }
            }
            
            // If we ended while still in a list, that's okay - it's at the end of the content
            // No need to require an empty line at the very end
            
            return {
                valid: errors.length === 0,
                errors: errors,
                hasLists: hasLists
            };
        }
        
        /**
         * Show list validation errors for a textarea
         * @param {HTMLTextAreaElement} textarea - The textarea element
         */
        function showListValidationErrors(textarea) {
            if (!textarea) return;
            
            const text = textarea.value;
            const result = validateListMarkdown(text);
            
            // Find or create error container - insert right after textarea
            const container = textarea.closest('.text-field-container') || textarea.parentElement;
            if (!container) return;
            
            let errorDiv = container.querySelector('.list-validation-errors');
            
            if (result.hasLists && !result.valid && result.errors.length > 0) {
                // Show errors
                if (!errorDiv) {
                    errorDiv = document.createElement('div');
                    errorDiv.className = 'list-validation-errors';
                    errorDiv.style.cssText = 'margin-top: 8px;';
                    // Insert right after the textarea
                    textarea.parentNode.insertBefore(errorDiv, textarea.nextSibling);
                }
                
                errorDiv.style.display = 'block';
                errorDiv.innerHTML = `
                    <div style="padding: 10px; background: #ffe6e6; border: 1px solid #ff4d4d; border-radius: 6px; color: #cc0000;">
                        <strong> List Markdown Errors:</strong>
                        ${result.errors.map(err => {
                            const errorMsg = typeof err === 'string' ? err : err.message;
                            const errorContent = typeof err === 'object' && err.content ? err.content : '';
                            if (errorContent) {
                                return `
                                    <div style="margin: 8px 0; padding: 8px; background: #fff; border-left: 3px solid #ff4d4d; border-radius: 4px;">
                                        <div style="margin-bottom: 6px;">${errorMsg}</div>
                                        <div style="font-size: 0.9em; color: #666;">
                                            <strong>Your Code:</strong>
                                            <code style="display: block; margin-top: 4px; padding: 6px; background: #f5f5f5; border-radius: 3px; white-space: pre-wrap; font-family: monospace; font-size: 0.85em;">${escapeHtml(errorContent)}</code>
                                        </div>
                                    </div>
                                `;
                            } else {
                                return `<div style="margin: 4px 0;">${errorMsg}</div>`;
                            }
                        }).join('')}
                    </div>
                `;
                textarea.classList.add('validation-error');
            } else {
                // Clear errors
                if (errorDiv) {
                    errorDiv.style.display = 'none';
                    errorDiv.innerHTML = '';
                }
                // Don't remove validation-error class here as it might be set by other validations
                // Only remove if no other errors exist
                const hasOtherErrors = container.querySelector('.table-validation-errors')?.style.display !== 'none';
                if (!hasOtherErrors) {
                    textarea.classList.remove('validation-error');
                }
            }
        }
        
        // ========== CATEGORY 9.7: BLOCKQUOTE VALIDATION HELPERS ==========
        
        /**
         * Validate markdown blockquotes and check for empty lines after blockquotes
         * @param {string} text - The text to check
         * @returns {Object} { valid: boolean, errors: string[], hasBlockquotes: boolean }
         */
        function validateBlockquoteMarkdown(text) {
            if (!text || typeof text !== 'string') {
                return { valid: true, errors: [], hasBlockquotes: false };
            }
            
            const lines = text.split('\n');
            const errors = [];
            let hasBlockquotes = false;
            let inBlockquote = false;
            let blockquoteStartLine = -1;
            let lastBlockquoteLine = -1;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const trimmed = line.trim();
                
                // Remove math expressions to avoid detecting blockquote markers inside them
                let lineWithoutMath = trimmed.replace(/\$[^$]+\$/g, '');
                lineWithoutMath = lineWithoutMath.replace(/\$\$[^$]+\$\$/g, '');
                
                // Check if line is a blockquote (starts with >)
                // Allow for indentation (spaces or tabs) before the >
                const isBlockquoteLine = /^\s*>/.test(lineWithoutMath);
                const isBlankLine = trimmed === '';
                const isBlankBlockquote = trimmed === '>';
                
                // Validate blockquote formatting: if it's a blockquote with content, must have exactly one space after >
                if (isBlockquoteLine && !isBlankBlockquote) {
                    // Check the original line (preserving leading whitespace) to see the exact spacing after >
                    const leadingWhitespaceMatch = line.match(/^(\s*)/);
                    const leadingWhitespace = leadingWhitespaceMatch ? leadingWhitespaceMatch[1] : '';
                    const afterLeadingWhitespace = line.substring(leadingWhitespace.length);
                    
                    // After removing leading whitespace, check if > is followed by exactly one space
                    if (afterLeadingWhitespace.startsWith('>')) {
                        const afterGT = afterLeadingWhitespace.substring(1);
                        
                        // Must have exactly one space after > when there's content
                        if (afterGT.length === 0) {
                            // This should have been caught by isBlankBlockquote, but just in case
                            // Blank blockquote is valid, skip
                        } else if (!afterGT.startsWith(' ')) {
                            // No space after > (starts with non-space character like 'text' or tab)
                            errors.push({
                                message: `Blockquote on line ${i + 1} must have exactly one space after the ">" character. Found "${afterGT[0] === '\t' ? 'tab' : afterGT[0]}" instead of a space.`,
                                content: line.length > 100 ? line.substring(0, 100) + '...' : line,
                                lineNumber: i + 1
                            });
                        } else if (afterGT.length > 1 && afterGT[1] === ' ') {
                            // Multiple spaces after > (second character is also a space)
                            errors.push({
                                message: `Blockquote on line ${i + 1} must have exactly one space after the ">" character. Found multiple spaces.`,
                                content: line.length > 100 ? line.substring(0, 100) + '...' : line,
                                lineNumber: i + 1
                            });
                        }
                        // If afterGT starts with exactly one space (and second char is not space), it's valid
                    }
                }
                
                if (isBlockquoteLine) {
                    hasBlockquotes = true;
                    
                    if (!inBlockquote) {
                        // Starting a new blockquote
                        inBlockquote = true;
                        blockquoteStartLine = i + 1;
                    }
                    
                    lastBlockquoteLine = i + 1;
                } else if (inBlockquote) {
                    // We were in a blockquote, check if this line ends the blockquote
                    if (isBlankLine) {
                        // Blank line after blockquote - this is correct, blockquote ends here
                        inBlockquote = false;
                        blockquoteStartLine = -1;
                        lastBlockquoteLine = -1;
                    } else {
                        // Non-blank line immediately after blockquote without empty line
                        // This is an error - content will be appended to the blockquote
                        // Get the last few blockquote lines and the problematic content
                        const blockquoteStart = Math.max(0, i - 5); // Get up to 5 lines before
                        const blockquoteContent = lines.slice(blockquoteStart, i).filter(l => /^\s*>/.test(l)).join('\n');
                        const problematicContent = line.length > 50 ? line.substring(0, 50) + '...' : line;
                        errors.push({
                            message: `Content immediately after blockquote without an empty line. Add an empty line after the blockquote before adding new content.`,
                            content: blockquoteContent + '\n' + problematicContent
                        });
                        // End the blockquote here
                        inBlockquote = false;
                        blockquoteStartLine = -1;
                        lastBlockquoteLine = -1;
                    }
                }
            }
            
            // If we ended while still in a blockquote, that's okay - it's at the end of the content
            // No need to require an empty line at the very end
            
            return {
                valid: errors.length === 0,
                errors: errors,
                hasBlockquotes: hasBlockquotes
            };
        }
        
        /**
         * Show blockquote validation errors for a textarea
         * @param {HTMLTextAreaElement} textarea - The textarea element
         */
        function showBlockquoteValidationErrors(textarea) {
            if (!textarea) return;
            
            const text = textarea.value;
            const result = validateBlockquoteMarkdown(text);
            
            // Find or create error container - insert right after textarea
            const container = textarea.closest('.text-field-container') || textarea.parentElement;
            if (!container) return;
            
            let errorDiv = container.querySelector('.blockquote-validation-errors');
            
            if (result.hasBlockquotes && !result.valid && result.errors.length > 0) {
                // Show errors
                if (!errorDiv) {
                    errorDiv = document.createElement('div');
                    errorDiv.className = 'blockquote-validation-errors';
                    errorDiv.style.cssText = 'margin-top: 8px;';
                    // Insert right after the textarea
                    textarea.parentNode.insertBefore(errorDiv, textarea.nextSibling);
                }
                
                errorDiv.style.display = 'block';
                errorDiv.innerHTML = `
                    <div style="padding: 10px; background: #ffe6e6; border: 1px solid #ff4d4d; border-radius: 6px; color: #cc0000;">
                        <strong> Blockquote Markdown Errors:</strong>
                        ${result.errors.map(err => {
                            const errorMsg = typeof err === 'string' ? err : err.message;
                            const errorContent = typeof err === 'object' && err.content ? err.content : '';
                            if (errorContent) {
                                return `
                                    <div style="margin: 8px 0; padding: 8px; background: #fff; border-left: 3px solid #ff4d4d; border-radius: 4px;">
                                        <div style="margin-bottom: 6px;">${errorMsg}</div>
                                        <div style="font-size: 0.9em; color: #666;">
                                            <strong>Your Code:</strong>
                                            <code style="display: block; margin-top: 4px; padding: 6px; background: #f5f5f5; border-radius: 3px; white-space: pre-wrap; font-family: monospace; font-size: 0.85em;">${escapeHtml(errorContent)}</code>
                                        </div>
                                    </div>
                                `;
                            } else {
                                return `<div style="margin: 4px 0;">${errorMsg}</div>`;
                            }
                        }).join('')}
                    </div>
                `;
                textarea.classList.add('validation-error');
            } else {
                // Clear errors
                if (errorDiv) {
                    errorDiv.style.display = 'none';
                    errorDiv.innerHTML = '';
                }
                // Don't remove validation-error class here as it might be set by other validations
                // Only remove if no other errors exist
                const hasOtherErrors = container.querySelector('.table-validation-errors')?.style.display !== 'none' ||
                                      container.querySelector('.list-validation-errors')?.style.display !== 'none';
                if (!hasOtherErrors) {
                    textarea.classList.remove('validation-error');
                }
            }
        }
        
        // ========== CATEGORY 9.8: OTHER VALIDATION ERROR DISPLAY HELPERS ==========
        
        /**
         * Show LaTeX validation errors for a textarea
         * @param {HTMLTextAreaElement} textarea - The textarea element
         */
        function showLatexValidationErrors(textarea) {
            if (!textarea) return;
            
            const text = textarea.value;
            const mathBlockErrors = validateBlockLatex(text);
            const blanksInLatexErrors = validateBlanksInLatex(text);
            const allErrors = [...mathBlockErrors, ...blanksInLatexErrors];
            
            // Find or create error container - insert right after textarea
            const container = textarea.closest('.text-field-container') || textarea.parentElement;
            if (!container) return;
            
            let errorDiv = container.querySelector('.latex-validation-errors');
            
            if (allErrors.length > 0) {
                // Show errors
                if (!errorDiv) {
                    errorDiv = document.createElement('div');
                    errorDiv.className = 'latex-validation-errors';
                    errorDiv.style.cssText = 'margin-top: 8px;';
                    // Insert right after the textarea
                    textarea.parentNode.insertBefore(errorDiv, textarea.nextSibling);
                }
                
                errorDiv.style.display = 'block';
                errorDiv.innerHTML = `
                    <div style="padding: 10px; background: #ffe6e6; border: 1px solid #ff4d4d; border-radius: 6px; color: #cc0000;">
                        <strong> LaTeX Errors:</strong>
                        ${allErrors.map(error => {
                            let errorMessage = '';
                            let fixMessage = '';
                            
                            if (error.type === 'incorrect_delimiters') {
                                errorMessage = 'Your LaTeX block needs newline characters around it';
                                fixMessage = 'Use: <code>$$\\n...your formula...\\n$$</code> (with \\n before and after)';
                            } else if (error.type === 'extra_newlines') {
                                errorMessage = 'Your LaTeX content has extra newline characters inside';
                                fixMessage = 'Remove any enters or \\n characters from inside your formula';
                            } else if (error.type === 'empty_content') {
                                errorMessage = 'Your LaTeX block is empty';
                                fixMessage = 'Add your formula between the $$\\n and \\n$$';
                            } else if (error.type === 'blank_in_latex') {
                                errorMessage = error.message || `Blank ${error.blank || ''} cannot be written inside LaTeX`;
                                fixMessage = 'Move the blank outside the LaTeX expression. Blanks should be placed before or after LaTeX, not inside it.';
                            } else {
                                errorMessage = error.message;
                                fixMessage = 'Check your LaTeX syntax';
                            }
                            
                            // Get content from error object, or use empty string if not available
                            const errorContent = error.content || '';
                            let codeDisplay = '';
                            if (error.type === 'blank_in_latex') {
                                // For blank in LaTeX errors, show the LaTeX expression with the blank
                                // Try to determine if it's inline or block LaTeX
                                const originalText = textarea.value;
                                const blankPos = originalText.indexOf(error.blank);
                                if (blankPos !== -1) {
                                    // Find the LaTeX expression containing this blank
                                    const beforeBlank = originalText.substring(0, blankPos);
                                    const afterBlank = originalText.substring(blankPos + error.blank.length);
                                    
                                    // Check for block LaTeX ($$...$$)
                                    const blockStart = beforeBlank.lastIndexOf('$$');
                                    const blockEnd = afterBlank.indexOf('$$');
                                    if (blockStart !== -1 && blockEnd !== -1) {
                                        const fullLatex = originalText.substring(blockStart, blankPos + error.blank.length + blockEnd + 2);
                                        codeDisplay = escapeHtml(fullLatex);
                                    } else {
                                        // Check for inline LaTeX ($...$)
                                        const inlineStart = beforeBlank.lastIndexOf('$');
                                        const inlineEnd = afterBlank.indexOf('$');
                                        if (inlineStart !== -1 && inlineEnd !== -1) {
                                            const fullLatex = originalText.substring(inlineStart, blankPos + error.blank.length + inlineEnd + 1);
                                            codeDisplay = escapeHtml(fullLatex);
                                        } else {
                                            codeDisplay = escapeHtml(errorContent ? `$$${errorContent}$$` : `$$...${error.blank}...$$`);
                                        }
                                    }
                                } else {
                                    codeDisplay = escapeHtml(errorContent ? `$$${errorContent}$$` : `$$...${error.blank}...$$`);
                                }
                            } else {
                                codeDisplay = errorContent ? `$$\\n${errorContent}\\n$$` : '$$\\n...\\n$$';
                            }
                            
                            return `
                                <div style="margin: 8px 0; padding: 8px; background: #fff; border-left: 3px solid #ff4d4d; border-radius: 4px;">
                                    <div style="margin-bottom: 6px;"> <strong>LaTeX Problem:</strong> ${errorMessage}</div>
                                    <div style="margin-bottom: 6px;"> <strong>How to Fix:</strong> ${fixMessage}</div>
                                    ${codeDisplay ? `
                                    <div style="font-size: 0.9em; color: #666;">
                                        <strong>Your Code:</strong>
                                        <code style="display: block; margin-top: 4px; padding: 6px; background: #f5f5f5; border-radius: 3px; white-space: pre-wrap; font-family: monospace; font-size: 0.85em;">${codeDisplay}</code>
                                    </div>
                                    ` : ''}
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;
                textarea.classList.add('validation-error');
            } else {
                // Clear errors
                if (errorDiv) {
                    errorDiv.style.display = 'none';
                    errorDiv.innerHTML = '';
                }
                const hasOtherErrors = container.querySelector('.table-validation-errors')?.style.display !== 'none' ||
                                      container.querySelector('.list-validation-errors')?.style.display !== 'none' ||
                                      container.querySelector('.blockquote-validation-errors')?.style.display !== 'none' ||
                                      container.querySelector('.image-validation-errors')?.style.display !== 'none' ||
                                      container.querySelector('.quote-validation-errors')?.style.display !== 'none' ||
                                      container.querySelector('.br-validation-errors')?.style.display !== 'none';
                if (!hasOtherErrors) {
                    textarea.classList.remove('validation-error');
                }
            }
        }
        
        /**
         * Show image validation errors for a textarea
         * @param {HTMLTextAreaElement} textarea - The textarea element
         */
        function showImageValidationErrors(textarea) {
            if (!textarea) return;
            
            const text = textarea.value;
            const imageDescErrors = validateImageDescriptions(text);
            
            // Find or create error container - insert right after textarea
            const container = textarea.closest('.text-field-container') || textarea.parentElement;
            if (!container) return;
            
            let errorDiv = container.querySelector('.image-validation-errors');
            
            if (imageDescErrors.length > 0) {
                // Show errors
                if (!errorDiv) {
                    errorDiv = document.createElement('div');
                    errorDiv.className = 'image-validation-errors';
                    errorDiv.style.cssText = 'margin-top: 8px;';
                    // Insert right after the textarea
                    textarea.parentNode.insertBefore(errorDiv, textarea.nextSibling);
                }
                
                errorDiv.style.display = 'block';
                errorDiv.innerHTML = `
                    <div style="padding: 10px; background: #ffe6e6; border: 1px solid #ff4d4d; border-radius: 6px; color: #cc0000;">
                        <strong> Image Description Errors:</strong>
                        ${imageDescErrors.map(error => {
                            if (error.type === 'malformed_image_syntax' || error.type === 'malformed_syntax') {
                                let problemMsg = 'Your image syntax has an error';
                                let fixMsg = 'Use the correct format: <code>![description](0)</code>';
                                
                                const errorMsg = error.message || '';
                                
                                if (errorMsg.includes('Space between ] and (')) {
                                    problemMsg = 'There\'s a space between ] and ( in your image';
                                    fixMsg = 'Remove the space: <code>![description](0)</code> not <code>![description] (0)</code>';
                                } else if (errorMsg.includes('Space between ! and [')) {
                                    problemMsg = 'There\'s a space between ! and [ in your image';
                                    fixMsg = 'Remove the space: <code>![description](0)</code> not <code>! [description](0)</code>';
                                } else if (errorMsg.includes('Square brackets used instead of parentheses')) {
                                    problemMsg = 'You used square brackets [] for the image number';
                                    fixMsg = 'Use parentheses instead: <code>![description](0)</code> not <code>![description][0]</code>';
                                } else if (errorMsg.includes('Parentheses used instead of square brackets')) {
                                    problemMsg = 'You used parentheses () for the description';
                                    fixMsg = 'Use square brackets instead: <code>![description](0)</code> not <code>!(description)(0)</code>';
                                } else if (errorMsg.includes('Curly braces used instead')) {
                                    if (errorMsg.includes('square brackets')) {
                                        problemMsg = 'You used curly braces {} for the image description';
                                        fixMsg = 'Use square brackets instead: <code>![description](0)</code> not <code>!{description}(0)</code>';
                                    } else {
                                        problemMsg = 'You used curly braces {} for the image number';
                                        fixMsg = 'Use parentheses instead: <code>![description](0)</code> not <code>![description]{0}</code>';
                                    }
                                } else if (errorMsg.includes('Space after opening (') || errorMsg.includes('Space before closing )')) {
                                    problemMsg = 'There are spaces around the image number';
                                    fixMsg = 'Remove spaces: <code>![description](0)</code> not <code>![description]( 0 )</code>';
                                } else if (errorMsg.includes('Missing closing ] bracket')) {
                                    problemMsg = 'Your image description is missing the closing ] bracket';
                                    fixMsg = 'Add the ] bracket: <code>![description](0)</code>';
                                } else if (errorMsg.includes('Missing opening [ bracket')) {
                                    problemMsg = 'Your image is missing the opening [ bracket';
                                    fixMsg = 'Add the [ bracket: <code>![description](0)</code>';
                                } else if (errorMsg.includes('Missing ! at the beginning')) {
                                    problemMsg = 'Your image is missing the ! at the start';
                                    fixMsg = 'Add the ! at the beginning: <code>![description](0)</code>';
                                } else if (errorMsg.includes('Missing opening ( parenthesis')) {
                                    problemMsg = 'Your image number is missing the opening ( parenthesis';
                                    fixMsg = 'Add the ( before the number: <code>![description](0)</code>';
                                } else if (errorMsg.includes('Missing closing ) parenthesis') || errorMsg.includes('Missing closing )')) {
                                    problemMsg = 'Your image number is missing the closing ) parenthesis';
                                    fixMsg = 'Add the ) after the number: <code>![description](0)</code>';
                                } else if (errorMsg.includes('extra characters')) {
                                    problemMsg = 'Your image syntax has extra characters after the number';
                                    fixMsg = 'Remove extra characters: <code>![description](0)</code>';
                                } else {
                                    // Use the message from the validation function
                                    problemMsg = errorMsg.split(':')[0] || problemMsg;
                                }
                                
                                const errorMatch = error.match || '';
                                
                                return `
                                    <div style="margin: 8px 0; padding: 8px; background: #fff; border-left: 3px solid #ff4d4d; border-radius: 4px;">
                                        <div style="margin-bottom: 6px;"> <strong>Image Problem:</strong> ${problemMsg}</div>
                                        <div style="margin-bottom: 6px;"> <strong>How to Fix:</strong> ${fixMsg}</div>
                                        ${errorMatch ? `
                                        <div style="font-size: 0.9em; color: #666;">
                                            <strong>What You Wrote:</strong>
                                            <code style="display: block; margin-top: 4px; padding: 6px; background: #f5f5f5; border-radius: 3px; white-space: pre-wrap; font-family: monospace; font-size: 0.85em;">${escapeHtml(errorMatch)}</code>
                                        </div>
                                        ` : ''}
                                    </div>
                                `;
                            } else if (error.type === 'newline_in_description') {
                                const escapedDesc = (error.description || '')
                                    .replace(/\n/g, '\\n')
                                    .replace(/\r/g, '\\r');
                                const errorIndex = error.index || '?';
                                return `
                                    <div style="margin: 8px 0; padding: 8px; background: #fff; border-left: 3px solid #ff4d4d; border-radius: 4px;">
                                        <div style="margin-bottom: 6px;"> <strong>Image Problem:</strong> Your image description cannot have line breaks (newlines) in it</div>
                                        <div style="margin-bottom: 6px;"> <strong>How to Fix:</strong> Keep the description on one line, no Enter/Return keys pressed</div>
                                        <div style="font-size: 0.9em; color: #666;">
                                            <strong>Image #${errorIndex} Description:</strong>
                                            <code style="display: block; margin-top: 4px; padding: 6px; background: #f5f5f5; border-radius: 3px; white-space: pre-wrap; font-family: monospace; font-size: 0.85em;">${escapeHtml(`![${escapedDesc}](${errorIndex})`)}</code>
                                        </div>
                                    </div>
                                `;
                            } else if (error.type === 'block_latex_in_description') {
                                const escapedDesc = escapeHtml(error.description || '');
                                const errorIndex = error.index || '?';
                                return `
                                    <div style="margin: 8px 0; padding: 8px; background: #fff; border-left: 3px solid #ff4d4d; border-radius: 4px;">
                                        <div style="margin-bottom: 6px;"> <strong>Image Problem:</strong> Block LaTeX ($$\\n...\\n$$) is not allowed in image descriptions</div>
                                        <div style="margin-bottom: 6px;"> <strong>How to Fix:</strong> Use inline LaTeX ($...$) instead. Change <code>$$\\nformula\\n$$</code> to <code>$formula$</code></div>
                                        <div style="font-size: 0.9em; color: #666;">
                                            <strong>Image #${errorIndex} Description:</strong>
                                            <code style="display: block; margin-top: 4px; padding: 6px; background: #f5f5f5; border-radius: 3px; white-space: pre-wrap; font-family: monospace; font-size: 0.85em;">${escapeHtml(`![${escapedDesc}](${errorIndex})`)}</code>
                                        </div>
                                    </div>
                                `;
                            } else {
                                // Fallback for any other error types
                                return `
                                    <div style="margin: 8px 0; padding: 8px; background: #fff; border-left: 3px solid #ff4d4d; border-radius: 4px;">
                                        <div style="margin-bottom: 6px;"> <strong>Image Problem:</strong> ${error.message || 'Image syntax error'}</div>
                                        ${error.match ? `
                                        <div style="font-size: 0.9em; color: #666;">
                                            <strong>What You Wrote:</strong>
                                            <code style="display: block; margin-top: 4px; padding: 6px; background: #f5f5f5; border-radius: 3px; white-space: pre-wrap; font-family: monospace; font-size: 0.85em;">${escapeHtml(error.match)}</code>
                                        </div>
                                        ` : ''}
                                    </div>
                                `;
                            }
                        }).join('')}
                    </div>
                `;
                textarea.classList.add('validation-error');
            } else {
                // Clear errors
                if (errorDiv) {
                    errorDiv.style.display = 'none';
                    errorDiv.innerHTML = '';
                }
                const hasOtherErrors = container.querySelector('.table-validation-errors')?.style.display !== 'none' ||
                                      container.querySelector('.list-validation-errors')?.style.display !== 'none' ||
                                      container.querySelector('.blockquote-validation-errors')?.style.display !== 'none' ||
                                      container.querySelector('.latex-validation-errors')?.style.display !== 'none' ||
                                      container.querySelector('.quote-validation-errors')?.style.display !== 'none' ||
                                      container.querySelector('.br-validation-errors')?.style.display !== 'none';
                if (!hasOtherErrors) {
                    textarea.classList.remove('validation-error');
                }
            }
        }
        
        /**
         * Show quote and dollar sign validation errors for a textarea
         * @param {HTMLTextAreaElement} textarea - The textarea element
         */
        function showQuoteValidationErrors(textarea) {
            if (!textarea) return;
            
            const text = textarea.value;
            const quoteErrors = validateQuotes(text);
            const dollarErrors = validateDollarSigns(text);
            
            // Find or create error container - insert right after textarea
            const container = textarea.closest('.text-field-container') || textarea.parentElement;
            if (!container) return;
            
            let errorDiv = container.querySelector('.quote-validation-errors');
            
            const allErrors = [...quoteErrors, ...dollarErrors];
            
            if (allErrors.length > 0) {
                // Show errors
                if (!errorDiv) {
                    errorDiv = document.createElement('div');
                    errorDiv.className = 'quote-validation-errors';
                    errorDiv.style.cssText = 'margin-top: 8px;';
                    // Insert right after the textarea
                    textarea.parentNode.insertBefore(errorDiv, textarea.nextSibling);
                }
                
                errorDiv.style.display = 'block';
                errorDiv.innerHTML = `
                    <div style="padding: 10px; background: #ffe6e6; border: 1px solid #ff4d4d; border-radius: 6px; color: #cc0000;">
                        <strong> Quote & Dollar Sign Errors:</strong>
                        ${allErrors.map(error => {
                            if (error.type === 'unmatched_dollar_signs') {
                                return `
                                    <div style="margin: 8px 0; padding: 8px; background: #fff3cd; border-left: 3px solid #ffc107; border-radius: 4px; color: #856404;">
                                        <div style="margin-bottom: 6px;"> <strong>Dollar Sign Warning:</strong> ${error.message}</div>
                                        <div> <strong>Note:</strong> This is a warning only and won't block saving or generation.</div>
                                    </div>
                                `;
                            } else {
                                const fixMessage = 'Each quote must have a matching pair - remove the extra or add the missing one';
                                return `
                                    <div style="margin: 8px 0; padding: 8px; background: #fff; border-left: 3px solid #ff4d4d; border-radius: 4px;">
                                        <div style="margin-bottom: 6px;"> <strong>Quote Error:</strong> ${error.message}</div>
                                        <div style="margin-bottom: 6px;"> <strong>How to Fix:</strong> ${fixMessage}</div>
                                        <div> <strong>Important:</strong> This will break JSON generation and cause data loss!</div>
                                    </div>
                                `;
                            }
                        }).join('')}
                    </div>
                `;
                textarea.classList.add('validation-error');
            } else {
                // Clear errors
                if (errorDiv) {
                    errorDiv.style.display = 'none';
                    errorDiv.innerHTML = '';
                }
                const hasOtherErrors = container.querySelector('.table-validation-errors')?.style.display !== 'none' ||
                                      container.querySelector('.list-validation-errors')?.style.display !== 'none' ||
                                      container.querySelector('.blockquote-validation-errors')?.style.display !== 'none' ||
                                      container.querySelector('.latex-validation-errors')?.style.display !== 'none' ||
                                      container.querySelector('.image-validation-errors')?.style.display !== 'none' ||
                                      container.querySelector('.br-validation-errors')?.style.display !== 'none';
                if (!hasOtherErrors) {
                    textarea.classList.remove('validation-error');
                }
            }
        }
        
        /**
         * Show <br> tag validation errors for a textarea
         * @param {HTMLTextAreaElement} textarea - The textarea element
         */
        function showBrTagValidationErrors(textarea) {
            if (!textarea) return;
            
            const text = textarea.value;
            const brErrors = validateBrTags(text);
            
            // Find or create error container - insert right after textarea
            const container = textarea.closest('.text-field-container') || textarea.parentElement;
            if (!container) return;
            
            let errorDiv = container.querySelector('.br-validation-errors');
            
            if (brErrors.length > 0) {
                // Show errors
                if (!errorDiv) {
                    errorDiv = document.createElement('div');
                    errorDiv.className = 'br-validation-errors';
                    errorDiv.style.cssText = 'margin-top: 8px;';
                    // Insert right after the textarea
                    textarea.parentNode.insertBefore(errorDiv, textarea.nextSibling);
                }
                
                errorDiv.style.display = 'block';
                errorDiv.innerHTML = `
                    <div style="padding: 10px; background: #ffe6e6; border: 1px solid #ff4d4d; border-radius: 6px; color: #cc0000;">
                        <strong> HTML Tag Errors:</strong>
                        ${brErrors.map(error => `
                            <div style="margin: 8px 0; padding: 8px; background: #fff; border-left: 3px solid #ff4d4d; border-radius: 4px;">
                                <div style="margin-bottom: 6px;"> <strong>HTML Tag Error:</strong> ${error.message}</div>
                                <div style="margin-bottom: 6px;"> <strong>How to Fix:</strong> Remove all &lt;br&gt; tags from your content. Use markdown line breaks or proper formatting instead.</div>
                                <div> <strong>Important:</strong> This will break JSON generation and cause data loss!</div>
                            </div>
                        `).join('')}
                    </div>
                `;
                textarea.classList.add('validation-error');
            } else {
                // Clear errors
                if (errorDiv) {
                    errorDiv.style.display = 'none';
                    errorDiv.innerHTML = '';
                }
                const hasOtherErrors = container.querySelector('.table-validation-errors')?.style.display !== 'none' ||
                                      container.querySelector('.list-validation-errors')?.style.display !== 'none' ||
                                      container.querySelector('.blockquote-validation-errors')?.style.display !== 'none' ||
                                      container.querySelector('.latex-validation-errors')?.style.display !== 'none' ||
                                      container.querySelector('.image-validation-errors')?.style.display !== 'none' ||
                                      container.querySelector('.quote-validation-errors')?.style.display !== 'none';
                if (!hasOtherErrors) {
                    textarea.classList.remove('validation-error');
                }
            }
        }
        
        // ========== END CATEGORY 9.8 ==========
        
        // ========== END CATEGORY 9.7 ==========
        
        // ========== END CATEGORY 9.6 ==========
        
        // ========== END CATEGORY 9.5 ==========
        
        // ========== CATEGORY 10: FILL IN THE BLANKS HELPERS ==========

        /**
         * Parse blanks from question text
         * Extracts blank numbers from ___1___, ___2___, etc.
         * @param {string} text - The question text
         * @returns {Array<number>} Array of blank numbers found
         */
        function parseBlanksFromText(text) {
            if (!text) return [];
            // Match exactly 3 underscores, number, 3 underscores
            const blankPattern = /___(\d+)___/g;
            const blanks = [];
            let match;
            while ((match = blankPattern.exec(text)) !== null) {
                blanks.push(parseInt(match[1], 10));
            }
            return blanks;
        }

        /**
         * Validate blank format in question text
         * Checks for correct format, sequential numbering, etc.
         * @param {string} text - The question text
         * @returns {Object} { valid: boolean, errors: Array<string>, blanks: Array<number> }
         */
        function validateBlankFormat(text) {
            const errors = [];
            
            if (!text || !text.trim()) {
                return { valid: true, errors: [], blanks: [] };
            }

            // Check for specific invalid patterns (only match clearly broken blank-like structures)
            // IMPORTANT: We intentionally ignore spaces around valid blanks so line breaks/spacing don't cause errors
            const invalidPatterns = [
                // Wrong number of underscores (exactly 2)
                { pattern: /(?<!_)__(\d+)__(?!_)/g, message: 'Only 2 underscores found (need exactly 3)', example: '__N__' },
                // Wrong number of underscores (1 underscore)
                { pattern: /(?<!_)_(\d+)_(?!_)/g, message: 'Only 1 underscore found (need exactly 3)', example: '_N_' },
                // Too many underscores (4 or more)
                { pattern: /____+(\d+)____+/g, message: 'Too many underscores (need exactly 3)', example: '____N____' },
                // Dashes instead of underscores
                { pattern: /---(\d+)---/g, message: 'Dashes used instead of underscores', example: '---N---' }
                // Note: We no longer flag spaces around blanks so patterns like "___1___ ___2___"
                // or line breaks between blanks are always accepted.
            ];

            for (const { pattern, message, example } of invalidPatterns) {
                const matches = text.match(pattern);
                if (matches) {
                    // Filter out valid blanks from the matches
                    const validBlanks = matches.filter(m => /^___\d+___$/.test(m));
                    const invalidMatches = matches.filter(m => !validBlanks.includes(m));
                    
                    if (invalidMatches.length > 0) {
                        errors.push(`Invalid blank format: ${message}. Found: "${invalidMatches[0].trim()}" (should be like ___1___)`);
                    }
                }
            }

            // Get valid blanks (in order as they appear in text)
            const blanks = parseBlanksFromText(text);
            
            if (blanks.length === 0) {
                // No blanks found - this is okay for fill_in_the_blanks type (they can add blanks later)
                return { valid: true, errors: [], blanks: [] };
            }

            // Check that blanks appear in correct order (1, 2, 3... as they appear in text)
            // NOT sorted - we want to check the actual order they appear
            for (let i = 0; i < blanks.length; i++) {
                const expectedNumber = i + 1;
                if (blanks[i] !== expectedNumber) {
                    errors.push(`Blanks must appear in order 1, 2, 3... in your text. Found ___${blanks[i]}___ at position ${i + 1}, expected ___${expectedNumber}___`);
                    break; // Only show first order error to avoid confusion
                }
            }

            // Check for duplicates (same blank number appears multiple times)
            const uniqueBlanks = [...new Set(blanks)];
            if (uniqueBlanks.length !== blanks.length) {
                const duplicates = blanks.filter((num, index) => blanks.indexOf(num) !== index);
                const uniqueDuplicates = [...new Set(duplicates)];
                errors.push(`Duplicate blank numbers found: ${uniqueDuplicates.map(n => `___${n}___`).join(', ')}`);
            }

            return {
                valid: errors.length === 0,
                errors,
                blanks: uniqueBlanks.sort((a, b) => a - b)
            };
        }

        /**
         * Update blank answers UI based on question text
         * Generates input fields for each detected blank
         * @param {HTMLElement} questionEl - The question container element
         */
        function updateBlankAnswersUI(questionEl) {
            const questionTextarea = questionEl.querySelector('textarea[placeholder*="Enter question text"]');
            const blanksContainer = questionEl.querySelector('#blanks-answers-container');
            
            if (!questionTextarea || !blanksContainer) return;

            const questionText = questionTextarea.value;
            const { valid, errors, blanks } = validateBlankFormat(questionText);

            // Show validation errors if any
            const errorContainer = questionEl.querySelector('#blanks-validation-errors');
            if (errorContainer) {
                if (errors.length > 0) {
                    errorContainer.style.display = 'block';
                    errorContainer.innerHTML = `
                        <div style="padding: 10px; background: #ffe6e6; border: 1px solid #ff4d4d; border-radius: 6px; color: #cc0000;">
                            <strong> Blank Format Errors:</strong>
                            <ul style="margin: 5px 0 0 20px; padding: 0;">
                                ${errors.map(err => `<li>${err}</li>`).join('')}
                            </ul>
                        </div>
                    `;
                } else {
                    errorContainer.style.display = 'none';
                    errorContainer.innerHTML = '';
                }
            }

            // Save existing blank answer values before clearing
            const existingValues = {};
            const existingBlankItems = blanksContainer.querySelectorAll('.blank-answer-item');
            existingBlankItems.forEach(item => {
                const blankNum = item.dataset.blankNumber;
                const textarea = item.querySelector('.blank-answer-input');
                if (blankNum && textarea) {
                    existingValues[blankNum] = textarea.value;
                }
            });

            // Clear existing inputs
            blanksContainer.innerHTML = '';

            if (blanks.length === 0) {
                blanksContainer.innerHTML = '<p style="color: var(--text-secondary); font-style: italic; padding: 10px;">No blanks detected. Use ___1___, ___2___, etc. in your question text.</p>';
                return;
            }

            // Show summary
            const summary = document.createElement('div');
            summary.style.cssText = 'padding: 8px 12px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 6px; margin-bottom: 15px; color: var(--text-primary);';
            summary.innerHTML = `<strong>Found ${blanks.length} blank${blanks.length > 1 ? 's' : ''}:</strong> ${blanks.map(n => `___${n}___`).join(', ')}`;
            blanksContainer.appendChild(summary);

            // Generate input fields for each blank
            blanks.forEach((blankNum) => {
                const blankItem = document.createElement('div');
                blankItem.className = 'form-group blank-answer-item';
                blankItem.style.cssText = 'margin-bottom: 15px;';
                blankItem.dataset.blankNumber = blankNum;
                
                blankItem.innerHTML = `
                    <label style="font-weight: 600; color: var(--text-primary);">
                        <span style="color: var(--accent); font-size: 1.1em;">___${blankNum}___</span> Answer
                    </label>
                    <div class="text-field-container">
                        <span class="input-label">Input Markdown</span>
                        <textarea class="blank-answer-input" placeholder="Enter answer for blank ${blankNum}..." style="min-height: 60px;" title="Answer text for blank ___${blankNum}___ (supports markdown and LaTeX)"></textarea>
                        <button type="button" class="markdown-btn" onclick="insertBold(this.parentElement.querySelector('textarea'))" title="Make selected text bold (**text**)">
                            <i class="fas fa-bold"></i>
                        </button>
                        <button type="button" class="markdown-btn" onclick="insertItalic(this.parentElement.querySelector('textarea'))" title="Make selected text italic (*text*)">
                            <i class="fas fa-italic"></i>
                        </button>
                        <button type="button" class="markdown-btn" onclick="insertBulletList(this.parentElement.querySelector('textarea'))" title="Convert line(s) to bullet list (- item)">
                            <i class="fas fa-list-ul"></i>
                        </button>
                        <button type="button" class="markdown-btn" onclick="insertNumberedList(this.parentElement.querySelector('textarea'))" title="Convert line(s) to numbered list (1. item)">
                            <i class="fas fa-list-ol"></i>
                        </button>
                        <button type="button" class="markdown-btn" onclick="insertBlockquote(this.parentElement.querySelector('textarea'))" title="Convert line(s) to blockquote (> text)">
                            <i class="fas fa-quote-right"></i>
                        </button>
                        <button type="button" class="markdown-btn" onclick="insertInlineLatex(this.parentElement.querySelector('textarea'))" title="Wrap selection with $ or insert $$">
                            <i class="fas fa-dollar-sign"></i>
                        </button>
                        <button type="button" class="markdown-btn" onclick="insertBlockLatex(this.parentElement.querySelector('textarea'))" title="Wrap selection with block LaTeX ($$\\n...\\n$$) or insert $$\\n\\n$$">
                            <i class="fas fa-square-root-alt"></i>
                        </button>
                        <button type="button" class="markdown-btn" onclick="removeMarkdownFormatting(this)" title="Undo last markdown formatting operation">
                            <i class="fas fa-undo"></i>
                        </button>
                        <button type="button" class="markdown-btn" onclick="redoMarkdownFormatting(this)" title="Redo last undone markdown formatting operation">
                            <i class="fas fa-redo"></i>
                        </button>
                        <button type="button" class="dir-btn" onclick="toggleDirection(this.parentElement.querySelector('textarea'))" title="Toggle text direction (LTR/RTL)">LTR</button>
                    </div>
                `;
                blanksContainer.appendChild(blankItem);
                
                // Attach previews to the new textarea
                const textarea = blankItem.querySelector('textarea');
                if (textarea) {
                    textarea.setAttribute('dir', 'rtl');
                    
                    // Restore previous value if it exists for this blank number
                    if (existingValues[blankNum]) {
                        textarea.value = existingValues[blankNum];
                    }
                    
                    attachPreviews(blankItem);
                    
                    // Update filled blanks preview on input
                    textarea.addEventListener('input', () => {
                        updateFilledBlanksPreview(questionEl);
                    });
                }
            });
            
            // Update the filled blanks preview
            updateFilledBlanksPreview(questionEl);
        }

        /**
         * Toggle direction for filled blanks preview
         * @param {HTMLElement} button - The button element
         */
        function toggleFilledBlanksDirection(button) {
            const questionEl = button.closest('.array-item');
            const preview = questionEl.querySelector('#filled-blanks-preview');
            
            if (!preview) return;
            
            const currentDir = preview.getAttribute('dir') || 'rtl';
            const newDir = currentDir === 'rtl' ? 'ltr' : 'rtl';
            
            preview.setAttribute('dir', newDir);
            preview.style.textAlign = newDir === 'rtl' ? 'right' : 'left';
            button.textContent = newDir === 'rtl' ? 'LTR' : 'RTL';
        }

        /**
         * Update the preview showing question with filled blanks
         * @param {HTMLElement} questionEl - The question container element
         */
        function updateFilledBlanksPreview(questionEl) {
            const questionTextarea = questionEl.querySelector('textarea[placeholder*="Enter question text"]');
            const preview = questionEl.querySelector('#filled-blanks-preview');
            const blanksContainer = questionEl.querySelector('#blanks-answers-container');
            
            if (!questionTextarea || !preview || !blanksContainer) return;
            
            let questionText = questionTextarea.value.trim();
            
            if (!questionText) {
                preview.innerHTML = '<p style="color: var(--text-secondary); font-style: italic;">Enter question text to see preview</p>';
                return;
            }
            
            // Get all blank answers
            const blankItems = blanksContainer.querySelectorAll('.blank-answer-item');
            const blankAnswers = {};
            
            blankItems.forEach(item => {
                const blankNum = item.dataset.blankNumber;
                const textarea = item.querySelector('.blank-answer-input');
                if (textarea && blankNum) {
                    blankAnswers[blankNum] = textarea.value.trim();
                }
            });
            
            // Check if all blanks have answers
            const blanks = parseBlanksFromText(questionText);
            const allFilled = blanks.every(num => blankAnswers[num]);
            
            if (!allFilled) {
                preview.innerHTML = '<p style="color: var(--text-secondary); font-style: italic;">Fill in all blank answers to see preview</p>';
                return;
            }
            
            // Replace blanks with answers
            let filledText = questionText;
            blanks.forEach(num => {
                const answer = blankAnswers[num] || '';
                // Replace ___num___ with the answer wrapped in a styled span
                const regex = new RegExp(`___${num}___`, 'g');
                filledText = filledText.replace(regex, `<span style="display: inline-block; padding: 2px 6px; background: linear-gradient(135deg, #28a745 0%, #20c997 100%); color: white; border-radius: 3px; font-weight: 600; box-shadow: 0 1px 3px rgba(0,0,0,0.2);">${answer}</span>`);
            });
            
            // Render markdown + math using the same logic as the main text preview
            // so that things like $\%$ behave identically.
            if (typeof renderLivePreview === 'function') {
                // Create a temporary hidden textarea that reuses renderLivePreview's pipeline
                const tempTextarea = document.createElement('textarea');
                tempTextarea.style.display = 'none';
                tempTextarea.value = filledText;
                
                // Insert it just before the preview so renderLivePreview finds the right target
                preview.parentElement.insertBefore(tempTextarea, preview);
                try {
                    renderLivePreview(tempTextarea);
                } finally {
                    tempTextarea.remove();
                }
            } else {
                // Fallback: basic Markdown + KaTeX rendering (should rarely be used)
                if (window.marked?.parse) {
                    try {
                        let html = window.marked.parse(filledText);
                        preview.innerHTML = html;
                        
                        if (window.katex && window.renderMathInElement) {
                            try {
                                window.renderMathInElement(preview, {
                                    delimiters: [
                                        { left: '$$', right: '$$', display: true },
                                        { left: '$', right: '$', display: false },
                                        { left: '\\(', right: '\\)', display: false },
                                        { left: '\\[', right: '\\]', display: true }
                                    ]
                                });
                                // Force all LaTeX elements to be LTR regardless of parent direction
                                const allMathElements = preview.querySelectorAll('.__math_block, .__math_inline, .katex, .katex-display, .katex-html, .katex *');
                                allMathElements.forEach(mathEl => {
                                    mathEl.setAttribute('dir', 'ltr');
                                    mathEl.style.direction = 'ltr';
                                    mathEl.style.unicodeBidi = 'isolate';
                                });
                            } catch (e) {
                                // ignore math errors
                            }
                        }
                    } catch (e) {
                        preview.innerHTML = filledText.replace(/\n/g, '<br>');
                    }
                } else {
                    preview.innerHTML = filledText.replace(/\n/g, '<br>');
                }
            }
        }

        /**
         * Insert next blank at cursor position
         * @param {HTMLTextAreaElement} textarea - The textarea element
         */
        function insertBlankAtCursor(textarea) {
            const questionText = textarea.value;
            const blanks = parseBlanksFromText(questionText);
            const nextBlankNum = blanks.length > 0 ? Math.max(...blanks) + 1 : 1;
            const blankText = `___${nextBlankNum}___`;
            
            const cursorPos = textarea.selectionStart;
            const textBefore = textarea.value.substring(0, cursorPos);
            const textAfter = textarea.value.substring(cursorPos);
            
            textarea.value = textBefore + blankText + textAfter;
            
            const newCursorPos = cursorPos + blankText.length;
            textarea.setSelectionRange(newCursorPos, newCursorPos);
            textarea.focus();
            
            // Trigger preview refresh and UI update
            refreshPreviewFor(textarea);
            textarea.dispatchEvent(new Event('input', { bubbles: true }));
        }

        /**
         * Collect blank answers from UI
         * @param {HTMLElement} questionEl - The question container element
         * @returns {Array<string>} Array of answers in order
         */
        function collectBlankAnswers(questionEl) {
            const blanksContainer = questionEl.querySelector('#blanks-answers-container');
            if (!blanksContainer) return [];
            
            const blankItems = blanksContainer.querySelectorAll('.blank-answer-item');
            const answers = [];
            
            blankItems.forEach((item) => {
                const textarea = item.querySelector('.blank-answer-input');
                if (textarea) {
                    answers.push(textarea.value.trim());
                }
            });
            
            return answers;
        }

        // ========== END CATEGORY 10 ==========

        // ========== CATEGORY 11: MATCHING HELPERS ==========

        /**
         * Add a matching item to left or right list
         * @param {HTMLElement} button - The button element
         * @param {string} side - Either 'left' or 'right'
         */
        function addMatchingItem(button, side) {
            const questionEl = button.closest('.array-item');
            const listContainer = questionEl.querySelector(`#matching-${side}-list-${questionEl.querySelector('[id^="matching-left-list-"]').id.split('-')[3]}`);
            
            if (!listContainer) {
                console.error(`Could not find ${side} list container`);
                return;
            }
            
            const itemCount = listContainer.querySelectorAll('.matching-item').length + 1;
            const itemId = `matching-${side}-item-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            
            const itemDiv = document.createElement('div');
            itemDiv.className = 'array-item matching-item';
            itemDiv.dataset.side = side;
            itemDiv.style.cssText = 'padding: 10px; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-primary);';
            
            itemDiv.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <strong style="color: var(--accent); font-size: 1.1em;">${side === 'left' ? 'L' : 'R'}${itemCount}</strong>
                    <div style="display: flex; gap: 5px;">
                        <button class="reorder-btn" onclick="moveMatchingItemUp(this)" title="Move Up" style="padding: 2px 6px; font-size: 0.8em;">
                            <i class="fas fa-arrow-up"></i>
                        </button>
                        <button class="reorder-btn" onclick="moveMatchingItemDown(this)" title="Move Down" style="padding: 2px 6px; font-size: 0.8em;">
                            <i class="fas fa-arrow-down"></i>
                        </button>
                        <button class="remove-btn" onclick="removeMatchingItem(this)" title="Remove" style="padding: 2px 8px; font-size: 0.9em;"></button>
                    </div>
                </div>
                <div class="text-field-container">
                    <span class="input-label">Input Markdown</span>
                    <textarea class="matching-item-text" placeholder="Enter ${side} item text..." style="min-height: 60px;" title="Text for this ${side} matching item (supports markdown and LaTeX)"></textarea>
                    <button type="button" class="markdown-btn" onclick="insertBold(this.parentElement.querySelector('textarea'))" title="Make selected text bold (**text**)">
                        <i class="fas fa-bold"></i>
                    </button>
                    <button type="button" class="markdown-btn" onclick="insertItalic(this.parentElement.querySelector('textarea'))" title="Make selected text italic (*text*)">
                        <i class="fas fa-italic"></i>
                    </button>
                    <button type="button" class="markdown-btn" onclick="insertBulletList(this.parentElement.querySelector('textarea'))" title="Convert line(s) to bullet list (- item)">
                        <i class="fas fa-list-ul"></i>
                    </button>
                    <button type="button" class="markdown-btn" onclick="insertNumberedList(this.parentElement.querySelector('textarea'))" title="Convert line(s) to numbered list (1. item)">
                        <i class="fas fa-list-ol"></i>
                    </button>
                    <button type="button" class="markdown-btn" onclick="insertBlockquote(this.parentElement.querySelector('textarea'))" title="Convert line(s) to blockquote (> text)">
                        <i class="fas fa-quote-right"></i>
                    </button>
                    <button type="button" class="markdown-btn" onclick="insertInlineLatex(this.parentElement.querySelector('textarea'))" title="Wrap selection with $ or insert $$">
                        <i class="fas fa-dollar-sign"></i>
                    </button>
                    <button type="button" class="markdown-btn" onclick="insertBlockLatex(this.parentElement.querySelector('textarea'))" title="Wrap selection with block LaTeX ($$\\n...\\n$$) or insert $$\\n\\n$$">
                        <i class="fas fa-square-root-alt"></i>
                    </button>
                    <button type="button" class="markdown-btn" onclick="removeMarkdownFormatting(this)" title="Undo last markdown formatting operation">
                        <i class="fas fa-undo"></i>
                    </button>
                    <button type="button" class="markdown-btn" onclick="redoMarkdownFormatting(this)" title="Redo last undone markdown formatting operation">
                        <i class="fas fa-redo"></i>
                    </button>
                    <button type="button" class="table-btn" onclick="insertTable(this.parentElement.querySelector('textarea'))" title="Insert a markdown table template">
                        <i class="fas fa-table"></i> Insert Table
                    </button>
                    <button type="button" class="image-btn" onclick="insertImage(this.parentElement.querySelector('textarea'))" title="Insert an image placeholder">
                        <i class="fas fa-image"></i> Insert Image
                    </button>
                    <button type="button" class="dir-btn" onclick="toggleDirection(this.parentElement.querySelector('textarea'))" title="Toggle text direction (LTR/RTL)">LTR</button>
                </div>
            `;
            
            listContainer.appendChild(itemDiv);
            
            // Record action for undo/redo (after adding to DOM so we have the actual element)
            recordFormAction({
                type: ACTION_TYPES.ADD_ITEM,
                element: itemDiv,
                parent: listContainer,
                nextSibling: itemDiv.nextSibling,
                containerId: null,
                updateNumbers: false,
                isMatchingItem: true, // Flag to identify matching items
                questionEl: questionEl, // Store question element for UI updates
                side: side // Store which side (left/right)
            });
            
            // Attach previews and set RTL direction
            const textarea = itemDiv.querySelector('textarea');
            if (textarea) {
                textarea.setAttribute('dir', 'rtl');
                attachPreviews(itemDiv);
            }
            
            // Update all item numbers
            updateMatchingItemNumbers(questionEl, side);
            
            // Update relationship UI
            updateRelationshipUI(questionEl);
        }

        /**
         * Remove a matching item
         * @param {HTMLElement} button - The remove button
         */
        function removeMatchingItem(button) {
            const item = button.closest('.matching-item');
            const side = item.dataset.side;
            // Get the matching container, then the question container
            const matchingContainer = item.closest('#matching-container');
            const questionEl = matchingContainer ? matchingContainer.closest('.array-item') : null;
            
            if (confirm(`Are you sure you want to remove this ${side} item?`)) {
                // Record action for undo/redo (before removing)
                recordFormAction({
                    type: ACTION_TYPES.REMOVE_ITEM,
                    element: item.cloneNode(true), // Clone for restoration
                    parent: item.parentElement,
                    nextSibling: item.nextSibling,
                    containerId: null,
                    updateNumbers: false,
                    isMatchingItem: true, // Flag to identify matching items
                    questionEl: questionEl, // Store question element for UI updates
                    side: side // Store which side (left/right)
                });
                
                item.remove();
                if (questionEl) {
                    updateMatchingItemNumbers(questionEl, side);
                    updateRelationshipUI(questionEl);
                }
            }
        }

        /**
         * Move matching item up
         * @param {HTMLElement} button - The move button
         */
        function moveMatchingItemUp(button) {
            const item = button.closest('.matching-item');
            const prevItem = item.previousElementSibling;
            
            if (prevItem && prevItem.classList.contains('matching-item')) {
                // Get the list container (parent of item)
                const listContainer = item.parentElement;
                
                // Move the item in DOM
                listContainer.insertBefore(item, prevItem);
                
                // IMMEDIATELY renumber ALL items in this list to 1, 2, 3...
                renumberMatchingItems(listContainer);
                
                // Update relationships dropdown - get question container properly
                const matchingContainer = item.closest('#matching-container');
                const questionEl = matchingContainer ? matchingContainer.closest('.array-item') : null;
                if (questionEl) {
                    updateRelationshipUI(questionEl);
                }
                
                markFormAsChanged();
                triggerAutoSave();
            }
        }

        /**
         * Move matching item down
         * @param {HTMLElement} button - The move button
         */
        function moveMatchingItemDown(button) {
            const item = button.closest('.matching-item');
            const nextItem = item.nextElementSibling;
            
            if (nextItem && nextItem.classList.contains('matching-item')) {
                // Get the list container (parent of item)
                const listContainer = item.parentElement;
                
                // Move the item in DOM
                listContainer.insertBefore(nextItem, item);
                
                // IMMEDIATELY renumber ALL items in this list to 1, 2, 3...
                renumberMatchingItems(listContainer);
                
                // Update relationships dropdown - get question container properly
                const matchingContainer = item.closest('#matching-container');
                const questionEl = matchingContainer ? matchingContainer.closest('.array-item') : null;
                if (questionEl) {
                    updateRelationshipUI(questionEl);
                }
                
                markFormAsChanged();
                triggerAutoSave();
            }
        }

        /**
         * Renumber all matching items in a list container to be sequential 1, 2, 3...
         * @param {HTMLElement} listContainer - The list containing matching items
         */
        function renumberMatchingItems(listContainer) {
            // Get all items in this list
            const items = listContainer.querySelectorAll('.matching-item');
            
            // Determine if this is left or right list (check first item's data-side)
            const firstItem = items[0];
            if (!firstItem) return;
            
            const side = firstItem.dataset.side;
            const prefix = side === 'left' ? 'L' : 'R';
            
            // Renumber each item: 1, 2, 3...
            items.forEach((item, index) => {
                const strong = item.querySelector('strong');
                if (strong) {
                    strong.textContent = `${prefix}${index + 1}`;
                }
            });
        }

        /**
         * Update matching item numbers after reordering (legacy - calls renumberMatchingItems)
         * @param {HTMLElement} questionEl - The question container
         * @param {string} side - Either 'left' or 'right'
         */
        function updateMatchingItemNumbers(questionEl, side) {
            // Find the matching container
            const matchingContainer = questionEl.querySelector('#matching-container');
            if (!matchingContainer) return;
            
            // Get all matching lists
            const lists = matchingContainer.querySelectorAll('.matching-list');
            
            // Renumber both lists
            lists.forEach(list => {
                renumberMatchingItems(list);
            });
        }

        /**
         * Add a relationship between left and right items
         * @param {HTMLElement} button - The add button
         */
        function addRelationship(button) {
            const questionEl = button.closest('.array-item');
            const leftItems = questionEl.querySelectorAll('[id^="matching-left-list-"] .matching-item');
            const rightItems = questionEl.querySelectorAll('[id^="matching-right-list-"] .matching-item');
            
            if (leftItems.length === 0 || rightItems.length === 0) {
                alert('Please add items to both left and right lists before creating relationships.');
                return;
            }
            
            const relationshipsList = questionEl.querySelector('[id^="relationships-list-"]');
            if (!relationshipsList) return;
            
            // Clear placeholder if it exists
            const placeholder = relationshipsList.querySelector('p');
            if (placeholder) {
                placeholder.remove();
            }
            
            const relationshipDiv = document.createElement('div');
            relationshipDiv.className = 'relationship-item';
            relationshipDiv.style.cssText = 'display: flex; align-items: center; gap: 10px; padding: 10px; background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 6px;';
            
            // Build options for left items
            let leftOptions = '<option value="">Select Left Item</option>';
            leftItems.forEach((item, index) => {
                leftOptions += `<option value="${index + 1}">L${index + 1}</option>`;
            });
            
            // Build options for right items
            let rightOptions = '<option value="">Select Right Item</option>';
            rightItems.forEach((item, index) => {
                rightOptions += `<option value="${index + 1}">R${index + 1}</option>`;
            });
            
            relationshipDiv.innerHTML = `
                <select class="relationship-left" style="flex: 1; padding: 6px; background: var(--bg-secondary); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 4px;" title="Select a left item to connect">
                    ${leftOptions}
                </select>
                <span style="color: var(--text-secondary); font-weight: bold;"></span>
                <select class="relationship-right" style="flex: 1; padding: 6px; background: var(--bg-secondary); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 4px;" title="Select a right item to connect">
                    ${rightOptions}
                </select>
                <button class="remove-btn" onclick="removeRelationship(this)" title="Remove Relationship" style="padding: 4px 10px;"></button>
            `;
            
            relationshipsList.appendChild(relationshipDiv);
        }

        /**
         * Remove a relationship
         * @param {HTMLElement} button - The remove button
         */
        function removeRelationship(button) {
            const relationshipDiv = button.closest('.relationship-item');
            const relationshipsList = relationshipDiv.parentElement;
            
            relationshipDiv.remove();
            
            // Add placeholder if no relationships left
            if (relationshipsList.querySelectorAll('.relationship-item').length === 0) {
                relationshipsList.innerHTML = '<p style="color: var(--text-secondary); font-style: italic; margin: 0;">No relationships added yet. Click "Add Relationship" to connect items.</p>';
            }
        }

        /**
         * Update relationship UI when items change
         * @param {HTMLElement} questionEl - The question container
         */
        function updateRelationshipUI(questionEl) {
            const relationshipsList = questionEl.querySelector('[id^="relationships-list-"]');
            if (!relationshipsList) {
                console.log('updateRelationshipUI: No relationships list found');
                return;
            }
            
            const relationships = relationshipsList.querySelectorAll('.relationship-item');
            const leftItems = questionEl.querySelectorAll('[id^="matching-left-list-"] .matching-item');
            const rightItems = questionEl.querySelectorAll('[id^="matching-right-list-"] .matching-item');
            
            console.log('updateRelationshipUI: Left items count:', leftItems.length, 'Right items count:', rightItems.length);
            
            // Rebuild options for each relationship
            relationships.forEach(relDiv => {
                const leftSelect = relDiv.querySelector('.relationship-left');
                const rightSelect = relDiv.querySelector('.relationship-right');
                const currentLeftValue = leftSelect.value;
                const currentRightValue = rightSelect.value;
                
                console.log('updateRelationshipUI: Current values - Left:', currentLeftValue, 'Right:', currentRightValue);
                
                // Rebuild left options
                let leftOptions = '<option value="">Select Left Item</option>';
                leftItems.forEach((item, index) => {
                    const selected = (index + 1) == currentLeftValue ? 'selected' : '';
                    leftOptions += `<option value="${index + 1}" ${selected}>L${index + 1}</option>`;
                });
                leftSelect.innerHTML = leftOptions;
                
                // Rebuild right options
                let rightOptions = '<option value="">Select Right Item</option>';
                rightItems.forEach((item, index) => {
                    const selected = (index + 1) == currentRightValue ? 'selected' : '';
                    rightOptions += `<option value="${index + 1}" ${selected}>R${index + 1}</option>`;
                });
                rightSelect.innerHTML = rightOptions;
                
                console.log('updateRelationshipUI: Rebuilt options - Left options count:', leftItems.length + 1, 'Right options count:', rightItems.length + 1);
            });
        }

        /**
         * Collect matching data from UI
         * @param {HTMLElement} questionEl - The question container
         * @returns {Object} { left: Array, right: Array, relationship: Array }
         */
        function collectMatchingData(questionEl) {
            const leftItems = questionEl.querySelectorAll('[id^="matching-left-list-"] .matching-item');
            const rightItems = questionEl.querySelectorAll('[id^="matching-right-list-"] .matching-item');
            const relationships = questionEl.querySelectorAll('[id^="relationships-list-"] .relationship-item');
            
            const left = [];
            leftItems.forEach(item => {
                const textarea = item.querySelector('.matching-item-text');
                if (textarea) {
                    left.push(textarea.value.trim());
                }
            });
            
            const right = [];
            rightItems.forEach(item => {
                const textarea = item.querySelector('.matching-item-text');
                if (textarea) {
                    right.push(textarea.value.trim());
                }
            });
            
            const relationship = [];
            relationships.forEach(relDiv => {
                const leftSelect = relDiv.querySelector('.relationship-left');
                const rightSelect = relDiv.querySelector('.relationship-right');
                const leftValue = parseInt(leftSelect.value, 10);
                const rightValue = parseInt(rightSelect.value, 10);
                
                if (leftValue && rightValue) {
                    relationship.push([leftValue, rightValue]);
                }
            });
            
            return { left, right, relationship };
        }

        // ========== END CATEGORY 11 ==========

        // ========== CATEGORY 4 REFACTORING: Validation Helper Functions ==========
        
        /**
         * Extract text indices for content section
         * @param {Object} content - Content section object
         * @returns {Object} Object with allIndices and uniqueIndices
         */
        function getContentTextIndices(content) {
            const text = content.text || '';
            const allIndices = extractAllImageIndices(text);
            const uniqueIndices = getUniqueIndices(allIndices);
            return { allIndices, uniqueIndices };
        }

        /**
         * Extract text indices for question section (handles MCQ, checkbox, matching, and free-form)
         * @param {Object} question - Question object
         * @returns {Object} Object with questionIndices, guideIndices, and their unique versions
         */
        function getQuestionTextIndices(question) {
            const questionText = question.question_text || '';
            const setupText = question.set_up_text || '';
            const guideAnswer = question.guide_answer || '';
            const questionType = question.question_type || 'free_form';
            const choices = question.choices || [];
            const leftItems = question.left || [];
            const rightItems = question.right || [];
            
            // Get question + setup indices
            let allQuestionIndices = extractAllImageIndices([setupText, questionText]);
            
            // Add choice indices for multiple_choice and checkbox
            if ((questionType === 'multiple_choice' || questionType === 'checkbox') && choices.length > 0) {
                choices.forEach((choice) => {
                    allQuestionIndices.push(...extractAllImageIndices(choice.text || ''));
                });
            }

            // Add left and right item indices for matching
            if (questionType === 'matching') {
                // Add all left items
                leftItems.forEach((item) => {
                    allQuestionIndices.push(...extractAllImageIndices(item || ''));
                });
                // Add all right items
                rightItems.forEach((item) => {
                    allQuestionIndices.push(...extractAllImageIndices(item || ''));
                });
            }
            
            const uniqueQuestionIndices = getUniqueIndices(allQuestionIndices);
            
            // Get guide answer indices (separate array for both multiple_choice and free-form)
            const allGuideIndices = extractAllImageIndices(guideAnswer);
            const uniqueGuideIndices = getUniqueIndices(allGuideIndices);
            
            return {
                allQuestionIndices,
                uniqueQuestionIndices,
                allGuideIndices,
                uniqueGuideIndices
            };
        }

        // ========== END CATEGORY 4 REFACTORING ==========

        // Get the next available image index for a given textarea
        function getNextImageIndex(textarea) {
            if (!textarea) return 0;
            
            const text = textarea.value || '';
            const existingIndices = extractImageIndices(text);
            
            if (existingIndices.length === 0) {
                return 0;
            }
            
            // Convert to numbers and find the highest index
            const numericIndices = existingIndices.map(idx => parseInt(idx)).filter(idx => !isNaN(idx));
            if (numericIndices.length === 0) {
                return 0;
            }
            
            const maxIndex = Math.max(...numericIndices);
            return maxIndex + 1;
        }

        // Validate block LaTeX content and return errors
        function validateImageDescriptions(content) {
            const errors = [];
            if (!content || content.trim().length === 0) {
                return errors; // Skip empty content
            }
            
            let md = content.replace(/\r\n?/g, '\n');
            
            // Check if there are any image-like patterns to validate
            const hasImagePattern = md.includes('![') || /\[([^\]]{1,100})\]\(\d+\)/.test(md);
            if (!hasImagePattern) {
                return errors; // No images to validate
            }
            
            // Protect LaTeX math expressions inside image descriptions before validation
            // This prevents false positives when descriptions contain LaTeX like $...$ or $\sqrt[3]{3}$
            const latexPlaceholders = [];
            let placeholderIndex = 0;
            
            // First, protect ALL inline math $...$ in the entire text
            // This must happen BEFORE we try to match image patterns, because LaTeX can contain brackets
            // that would confuse the image pattern matching (e.g., $\sqrt[3]{16}$)
            md = md.replace(/\$([^$\n]{1,200}?)\$/g, (mathMatch, mathContent) => {
                // Only protect if it looks like actual math (has some content and isn't just $$)
                if (mathContent.trim().length > 0) {
                    const placeholder = `@@LATEX_INLINE_IMG_${placeholderIndex}@@`;
                    latexPlaceholders[placeholderIndex] = mathMatch;
                    placeholderIndex++;
                    return placeholder;
                }
                return mathMatch; // Don't protect if it's malformed
            });
            
            // Check for malformed image syntax patterns
            const malformedPatterns = [
                { regex: /!\[([^\]]*?)\]\s+\(\d+\)/g, message: 'Space between ] and ( in image syntax' },  // ![desc] (0)
                { regex: /!\s+\[([^\]]*?)\]\(\d+\)/g, message: 'Space between ! and [ in image syntax' },  // ! [desc](0)
                { regex: /!\[([^\]]*?)\]\[\d+\]/g, message: 'Square brackets used instead of parentheses for image index' },  // ![desc][0]
                { regex: /!\(([^)]*?)\)\(\d+\)/g, message: 'Parentheses used instead of square brackets for image description' },  // !(desc)(0)
                { regex: /!\[([^\]]*?)\]\s*\[\s*\d+\s*\]/g, message: 'Square brackets used instead of parentheses for image index' },  // ![desc][0] with spaces
                { regex: /!\{([^}]*?)\}\(\d+\)/g, message: 'Curly braces used instead of square brackets for image description' },  // !{desc}(0)
                { regex: /!\[([^\]]*?)\]\{\d+\}/g, message: 'Curly braces used instead of parentheses for image index' },  // ![desc]{0}
                // Spaces inside parentheses for index
                { regex: /!\[([^\]]*?)\]\(\s+\d+\)/g, message: 'Space after opening ( in image index' },  // ![desc]( 0)
                { regex: /!\[([^\]]*?)\]\(\d+\s+\)/g, message: 'Space before closing ) in image index' },  // ![desc](0 )
                // Missing brackets patterns
                { regex: /!\[([^\]\n]{1,100})\(\d+\)/g, message: 'Missing closing ] bracket in image description' },  // ![desc(0) - no ] before (
                { regex: /!([a-zA-Z][^\[\]\n]{0,100})\]\(\d+\)/g, message: 'Missing opening [ bracket in image description' },  // !desc](0) - starts with letter, no [ after !
                { regex: /!\[([^\]]*?)\]\d+\)/g, message: 'Missing opening ( parenthesis in image index' },  // ![desc]0) - digit directly after ]
                { regex: /!\[([^\]]*?)\]\(\d+[^\)\s]/g, message: 'Missing closing ) parenthesis in image index or extra characters' },  // ![desc](0X - digit followed by non-) non-space
                { regex: /!\[([^\]]*?)\]\(\d+$/gm, message: 'Missing closing ) parenthesis in image index' },  // ![desc](0 - ends without )
                // Missing ! at the beginning - matches [desc](digit) that looks like it should be an image
                { regex: /(?<![!\w])\[([^\]]{1,100})\]\(\d+\)/g, message: 'Missing ! at the beginning of image syntax' }  // [desc](0) - no ! before [
            ];
            
            malformedPatterns.forEach(pattern => {
                const matches = md.match(pattern.regex);
                if (matches) {
                    matches.forEach(match => {
                        errors.push({
                            type: 'malformed_image_syntax',
                            message: `${pattern.message}: "${match.substring(0, 50)}${match.length > 50 ? '...' : ''}"`,
                            match: match
                        });
                    });
                }
            });
            
            // Check for newlines in image descriptions BEFORE restoring LaTeX
            // This prevents false positives from LaTeX commands like \neq or \right(
            // We check while LaTeX is still protected as placeholders
            const imageMatchesBeforeRestore = md.match(/!\[([\s\S]*?)\]\(\d+\)/g);
            if (imageMatchesBeforeRestore) {
                imageMatchesBeforeRestore.forEach(match => {
                    // Extract the description part
                    const descMatch = match.match(/!\[([\s\S]*?)\]\(/);
                    if (descMatch && descMatch[1]) {
                        let description = descMatch[1];
                        
                        // Temporarily restore LaTeX to check the full description
                        // Then remove LaTeX expressions to check for newlines outside of LaTeX
                        latexPlaceholders.forEach((latex, idx) => {
                            description = description.replace(`@@LATEX_INLINE_IMG_${idx}@@`, latex);
                        });
                        
                        // Check for block LaTeX ($$\n...\n$$) in image description - not allowed
                        if (description.includes('$$')) {
                            // Extract the index
                            const indexMatch = match.match(/\]\((\d+)\)/);
                            const index = indexMatch ? indexMatch[1] : '?';
                            errors.push({
                                type: 'block_latex_in_description',
                                message: `Block LaTeX ($$\\n...\\n$$) is not allowed in image descriptions. Use inline LaTeX ($...$) instead (image index: ${index})`,
                                description: description,
                                index: index
                            });
                        }
                        
                        // Remove all LaTeX expressions (inline and block) before checking for newlines
                        // This ensures LaTeX commands like \neq or \right( don't trigger false positives
                        const descriptionWithoutMath = removeMathExpressions(description);
                        
                        // Check if description contains newlines (both literal \n and actual newlines)
                        // Only check the parts outside of LaTeX expressions
                        if (descriptionWithoutMath.includes('\n') || descriptionWithoutMath.includes('\r') || descriptionWithoutMath.includes('\\n') || descriptionWithoutMath.includes('\\r')) {
                            // Extract the index
                            const indexMatch = match.match(/\]\((\d+)\)/);
                            const index = indexMatch ? indexMatch[1] : '?';
                            errors.push({
                                type: 'newline_in_description',
                                message: `Image description cannot contain newline characters (image index: ${index})`,
                                description: description,
                                index: index
                            });
                        }
                    }
                });
            }
            
            // Restore LaTeX math expressions after validation (for any remaining processing)
            latexPlaceholders.forEach((latex, idx) => {
                md = md.replace(`@@LATEX_INLINE_IMG_${idx}@@`, latex);
            });
            
            return errors;
        }

        /**
         * Validate that blanks (___i___) are not written inside LaTeX expressions
         * @param {string} content - The text to check
         * @returns {Array} Array of error objects
         */
        function validateBlanksInLatex(content) {
            const errors = [];
            if (!content || content.trim().length === 0) {
                return errors; // Skip empty content
            }
            
            // Pattern to match blanks: ___1___, ___2___, etc.
            const blankPattern = /___(\d+)___/g;
            
            // Find all LaTeX expressions (both inline $...$ and block $$...$$)
            // First, find block LaTeX ($$...$$) - handle both formats
            const blockLatexPattern = /\$\$[\s\S]*?\$\$/g;
            const blockRanges = [];
            let blockMatch;
            blockLatexPattern.lastIndex = 0;
            
            // Process block LaTeX and track their positions
            while ((blockMatch = blockLatexPattern.exec(content)) !== null) {
                const match = blockMatch[0];
                const startPos = blockMatch.index;
                const endPos = startPos + match.length;
                
                // Track this block LaTeX range
                blockRanges.push({ start: startPos, end: endPos });
                
                // Check if this block LaTeX contains any blanks
                const blankMatches = match.match(blankPattern);
                if (blankMatches) {
                    // Extract the content inside the LaTeX (without the $$ delimiters)
                    const innerContent = match.replace(/^\$\$/, '').replace(/\$\$$/, '');
                    blankMatches.forEach(blankMatch => {
                        errors.push({
                            type: 'blank_in_latex',
                            message: `Blank ${blankMatch} cannot be written inside LaTeX. Blanks should be outside LaTeX expressions.`,
                            content: innerContent,
                            blank: blankMatch
                        });
                    });
                }
            }
            
            // Find all inline LaTeX expressions
            const inlineLatexPattern = /\$[^$\n]*?\$/g;
            let inlineMatch;
            inlineLatexPattern.lastIndex = 0;
            
            while ((inlineMatch = inlineLatexPattern.exec(content)) !== null) {
                const match = inlineMatch[0];
                const startPos = inlineMatch.index;
                const endPos = startPos + match.length;
                
                // Check if this inline LaTeX is inside a block LaTeX
                const isInsideBlock = blockRanges.some(range => 
                    startPos >= range.start && endPos <= range.end
                );
                
                if (!isInsideBlock) {
                    // This is a genuine inline LaTeX expression
                    // Check if it contains any blanks
                    const blankMatches = match.match(blankPattern);
                    if (blankMatches) {
                        // Extract the content inside the LaTeX (without the $ delimiters)
                        const innerContent = match.replace(/^\$/, '').replace(/\$$/, '');
                        blankMatches.forEach(blankMatch => {
                            errors.push({
                                type: 'blank_in_latex',
                                message: `Blank ${blankMatch} cannot be written inside LaTeX. Blanks should be outside LaTeX expressions.`,
                                content: innerContent,
                                blank: blankMatch
                            });
                        });
                    }
                }
            }
            
            return errors;
        }

        function validateBlockLatex(content) {
            const errors = [];
            if (!content || content.trim().length === 0) {
                return errors; // Skip empty content
            }
            
            let md = content.replace(/\r\n?/g, '\n');
            
            // Only check for block LaTeX if there are $$ patterns
            if (!md.includes('$$')) {
                return errors; // No block LaTeX to validate
            }
            
            // Check for old format $$...$$ (without newlines) and show error
            const oldFormatMatches = md.match(/\$\$([\s\S]*?)\$\$/g);
            if (oldFormatMatches) {
                oldFormatMatches.forEach(match => {
                    // Skip if this is already a valid newline format
                    if (!match.match(/^\$\$\s*\\n[\s\S]*?\\n\s*\$\$$/)) {
                        // Make sure this is actually block LaTeX (not just $$ in text)
                        const inner = match.replace(/^\$\$/, '').replace(/\$\$$/, '');
                        if (inner.trim().length > 0) { // Only error if there's actual content
                            errors.push({
                                type: 'incorrect_delimiters',
                                message: 'Block latex must use newline delimiters: $$\\n...\\n$$ or $$ \\n...\\n $$',
                                content: inner
                            });
                        }
                    }
                });
            }
            
            // Check for valid format with extra newlines
            const validFormatMatches = md.match(/\$\$\s*\\n([\s\S]*?)\\n\s*\$\$/g);
            if (validFormatMatches) {
                validFormatMatches.forEach(match => {
                    const innerMatch = match.match(/\$\$\s*\\n([\s\S]*?)\\n\s*\$\$/);
                    if (innerMatch) {
                        const inner = innerMatch[1];
                        // Check for extra newlines inside the content
                        if (inner.includes('\\n') || inner.includes('\n')) {
                            errors.push({
                                type: 'extra_newlines',
                                message: 'Block latex cannot contain extra newline characters inside the content',
                                content: inner
                            });
                        }
                        // Check for empty content
                        if (inner.trim().length === 0) {
                            errors.push({
                                type: 'empty_content',
                                message: 'Block latex cannot be empty',
                                content: inner
                            });
                        }
                    }
                });
            }
            
            return errors;
        }

        // Validate <br> tags in content
        function validateBrTags(content) {
            const errors = [];
            if (!content || content.trim().length === 0) {
                return errors; // Skip empty content
            }
            
            // Check for <br> tags (case insensitive, with or without closing tag)
            const brPattern = /<br\s*\/?>/gi;
            const matches = content.match(brPattern);
            if (matches && matches.length > 0) {
                errors.push({
                    type: 'br_tag',
                    message: `<br> tags are not allowed in the content. Found ${matches.length} occurrence(s).`
                });
            }
            
            return errors;
        }

        // Validate unmatched quotes that would break JSON
        function validateQuotes(content) {
            const errors = [];
            if (!content || content.trim().length === 0) {
                return errors; // Skip empty content
            }
            
            // Count unescaped double quotes - if odd number, they are unmatched
            const unescapedQuotes = (content.match(/(?<!\\)"/g) || []).length;
            if (unescapedQuotes > 0 && unescapedQuotes % 2 !== 0) {
                errors.push({
                    type: 'unmatched_quotes',
                    message: `Text contains ${unescapedQuotes} double quote(s) that are not properly matched. Each quote must have a matching pair - remove the extra or add the missing one.`
                });
            }
            
            return errors;
        }
        
        function validateDollarSigns(content) {
            const errors = [];
            if (!content || content.trim().length === 0) {
                return errors; // Skip empty content
            }
            
            // Count unescaped dollar signs - if odd number, they are unmatched
            const unescapedDollars = (content.match(/(?<!\\)\$/g) || []).length;
            if (unescapedDollars > 0 && unescapedDollars % 2 !== 0) {
                errors.push({
                    type: 'unmatched_dollar_signs',
                    message: `Text contains ${unescapedDollars} dollar sign(s) that are not properly matched. Each $ should have a matching pair for LaTeX math. Please review and correct if needed.`
                });
            }
            
            return errors;
        }
        
        // Get a descriptive location for a textarea element
        function getTextareaLocation(textarea) {
            // Check if textarea is in content sections container
            if (textarea.closest('#content_sections_container')) {
                // Find which main content section this textarea belongs to
                const contentSections = document.querySelectorAll('#content_sections_container > .array-item');
                for (let i = 0; i < contentSections.length; i++) {
                    if (contentSections[i].contains(textarea)) {
                        return `Content Section ${i + 1}`;
                    }
                }
            }
            
            // Check if textarea is in questions container
            if (textarea.closest('#questions_container')) {
                // Find which main question this textarea belongs to
                const questions = document.querySelectorAll('#questions_container > .array-item');
                for (let i = 0; i < questions.length; i++) {
                    if (questions[i].contains(textarea)) {
                        return `Question ${i + 1}`;
                    }
                }
            }
            
            // Check for specific form fields
            const textareaId = textarea.id;
            if (textareaId) {
                switch (textareaId) {
                    case 'lesson_preamble':
                        return 'Lesson Preamble';
                    default:
                        return `Field "${textareaId}"`;
                }
            }
            
            // Check for label text
            const label = textarea.previousElementSibling?.textContent?.trim();
            if (label && label.length > 0 && label.length < 50) {
                return label.replace(':', '').trim();
            }
            
            // Check parent container for clues
            const parent = textarea.closest('.form-group, .array-item, .form-section');
            if (parent) {
                const parentLabel = parent.querySelector('label')?.textContent?.trim();
                if (parentLabel) {
                    return parentLabel.replace(':', '').trim();
                }
            }
            
            return 'Unknown Location';
        }

        function generateJSON() {
            // If PDF viewer is active, switch to JSON preview
            const pdfBtn = document.getElementById('toggle-pdf-btn');
            if (pdfBtn && pdfBtn.classList.contains('active')) {
                showJsonPreview();
            }
            
            // Validate basic form data
            const textbookPage = document.getElementById('textbook_page').value;
            const textbookPdfPage = document.getElementById('textbook_pdf_page').value;
            const guidebookStart = document.getElementById('guidebook_start_page').value;
            const guidebookEnd = document.getElementById('guidebook_end_page').value;
            const pageType = document.getElementById('page_type').value;
            
            // Validation
            const validationErrors = [];
            const validationWarnings = [];
            
            if (!textbookPage) {
                validationErrors.push("Textbook page is required");
            } else if (!Number.isInteger(parseFloat(textbookPage))) {
                validationErrors.push("Textbook page must be a whole number");
            }
            if (!textbookPdfPage) {
                validationErrors.push("Textbook PDF page is required");
            } else if (!Number.isInteger(parseFloat(textbookPdfPage))) {
                validationErrors.push("Textbook PDF page must be a whole number");
            }
            if (!guidebookStart) {
                validationErrors.push("Guidebook start page is required");
            } else if (!Number.isInteger(parseFloat(guidebookStart))) {
                validationErrors.push("Guidebook start page must be a whole number");
            }
            if (!guidebookEnd) {
                validationErrors.push("Guidebook end page is required");
            } else if (!Number.isInteger(parseFloat(guidebookEnd))) {
                validationErrors.push("Guidebook end page must be a whole number");
            }
            if (guidebookStart && guidebookEnd && parseInt(guidebookStart) > parseInt(guidebookEnd)) {
                validationErrors.push("Guidebook start page cannot be greater than end page");
            }
            if (!pageType || pageType.trim().length === 0) {
                validationErrors.push("Page type is required");
            }
            
            // Validate no duplicate question IDs
            const questionIds = new Map(); // Map to track question IDs and their locations
            const questionContainers = document.querySelectorAll('#questions_container > .array-item');
            questionContainers.forEach((questionEl, index) => {
                const questionIdInput = findFieldByLabel(questionEl, 'Question ID', 'input');
                if (questionIdInput && questionIdInput.value && questionIdInput.value.trim()) {
                    const qid = questionIdInput.value.trim();
                    if (questionIds.has(qid)) {
                        const firstLocation = questionIds.get(qid);
                        validationErrors.push(`Duplicate Question ID "${qid}" found in Question ${index + 1} (also in Question ${firstLocation})`);
                    } else {
                        questionIds.set(qid, index + 1);
                    }
                }
            });
            
            // Validate block LaTeX in all content sections and questions (exclude output fields)
            const allTextareas = document.querySelectorAll('textarea');
            allTextareas.forEach((textarea, index) => {
                // Skip validation for output/display fields
                const textareaId = textarea.id;
                if (textareaId === 'json_input' || textareaId === 'json_output' || 
                    textarea.classList.contains('output-field') || 
                    textarea.hasAttribute('readonly')) {
                    return; // Skip this textarea
                }
                
                const content = textarea.value || '';
                const mathBlockErrors = validateBlockLatex(content);
                if (mathBlockErrors.length > 0) {
                    const location = getTextareaLocation(textarea);
                    mathBlockErrors.forEach(error => {
                        validationErrors.push(`Block LaTeX Error in ${location}: ${error.message}`);
                    });
                }
                
                // Validate blanks in LaTeX
                const blanksInLatexErrors = validateBlanksInLatex(content);
                if (blanksInLatexErrors.length > 0) {
                    const location = getTextareaLocation(textarea);
                    blanksInLatexErrors.forEach(error => {
                        validationErrors.push(`Blank in LaTeX Error in ${location}: ${error.message}`);
                    });
                }
                
                const imageDescErrors = validateImageDescriptions(content);
                if (imageDescErrors.length > 0) {
                    const location = getTextareaLocation(textarea);
                    imageDescErrors.forEach(error => {
                        validationErrors.push(`Image Description Error in ${location}: ${error.message}`);
                    });
                }
                
                const quoteErrors = validateQuotes(content);
                if (quoteErrors.length > 0) {
                    const location = getTextareaLocation(textarea);
                    quoteErrors.forEach(error => {
                        validationErrors.push(`Quote Error in ${location}: ${error.message}`);
                    });
                }
                
                const dollarErrors = validateDollarSigns(content);
                if (dollarErrors.length > 0) {
                    const location = getTextareaLocation(textarea);
                    dollarErrors.forEach(error => {
                        validationWarnings.push(`Dollar Sign Warning in ${location}: ${error.message}`);
                    });
                }
                
                // Validate <br> tags
                const brErrors = validateBrTags(content);
                if (brErrors.length > 0) {
                    const location = getTextareaLocation(textarea);
                    brErrors.forEach(error => {
                        validationErrors.push(`HTML Tag Error in ${location}: ${error.message}`);
                    });
                }
                
                // Validate table markdown
                const tableValidation = validateTableMarkdown(content);
                if (tableValidation.hasTables && !tableValidation.valid && tableValidation.errors.length > 0) {
                    const location = getTextareaLocation(textarea);
                    tableValidation.errors.forEach(error => {
                        const errorMsg = typeof error === 'string' ? error : error.message;
                        validationErrors.push(`Table Markdown Error in ${location}: ${errorMsg}`);
                    });
                }
                
                // Validate list markdown
                const listValidation = validateListMarkdown(content);
                if (listValidation.hasLists && !listValidation.valid && listValidation.errors.length > 0) {
                    const location = getTextareaLocation(textarea);
                    listValidation.errors.forEach(error => {
                        const errorMsg = typeof error === 'string' ? error : error.message;
                        validationErrors.push(`List Markdown Error in ${location}: ${errorMsg}`);
                    });
                }
                
                // Validate blockquote markdown
                const blockquoteValidation = validateBlockquoteMarkdown(content);
                if (blockquoteValidation.hasBlockquotes && !blockquoteValidation.valid && blockquoteValidation.errors.length > 0) {
                    const location = getTextareaLocation(textarea);
                    blockquoteValidation.errors.forEach(error => {
                        const errorMsg = typeof error === 'string' ? error : error.message;
                        validationErrors.push(`Blockquote Markdown Error in ${location}: ${errorMsg}`);
                    });
                }
            });
            
            if (validationErrors.length > 0) {
                // Track validation errors
                const errorCategories = categorizeValidationErrors(validationErrors);
                trackEvent('validation_errors', {
                    total_errors: validationErrors.length,
                    error_type_required_field: errorCategories.required_field,
                    error_type_block_latex: errorCategories.block_latex,
                    error_type_image_description: errorCategories.image_description,
                    error_type_quote_error: errorCategories.quote_error,
                    error_type_dollar_sign: errorCategories.dollar_sign,
                    error_type_table_markdown: errorCategories.table_markdown,
                    error_type_list_markdown: errorCategories.list_markdown,
                    error_type_blockquote_markdown: errorCategories.blockquote_markdown,
                    error_type_html_tag: errorCategories.html_tag,
                    error_type_image_reference: errorCategories.image_reference,
                    error_type_image_mismatch: errorCategories.image_mismatch,
                    error_type_image_numbering: errorCategories.image_numbering,
                    error_type_question_id: errorCategories.question_id,
                    error_type_question_text: errorCategories.question_text,
                    error_type_guide_answer: errorCategories.guide_answer,
                    error_type_guide_pdf_page: errorCategories.guide_pdf_page,
                    error_type_blank_format: errorCategories.blank_format,
                    error_type_matching_format: errorCategories.matching_format,
                    error_type_choice_format: errorCategories.choice_format,
                    error_type_duplicate_id: errorCategories.duplicate_id,
                    error_type_other: errorCategories.other,
                    validation_context: 'json_generation'
                });
                
                alert("Validation errors:\n" + validationErrors.join("\n"));
                return;
            }
            
            // Collect form data and generate JSON
            const jsonData = {
                textbook_page: textbookPage ? parseInt(textbookPage) : null,
                textbook_pdf_page: textbookPdfPage ? parseInt(textbookPdfPage) : null,
                guidebook_pdf_pages: generateGuidebookPageArray(),
                page_type: document.getElementById('page_type').value || "content",
                lesson_preamble: null,
                instructional_content: [],
                practice_questions: []
            };

            // Collect content sections - only get the main content sections (direct children)
            const contentElements = document.querySelectorAll('#content_sections_container > .array-item');
            contentElements.forEach((contentEl, index) => {
                try {
                    const contentData = collectContentData(contentEl);
                    
                    // Warn if section title is empty
                    if (!contentData.section_title) {
                        validationWarnings.push(ErrorMessages.warningSectionTitle(index));
                    }
                    
                    // Require content text
                    if (!contentData.text || /^\d+$/.test(contentData.text)) {
                        validationErrors.push(ErrorMessages.requiredContent(index));
                    } else {
                        jsonData.instructional_content.push(contentData);
                    }
                } catch (error) {
                    validationErrors.push(`Content Section ${index + 1}: ${error.message}`);
                }
            });

            // Add lesson preamble if provided
            const lessonId = document.getElementById('lesson_id').value;
            if (lessonId) {
                // Validate lesson ID is a string
                if (typeof lessonId !== 'string' || lessonId.trim().length === 0) {
                    validationErrors.push("Lesson ID must be a non-empty string");
                }
                
                if (validationErrors.length > 0) {
                    alert("Validation errors:\n" + validationErrors.join("\n"));
                    return;
                }
                
                jsonData.lesson_preamble = {
                    id: lessonId.trim(),
                    title: document.getElementById('lesson_title').value || "",
                    lesson_standards: Array.from(document.querySelectorAll('#lesson_standards input')).map(input => input.value).filter(v => v),
                    terminology: Array.from(document.querySelectorAll('#terminology input')).map(input => input.value).filter(v => v),
                    text: document.getElementById('lesson_text').value || ""
                };
            }

            // Collect questions - only get the main questions (direct children)
            const questionElements = document.querySelectorAll('#questions_container > .array-item');
            questionElements.forEach((questionEl, index) => {
                try {
                    const questionData = collectQuestionData(questionEl);
                    
                    // Enforce required fields for each question
                    if (!questionData.id) {
                        validationErrors.push(ErrorMessages.requiredQuestionID(index));
                    }
                    
                    // Validate annotate and create_table types
                    if (questionData.question_type === 'annotate' || questionData.question_type === 'create_table') {
                        // Validate required fields
                        if (!questionData.question_text || /^\d+$/.test(questionData.question_text)) {
                            validationErrors.push(ErrorMessages.requiredQuestionText(index));
                        }
                        
                        // Validate guide answer is required for these types
                        if (!questionData.guide_answer || questionData.guide_answer.trim().length === 0) {
                            validationErrors.push(`Question ${index + 1}: Guide Answer is required for ${questionData.question_type === 'annotate' ? 'annotate' : 'create_table'} question type`);
                        }
                        
                        // Validate guide PDF page
                        if (!questionData.guide_pdf_page) {
                            validationErrors.push(ErrorMessages.requiredGuidePage(index));
                        } else if (isNaN(questionData.guide_pdf_page) || !Number.isInteger(questionData.guide_pdf_page) || questionData.guide_pdf_page <= 0) {
                            validationErrors.push(ErrorMessages.invalidGuidePage(index));
                        } else {
                            // Validate guide PDF page is within guidebook range
                            const gbStart = parseInt(guidebookStart, 10);
                            const gbEnd = parseInt(guidebookEnd, 10);
                            if (!isNaN(gbStart) && !isNaN(gbEnd) && gbStart > 0 && gbEnd > 0) {
                                if (questionData.guide_pdf_page < gbStart || questionData.guide_pdf_page > gbEnd) {
                                    validationErrors.push(ErrorMessages.guidePageOutOfRange(index, questionData.guide_pdf_page, gbStart, gbEnd));
                                }
                            }
                        }
                    } else if (questionData.question_type === 'fill_in_the_blanks') {
                        // Fill in the blanks validation
                        if (!questionData.question_text || /^\d+$/.test(questionData.question_text)) {
                            validationErrors.push(ErrorMessages.requiredQuestionText(index));
                        } else {
                            // Validate blank format
                            const { valid, errors, blanks } = validateBlankFormat(questionData.question_text);
                            
                            if (blanks.length === 0) {
                                validationErrors.push(ErrorMessages.noBlanksFound(index));
                            } else if (!valid) {
                                errors.forEach(err => {
                                    validationErrors.push(ErrorMessages.invalidBlankFormat(index, err));
                                });
                            }
                            
                            // Validate values array
                            if (!questionData.values || !Array.isArray(questionData.values)) {
                                validationErrors.push(ErrorMessages.blankAnswerMismatch(index, blanks.length, 0));
                            } else {
                                // Check count matches
                                if (questionData.values.length !== blanks.length) {
                                    validationErrors.push(ErrorMessages.blankAnswerMismatch(index, blanks.length, questionData.values.length));
                                }
                                
                                // Check for empty answers
                                const emptyBlanks = [];
                                questionData.values.forEach((answer, idx) => {
                                    if (!answer || answer.trim() === '') {
                                        emptyBlanks.push(`___${blanks[idx]}___`);
                                    }
                                });
                                if (emptyBlanks.length > 0) {
                                    validationErrors.push(ErrorMessages.missingBlankAnswers(index, emptyBlanks));
                                }
                            }
                        }
                        
                        // Validate guide PDF page
                        if (!questionData.guide_pdf_page) {
                            validationErrors.push(ErrorMessages.requiredGuidePage(index));
                        } else if (isNaN(questionData.guide_pdf_page) || !Number.isInteger(questionData.guide_pdf_page) || questionData.guide_pdf_page <= 0) {
                            validationErrors.push(ErrorMessages.invalidGuidePage(index));
                        } else {
                            // Validate guide PDF page is within guidebook range
                            const gbStart = parseInt(guidebookStart, 10);
                            const gbEnd = parseInt(guidebookEnd, 10);
                            if (!isNaN(gbStart) && !isNaN(gbEnd) && gbStart > 0 && gbEnd > 0) {
                                if (questionData.guide_pdf_page < gbStart || questionData.guide_pdf_page > gbEnd) {
                                    validationErrors.push(ErrorMessages.guidePageOutOfRange(index, questionData.guide_pdf_page, gbStart, gbEnd));
                                }
                            }
                        }
                    } else if (questionData.question_type === 'matching') {
                        // Matching validation
                        if (!questionData.question_text || /^\d+$/.test(questionData.question_text)) {
                            validationErrors.push(ErrorMessages.requiredQuestionText(index));
                        }
                        
                        // Validate left items
                        if (!questionData.left || questionData.left.length === 0) {
                            validationErrors.push(ErrorMessages.matchingNoLeftItems(index));
                        } else {
                            questionData.left.forEach((item, itemIdx) => {
                                if (!item || item.trim() === '') {
                                    validationErrors.push(ErrorMessages.matchingEmptyLeftItem(index, itemIdx + 1));
                                }
                            });
                        }
                        
                        // Validate right items
                        if (!questionData.right || questionData.right.length === 0) {
                            validationErrors.push(ErrorMessages.matchingNoRightItems(index));
                        } else {
                            questionData.right.forEach((item, itemIdx) => {
                                if (!item || item.trim() === '') {
                                    validationErrors.push(ErrorMessages.matchingEmptyRightItem(index, itemIdx + 1));
                                }
                            });
                        }
                        
                        // Validate relationships
                        if (questionData.relationship && Array.isArray(questionData.relationship)) {
                            questionData.relationship.forEach((rel, relIdx) => {
                                if (!Array.isArray(rel) || rel.length !== 2) {
                                    validationErrors.push(ErrorMessages.matchingIncompleteRelationship(index, relIdx + 1));
                                } else {
                                    const [leftIdx, rightIdx] = rel;
                                    const leftCount = questionData.left ? questionData.left.length : 0;
                                    const rightCount = questionData.right ? questionData.right.length : 0;
                                    
                                    if (!leftIdx || !rightIdx) {
                                        validationErrors.push(ErrorMessages.matchingIncompleteRelationship(index, relIdx + 1));
                                    } else if (leftIdx < 1 || leftIdx > leftCount || rightIdx < 1 || rightIdx > rightCount) {
                                        validationErrors.push(ErrorMessages.matchingInvalidRelationship(index, leftIdx, rightIdx, leftCount, rightCount));
                                    }
                                }
                            });
                        }
                        
                        // Validate guide PDF page
                        if (!questionData.guide_pdf_page) {
                            validationErrors.push(ErrorMessages.requiredGuidePage(index));
                        } else if (isNaN(questionData.guide_pdf_page) || !Number.isInteger(questionData.guide_pdf_page) || questionData.guide_pdf_page <= 0) {
                            validationErrors.push(ErrorMessages.invalidGuidePage(index));
                        } else {
                            // Validate guide PDF page is within guidebook range
                            const gbStart = parseInt(guidebookStart, 10);
                            const gbEnd = parseInt(guidebookEnd, 10);
                            if (!isNaN(gbStart) && !isNaN(gbEnd) && gbStart > 0 && gbEnd > 0) {
                                if (questionData.guide_pdf_page < gbStart || questionData.guide_pdf_page > gbEnd) {
                                    validationErrors.push(ErrorMessages.guidePageOutOfRange(index, questionData.guide_pdf_page, gbStart, gbEnd));
                                }
                            }
                        }
                    } else {
                        // Validate other fields for all other types
                        if (!questionData.question_text || /^\d+$/.test(questionData.question_text)) {
                            validationErrors.push(ErrorMessages.requiredQuestionText(index));
                        }
                        
                        if (questionData.question_type === 'multiple_choice') {
                            // Multiple choice validation
                            if (!questionData.choices || questionData.choices.length === 0) {
                                validationErrors.push(ErrorMessages.requiredChoices(index));
                            } else {
                                // Validate choice IDs consistency (all filled or all empty)
                                const choicesWithIDs = questionData.choices.filter(c => c.id && c.id.trim() !== '');
                                if (choicesWithIDs.length > 0 && choicesWithIDs.length < questionData.choices.length) {
                                    validationErrors.push(ErrorMessages.inconsistentChoiceIDs(index, 'multiple_choice'));
                            }
                            }
                            // Validate value field (1-indexed position)
                            if (!questionData.value || typeof questionData.value !== 'number') {
                                validationErrors.push(ErrorMessages.requiredCorrectAnswer(index));
                            } else if (questionData.value < 1 || questionData.value > questionData.choices.length) {
                                validationErrors.push(`Question ${index + 1} (Multiple Choice) - Problem: Selected answer position (${questionData.value}) is out of range. You have ${questionData.choices.length} choices.\n    Fix: Select a valid answer position.`);
                            }
                            // guide_answer is now optional (for notes)
                        } else if (questionData.question_type === 'checkbox') {
                            // Checkbox validation
                            if (!questionData.choices || questionData.choices.length === 0) {
                                validationErrors.push(ErrorMessages.requiredCheckboxChoices(index));
                            } else {
                                // Validate choice IDs consistency (all filled or all empty)
                                const choicesWithIDs = questionData.choices.filter(c => c.id && c.id.trim() !== '');
                                if (choicesWithIDs.length > 0 && choicesWithIDs.length < questionData.choices.length) {
                                    validationErrors.push(ErrorMessages.inconsistentChoiceIDs(index, 'checkbox'));
                                }
                                
                                // Validate values array
                                if (!questionData.values || !Array.isArray(questionData.values)) {
                                    validationErrors.push(ErrorMessages.requiredCheckedChoice(index));
                                } else if (questionData.values.length !== questionData.choices.length) {
                                    validationErrors.push(`Question ${index + 1} (Checkbox) - Problem: Mismatch between number of choices (${questionData.choices.length}) and values array (${questionData.values.length}).\n    Fix: Make sure each choice has a corresponding correct/incorrect value.`);
                                } else if (!questionData.values.some(v => v === true)) {
                                    validationErrors.push(ErrorMessages.requiredCheckedChoice(index));
                                }
                            }
                            // guide_answer is now optional (for notes)
                        } else {
                            // Free form - validate guide answer
                            if (!questionData.guide_answer) {
                                validationErrors.push(ErrorMessages.requiredAnswer(index));
                            }
                        }
                        
                        // Validate guide PDF page is an integer
                        if (!questionData.guide_pdf_page) {
                            validationErrors.push(ErrorMessages.requiredGuidePage(index));
                        } else if (isNaN(questionData.guide_pdf_page) || !Number.isInteger(questionData.guide_pdf_page) || questionData.guide_pdf_page <= 0) {
                            validationErrors.push(ErrorMessages.invalidGuidePage(index));
                        } else {
                            // Validate guide PDF page is within guidebook range
                            const gbStart = parseInt(guidebookStart, 10);
                            const gbEnd = parseInt(guidebookEnd, 10);
                            if (!isNaN(gbStart) && !isNaN(gbEnd) && gbStart > 0 && gbEnd > 0) {
                                if (questionData.guide_pdf_page < gbStart || questionData.guide_pdf_page > gbEnd) {
                                    validationErrors.push(ErrorMessages.guidePageOutOfRange(index, questionData.guide_pdf_page, gbStart, gbEnd));
                                }
                            }
                        }
                    }
                    
                    // Only add question if no validation errors for this question
                    if (!validationErrors.some(e => e.startsWith(`Question ${index + 1}:`)) && 
                        !validationErrors.some(e => e.includes(`Question ${index + 1}`))) {
                        jsonData.practice_questions.push(questionData);
                    }
                } catch (error) {
                    validationErrors.push(`Question ${index + 1}: ${error.message}`);
                }
            });

            
            // Validate image consistency (duplicate indices and mismatched counts)
            // NOTE: This comprehensive check covers both missing references and unused bboxes
            // Removed validateImageReferences() and validateImageBboxes() to prevent duplicate error messages
            const imageConsistencyErrors = validateImageConsistency(jsonData);
            if (imageConsistencyErrors.length > 0) {
                validationErrors.push(...imageConsistencyErrors);
            }
            
            // Validate image index ordering (must start from 0 and be sequential)
            const imageOrderingErrors = validateImageOrdering(jsonData);
            if (imageOrderingErrors.length > 0) {
                validationErrors.push(...imageOrderingErrors);
            }
            
            // Final validation check - errors block, warnings just inform
            if (validationErrors.length > 0) {
                alert("Validation errors found:\n" + validationErrors.join("\n"));
                return;
            }
            
            // Show warnings if any (but don't block generation)
            if (validationWarnings.length > 0) {
                alert("Validation warnings:\n" + validationWarnings.join("\n"));
            }
            
            // Display formatted JSON
            const jsonOutput = document.getElementById('json_output');
            jsonOutput.innerHTML = formatJSON(jsonData);
            jsonOutput.setAttribute('data-raw-json', JSON.stringify(jsonData));
            
            // Track session duration on JSON generation
            trackSessionDuration('json_generation');
            
            // Track JSON generation with detailed statistics
            const stats = getFormStats();
            const jsonString = JSON.stringify(jsonData);
            
            // Calculate section sizes from generated data
            const contentSizes = jsonData.instructional_content.map(c => 
                ((c.section_title || '') + (c.text || '')).length
            );
            const questionSizes = jsonData.practice_questions.map(q => {
                let size = (q.question_text || '').length + (q.set_up_text || '').length;
                if (q.guide_answer) size += q.guide_answer.length;
                if (q.choices) {
                    size += q.choices.reduce((sum, c) => sum + (c.text || '').length, 0);
                }
                return size;
            });
            
            trackEvent('json_generated', {
                total_questions: stats.totalQuestions,
                total_content_sections: stats.totalContentSections,
                question_type_free_form: stats.questionTypes.free_form || 0,
                question_type_multiple_choice: stats.questionTypes.multiple_choice || 0,
                question_type_checkbox: stats.questionTypes.checkbox || 0,
                question_type_fill_in_the_blanks: stats.questionTypes.fill_in_the_blanks || 0,
                question_type_matching: stats.questionTypes.matching || 0,
                question_type_annotate: stats.questionTypes.annotate || 0,
                question_type_create_table: stats.questionTypes.create_table || 0,
                avg_question_size: stats.avgQuestionSize,
                avg_content_section_size: stats.avgContentSectionSize,
                total_question_size: stats.totalQuestionSize,
                total_content_section_size: stats.totalContentSectionSize,
                min_content_section_size: contentSizes.length > 0 ? Math.min(...contentSizes) : 0,
                max_content_section_size: contentSizes.length > 0 ? Math.max(...contentSizes) : 0,
                min_question_size: questionSizes.length > 0 ? Math.min(...questionSizes) : 0,
                max_question_size: questionSizes.length > 0 ? Math.max(...questionSizes) : 0,
                json_length: jsonString.length,
                has_lesson_preamble: !!jsonData.lesson_preamble,
                validation_warnings_count: validationWarnings.length
            });
            
        }
        
        // Collect form data without validation (for undo/redo purposes)
        function collectFormDataWithoutValidation() {
            const textbookPage = document.getElementById('textbook_page').value;
            const textbookPdfPage = document.getElementById('textbook_pdf_page').value;
            const guidebookStart = document.getElementById('guidebook_start_page').value;
            const guidebookEnd = document.getElementById('guidebook_end_page').value;
            const pageType = document.getElementById('page_type').value;
            
            // Collect form data and generate JSON (without validation)
            const jsonData = {
                textbook_page: textbookPage ? parseInt(textbookPage) : null,
                textbook_pdf_page: textbookPdfPage ? parseInt(textbookPdfPage) : null,
                guidebook_pdf_pages: generateGuidebookPageArray(),
                page_type: pageType || "content",
                lesson_preamble: null,
                instructional_content: [],
                practice_questions: []
            };

            // Collect content sections - only get the main content sections (direct children)
            const contentElements = document.querySelectorAll('#content_sections_container > .array-item');
            contentElements.forEach((contentEl) => {
                try {
                    const contentData = collectContentData(contentEl);
                    jsonData.instructional_content.push(contentData);
                } catch (error) {
                    // Skip sections that fail to collect
                    console.warn('Failed to collect content section:', error);
                }
            });

            // Add lesson preamble if provided
            const lessonId = document.getElementById('lesson_id').value;
            if (lessonId) {
                jsonData.lesson_preamble = {
                    id: lessonId.trim(),
                    title: document.getElementById('lesson_title').value || "",
                    lesson_standards: Array.from(document.querySelectorAll('#lesson_standards input')).map(input => input.value).filter(v => v),
                    terminology: Array.from(document.querySelectorAll('#terminology input')).map(input => input.value).filter(v => v),
                    text: document.getElementById('lesson_text').value || ""
                };
            }

            // Collect questions - only get the main questions (direct children)
            const questionElements = document.querySelectorAll('#questions_container > .array-item');
            questionElements.forEach((questionEl) => {
                try {
                    const questionData = collectQuestionData(questionEl);
                    jsonData.practice_questions.push(questionData);
                } catch (error) {
                    // Skip questions that fail to collect
                    console.warn('Failed to collect question:', error);
                }
            });
            
            return jsonData;
        }

        // Helper function to escape HTML special characters
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        /**
         * Format JSON with arrays on one line
         * @param {*} obj - The object to format
         * @param {number} indent - Current indentation level
         * @returns {string} Formatted JSON string
         */
        function formatJSONWithCompactArrays(obj, indent = 0) {
            const indentStr = '  '.repeat(indent);
            const nextIndentStr = '  '.repeat(indent + 1);
            
            if (obj === null) return 'null';
            if (obj === undefined) return 'undefined';
            if (typeof obj === 'boolean') return obj.toString();
            if (typeof obj === 'number') return obj.toString();
            if (typeof obj === 'string') return JSON.stringify(obj);
            
            if (Array.isArray(obj)) {
                if (obj.length === 0) return '[]';
                
                // Check if all items are primitives (not objects)
                const allPrimitives = obj.every(item => 
                    item === null || 
                    item === undefined || 
                    typeof item === 'boolean' || 
                    typeof item === 'number' || 
                    typeof item === 'string' ||
                    (Array.isArray(item) && item.every(i => typeof i === 'number' || typeof i === 'string' || typeof i === 'boolean'))
                );
                
                if (allPrimitives) {
                    // Simple array - format on one line
                    const items = obj.map(item => {
                        if (Array.isArray(item)) {
                            return '[' + item.map(i => JSON.stringify(i)).join(', ') + ']';
                        }
                        return JSON.stringify(item);
                    });
                    return '[' + items.join(', ') + ']';
                }
                
                // Array contains objects - format each object on multiple lines
                const items = obj.map(item => {
                    if (typeof item === 'object' && !Array.isArray(item)) {
                        // Format object with each field on its own line, but keep arrays in it compact
                        return formatJSONWithCompactArrays(item, indent + 1);
                    }
                    return JSON.stringify(item);
                });
                
                return '[\n' + items.map(item => nextIndentStr + item).join(',\n') + '\n' + indentStr + ']';
            }
            
            if (typeof obj === 'object') {
                // Format objects with proper indentation
                const entries = Object.entries(obj);
                if (entries.length === 0) return '{}';
                
                const lines = entries.map(([key, value]) => {
                    const valueStr = formatJSONWithCompactArrays(value, indent + 1);
                    return `${nextIndentStr}"${key}": ${valueStr}`;
                });
                
                return '{\n' + lines.join(',\n') + '\n' + indentStr + '}';
            }
            
            return JSON.stringify(obj);
        }

        function formatJSON(obj) {
            // Custom JSON formatter that keeps arrays on one line
            const jsonString = formatJSONWithCompactArrays(obj, 0);
            
            // Use a completely different approach - build HTML directly without regex conflicts
            let result = '';
            let i = 0;
            let inString = false;
            let stringStart = -1;
            let stringContent = '';
            
            while (i < jsonString.length) {
                const char = jsonString[i];
                const nextChar = jsonString[i + 1];
                
                if (char === '"' && !inString) {
                    // Start of a string
                    inString = true;
                    stringStart = i;
                    stringContent = '';
                    i++;
                    continue;
                }
                
                if (char === '"' && inString) {
                    // End of a string
                    inString = false;
                    
                    // Check if this string is a key (followed by colon) or a value
                    let isKey = false;
                    let j = i + 1;
                    while (j < jsonString.length && (jsonString[j] === ' ' || jsonString[j] === '\n' || jsonString[j] === '\t')) {
                        j++;
                    }
                    if (jsonString[j] === ':') {
                        isKey = true;
                    }
                    
                    if (isKey) {
                        result += '<span class="json-key">"' + escapeHtml(stringContent) + '"</span>';
                    } else {
                        result += '<span class="json-string">"' + escapeHtml(stringContent) + '"</span>';
                    }
                    
                    i++;
                    continue;
                }
                
                if (inString) {
                    stringContent += char;
                    i++;
                    continue;
                }
                
                // Handle numbers
                if (char >= '0' && char <= '9') {
                    let number = '';
                    while (i < jsonString.length && 
                           ((jsonString[i] >= '0' && jsonString[i] <= '9') || jsonString[i] === '.' || jsonString[i] === 'e' || jsonString[i] === 'E' || jsonString[i] === '+' || jsonString[i] === '-')) {
                        number += jsonString[i];
                        i++;
                    }
                    result += '<span class="json-number">' + number + '</span>';
                    continue;
                }
                
                // Handle booleans and null
                if (char === 't' && jsonString.substring(i, i + 4) === 'true') {
                    result += '<span class="json-boolean">true</span>';
                    i += 4;
                    continue;
                }
                if (char === 'f' && jsonString.substring(i, i + 5) === 'false') {
                    result += '<span class="json-boolean">false</span>';
                    i += 5;
                    continue;
                }
                if (char === 'n' && jsonString.substring(i, i + 4) === 'null') {
                    result += '<span class="json-null">null</span>';
                    i += 4;
                    continue;
                }
                
                // Add other characters as-is
                result += char;
                i++;
            }
            
            return result;
        }

        // Generate guidebook page array with start and end pages only
        function generateGuidebookPageArray() {
            const startPage = parseInt(document.getElementById('guidebook_start_page').value);
            const endPage = parseInt(document.getElementById('guidebook_end_page').value);
            
            if (!startPage || !endPage) {
                return [];
            }
            
            // Always return array with exactly 2 elements: start and end
            return [startPage, endPage];
        }
        // Toggle between raw JSON and formatted preview

        // Normalize bbox formats (old/new) into array of { page, position: [[x0,y0],[x1,y1]] }
        function normalizeBboxArray(bbox, defaultPage) {
            if (!bbox) return [];
            // If it's already an array of objects with page/position
            if (Array.isArray(bbox) && bbox.length > 0 && typeof bbox[0] === 'object' && bbox[0] !== null && 'position' in bbox[0]) {
                return bbox.map(item => ({
                    page: Number.isInteger(item.page) ? item.page : (defaultPage || 0),
                    position: Array.isArray(item.position) ? item.position : [[0,0],[0,0]]
                }));
            }
            // If it's an array of coordinate pairs (multiple bboxes)
            if (Array.isArray(bbox) && bbox.length > 0 && Array.isArray(bbox[0]) && Array.isArray(bbox[0][0])) {
                return bbox.map(pair => ({ page: defaultPage || 0, position: pair }));
            }
            // If it's a single bbox in the form [[x0,y0],[x1,y1]] (only if elements are numbers, not arrays)
            if (Array.isArray(bbox) && bbox.length === 2 && Array.isArray(bbox[0]) && Array.isArray(bbox[1]) && 
                typeof bbox[0][0] === 'number' && typeof bbox[0][1] === 'number' && 
                typeof bbox[1][0] === 'number' && typeof bbox[1][1] === 'number') {
                return [{ page: defaultPage || 0, position: bbox }];
            }
            return [];
        }

        function setInputValue(selector, value) {
            const el = document.querySelector(selector);
            if (el) el.value = value == null ? '' : value;
        }

        function clearDynamicContainers() {
            // Clear all live previews first to fix rendering issue
            const allPreviews = document.querySelectorAll('.live-preview');
            allPreviews.forEach(preview => {
                preview.innerHTML = '';
            });
            
            // Content sections
            const contentContainer = document.getElementById('content_sections_container');
            if (contentContainer) contentContainer.innerHTML = '';
            // Questions
            const questionsContainer = document.getElementById('questions_container');
            if (questionsContainer) questionsContainer.innerHTML = '';
            // Lesson arrays
            const standards = document.getElementById('lesson_standards');
            if (standards) standards.innerHTML = '';
            const terminology = document.getElementById('terminology');
            if (terminology) terminology.innerHTML = '';
        }

        function fillStringArray(containerId, values, addFn) {
            const container = document.getElementById(containerId);
            if (!container) return;
            container.innerHTML = '';
            (values || []).forEach(val => {
                addFn();
                const last = container.lastElementChild;
                const input = last && last.querySelector('input');
                if (input) input.value = val;
            });
        }

        function fillBboxGroup(groupEl, bboxList) {
            if (!groupEl) return;
            const container = groupEl.querySelector('.bbox-container');
            if (!container) return;
            
            // Determine the type of bbox group to use appropriate before/after functions
            const labelEl = groupEl.querySelector('label');
            const labelText = labelEl ? labelEl.textContent : '';
            
            let beforeFunc = 'addContentBboxBefore';
            let afterFunc = 'addContentBboxAfter';
            let beforeTitle = 'Add BBox Before';
            let afterTitle = 'Add BBox After';
            
            // Determine correct functions based on label text
            if (labelText.includes('Question Images')) {
                beforeFunc = 'addQuestionImageBefore';
                afterFunc = 'addQuestionImageAfter';
                beforeTitle = 'Add Image Before';
                afterTitle = 'Add Image After';
            } else if (labelText.includes('Answer Images')) {
                beforeFunc = 'addAnswerImageBefore';
                afterFunc = 'addAnswerImageAfter';
                beforeTitle = 'Add Image Before';
                afterTitle = 'Add Image After';
            } else if (labelText.includes('Section Images')) {
                beforeFunc = 'addContentImageBefore';
                afterFunc = 'addContentImageAfter';
                beforeTitle = 'Add Image Before';
                afterTitle = 'Add Image After';
            }
            
            // Clear existing rows
            container.innerHTML = '';
            const rowsToCreate = (bboxList && bboxList.length) ? bboxList.length : 1;
            
            // Template for a single bbox/image row (now includes Before/After buttons)
            const rowHTML = `
                <div class="array-item">
                    <div class="bbox-inputs">
                        <input type="number" placeholder="Page" class="bbox-page" min="1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                        <input type="number" placeholder="X0" class="bbox-x0" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                        <input type="number" placeholder="Y0" class="bbox-y0" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                        <input type="number" placeholder="X1" class="bbox-x1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                        <input type="number" placeholder="Y1" class="bbox-y1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    </div>
                    <div class="row-actions">
                        <button class="reorder-btn" onclick="moveItemUp(this)" title="Move Up"><i class="fas fa-arrow-up"></i></button>
                        <button class="reorder-btn" onclick="moveItemDown(this)" title="Move Down"><i class="fas fa-arrow-down"></i></button>
                        <button class="add-bbox-btn" onclick="${beforeFunc}(this)" title="${beforeTitle}">
                            <i class="fas fa-plus"></i> Before
                        </button>
                        <button class="add-bbox-btn" onclick="${afterFunc}(this)" title="${afterTitle}">
                            <i class="fas fa-plus"></i> After
                        </button>
                        <button class="add-btn" onclick="openBboxDrawer(this)"><i class="fas fa-pen-square"></i> Draw</button>
                        <button class="add-btn" onclick="pasteBboxJson(this)"><i class="fas fa-paste"></i> Paste</button>
                        <button class="add-btn" onclick="copyBboxJson(this)"><i class="fas fa-copy"></i> Copy</button>
                        <button class="duplicate-btn" onclick="duplicateBbox(this)" title="Duplicate"><i class="fas fa-clone"></i></button>
                        <button class="remove-btn" onclick="removeArrayItem(this)"></button>
                    </div>
                </div>`;
            for (let i = 0; i < rowsToCreate; i++) {
                const wrapper = document.createElement('div');
                wrapper.innerHTML = rowHTML.trim();
                container.appendChild(wrapper.firstElementChild);
            }
            const items = container.querySelectorAll('.array-item');
            (bboxList || []).forEach((bbox, idx) => {
                const inputs = items[idx] ? items[idx].querySelectorAll('.bbox-inputs input') : null;
                if (!inputs || inputs.length < 5) return;
                inputs[0].value = bbox.page || '';
                inputs[1].value = bbox.position?.[0]?.[0] ?? '';
                inputs[2].value = bbox.position?.[0]?.[1] ?? '';
                inputs[3].value = bbox.position?.[1]?.[0] ?? '';
                inputs[4].value = bbox.position?.[1]?.[1] ?? '';
            });
        }

        function populateContentSections(data, defaultPage) {
            const sections = Array.isArray(data?.instructional_content) ? data.instructional_content : [];
            const container = document.getElementById('content_sections_container');
            
            // Set bulk operation flag to skip redundant updates
            isBulkOperation = true;
            
            sections.forEach((sec, idx) => {
                addContentSection();
                const sectionEl = container.lastElementChild;
                const groups = sectionEl.querySelectorAll('.form-group');
                // 0: title, 1: text, 2: images
                const title = (sec.section_title ?? sec.title ?? '').toString();
                const text = (sec.text ?? '').toString();
                groups[0].querySelector('input').value = title;
                groups[1].querySelector('textarea').value = text;
                const normImages = normalizeBboxArray(sec.images, defaultPage);
                fillBboxGroup(groups[2], normImages);
            });
            
            // Reset bulk operation flag
            isBulkOperation = false;
            
            // Ensure numbering is correct after populating all sections
            updateContentSectionNumbers();
        }

        // Helper function to find form field by label text
        function findFieldByLabel(container, labelText, fieldType = 'input') {
            const formGroups = container.querySelectorAll('.form-group');
            for (const group of formGroups) {
                const label = group.querySelector('label');
                if (label && label.textContent.includes(labelText)) {
                    if (fieldType === 'input') {
                        return group.querySelector('input');
                    } else if (fieldType === 'textarea') {
                        return group.querySelector('textarea');
                    } else if (fieldType === 'select') {
                        return group.querySelector('select');
                    } else if (fieldType === 'checkbox') {
                        return group.querySelector('input[type="checkbox"]');
                    }
                }
            }
            return null;
        }

        // Helper function to find form group by label text
        function findFormGroupByLabel(container, labelText) {
            const formGroups = container.querySelectorAll('.form-group');
            for (const group of formGroups) {
                const label = group.querySelector('label');
                if (label && label.textContent.includes(labelText)) {
                    return group;
                }
            }
            return null;
        }

        // ========== CATEGORY 3 REFACTORING: Field Selection by Label ==========
        
        /**
         * Get field value by label text
         * @param {HTMLElement} container - The container element
         * @param {string} labelText - The label text to search for
         * @param {string} fieldType - The type of field ('input', 'textarea', 'select', 'checkbox')
         * @returns {string|boolean} The field value (trimmed) or empty string if not found
         */
        function getFieldValue(container, labelText, fieldType = 'input') {
            const field = findFieldByLabel(container, labelText, fieldType);
            if (!field) return fieldType === 'checkbox' ? false : '';
            
            if (fieldType === 'checkbox') {
                return field.checked;
            }
            return field.value.trim();
        }

        /**
         * Set field value by label text
         * @param {HTMLElement} container - The container element
         * @param {string} labelText - The label text to search for
         * @param {any} value - The value to set
         * @param {string} fieldType - The type of field ('input', 'textarea', 'select', 'checkbox')
         */
        function setFieldValue(container, labelText, value, fieldType = 'input') {
            const field = findFieldByLabel(container, labelText, fieldType);
            if (!field) return;
            
            if (fieldType === 'checkbox') {
                field.checked = !!value;
            } else {
                field.value = value;
            }
        }

        // ========== END CATEGORY 3 REFACTORING ==========

        function populateQuestions(data, defaultPage) {
            const questions = Array.isArray(data?.practice_questions) ? data.practice_questions : [];
            const container = document.getElementById('questions_container');
            
            // Set bulk operation flag to skip redundant updates
            isBulkOperation = true;
            
            questions.forEach(q => {
                addQuestion();
                const qEl = container.lastElementChild;
                
                // Find fields by label instead of array indices
                const questionIdInput = findFieldByLabel(qEl, 'Question ID');
                if (questionIdInput) {
                    questionIdInput.value = (q.id ?? '').toString();
                }
                
                
                const questionTypeSelect = findFieldByLabel(qEl, 'Question Type', 'select');
                const questionType = q.question_type || 'free_form';
                if (questionTypeSelect) {
                    questionTypeSelect.value = questionType;
                    // Trigger toggle to show/hide appropriate fields
                    toggleQuestionType(questionTypeSelect);
                }
                
                const setupTextTextarea = findFieldByLabel(qEl, 'Set-up Text', 'textarea');
                if (setupTextTextarea) {
                    setupTextTextarea.value = (q.set_up_text ?? '').toString();
                }
                
                const questionTextTextarea = findFieldByLabel(qEl, 'Question Text', 'textarea');
                if (questionTextTextarea) {
                    questionTextTextarea.value = (q.question_text ?? '').toString();
                }
                
                // Handle different question types
                if (questionType === 'fill_in_the_blanks') {
                    // Fill in the blanks: populate blank answers
                    updateBlankAnswersUI(qEl);
                    
                    // Populate answers for each blank
                    if (q.values && Array.isArray(q.values)) {
                        const blankItems = qEl.querySelectorAll('.blank-answer-item');
                        blankItems.forEach((item, index) => {
                            const textarea = item.querySelector('.blank-answer-input');
                            if (textarea && q.values[index] !== undefined) {
                                textarea.value = q.values[index];
                                // Trigger preview
                                attachPreviews(item);
                            }
                        });
                        
                        // Update the filled blanks preview after loading values
                        updateFilledBlanksPreview(qEl);
                    }
                    
                    // Populate guide answer notes (optional) - query within blanks container
                    const blanksContainer = qEl.querySelector('#blanks-container');
                    const guideAnswerNotesTextarea = blanksContainer?.querySelector('.guide-answer-notes');
                    if (guideAnswerNotesTextarea) {
                        guideAnswerNotesTextarea.value = (q.guide_answer ?? '').toString();
                    }
                } else if (questionType === 'matching') {
                    // Matching: populate left items, right items, and relationships
                    const leftList = qEl.querySelector('[id^="matching-left-list-"]');
                    const rightList = qEl.querySelector('[id^="matching-right-list-"]');
                    
                    // Populate left items
                    if (leftList && q.left && Array.isArray(q.left)) {
                        leftList.innerHTML = '';
                        q.left.forEach((itemText) => {
                            const addLeftBtn = qEl.querySelector('button[onclick*="addMatchingItem"][onclick*="left"]');
                            if (addLeftBtn) {
                                addMatchingItem(addLeftBtn, 'left');
                                const lastItem = leftList.lastElementChild;
                                if (lastItem) {
                                    const textarea = lastItem.querySelector('.matching-item-text');
                                    if (textarea) {
                                        textarea.value = itemText;
                                        attachPreviews(lastItem);
                                    }
                                }
                            }
                        });
                    }
                    
                    // Populate right items
                    if (rightList && q.right && Array.isArray(q.right)) {
                        rightList.innerHTML = '';
                        q.right.forEach((itemText) => {
                            const addRightBtn = qEl.querySelector('button[onclick*="addMatchingItem"][onclick*="right"]');
                            if (addRightBtn) {
                                addMatchingItem(addRightBtn, 'right');
                                const lastItem = rightList.lastElementChild;
                                if (lastItem) {
                                    const textarea = lastItem.querySelector('.matching-item-text');
                                    if (textarea) {
                                        textarea.value = itemText;
                                        attachPreviews(lastItem);
                                    }
                                }
                            }
                        });
                    }
                    
                    // Populate relationships
                    const relationshipsList = qEl.querySelector('[id^="relationships-list-"]');
                    if (relationshipsList && q.relationship && Array.isArray(q.relationship)) {
                        relationshipsList.innerHTML = '';
                        q.relationship.forEach(([leftIdx, rightIdx]) => {
                            const addRelBtn = qEl.querySelector('button[onclick*="addRelationship"]');
                            if (addRelBtn) {
                                addRelationship(addRelBtn);
                                const lastRel = relationshipsList.lastElementChild;
                                if (lastRel) {
                                    const leftSelect = lastRel.querySelector('.relationship-left');
                                    const rightSelect = lastRel.querySelector('.relationship-right');
                                    if (leftSelect) leftSelect.value = leftIdx;
                                    if (rightSelect) rightSelect.value = rightIdx;
                                }
                            }
                        });
                    }
                    
                    // Populate guide answer notes (optional) - query within matching container
                    const matchingContainer = qEl.querySelector('#matching-container');
                    const guideAnswerNotesTextarea = matchingContainer?.querySelector('.guide-answer-notes');
                    if (guideAnswerNotesTextarea) {
                        guideAnswerNotesTextarea.value = (q.guide_answer ?? '').toString();
                    }
                } else if ((questionType === 'multiple_choice' || questionType === 'checkbox') && q.choices && Array.isArray(q.choices)) {
                    // Fill choices
                    const choicesList = qEl.querySelector('[id^="choices-list-"]');
                    if (choicesList) {
                        choicesList.innerHTML = '';
                        q.choices.forEach((choice, choiceIndex) => {
                            addChoice(choicesList.parentElement.querySelector('.add-btn'), 'end', questionType);
                            const lastChoice = choicesList.lastElementChild;
                            if (lastChoice) {
                                const choiceIdInput = lastChoice.querySelector('.choice-id');
                                const choiceTextArea = lastChoice.querySelector('.choice-text');
                                const choiceCorrectInput = lastChoice.querySelector('.choice-correct');
                                if (choiceIdInput) {
                                    choiceIdInput.value = (choice.id ?? '').toString();
                                    // Update header to reflect the ID
                                    updateChoiceHeader(choiceIdInput);
                                }
                                if (choiceTextArea) {
                                    choiceTextArea.value = (choice.text ?? '').toString();
                                }
                                // For checkbox: restore from values array
                                if (choiceCorrectInput && q.values && q.values[choiceIndex] !== undefined) {
                                    choiceCorrectInput.checked = q.values[choiceIndex];
                                } else if (choiceCorrectInput && choice.checked !== undefined) {
                                    // Backward compatibility: support old 'checked' field
                                    choiceCorrectInput.checked = choice.checked;
                                }
                            }
                        });
                    }
                    
                    // Attach listeners for real-time updates
                    attachChoiceListeners(qEl);
                    
                    // For multiple choice: set correct answer from value field (1-indexed position)
                    if (questionType === 'multiple_choice') {
                        const correctAnswerRadios = qEl.querySelectorAll('.choice-correct-radio');
                        if (q.value && correctAnswerRadios[q.value - 1]) {
                            correctAnswerRadios[q.value - 1].checked = true;
                        } else if (q.guide_answer) {
                            // Backward compatibility: support old guide_answer with ID
                    const correctAnswerSelect = qEl.querySelector('.correct-answer-select');
                            if (correctAnswerSelect) {
                        correctAnswerSelect.value = q.guide_answer;
                            }
                        }
                    } else if (questionType === 'checkbox') {
                        // Update checkbox summary after loading
                        updateCheckboxSummary(qEl);
                    }
                    
                    // Populate guide answer notes (optional) for both multiple choice and checkbox
                    const guideAnswerNotesTextarea = qEl.querySelector('.guide-answer-notes');
                    if (guideAnswerNotesTextarea) {
                        guideAnswerNotesTextarea.value = (q.guide_answer ?? '').toString();
                    }
                } else {
                    // Free form - fill guide answer
                    const guideAnswerTextarea = qEl.querySelector('#guide-answer-container textarea');
                    if (guideAnswerTextarea) {
                        guideAnswerTextarea.value = (q.guide_answer ?? '').toString();
                    }
                }
                
                // Find Guide PDF Page field by label
                const guidePdfPageInput = findFieldByLabel(qEl, 'Guide PDF Page');
                const guidePdfPage = (q.guide_pdf_page ?? null);
                if (guidePdfPageInput && guidePdfPage != null) {
                    guidePdfPageInput.value = guidePdfPage;
                }

                const questionImages = normalizeBboxArray(q.question_images, defaultPage);
                const answerImages = normalizeBboxArray(q.guide_answer_images, guidePdfPage || defaultPage);

                // Find image groups by label
                const questionImagesGroup = findFormGroupByLabel(qEl, 'Question Images');
                const answerImagesGroup = findFormGroupByLabel(qEl, 'Answer Images');
                if (questionImagesGroup) {
                    fillBboxGroup(questionImagesGroup, questionImages);
                }
                if (answerImagesGroup) {
                    fillBboxGroup(answerImagesGroup, answerImages);
                }

                // Find related question field by label
                const relatedQuestionInput = findFieldByLabel(qEl, 'Related Question');
                const related = q.related_question == null ? '' : q.related_question;
                if (relatedQuestionInput) {
                    relatedQuestionInput.value = related;
                }
                
                // Attach previews and bbox validation after populating
                setTimeout(() => {
                    attachPreviews(qEl);
                    attachBboxValidation(qEl);
                }, 100);
            });
            
            // Reset bulk operation flag
            isBulkOperation = false;
            
            // Ensure numbering is correct after populating all questions
            updateQuestionNumbers();
        }

        function populateFormFromJSON(data) {
            // Clear entire form first
            resetForm(true);

            // Basic info
            setInputValue('#textbook_page', data.textbook_page ?? '');
            setInputValue('#textbook_pdf_page', data.textbook_pdf_page ?? '');
            const gb = Array.isArray(data.guidebook_pdf_pages) ? data.guidebook_pdf_pages : [];
            if (gb.length === 1) {
                setInputValue('#guidebook_start_page', gb[0]);
                setInputValue('#guidebook_end_page', gb[0]);
            } else if (gb.length >= 2) {
                setInputValue('#guidebook_start_page', gb[0]);
                setInputValue('#guidebook_end_page', gb[1]);
            } else {
                setInputValue('#guidebook_start_page', '');
                setInputValue('#guidebook_end_page', '');
            }
            if (data.page_type) {
                const pageTypeEl = document.getElementById('page_type');
                if (pageTypeEl) pageTypeEl.value = data.page_type;
            }

            // Lesson preamble
            const lp = data.lesson_preamble;
            if (lp && typeof lp === 'object') {
                setInputValue('#lesson_id', lp.id ?? lp.lesson_id ?? '');
                setInputValue('#lesson_title', lp.title ?? lp.lesson_title ?? '');
                setInputValue('#lesson_text', lp.text ?? '');
                fillStringArray('lesson_standards', lp.lesson_standards || [], addLessonStandard);
                fillStringArray('terminology', lp.terminology || [], addTerminology);
            } else {
                // keep empty arrays
                fillStringArray('lesson_standards', [], addLessonStandard);
                fillStringArray('terminology', [], addTerminology);
            }

            const defaultPage = data.textbook_pdf_page || data.textbook_page || 0;

            // Content sections
            populateContentSections(data, defaultPage);

            // Questions
            populateQuestions(data, defaultPage);

                // After DOM is populated, attach and render previews for all textareas
            attachPreviews(document);
            
            // Attach bbox validation to all loaded bboxes
            attachBboxValidation(document);
            
            // Ensure all textareas maintain correct direction after population
            const allTextareas = document.querySelectorAll('textarea, input[type="text"]');
            allTextareas.forEach(ta => {
                if (ta.hasAttribute('data-ltr')) {
                    // LTR fields (JSON input, lesson standards)
                    ta.setAttribute('dir', 'ltr');
                } else {
                    // RTL fields (content, questions, titles, etc.)
                    ta.setAttribute('dir', 'rtl');
                }
                // CSS will handle the styling based on data-ltr attribute
            });
            
            // Update all direction toggle buttons to show correct text
            const allDirBtns = document.querySelectorAll('.dir-btn');
            allDirBtns.forEach(btn => {
                const textarea = btn.closest('.text-field-container')?.querySelector('textarea') || 
                                btn.parentElement?.querySelector('textarea') ||
                                btn.parentElement?.querySelector('input[type="text"]');
                if (textarea) {
                    const isLTR = textarea.hasAttribute('data-ltr');
                    // Button shows what clicking it will do
                    btn.textContent = isLTR ? 'RTL' : 'LTR';
                }
            });
            
            // If final preview tab is active, regenerate it after loading JSON
            const finalPreviewTab = document.getElementById('final-preview');
            if (finalPreviewTab && finalPreviewTab.classList.contains('active')) {
                // Use setTimeout to ensure DOM is fully updated before generating preview
                setTimeout(() => {
                    generateFinalPreview();
                }, 100);
            }
        }

        // Try to repair and parse malformed JSON inputs commonly encountered
        /**
         * Convert Python dict syntax to JSON syntax
         * @param {string} text - The text that might be a Python dict
         * @returns {string} JSON-compatible text
         */
        function convertPythonDictToJSON(text) {
            let result = '';
            let i = 0;
            let inSingleQuoteString = false;
            let inDoubleQuoteString = false;
            let currentString = '';
            
            while (i < text.length) {
                const char = text[i];
                const nextChar = text[i + 1];
                
                // Handle escape sequences in strings
                if (char === '\\' && inSingleQuoteString) {
                    if (nextChar === "'") {
                        // Escaped single quote in single-quote string
                        currentString += "'";
                        i += 2;
                        continue;
                    } else if (nextChar === '\\') {
                        // Escaped backslash - add single backslash to content
                        currentString += '\\';
                        i += 2;
                        continue;
                    } else if (nextChar === 'n') {
                        // Newline escape sequence - convert to actual newline
                        currentString += '\n';
                        i += 2;
                        continue;
                    } else if (nextChar === 't') {
                        // Tab escape sequence - convert to actual tab
                        currentString += '\t';
                        i += 2;
                        continue;
                    } else if (nextChar === 'r') {
                        // Carriage return escape sequence - convert to actual CR
                        currentString += '\r';
                        i += 2;
                        continue;
                    }
                    // For any other escaped character, keep both the backslash and character
                    currentString += char;
                    i++;
                    continue;
                }
                
                // Handle escape sequences in double-quote strings
                if (char === '\\' && inDoubleQuoteString) {
                    if (nextChar === '"') {
                        // Escaped double quote
                        result += '\\"';
                        i += 2;
                        continue;
                    } else if (nextChar === '\\') {
                        // Escaped backslash
                        result += '\\\\';
                        i += 2;
                        continue;
                    }
                    // For other escape sequences, keep as-is
                    result += char;
                    i++;
                    continue;
                }
                
                // Handle single quotes
                if (char === "'" && !inDoubleQuoteString) {
                    if (!inSingleQuoteString) {
                        // Start of single-quote string
                        inSingleQuoteString = true;
                        result += '"'; // Use double quote in JSON
                    } else {
                        // End of single-quote string
                        inSingleQuoteString = false;
                        // Escape special characters for JSON
                        let escapedString = '';
                        for (let j = 0; j < currentString.length; j++) {
                            const ch = currentString[j];
                            const prevCh = j > 0 ? currentString[j-1] : '';
                            
                            // Escape backslashes (must be done first!)
                            if (ch === '\\') {
                                escapedString += '\\\\';
                            }
                            // Escape double quotes that aren't already escaped
                            else if (ch === '"' && prevCh !== '\\') {
                                escapedString += '\\"';
                            }
                            // Escape newlines for JSON
                            else if (ch === '\n') {
                                escapedString += '\\n';
                            }
                            // Escape tabs for JSON
                            else if (ch === '\t') {
                                escapedString += '\\t';
                            }
                            // Escape carriage returns for JSON
                            else if (ch === '\r') {
                                escapedString += '\\r';
                            }
                            // Keep other characters as-is
                            else {
                                escapedString += ch;
                            }
                        }
                        result += escapedString + '"';
                        currentString = '';
                    }
                    i++;
                    continue;
                }
                
                // Handle double quotes
                if (char === '"' && !inSingleQuoteString) {
                    inDoubleQuoteString = !inDoubleQuoteString;
                    result += char;
                    i++;
                    continue;
                }
                
                // Accumulate string content or regular content
                if (inSingleQuoteString) {
                    currentString += char;
                } else {
                    result += char;
                }
                
                i++;
            }
            
            // Replace Python boolean/null values with JSON equivalents (only outside strings)
            // This is now safe because we've already processed all strings
            result = result.replace(/\bTrue\b/g, 'true');
            result = result.replace(/\bFalse\b/g, 'false');
            result = result.replace(/\bNone\b/g, 'null');
            
            return result;
        }

        function attemptRepairAndParseJSON(rawText) {
            const notes = [];
            let t = (rawText || '').trim().replace(/^\uFEFF/, '');

            // Normalize line endings
            t = t.replace(/\r\n?/g, '\n');

            // Remove trailing commas like ,] or ,}
            const t1 = t;
            t = t.replace(/,\s*([\]\}])/g, '$1');
            if (t !== t1) notes.push('removed trailing commas');

            // Fix a premature closing brace before known top-level fields
            const t2 = t;
            t = t.replace(/\}\s*,\s*"(instructional_content)"/g, ', "$1"')
                 .replace(/\}\s*,\s*"(practice_questions)"/g, ', "$1"')
                 .replace(/\}\s*,\s*"(lesson_preamble)"/g, ', "$1"');
            if (t !== t2) notes.push('merged split top-level object');

            // Balance top-level braces if mismatched
            const opens = (t.match(/\{/g) || []).length;
            const closes = (t.match(/\}/g) || []).length;
            if (opens > closes) {
                t += '}'.repeat(opens - closes);
                notes.push('added missing }');
            } else if (closes > opens) {
                let diff = closes - opens;
                while (diff-- > 0) t = t.replace(/\}\s*$/, '');
                notes.push('removed extra } at end');
            }

            // Attempt parse
            let data;
            try {
                data = JSON.parse(t);
            } catch (e) {
                return { ok: false, error: e, notes };
            }

            // Map a stray top-level text into lesson_preamble.text
            if (typeof data.text === 'string') {
                if (!data.lesson_preamble || typeof data.lesson_preamble !== 'object') {
                    data.lesson_preamble = { id: '', title: '', lesson_standards: [], terminology: [], text: data.text };
                } else if (!data.lesson_preamble.text) {
                    data.lesson_preamble.text = data.text;
                }
                delete data.text;
                notes.push('moved stray top-level "text" into lesson_preamble.text');
            }

            // Ensure guidebook_pdf_pages is either null or a 2-length array
            if (Array.isArray(data.guidebook_pdf_pages)) {
                if (data.guidebook_pdf_pages.length === 1) {
                    data.guidebook_pdf_pages = [data.guidebook_pdf_pages[0], data.guidebook_pdf_pages[0]];
                    notes.push('normalized guidebook_pdf_pages to [start, end]');
                } else if (data.guidebook_pdf_pages.length > 2) {
                    data.guidebook_pdf_pages = [data.guidebook_pdf_pages[0], data.guidebook_pdf_pages[data.guidebook_pdf_pages.length - 1]];
                    notes.push('trimmed guidebook_pdf_pages to 2 items');
                }
            }

            return { ok: true, data, notes };
        }

        function loadJSON() {
            const txt = document.getElementById('json_input').value;
            if (!txt || !txt.trim()) {
                alert(' Please paste your JSON data in the text box before clicking "Load JSON".');
                return;
            }
            
            // Add confirmation popup for loading JSON
            if (!confirm(' Warning: Loading new JSON will delete everything you\'ve entered in the form.\n\nDo you want to continue?')) {
                return;
            }
            
            // Save current form state for undo (without validation)
            let previousState = null;
            try {
                previousState = collectFormDataWithoutValidation();
            } catch (e) {
                console.warn('Could not save form state for undo:', e);
            }
            
            let data;
            let convertedText = txt;
            
            // Try parsing as regular JSON first
            try {
                data = JSON.parse(txt);
            } catch (e) {
                // If it fails, try converting Python dict syntax to JSON
                console.log('Initial JSON parse failed, attempting Python dict conversion...');
                try {
                    convertedText = convertPythonDictToJSON(txt);
                    data = JSON.parse(convertedText);
                    console.log(' Successfully parsed as Python dict and converted to JSON');
                } catch (e2) {
                    // If Python conversion also fails, try repair
                    console.log('Python dict conversion failed, attempting JSON repair...');
                    const result = attemptRepairAndParseJSON(convertedText);
                    if (!result.ok) {
                        alert(' Problem: The data you pasted is not valid JSON or Python dict format and couldn\'t be fixed automatically.\n\n Fix: Check for common issues:\n    Missing commas between items\n    Missing quotation marks\n    Extra or missing brackets { }\n    Python: Use True/False/None (will be auto-converted)\n\n Tip: Use a JSON validator tool to find the exact error.');
                        return;
                    }
                    data = result.data;
                    if (result.notes.length) console.warn('JSON repairs applied:', result.notes.join('; '));
                }
            }
            try {
                // Clear saved data when loading new JSON
                clearSavedData();
                
                // Record action for undo/redo BEFORE populating (so population actions aren't recorded)
                recordFormAction({
                    type: ACTION_TYPES.LOAD_JSON,
                    jsonData: data,
                    previousState: previousState
                });
                
                // Set flag to prevent actions during population from being recorded
                isFormUndoRedoInProgress = true;
                try {
                populateFormFromJSON(data);
                } finally {
                    isFormUndoRedoInProgress = false;
                }
                
                // Start a new session when JSON is loaded (user is starting new work)
                startNewSession('json_load');
                
                // Auto-resize all textareas after loading
                setTimeout(() => {
                    autoResizeAllTextareas();
                }, 100);
                
                // Mark as no unsaved changes after loading
                hasUnsavedChanges = false;
                updateSaveIndicator('none');
                
                // Track JSON import with statistics (only if not during undo/redo)
                if (!isFormUndoRedoInProgress) {
                setTimeout(() => {
                    // Track session duration on JSON import (will be 0 or very small since we just started)
                    trackSessionDuration('json_import');
                    
                    const stats = getFormStats();
                    const importedQuestions = data.practice_questions ? data.practice_questions.length : 0;
                    const importedContentSections = data.instructional_content ? data.instructional_content.length : 0;
                    
                    // Count question types from imported data
                    const importedQuestionTypes = {};
                    if (data.practice_questions) {
                        data.practice_questions.forEach(q => {
                            const type = q.question_type || 'free_form';
                            importedQuestionTypes[type] = (importedQuestionTypes[type] || 0) + 1;
                        });
                    }
                    
                    trackEvent('json_imported', {
                        imported_questions: importedQuestions,
                        imported_content_sections: importedContentSections,
                        imported_question_type_free_form: importedQuestionTypes.free_form || 0,
                        imported_question_type_multiple_choice: importedQuestionTypes.multiple_choice || 0,
                        imported_question_type_checkbox: importedQuestionTypes.checkbox || 0,
                        imported_question_type_fill_in_the_blanks: importedQuestionTypes.fill_in_the_blanks || 0,
                        imported_question_type_matching: importedQuestionTypes.matching || 0,
                        imported_question_type_annotate: importedQuestionTypes.annotate || 0,
                        imported_question_type_create_table: importedQuestionTypes.create_table || 0,
                        json_length: txt.length,
                        has_lesson_preamble: !!data.lesson_preamble,
                        has_textbook_pdf: !!data.textbook_pdf,
                        has_guidebook_pdf: !!data.guidebook_pdf
                    });
                }, 500);
                
                alert(' Success! Your form has been filled with the data from the JSON.');
                }
            } catch (e) {
                console.error(e);
                trackEvent('json_import_failed', {
                    error_message: e.message.substring(0, 100) // Limit error message length
                });
                alert('Failed to populate form from JSON: ' + e.message);
            }
        }

        // Reset/clear the form fields
        function resetForm(isInternalCall) {
            // Clear saved data when clearing form
            if (!isInternalCall) {
                clearSavedData();
                hasUnsavedChanges = false;
                updateSaveIndicator('none');
            }
            
            // Clear all live previews first to fix rendering issue
            const allPreviews = document.querySelectorAll('.live-preview');
            allPreviews.forEach(preview => {
                preview.innerHTML = '';
            });
            
            // basic
            setInputValue('#textbook_page', '');
            setInputValue('#textbook_pdf_page', '');
            setInputValue('#guidebook_start_page', '');
            setInputValue('#guidebook_end_page', '');
            const pageTypeEl = document.getElementById('page_type');
            if (pageTypeEl) pageTypeEl.value = 'content';

            // lesson preamble
            setInputValue('#lesson_id', '');
            setInputValue('#lesson_title', '');
            setInputValue('#lesson_text', '');

            // dynamic containers
            clearDynamicContainers();

            // Recreate one empty row for lesson standards and terminology
            const standards = document.getElementById('lesson_standards');
            if (standards) {
                standards.innerHTML = '';
                addLessonStandard();
            }
            const terminology = document.getElementById('terminology');
            if (terminology) {
                terminology.innerHTML = '';
                addTerminology();
            }

            // Clear JSON output/preview and input unless internal
            const jsonOutput = document.getElementById('json_output');
            if (jsonOutput) {
                jsonOutput.innerHTML = '<span class="json-key">//</span> <span class="json-string">JSON will be generated here...</span>';
                jsonOutput.removeAttribute('data-raw-json');
            }
            if (!isInternalCall) {
                setInputValue('#json_input', '');
            }
            
            // Re-attach previews after clearing to ensure proper initialization
            setTimeout(() => {
                attachPreviews(document);
                
                // Ensure all textareas are set to correct direction after reset
                const allTextareas = document.querySelectorAll('textarea, input[type="text"]');
                allTextareas.forEach(ta => {
                    if (ta.hasAttribute('data-ltr')) {
                        // LTR fields (JSON input, lesson standards)
                        ta.setAttribute('dir', 'ltr');
                    } else {
                        // RTL fields (content, questions, titles, etc.)
                        ta.setAttribute('dir', 'rtl');
                    }
                    // CSS will handle the styling based on data-ltr attribute
                });
                
                // Update all direction toggle buttons to show correct text
                const allDirBtns = document.querySelectorAll('.dir-btn');
                allDirBtns.forEach(btn => {
                    const textarea = btn.closest('.text-field-container')?.querySelector('textarea') || 
                                    btn.parentElement?.querySelector('textarea') ||
                                    btn.parentElement?.querySelector('input[type="text"]');
                    if (textarea) {
                        const isLTR = textarea.hasAttribute('data-ltr');
                        // Button shows what clicking it will do
                        btn.textContent = isLTR ? 'RTL' : 'LTR';
                    }
                });
            }, 100);
        }


        // Markdown toolbar functions - Undo/Redo history tracking
        const undoHistory = new Map(); // Map of field -> array of operations
        const redoHistory = new Map(); // Map of field -> array of operations
        
        function addToUndoHistory(field, operation) {
            if (!undoHistory.has(field)) {
                undoHistory.set(field, []);
            }
            const history = undoHistory.get(field);
            history.push(operation);
            // Keep only last 50 operations
            if (history.length > 50) {
                history.shift();
            }
            // Clear redo history when a new operation is added
            if (redoHistory.has(field)) {
                redoHistory.get(field).length = 0;
            }
        }
        
        function insertMarkdown(element, syntax, wrap = true) {
            const start = element.selectionStart;
            const end = element.selectionEnd;
            const selectedText = element.value.substring(start, end);
            const textBefore = element.value.substring(0, start);
            const textAfter = element.value.substring(end);
            
            let newText, newCursorPos;
            
            if (selectedText && wrap) {
                // Wrap selected text
                newText = textBefore + syntax[0] + selectedText + syntax[1] + textAfter;
                newCursorPos = start + syntax[0].length + selectedText.length + syntax[1].length;
            } else {
                // Insert placeholder
                newText = textBefore + syntax[0] + syntax[1] + textAfter;
                newCursorPos = start + syntax[0].length;
            }
            
            const oldValue = element.value;
            element.value = newText;
            element.setSelectionRange(newCursorPos, newCursorPos);
            element.focus();
            
            // Track this operation for undo
            addToUndoHistory(element, {
                type: 'markdown',
                oldValue: oldValue,
                newValue: newText,
                oldSelection: { start: start, end: end },
                newSelection: { start: newCursorPos, end: newCursorPos }
            });
            
            if (element.tagName === 'TEXTAREA') {
                refreshPreviewFor(element);
            }
            element.dispatchEvent(new Event('input', { bubbles: true }));
            
            // Mark form as changed and trigger auto-save
            markFormAsChanged();
            triggerAutoSave();
        }
        
        function insertBold(element) {
            const field = element.tagName === 'BUTTON' ? element.parentElement.querySelector('textarea, input[type="text"]') : element;
            insertMarkdown(field, ['**', '**'], true);
            trackEvent('markdown_button_used', { button_type: 'bold' });
        }
        
        function insertItalic(element) {
            const field = element.tagName === 'BUTTON' ? element.parentElement.querySelector('textarea, input[type="text"]') : element;
            insertMarkdown(field, ['*', '*'], true);
            trackEvent('markdown_button_used', { button_type: 'italic' });
        }
        
        function insertBulletList(element) {
            const field = element.tagName === 'BUTTON' ? element.parentElement.querySelector('textarea') : element;
            if (!field || field.tagName !== 'TEXTAREA') return; // Only works with textareas
            
            const start = field.selectionStart;
            const end = field.selectionEnd;
            const text = field.value;
            const textBefore = text.substring(0, start);
            const textAfter = text.substring(end);
            
            // Find the start of the current line(s)
            const lineStart = textBefore.lastIndexOf('\n') + 1;
            const lineEnd = textAfter.indexOf('\n') === -1 ? text.length : end + textAfter.indexOf('\n');
            
            const selectedText = text.substring(lineStart, lineEnd);
            const lines = selectedText.split('\n');
            
            // Process each line
            const processedLines = lines.map(line => {
                const trimmed = line.trim();
                if (trimmed === '') return line; // Preserve empty lines as-is
                // Check if line already starts with bullet
                if (trimmed.startsWith('- ') || trimmed.match(/^[-*+]\s/)) {
                    return line; // Already a bullet, don't change
                }
                // Add bullet marker
                const indent = line.match(/^(\s*)/)[1];
                return indent + '- ' + trimmed;
            });
            
            const newText = text.substring(0, lineStart) + processedLines.join('\n') + text.substring(lineEnd);
            const oldValue = field.value;
            field.value = newText;
            
            // Set cursor position
            const newCursorPos = start + (processedLines.join('\n').length - selectedText.length);
            field.setSelectionRange(newCursorPos, newCursorPos);
            field.focus();
            
            // Track this operation for undo
            addToUndoHistory(field, {
                type: 'bullet_list',
                oldValue: oldValue,
                newValue: newText,
                oldSelection: { start: start, end: end },
                newSelection: { start: newCursorPos, end: newCursorPos }
            });
            
            refreshPreviewFor(field);
            field.dispatchEvent(new Event('input', { bubbles: true }));
            
            // Mark form as changed and trigger auto-save
            markFormAsChanged();
            triggerAutoSave();
            
            trackEvent('markdown_button_used', { button_type: 'bullet_list' });
        }
        
        function insertNumberedList(element) {
            const field = element.tagName === 'BUTTON' ? element.parentElement.querySelector('textarea') : element;
            if (!field || field.tagName !== 'TEXTAREA') return; // Only works with textareas
            
            const start = field.selectionStart;
            const end = field.selectionEnd;
            const text = field.value;
            const textBefore = text.substring(0, start);
            const textAfter = text.substring(end);
            
            // Find the start of the current line(s)
            const lineStart = textBefore.lastIndexOf('\n') + 1;
            const lineEnd = textAfter.indexOf('\n') === -1 ? text.length : end + textAfter.indexOf('\n');
            
            const selectedText = text.substring(lineStart, lineEnd);
            const lines = selectedText.split('\n');
            
            // Process each line
            let lineNumber = 1;
            // Check if there's a numbered list before this to continue numbering
            const beforeText = text.substring(0, lineStart);
            const lastNumberedLine = beforeText.match(/(\d+)\.\s[^\n]*$/);
            if (lastNumberedLine) {
                lineNumber = parseInt(lastNumberedLine[1]) + 1;
            }
            
            const processedLines = lines.map(line => {
                const trimmed = line.trim();
                if (trimmed === '') return line; // Preserve empty lines as-is
                // Check if line already starts with number
                if (trimmed.match(/^\d+\.\s/)) {
                    return line; // Already numbered, don't change
                }
                // Add number marker
                const indent = line.match(/^(\s*)/)[1];
                const numbered = indent + lineNumber + '. ' + trimmed;
                lineNumber++;
                return numbered;
            });
            
            const newText = text.substring(0, lineStart) + processedLines.join('\n') + text.substring(lineEnd);
            const oldValue = field.value;
            field.value = newText;
            
            // Set cursor position
            const newCursorPos = start + (processedLines.join('\n').length - selectedText.length);
            field.setSelectionRange(newCursorPos, newCursorPos);
            field.focus();
            
            // Track this operation for undo
            addToUndoHistory(field, {
                type: 'numbered_list',
                oldValue: oldValue,
                newValue: newText,
                oldSelection: { start: start, end: end },
                newSelection: { start: newCursorPos, end: newCursorPos }
            });
            
            refreshPreviewFor(field);
            field.dispatchEvent(new Event('input', { bubbles: true }));
            
            // Mark form as changed and trigger auto-save
            markFormAsChanged();
            triggerAutoSave();
            
            trackEvent('markdown_button_used', { button_type: 'numbered_list' });
        }
        
        function insertBlockquote(element) {
            const field = element.tagName === 'BUTTON' ? element.parentElement.querySelector('textarea') : element;
            if (!field || field.tagName !== 'TEXTAREA') return; // Only works with textareas
            
            const start = field.selectionStart;
            const end = field.selectionEnd;
            const text = field.value;
            const textBefore = text.substring(0, start);
            const textAfter = text.substring(end);
            
            // Find the start of the current line(s)
            const lineStart = textBefore.lastIndexOf('\n') + 1;
            const lineEnd = textAfter.indexOf('\n') === -1 ? text.length : end + textAfter.indexOf('\n');
            
            const selectedText = text.substring(lineStart, lineEnd);
            const lines = selectedText.split('\n');
            
            // Process each line
            const processedLines = lines.map(line => {
                const trimmed = line.trim();
                // Handle empty lines - add blockquote marker
                if (trimmed === '') {
                    const indent = line.match(/^(\s*)/)[1];
                    return indent + '> ';
                }
                // Check if line already starts with blockquote (with proper spacing: > followed by exactly one space)
                if (trimmed.match(/^>\s[^\s]/) || trimmed === '>') {
                    return line; // Already a blockquote, don't change
                }
                // Add blockquote marker with exactly one space (per validation requirement)
                const indent = line.match(/^(\s*)/)[1];
                return indent + '> ' + trimmed;
            });
            
            const newText = text.substring(0, lineStart) + processedLines.join('\n') + text.substring(lineEnd);
            const oldValue = field.value;
            field.value = newText;
            
            // Calculate new cursor position
            let newCursorPos;
            // If cursor was on an empty line (no selection and line is empty), place cursor after "> "
            if (start === end && selectedText.trim() === '') {
                // Find where the cursor should be - right after "> " on the current line
                const beforeNewText = text.substring(0, lineStart);
                const currentLineInNewText = processedLines[0]; // First processed line
                newCursorPos = beforeNewText.length + currentLineInNewText.length;
            } else {
                // Multiple lines or selection - place cursor at the end of the processed text
                newCursorPos = start + (processedLines.join('\n').length - selectedText.length);
            }
            
            field.setSelectionRange(newCursorPos, newCursorPos);
            field.focus();
            
            // Track this operation for undo
            addToUndoHistory(field, {
                type: 'blockquote',
                oldValue: oldValue,
                newValue: newText,
                oldSelection: { start: start, end: end },
                newSelection: { start: newCursorPos, end: newCursorPos }
            });
            
            refreshPreviewFor(field);
            field.dispatchEvent(new Event('input', { bubbles: true }));
            
            // Mark form as changed and trigger auto-save
            markFormAsChanged();
            triggerAutoSave();
            
            trackEvent('markdown_button_used', { button_type: 'blockquote' });
        }
        
        function removeMarkdownFormatting(element) {
            try {
                const field = element.tagName === 'BUTTON' ? element.parentElement.querySelector('textarea, input[type="text"]') : element;
                if (!field) {
                    console.error('removeMarkdownFormatting: Could not find field');
                    return;
                }
                
                // Get undo history for this field
                const history = undoHistory.get(field);
                if (!history || history.length === 0) {
                    // No history to undo
                    return;
                }
                
                // Get the last operation
                const lastOp = history.pop();
                
                // Save current state before undo for redo
                const currentValue = field.value;
                const currentSelection = { start: field.selectionStart, end: field.selectionEnd };
                
                // Add to redo history - this will restore us back to the state before undo
                if (!redoHistory.has(field)) {
                    redoHistory.set(field, []);
                }
                redoHistory.get(field).push({
                    type: lastOp.type,
                    oldValue: lastOp.oldValue, // Where we are going (after undo)
                    newValue: lastOp.newValue, // Where we want to go back to (before undo)
                    oldSelection: lastOp.oldSelection, // Selection after undo
                    newSelection: lastOp.newSelection // Selection before undo (what we want to restore)
                });
                
                // Restore the old value and selection (undo)
                field.value = lastOp.oldValue;
                field.setSelectionRange(lastOp.oldSelection.start, lastOp.oldSelection.end);
                field.focus();
                
                // Refresh preview if it's a textarea
                if (field.tagName === 'TEXTAREA') {
                    refreshPreviewFor(field);
                }
                field.dispatchEvent(new Event('input', { bubbles: true }));
                
                // Mark form as changed and trigger auto-save
                markFormAsChanged();
                triggerAutoSave();
                
                trackEvent('markdown_button_used', { button_type: 'undo' });
            } catch (error) {
                console.error('Error in removeMarkdownFormatting:', error);
            }
        }
        
        function redoMarkdownFormatting(element) {
            try {
                const field = element.tagName === 'BUTTON' ? element.parentElement.querySelector('textarea, input[type="text"]') : element;
                if (!field) {
                    console.error('redoMarkdownFormatting: Could not find field');
                    return;
                }
                
                // Get redo history for this field
                const history = redoHistory.get(field);
                if (!history || history.length === 0) {
                    // No history to redo
                    return;
                }
                
                // Get the last redo operation
                const lastOp = history.pop();
                
                // Save current state before redo for undo
                const currentValue = field.value;
                const currentSelection = { start: field.selectionStart, end: field.selectionEnd };
                
                // Add current state back to undo history (so we can undo the redo)
                if (!undoHistory.has(field)) {
                    undoHistory.set(field, []);
                }
                undoHistory.get(field).push({
                    type: lastOp.type,
                    oldValue: lastOp.oldValue, // Current state (after undo)
                    newValue: lastOp.newValue, // State we're going to (before undo)
                    oldSelection: lastOp.oldSelection, // Current selection
                    newSelection: lastOp.newSelection // Selection we're restoring
                });
                
                // Restore the redo value and selection (redo - go back to state before undo)
                field.value = lastOp.newValue;
                field.setSelectionRange(lastOp.newSelection.start, lastOp.newSelection.end);
                field.focus();
                
                // Refresh preview if it's a textarea
                if (field.tagName === 'TEXTAREA') {
                    refreshPreviewFor(field);
                }
                field.dispatchEvent(new Event('input', { bubbles: true }));
                
                // Mark form as changed and trigger auto-save
                markFormAsChanged();
                triggerAutoSave();
                
                trackEvent('markdown_button_used', { button_type: 'redo' });
            } catch (error) {
                console.error('Error in redoMarkdownFormatting:', error);
            }
        }
        
        function insertInlineLatex(element) {
            const field = element.tagName === 'BUTTON' ? element.parentElement.querySelector('textarea, input[type="text"]') : element;
            const start = field.selectionStart;
            const end = field.selectionEnd;
            const selectedText = field.value.substring(start, end);
            const textBefore = field.value.substring(0, start);
            const textAfter = field.value.substring(end);
            
            let newText, newCursorPos;
            
            if (selectedText) {
                // Wrap selected text with $
                newText = textBefore + '$' + selectedText + '$' + textAfter;
                newCursorPos = start + 1 + selectedText.length + 1;
            } else {
                // Insert $$ with cursor in middle
                newText = textBefore + '$$' + textAfter;
                newCursorPos = start + 1;
            }
            
            const oldValue = field.value;
            field.value = newText;
            field.setSelectionRange(newCursorPos, newCursorPos);
            field.focus();
            
            // Track this operation for undo
            addToUndoHistory(field, {
                type: 'inline_latex',
                oldValue: oldValue,
                newValue: newText,
                oldSelection: { start: start, end: end },
                newSelection: { start: newCursorPos, end: newCursorPos }
            });
            
            if (field.tagName === 'TEXTAREA') {
                refreshPreviewFor(field);
            }
            field.dispatchEvent(new Event('input', { bubbles: true }));
            
            // Mark form as changed and trigger auto-save
            markFormAsChanged();
            triggerAutoSave();
            
            trackEvent('markdown_button_used', { button_type: 'inline_latex' });
        }
        
        function insertBlockLatex(element) {
            const field = element.tagName === 'BUTTON' ? element.parentElement.querySelector('textarea') : element;
            if (!field || field.tagName !== 'TEXTAREA') return; // Only works with textareas
            
            const start = field.selectionStart;
            const end = field.selectionEnd;
            const selectedText = field.value.substring(start, end);
            const textBefore = field.value.substring(0, start);
            const textAfter = field.value.substring(end);
            
            let newText, newCursorPos;
            
            if (selectedText) {
                // Wrap selected text with $$\n...\n$$ (literal \n strings)
                newText = textBefore + '$$\\n' + selectedText + '\\n$$' + textAfter;
                newCursorPos = start + 4 + selectedText.length + 4;
            } else {
                // Insert $$\n\n$$ with cursor in middle (literal \n strings)
                newText = textBefore + '$$\\n\\n$$' + textAfter;
                newCursorPos = start + 4;
            }
            
            const oldValue = field.value;
            field.value = newText;
            field.setSelectionRange(newCursorPos, newCursorPos);
            field.focus();
            
            // Track this operation for undo
            addToUndoHistory(field, {
                type: 'block_latex',
                oldValue: oldValue,
                newValue: newText,
                oldSelection: { start: start, end: end },
                newSelection: { start: newCursorPos, end: newCursorPos }
            });
            
            refreshPreviewFor(field);
            field.dispatchEvent(new Event('input', { bubbles: true }));
            
            // Mark form as changed and trigger auto-save
            markFormAsChanged();
            triggerAutoSave();
        }
        
        // Insert table into text field with automatic indexing
        function insertTable(textarea) {
            // Check if this is a restricted field (lesson text)
            const isLessonText = textarea.id === 'lesson_text';
            
            if (isLessonText) {
                alert('Tables are not allowed in lesson preamble text. Please add tables only in question text, guide answers, set-up text, or content sections.');
                return;
            }
            
            const tableDescription = prompt('Enter table description (optional):');
            
            // Get the next available image index automatically
            const nextIndex = getNextImageIndexForField(textarea);
            
            const numColumns = prompt('Enter number of columns (e.g., 3):');
            if (!numColumns || isNaN(numColumns) || numColumns < 1) {
                alert('Please enter a valid number of columns');
                return;
            }
            
            const numRows = prompt('Enter number of rows (e.g., 3):');
            if (!numRows || isNaN(numRows) || numRows < 1) {
                alert('Please enter a valid number of rows');
                return;
            }
            
            // Build table structure
            let tableMarkdown = '';
            
            // Add image reference with automatic index
            if (tableDescription && tableDescription.trim()) {
                tableMarkdown += `![${tableDescription.trim()}](${nextIndex})\n`;
            } else {
                tableMarkdown += `![](${nextIndex})\n`;
            }
            
            // Add table headers
            const headers = [];
            for (let i = 1; i <= numColumns; i++) {
                headers.push(`Header ${i}`);
            }
            tableMarkdown += `| ${headers.join(' | ')} |\n`;
            
            // Add separator line
            const separators = [];
            for (let i = 1; i <= numColumns; i++) {
                separators.push('----------');
            }
            tableMarkdown += `| ${separators.join(' | ')} |\n`;
            
            // Add data rows
            for (let row = 1; row <= numRows; row++) {
                const cells = [];
                for (let col = 1; col <= numColumns; col++) {
                    cells.push(`Row ${row}, Cell ${col}`);
                }
                tableMarkdown += `| ${cells.join(' | ')} |\n`;
            }
            
            // Insert at cursor position or at end
            const cursorPos = textarea.selectionStart;
            const textBefore = textarea.value.substring(0, cursorPos);
            const textAfter = textarea.value.substring(cursorPos);
            
            textarea.value = textBefore + tableMarkdown + textAfter;
            
            // Set cursor position after the inserted table
            const newCursorPos = cursorPos + tableMarkdown.length;
            textarea.setSelectionRange(newCursorPos, newCursorPos);
            textarea.focus();
            refreshPreviewFor(textarea);
            
            // Trigger input event to update radio buttons (if in a multiple choice question)
            // This will trigger the existing event listener that updates radio buttons
            textarea.dispatchEvent(new Event('input', { bubbles: true }));
            
            // Mark form as changed and trigger auto-save
            markFormAsChanged();
            triggerAutoSave();
            
            trackEvent('markdown_button_used', { 
                button_type: 'table',
                table_columns: parseInt(numColumns),
                table_rows: parseInt(numRows)
            });
        }

        // Insert image into text field with automatic indexing
        function insertImage(textarea) {
            
            // Check if this is a restricted field (lesson text)
            const isLessonText = textarea.id === 'lesson_text';
            
            if (isLessonText) {
                alert('Images are not allowed in lesson preamble text. Please add images only in question text, guide answers, set-up text, or content sections.');
                return;
            }
            
            const imageDescription = prompt('Enter image description (optional):');
            if (imageDescription === null) return; // User cancelled
            
            // Get the next available image index automatically
            const nextIndex = getNextImageIndexForField(textarea);
            
            // Build image markdown with automatic index
            let imageMarkdown = '';
            if (imageDescription && imageDescription.trim()) {
                imageMarkdown = `![${imageDescription.trim()}](${nextIndex})`;
            } else {
                imageMarkdown = `![](${nextIndex})`;
            }
            
            
            // Insert at cursor position or at end
            const cursorPos = textarea.selectionStart;
            const textBefore = textarea.value.substring(0, cursorPos);
            const textAfter = textarea.value.substring(cursorPos);
            
            textarea.value = textBefore + imageMarkdown + textAfter;
            
            // Set cursor position after the inserted image
            const newCursorPos = cursorPos + imageMarkdown.length;
            textarea.setSelectionRange(newCursorPos, newCursorPos);
            textarea.focus();
            
            refreshPreviewFor(textarea);
            
            // Trigger input event to update radio buttons (if in a multiple choice question)
            // This will trigger the existing event listener that updates radio buttons
            textarea.dispatchEvent(new Event('input', { bubbles: true }));
            
            // Mark form as changed and trigger auto-save
            markFormAsChanged();
            triggerAutoSave();
            
            trackEvent('markdown_button_used', { button_type: 'image' });
        }

        // Copy JSON to clipboard
        function copyJSON() {
            const jsonOutput = document.getElementById('json_output');
            const jsonText = jsonOutput.textContent || jsonOutput.innerText;
            
            // Create a temporary textarea to copy the text
            const textarea = document.createElement('textarea');
            textarea.value = jsonText;
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);
            
            // Show feedback
            const copyBtn = event.target.closest('button');
            const originalText = copyBtn.innerHTML;
            copyBtn.innerHTML = '<i class="fas fa-check"></i> Copied!';
            copyBtn.style.background = '#28a745';
            
            setTimeout(() => {
                copyBtn.innerHTML = originalText;
                copyBtn.style.background = '';
            }, 2000);
            
            // Track session duration on JSON export
            trackSessionDuration('json_export');
            
            // Track JSON export with statistics
            const stats = getFormStats();
            trackEvent('json_exported', {
                total_questions: stats.totalQuestions,
                total_content_sections: stats.totalContentSections,
                question_type_free_form: stats.questionTypes.free_form || 0,
                question_type_multiple_choice: stats.questionTypes.multiple_choice || 0,
                question_type_checkbox: stats.questionTypes.checkbox || 0,
                question_type_fill_in_the_blanks: stats.questionTypes.fill_in_the_blanks || 0,
                question_type_matching: stats.questionTypes.matching || 0,
                question_type_annotate: stats.questionTypes.annotate || 0,
                question_type_create_table: stats.questionTypes.create_table || 0,
                json_length: jsonText.length
            });
        }

        // Confirm before clearing the form
        function confirmClearForm() {
            if (confirm(' Warning: This will delete everything you\'ve entered in the form and clear your saved progress.\n\nAre you sure you want to clear the form?')) {
                // Save current form state for undo (without validation)
                let savedState = null;
                try {
                    savedState = collectFormDataWithoutValidation();
                } catch (e) {
                    console.warn('Could not save form state for undo:', e);
                }
                
                // Record action for undo/redo BEFORE clearing (so clearing actions aren't recorded)
                recordFormAction({
                    type: ACTION_TYPES.CLEAR_FORM,
                    savedState: savedState,
                    clearFunction: resetForm
                });
                
                // Track form clearing
                const stats = getFormStats();
                trackEvent('form_cleared', {
                    total_questions_before_clear: stats.totalQuestions,
                    total_content_sections_before_clear: stats.totalContentSections
                });
                
                // Set flag to prevent actions during reset from being recorded
                isFormUndoRedoInProgress = true;
                try {
                resetForm(false);
                } finally {
                    isFormUndoRedoInProgress = false;
                }
            }
        }

        // ===== MANUAL SAVE FUNCTIONALITY =====
        
        const SAVE_KEY = 'transcription_form_save';
        let hasUnsavedChanges = false;
        let lastSavedData = null;
        let autoSaveTimeout = null;
        let fieldValues = new Map(); // Track field values to detect changes
        
        // Update save indicator
        function updateSaveIndicator(status) {
            const indicator = document.getElementById('saveIndicator');
            if (!indicator) return;
            
            const text = indicator.querySelector('span');
            if (!text) return;
            
            indicator.className = 'auto-save-indicator';
            
            if (status === 'unsaved') {
                indicator.classList.add('saving');
                text.textContent = ' Unsaved changes';
            } else if (status === 'saving') {
                indicator.classList.add('saving');
                text.textContent = 'Saving...';
            } else if (status === 'saved') {
                indicator.classList.add('saved');
                text.textContent = ' All saved';
            } else {
                text.textContent = 'No changes';
            }
        }
        
        // Track that form has changes
        function markFormAsChanged() {
            hasUnsavedChanges = true;
            updateSaveIndicator('unsaved');
        }
        
        // Debounced auto-save function
        function triggerAutoSave() {
            // Clear any pending auto-save
            if (autoSaveTimeout) {
                clearTimeout(autoSaveTimeout);
            }
            
            // Only save if there are unsaved changes
            if (!hasUnsavedChanges) {
                return;
            }
            
            // Debounce: wait 1 second after last change before saving
            autoSaveTimeout = setTimeout(() => {
                if (hasUnsavedChanges) {
                    try {
                        updateSaveIndicator('saving');
                        saveProgress(true); // Pass true to indicate this is an auto-save
                    } catch (error) {
                        console.error('Auto-save failed:', error);
                        updateSaveIndicator('unsaved');
                    }
                }
            }, 1000);
        }
        
        // Manual save function - uses the same generateJSON logic
        // Optional parameter: isAutoSave - if true, suppress some alerts for validation warnings
        function saveProgress(isAutoSave = false) {
            try {
                // Use the exact same logic as generateJSON() to create the JSON structure
                const textbookPage = document.getElementById('textbook_page').value;
                const textbookPdfPage = document.getElementById('textbook_pdf_page').value;
                const guidebookStart = document.getElementById('guidebook_start_page').value;
                const guidebookEnd = document.getElementById('guidebook_end_page').value;
                const pageType = document.getElementById('page_type').value;
                
                // Validate block LaTeX in all content sections and questions before saving (exclude output fields)
                const validationErrors = [];
                const validationWarnings = [];
                const allTextareas = document.querySelectorAll('textarea');
                allTextareas.forEach((textarea, index) => {
                    // Skip validation for output/display fields
                    const textareaId = textarea.id;
                    if (textareaId === 'json_input' || textareaId === 'json_output' || 
                        textarea.classList.contains('output-field') || 
                        textarea.hasAttribute('readonly')) {
                        return; // Skip this textarea
                    }
                    
                    const content = textarea.value || '';
                    const mathBlockErrors = validateBlockLatex(content);
                    if (mathBlockErrors.length > 0) {
                        mathBlockErrors.forEach(error => {
                            validationErrors.push(`Block LaTeX Error in ${getTextareaLocation(textarea)}: ${error.message}`);
                        });
                    }
                    
                    // Validate blanks in LaTeX
                    const blanksInLatexErrors = validateBlanksInLatex(content);
                    if (blanksInLatexErrors.length > 0) {
                        blanksInLatexErrors.forEach(error => {
                            validationErrors.push(`Blank in LaTeX Error in ${getTextareaLocation(textarea)}: ${error.message}`);
                        });
                    }
                    
                    const imageDescErrors = validateImageDescriptions(content);
                    if (imageDescErrors.length > 0) {
                        imageDescErrors.forEach(error => {
                            validationErrors.push(`Image Description Error in ${getTextareaLocation(textarea)}: ${error.message}`);
                        });
                    }
                    
                    const quoteErrors = validateQuotes(content);
                    if (quoteErrors.length > 0) {
                        quoteErrors.forEach(error => {
                            validationErrors.push(`Quote Error in ${getTextareaLocation(textarea)}: ${error.message}`);
                        });
                    }
                    
                    // Validate <br> tags
                    const brErrors = validateBrTags(content);
                    if (brErrors.length > 0) {
                        brErrors.forEach(error => {
                            validationErrors.push(`HTML Tag Error in ${getTextareaLocation(textarea)}: ${error.message}`);
                        });
                    }
                    
                    const dollarErrors = validateDollarSigns(content);
                    if (dollarErrors.length > 0) {
                        dollarErrors.forEach(error => {
                            validationWarnings.push(`Dollar Sign Warning in ${getTextareaLocation(textarea)}: ${error.message}`);
                        });
                    }
                    
                    // Validate table markdown
                    const tableValidation = validateTableMarkdown(content);
                    if (tableValidation.hasTables && !tableValidation.valid && tableValidation.errors.length > 0) {
                        tableValidation.errors.forEach(error => {
                            const errorMsg = typeof error === 'string' ? error : error.message;
                            validationErrors.push(`Table Markdown Error in ${getTextareaLocation(textarea)}: ${errorMsg}`);
                        });
                    }
                    
                    // Validate list markdown
                    const listValidation = validateListMarkdown(content);
                    if (listValidation.hasLists && !listValidation.valid && listValidation.errors.length > 0) {
                        listValidation.errors.forEach(error => {
                            const errorMsg = typeof error === 'string' ? error : error.message;
                            validationErrors.push(`List Markdown Error in ${getTextareaLocation(textarea)}: ${errorMsg}`);
                        });
                    }
                    
                    // Validate blockquote markdown
                    const blockquoteValidation = validateBlockquoteMarkdown(content);
                    if (blockquoteValidation.hasBlockquotes && !blockquoteValidation.valid && blockquoteValidation.errors.length > 0) {
                        blockquoteValidation.errors.forEach(error => {
                            const errorMsg = typeof error === 'string' ? error : error.message;
                            validationErrors.push(`Blockquote Markdown Error in ${getTextareaLocation(textarea)}: ${errorMsg}`);
                        });
                    }
                });
                
                // Required top-level fields
                if (!textbookPage) validationErrors.push('Textbook page is required');
                if (!textbookPdfPage) validationErrors.push('Textbook PDF page is required');
                if (!guidebookStart) validationErrors.push('Guidebook start page is required');
                if (!guidebookEnd) validationErrors.push('Guidebook end page is required');
                if (guidebookStart && guidebookEnd && parseInt(guidebookStart) > parseInt(guidebookEnd)) {
                    validationErrors.push('Guidebook start page cannot be greater than end page');
                }
                if (!pageType || pageType.trim().length === 0) validationErrors.push('Page type is required');

                if (validationErrors.length > 0) {
                    // Track validation errors
                    const errorCategories = categorizeValidationErrors(validationErrors);
                    trackEvent('validation_errors', {
                        total_errors: validationErrors.length,
                        error_type_required_field: errorCategories.required_field,
                        error_type_block_latex: errorCategories.block_latex,
                        error_type_image_description: errorCategories.image_description,
                        error_type_quote_error: errorCategories.quote_error,
                        error_type_dollar_sign: errorCategories.dollar_sign,
                        error_type_table_markdown: errorCategories.table_markdown,
                        error_type_list_markdown: errorCategories.list_markdown,
                        error_type_blockquote_markdown: errorCategories.blockquote_markdown,
                        error_type_html_tag: errorCategories.html_tag,
                        error_type_image_reference: errorCategories.image_reference,
                        error_type_image_mismatch: errorCategories.image_mismatch,
                        error_type_image_numbering: errorCategories.image_numbering,
                        error_type_question_id: errorCategories.question_id,
                        error_type_question_text: errorCategories.question_text,
                        error_type_guide_answer: errorCategories.guide_answer,
                        error_type_guide_pdf_page: errorCategories.guide_pdf_page,
                        error_type_blank_format: errorCategories.blank_format,
                        error_type_matching_format: errorCategories.matching_format,
                        error_type_choice_format: errorCategories.choice_format,
                        error_type_duplicate_id: errorCategories.duplicate_id,
                        error_type_other: errorCategories.other,
                        validation_context: isAutoSave ? 'auto_save' : 'manual_save'
                    });
                    
                    // For auto-save, don't show alerts but log to console and keep unsaved state
                    if (isAutoSave) {
                        console.warn('Auto-save blocked by validation errors:', validationErrors);
                        updateSaveIndicator('unsaved');
                        return;
                    }
                    alert("Cannot save - Validation errors found:\n" + validationErrors.join("\n"));
                    return;
                }
                
                // Build JSON using the same structure as generateJSON()
                const jsonData = {
                    textbook_page: textbookPage ? parseInt(textbookPage) : null,
                    textbook_pdf_page: textbookPdfPage ? parseInt(textbookPdfPage) : null,
                    guidebook_pdf_pages: generateGuidebookPageArray(),
                    page_type: document.getElementById('page_type').value || "content",
                    lesson_preamble: null,
                    instructional_content: [],
                    practice_questions: []
                };

                // Collect content sections (same logic as generateJSON) - only get the main content sections (direct children)
                const contentElements = document.querySelectorAll('#content_sections_container > .array-item');
                contentElements.forEach((contentEl, index) => {
                    try {
                        const contentData = collectContentData(contentEl);
                        
                        // Warn if section title is empty
                        if (!contentData.section_title) {
                            validationWarnings.push(ErrorMessages.warningSectionTitle(index));
                        }
                        
                        if (!contentData.text || /^\d+$/.test(contentData.text)) {
                            validationErrors.push(ErrorMessages.requiredContent(index));
                        } else {
                            jsonData.instructional_content.push(contentData);
                        }
                    } catch (error) {
                        validationErrors.push(`Content Section ${index + 1}: ${error.message}`);
                    }
                });

                // Add lesson preamble if provided
                const lessonId = document.getElementById('lesson_id').value;
                if (lessonId) {
                    jsonData.lesson_preamble = {
                        id: lessonId.trim(),
                        title: document.getElementById('lesson_title').value || "",
                        lesson_standards: Array.from(document.querySelectorAll('#lesson_standards input')).map(input => input.value).filter(v => v),
                        terminology: Array.from(document.querySelectorAll('#terminology input')).map(input => input.value).filter(v => v),
                        text: document.getElementById('lesson_text').value || ""
                    };
                }

                // Collect questions (same logic as generateJSON) - only get the main questions (direct children)
                const questionElements = document.querySelectorAll('#questions_container > .array-item');
                questionElements.forEach((questionEl, index) => {
                    try {
                        const questionData = collectQuestionData(questionEl);
                        
                        // Validate required fields
                        if (!questionData.id) validationErrors.push(ErrorMessages.requiredQuestionID(index));
                        
                        // Validate annotate and create_table types
                        if (questionData.question_type === 'annotate' || questionData.question_type === 'create_table') {
                            // Validate required fields
                            if (!questionData.question_text || /^\d+$/.test(questionData.question_text)) {
                                validationErrors.push(ErrorMessages.requiredQuestionText(index));
                            }
                            
                            // Validate guide PDF page
                            if (!questionData.guide_pdf_page) {
                                validationErrors.push(ErrorMessages.requiredGuidePage(index));
                            } else if (isNaN(questionData.guide_pdf_page) || !Number.isInteger(questionData.guide_pdf_page) || questionData.guide_pdf_page <= 0) {
                                validationErrors.push(ErrorMessages.invalidGuidePage(index));
                            } else {
                                // Validate guide PDF page is within guidebook range
                                const gbStart = parseInt(guidebookStart, 10);
                                const gbEnd = parseInt(guidebookEnd, 10);
                                if (!isNaN(gbStart) && !isNaN(gbEnd) && gbStart > 0 && gbEnd > 0) {
                                    if (questionData.guide_pdf_page < gbStart || questionData.guide_pdf_page > gbEnd) {
                                        validationErrors.push(ErrorMessages.guidePageOutOfRange(index, questionData.guide_pdf_page, gbStart, gbEnd));
                                    }
                                }
                            }
                        } else if (questionData.question_type === 'fill_in_the_blanks') {
                            // Fill in the blanks validation (same as in generateJSON)
                            if (!questionData.question_text || /^\d+$/.test(questionData.question_text)) {
                                validationErrors.push(ErrorMessages.requiredQuestionText(index));
                            } else {
                                const { valid, errors, blanks } = validateBlankFormat(questionData.question_text);
                                
                                if (blanks.length === 0) {
                                    validationErrors.push(ErrorMessages.noBlanksFound(index));
                                } else if (!valid) {
                                    errors.forEach(err => {
                                        validationErrors.push(ErrorMessages.invalidBlankFormat(index, err));
                                    });
                                }
                                
                                if (!questionData.values || !Array.isArray(questionData.values)) {
                                    validationErrors.push(ErrorMessages.blankAnswerMismatch(index, blanks.length, 0));
                                } else {
                                    if (questionData.values.length !== blanks.length) {
                                        validationErrors.push(ErrorMessages.blankAnswerMismatch(index, blanks.length, questionData.values.length));
                                    }
                                    
                                    const emptyBlanks = [];
                                    questionData.values.forEach((answer, idx) => {
                                        if (!answer || answer.trim() === '') {
                                            emptyBlanks.push(`___${blanks[idx]}___`);
                                        }
                                    });
                                    if (emptyBlanks.length > 0) {
                                        validationErrors.push(ErrorMessages.missingBlankAnswers(index, emptyBlanks));
                                    }
                                }
                            }
                            
                            if (!questionData.guide_pdf_page) {
                                validationErrors.push(ErrorMessages.requiredGuidePage(index));
                            } else if (isNaN(questionData.guide_pdf_page) || !Number.isInteger(questionData.guide_pdf_page) || questionData.guide_pdf_page <= 0) {
                                validationErrors.push(ErrorMessages.invalidGuidePage(index));
                            } else {
                                // Validate guide PDF page is within guidebook range
                                const gbStart = parseInt(guidebookStart, 10);
                                const gbEnd = parseInt(guidebookEnd, 10);
                                if (!isNaN(gbStart) && !isNaN(gbEnd) && gbStart > 0 && gbEnd > 0) {
                                    if (questionData.guide_pdf_page < gbStart || questionData.guide_pdf_page > gbEnd) {
                                        validationErrors.push(ErrorMessages.guidePageOutOfRange(index, questionData.guide_pdf_page, gbStart, gbEnd));
                                    }
                                }
                            }
                        } else if (questionData.question_type === 'matching') {
                            // Matching validation (same as in generateJSON)
                            if (!questionData.question_text || /^\d+$/.test(questionData.question_text)) {
                                validationErrors.push(ErrorMessages.requiredQuestionText(index));
                            }
                            
                            if (!questionData.left || questionData.left.length === 0) {
                                validationErrors.push(ErrorMessages.matchingNoLeftItems(index));
                            } else {
                                questionData.left.forEach((item, itemIdx) => {
                                    if (!item || item.trim() === '') {
                                        validationErrors.push(ErrorMessages.matchingEmptyLeftItem(index, itemIdx + 1));
                                    }
                                });
                            }
                            
                            if (!questionData.right || questionData.right.length === 0) {
                                validationErrors.push(ErrorMessages.matchingNoRightItems(index));
                            } else {
                                questionData.right.forEach((item, itemIdx) => {
                                    if (!item || item.trim() === '') {
                                        validationErrors.push(ErrorMessages.matchingEmptyRightItem(index, itemIdx + 1));
                                    }
                                });
                            }
                            
                            if (questionData.relationship && Array.isArray(questionData.relationship)) {
                                questionData.relationship.forEach((rel, relIdx) => {
                                    if (!Array.isArray(rel) || rel.length !== 2) {
                                        validationErrors.push(ErrorMessages.matchingIncompleteRelationship(index, relIdx + 1));
                                    } else {
                                        const [leftIdx, rightIdx] = rel;
                                        const leftCount = questionData.left ? questionData.left.length : 0;
                                        const rightCount = questionData.right ? questionData.right.length : 0;
                                        
                                        if (!leftIdx || !rightIdx) {
                                            validationErrors.push(ErrorMessages.matchingIncompleteRelationship(index, relIdx + 1));
                                        } else if (leftIdx < 1 || leftIdx > leftCount || rightIdx < 1 || rightIdx > rightCount) {
                                            validationErrors.push(ErrorMessages.matchingInvalidRelationship(index, leftIdx, rightIdx, leftCount, rightCount));
                                        }
                                    }
                                });
                            }
                            
                            if (!questionData.guide_pdf_page) {
                                validationErrors.push(ErrorMessages.requiredGuidePage(index));
                            } else if (isNaN(questionData.guide_pdf_page) || !Number.isInteger(questionData.guide_pdf_page) || questionData.guide_pdf_page <= 0) {
                                validationErrors.push(ErrorMessages.invalidGuidePage(index));
                            } else {
                                // Validate guide PDF page is within guidebook range
                                const gbStart = parseInt(guidebookStart, 10);
                                const gbEnd = parseInt(guidebookEnd, 10);
                                if (!isNaN(gbStart) && !isNaN(gbEnd) && gbStart > 0 && gbEnd > 0) {
                                    if (questionData.guide_pdf_page < gbStart || questionData.guide_pdf_page > gbEnd) {
                                        validationErrors.push(ErrorMessages.guidePageOutOfRange(index, questionData.guide_pdf_page, gbStart, gbEnd));
                                    }
                                }
                            }
                        } else {
                            // Validate other fields for all other types
                            if (!questionData.question_text || /^\d+$/.test(questionData.question_text)) {
                                validationErrors.push(ErrorMessages.requiredQuestionText(index));
                            }
                            
                            if (questionData.question_type === 'multiple_choice') {
                                if (!questionData.choices || questionData.choices.length === 0) {
                                    validationErrors.push(ErrorMessages.requiredChoices(index));
                                } else {
                                    // Validate choice IDs consistency (all filled or all empty)
                                    const choicesWithIDs = questionData.choices.filter(c => c.id && c.id.trim() !== '');
                                    if (choicesWithIDs.length > 0 && choicesWithIDs.length < questionData.choices.length) {
                                        validationErrors.push(ErrorMessages.inconsistentChoiceIDs(index, 'multiple_choice'));
                                }
                                }
                                // Validate value field (1-indexed position)
                                if (!questionData.value || typeof questionData.value !== 'number') {
                                    validationErrors.push(ErrorMessages.requiredCorrectAnswer(index));
                                } else if (questionData.value < 1 || questionData.value > questionData.choices.length) {
                                    validationErrors.push(`Question ${index + 1} (Multiple Choice) - Problem: Selected answer position (${questionData.value}) is out of range. You have ${questionData.choices.length} choices.\n    Fix: Select a valid answer position.`);
                                }
                                // guide_answer is now optional (for notes)
                            } else if (questionData.question_type === 'checkbox') {
                                // Checkbox validation
                                if (!questionData.choices || questionData.choices.length === 0) {
                                    validationErrors.push(ErrorMessages.requiredCheckboxChoices(index));
                                } else {
                                    // Validate choice IDs consistency (all filled or all empty)
                                    const choicesWithIDs = questionData.choices.filter(c => c.id && c.id.trim() !== '');
                                    if (choicesWithIDs.length > 0 && choicesWithIDs.length < questionData.choices.length) {
                                        validationErrors.push(ErrorMessages.inconsistentChoiceIDs(index, 'checkbox'));
                                    }
                                    
                                    // Validate values array
                                    if (!questionData.values || !Array.isArray(questionData.values)) {
                                        validationErrors.push(ErrorMessages.requiredCheckedChoice(index));
                                    } else if (questionData.values.length !== questionData.choices.length) {
                                        validationErrors.push(`Question ${index + 1} (Checkbox) - Problem: Mismatch between number of choices (${questionData.choices.length}) and values array (${questionData.values.length}).\n    Fix: Make sure each choice has a corresponding correct/incorrect value.`);
                                    } else if (!questionData.values.some(v => v === true)) {
                                        validationErrors.push(ErrorMessages.requiredCheckedChoice(index));
                                    }
                                }
                                // guide_answer is now optional (for notes)
                            } else {
                                // Free form - validate guide answer
                                if (!questionData.guide_answer) {
                                    validationErrors.push(ErrorMessages.requiredAnswer(index));
                                }
                            }
                            
                            // Validate guide PDF page
                            if (!questionData.guide_pdf_page) {
                                validationErrors.push(ErrorMessages.requiredGuidePage(index));
                            } else if (isNaN(questionData.guide_pdf_page) || !Number.isInteger(questionData.guide_pdf_page) || questionData.guide_pdf_page <= 0) {
                                validationErrors.push(ErrorMessages.invalidGuidePage(index));
                            } else {
                                // Validate guide PDF page is within guidebook range
                                const gbStart = parseInt(guidebookStart, 10);
                                const gbEnd = parseInt(guidebookEnd, 10);
                                if (!isNaN(gbStart) && !isNaN(gbEnd) && gbStart > 0 && gbEnd > 0) {
                                    if (questionData.guide_pdf_page < gbStart || questionData.guide_pdf_page > gbEnd) {
                                        validationErrors.push(ErrorMessages.guidePageOutOfRange(index, questionData.guide_pdf_page, gbStart, gbEnd));
                                    }
                                }
                            }
                        }
                        
                        // Only add question if no validation errors for this question
                        if (!validationErrors.some(e => e.startsWith(`Question ${index + 1}:`)) && 
                            !validationErrors.some(e => e.includes(`Question ${index + 1}`))) {
                            jsonData.practice_questions.push(questionData);
                        }
                    } catch (error) {
                        console.warn(`Question ${index + 1}: ${error.message}`);
                    }
                });

                if (validationErrors.length > 0) {
                    // For auto-save, don't show alerts but log to console and keep unsaved state
                    if (isAutoSave) {
                        console.warn('Auto-save blocked by validation errors:', validationErrors);
                        updateSaveIndicator('unsaved');
                        return;
                    }
                    alert("Cannot save - Validation errors found:\n" + validationErrors.join("\n"));
                    return;
                }

                // Show warnings if any (but don't block saving)
                // Only show alerts for manual saves, not auto-saves
                if (validationWarnings.length > 0 && !isAutoSave) {
                    alert("Validation warnings:\n" + validationWarnings.join("\n"));
                }

                // Add timestamp for tracking
                jsonData._save_timestamp = new Date().toISOString();
                
                const dataString = JSON.stringify(jsonData);
                
                localStorage.setItem(SAVE_KEY, dataString);
                lastSavedData = dataString;
                hasUnsavedChanges = false;
                
                updateSaveIndicator('saved');
                
                // Track session duration on save
                trackSessionDuration('save');
                
                // Track save with statistics
                const stats = getFormStats();
                trackEvent('progress_saved', {
                    save_type: isAutoSave ? 'auto' : 'manual',
                    total_questions: stats.totalQuestions,
                    total_content_sections: stats.totalContentSections,
                    question_type_free_form: stats.questionTypes.free_form || 0,
                    question_type_multiple_choice: stats.questionTypes.multiple_choice || 0,
                    question_type_checkbox: stats.questionTypes.checkbox || 0,
                    question_type_fill_in_the_blanks: stats.questionTypes.fill_in_the_blanks || 0,
                    question_type_matching: stats.questionTypes.matching || 0,
                    question_type_annotate: stats.questionTypes.annotate || 0,
                    question_type_create_table: stats.questionTypes.create_table || 0,
                    has_lesson_preamble: !!jsonData.lesson_preamble,
                    data_size: dataString.length
                });
                
                // Show brief success message
                const saveBtn = document.getElementById('saveBtn');
                if (saveBtn) {
                    const originalIcon = saveBtn.innerHTML;
                    saveBtn.innerHTML = '<i class="fas fa-check"></i>';
                    saveBtn.style.background = 'rgba(40, 167, 69, 0.3)';
                    
                    setTimeout(() => {
                        saveBtn.innerHTML = originalIcon;
                        saveBtn.style.background = '';
                    }, 1500);
                }
            } catch (e) {
                console.error('Failed to save form data:', e);
                alert('Failed to save progress: ' + e.message);
            }
        }
        
        // Load form data from localStorage - returns the JSON data directly
        function loadSavedData() {
            try {
                const savedData = localStorage.getItem(SAVE_KEY);
                if (savedData) {
                    const jsonData = JSON.parse(savedData);
                    return jsonData;
                }
            } catch (e) {
                console.error('Failed to load saved data:', e);
            }
            return null;
        }
        
        // Clear saved data
        function clearSavedData() {
            try {
                localStorage.removeItem(SAVE_KEY);
                lastSavedData = null;
                hasUnsavedChanges = false;
                updateSaveIndicator('none');
            } catch (e) {
                console.error('Failed to clear saved data:', e);
            }
        }
        
        // Track changes to form inputs and auto-save
        function attachChangeTrackers() {
            const container = document.querySelector('.container');
            if (!container) return;
            
            // Track initial values when fields get focus
            container.addEventListener('focusin', (e) => {
                if (e.target.matches('input, textarea, select')) {
                    // Skip search input - it shouldn't trigger auto-save
                    if (e.target.id === 'searchFilter') return;
                    
                    // Store the value when field gets focus
                    fieldValues.set(e.target, e.target.value);
                }
            }, true);
            
            // Track changes and auto-save on blur
            container.addEventListener('focusout', (e) => {
                if (e.target.matches('input, textarea, select')) {
                    // Skip search input - it shouldn't trigger auto-save
                    if (e.target.id === 'searchFilter') return;
                    
                    const originalValue = fieldValues.get(e.target);
                    const currentValue = e.target.value;
                    
                    // Check if value actually changed
                    if (originalValue !== currentValue) {
                        markFormAsChanged();
                        // Trigger auto-save after field loses focus and value changed
                        triggerAutoSave();
                    }
                    
                    // Clean up stored value
                    fieldValues.delete(e.target);
                }
            }, true);
            
            // Also track input events for immediate feedback (but save on blur)
            container.addEventListener('input', (e) => {
                if (e.target.matches('input, textarea, select')) {
                    // Skip search input - it shouldn't trigger auto-save
                    if (e.target.id === 'searchFilter') return;
                    
                    // Mark as changed immediately for visual feedback
                    const originalValue = fieldValues.get(e.target);
                    const currentValue = e.target.value;
                    
                    if (originalValue !== currentValue) {
                        markFormAsChanged();
                    }
                }
            });
            
            // Track when buttons modify the form (add/remove/duplicate items)
            container.addEventListener('click', (e) => {
                if (e.target.closest('.add-btn, .remove-btn, .duplicate-btn')) {
                    markFormAsChanged();
                    // Auto-save when items are added/removed/duplicated (after a short delay)
                    triggerAutoSave();
                }
            });
            
            // Track select changes (dropdowns)
            container.addEventListener('change', (e) => {
                if (e.target.matches('select')) {
                    markFormAsChanged();
                    triggerAutoSave();
                }
            });
        }
        
        // Warn user about unsaved changes on page reload/close
        function attachUnloadWarning() {
            window.addEventListener('beforeunload', (e) => {
                if (hasUnsavedChanges) {
                    // Prompt to save before leaving
                    const message = 'You have unsaved changes. Do you want to save before leaving?';
                    e.preventDefault();
                    e.returnValue = message;
                    
                    // Try to save automatically on unload (call the save function directly)
                    try {
                        saveProgress();
                    } catch (err) {
                        console.error('Failed to auto-save on unload:', err);
                    }
                    
                    return message;
                }
            });
        }
        
        // Add keyboard shortcut for save (Ctrl+S)
        function attachSaveKeyboardShortcut() {
            document.addEventListener('keydown', (e) => {
                // Ctrl+S or Cmd+S
                if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                    e.preventDefault();
                    saveProgress();
                }
            });
        }

        // Function to check for duplicate question IDs and highlight them
        function checkDuplicateQuestionIds() {
            const questionIds = new Map(); // Map to track question IDs
            const questionContainers = document.querySelectorAll('#questions_container > .array-item');
            const duplicates = new Set();
            
            // First pass: identify all duplicates
            questionContainers.forEach((questionEl) => {
                const questionIdInput = findFieldByLabel(questionEl, 'Question ID', 'input');
                if (questionIdInput && questionIdInput.value && questionIdInput.value.trim()) {
                    const qid = questionIdInput.value.trim();
                    if (questionIds.has(qid)) {
                        duplicates.add(qid);
                    } else {
                        questionIds.set(qid, questionIdInput);
                    }
                }
            });
            
            // Second pass: highlight all fields with duplicate IDs
            questionContainers.forEach((questionEl) => {
                const questionIdInput = findFieldByLabel(questionEl, 'Question ID', 'input');
                if (questionIdInput && questionIdInput.value && questionIdInput.value.trim()) {
                    const qid = questionIdInput.value.trim();
                    if (duplicates.has(qid)) {
                        // Highlight as error
                        questionIdInput.style.borderColor = '#dc3545';
                        questionIdInput.style.borderWidth = '2px';
                        questionIdInput.title = `Duplicate Question ID: "${qid}" appears multiple times`;
                    } else {
                        // Remove highlight
                        questionIdInput.style.borderColor = '';
                        questionIdInput.style.borderWidth = '';
                        questionIdInput.title = '';
                    }
                }
            });
        }

        // Function to attach duplicate question ID validation listeners
        function attachQuestionIdValidation() {
            // Use event delegation on the questions container
            const questionsContainer = document.getElementById('questions_container');
            if (questionsContainer) {
                questionsContainer.addEventListener('blur', function(event) {
                    // Check if the blurred element is a question ID input
                    const target = event.target;
                    if (target && target.matches('input[type="text"]')) {
                        const formGroup = target.closest('.form-group');
                        if (formGroup) {
                            const label = formGroup.querySelector('label');
                            if (label && label.textContent.includes('Question ID')) {
                                // This is a question ID field, check for duplicates
                                checkDuplicateQuestionIds();
                            }
                        }
                    }
                }, true); // Use capture phase to catch all blur events
                
                // Also check on input for immediate feedback
                questionsContainer.addEventListener('input', function(event) {
                    const target = event.target;
                    if (target && target.matches('input[type="text"]')) {
                        const formGroup = target.closest('.form-group');
                        if (formGroup) {
                            const label = formGroup.querySelector('label');
                            if (label && label.textContent.includes('Question ID')) {
                                // Debounce the check slightly to avoid too many calls
                                clearTimeout(window._questionIdCheckTimeout);
                                window._questionIdCheckTimeout = setTimeout(() => {
                                    checkDuplicateQuestionIds();
                                }, 500);
                            }
                        }
                    }
                }, true);
            }
        }

        // Initialize page
        window.onload = function() {
            
            // Check if user needs to reload for latest version (initial check)
            checkVersionReload();
            
            // Periodically check if reload is needed (every hour while page is open)
            setInterval(checkVersionReload, 60 * 60 * 1000);
            
            // Auto-load PDFs from IndexedDB storage (for both bbox modal and main PDF viewer)
            initializePdfStore();
            
            // Initialize dark mode
            initializeDarkMode();
            
            // Initialize font settings
            initializeFontSettings();
            
            // Initialize auto-resize toggle
            initializeAutoResize();
            
            // Set direction based on data-ltr attribute
            const allTextareas = document.querySelectorAll('textarea, input[type="text"]');
            allTextareas.forEach(ta => {
                if (ta.hasAttribute('data-ltr')) {
                    // LTR fields (JSON input, lesson standards)
                    ta.setAttribute('dir', 'ltr');
                } else {
                    // RTL fields (content, questions, titles, etc.)
                    ta.setAttribute('dir', 'rtl');
                }
                // CSS will handle the styling based on data-ltr attribute
            });
            
            // Then attach previews (which will inherit the correct direction)
            attachPreviews(document);
            
            // Update all existing direction toggle buttons to show correct text
            const allDirBtns = document.querySelectorAll('.dir-btn');
            allDirBtns.forEach(btn => {
                const textarea = btn.closest('.text-field-container')?.querySelector('textarea') || 
                                btn.parentElement?.querySelector('textarea') ||
                                btn.parentElement?.querySelector('input[type="text"]');
                if (textarea) {
                    const isLTR = textarea.hasAttribute('data-ltr');
                    // Button shows what clicking it will do
                    btn.textContent = isLTR ? 'RTL' : 'LTR';
                }
            });
            
            // Try to load saved data
            const savedData = loadSavedData();
            if (savedData) {
                const savedDate = savedData._save_timestamp ? new Date(savedData._save_timestamp) : new Date();
                const timeAgo = getTimeAgo(savedDate);
                
                if (confirm(`Found saved data from ${timeAgo}. Would you like to restore it?`)) {
                    try {
                        // Use the same populateFormFromJSON function that loads JSON
                        populateFormFromJSON(savedData);
                        
                        
                        // Set the initial saved state
                        lastSavedData = JSON.stringify(savedData);
                        hasUnsavedChanges = false;
                        updateSaveIndicator('saved');
                        
                        alert('Your previous work has been restored!');
                    } catch (e) {
                        console.error('Failed to restore saved data:', e);
                        alert('Failed to restore saved data. Starting with a clean form.');
                        clearSavedData();
                    }
                } else {
                    clearSavedData();
                }
            }
            
            // Attach change tracking (lightweight)
            attachChangeTrackers();
            
            // Attach unload warning for unsaved changes
            attachUnloadWarning();
            
            // Attach context listeners for PDF viewer auto-sync
            attachContextListeners();
            
            // Attach question ID duplicate validation
            attachQuestionIdValidation();
            
            // Attach Ctrl+S keyboard shortcut
            attachSaveKeyboardShortcut();
            
            // Attach bbox validation to all existing bbox fields on page load
            attachBboxValidation(document);
            
            // Fix any existing section/question numbering on page load
            updateContentSectionNumbers();
            updateQuestionNumbers();
            
            // Initialize new UX features
            initializeFieldValidation();
            updateQuickJumpMenu();
            
            // Set up observers for dynamic content updates
            const observer = new MutationObserver(() => {
                updateQuickJumpMenu();
            });
            
            observer.observe(document.getElementById('content_sections_container'), {
                childList: true,
                subtree: true
            });
            
            observer.observe(document.getElementById('questions_container'), {
                childList: true,
                subtree: true
            });
            
            // Check if we should auto-open What's New modal for new version
            checkAndOpenWhatsNew();
            
            // Update version displays (use DISPLAY_VERSION for UI, CURRENT_VERSION for internal tracking)
            const versionNumberEl = document.getElementById('version-number');
            const whatsNewVersionEl = document.getElementById('whats-new-version-number');
            if (versionNumberEl) {
                versionNumberEl.textContent = DISPLAY_VERSION;
            }
            if (whatsNewVersionEl) {
                whatsNewVersionEl.textContent = DISPLAY_VERSION;
            }
            
        };
        
        // Helper function to format time ago
        function getTimeAgo(date) {
            const seconds = Math.floor((new Date() - date) / 1000);
            
            if (seconds < 60) {
                return 'just now';
            }
            
            const minutes = Math.floor(seconds / 60);
            if (minutes < 60) {
                return `${minutes} minute${minutes !== 1 ? 's' : ''} ago`;
            }
            
            const hours = Math.floor(minutes / 60);
            if (hours < 24) {
                return `${hours} hour${hours !== 1 ? 's' : ''} ago`;
            }
            
            const days = Math.floor(hours / 24);
            if (days < 7) {
                return `${days} day${days !== 1 ? 's' : ''} ago`;
            }
            
            return date.toLocaleDateString() + ' at ' + date.toLocaleTimeString();
        }
        
        // Check if user needs to reload for latest version
        // Note: CURRENT_VERSION and VERSION_SEEN_KEY are defined at the top of the script (line ~10)
        function checkVersionReload() {
            try {
                const PAGE_LOAD_TIME_KEY = 'transcription_tool_page_load_time';
                const RELOAD_PROMPT_INTERVAL = 3 * 24 * 60 * 60 * 1000; // 3 days
                const PROMPT_SHOWN_KEY = 'transcription_tool_reload_prompt_shown';
                const CURRENT_VERSION_KEY = 'transcription_tool_current_version';
                // CURRENT_VERSION is defined above - use that
                const PAGE_LOAD_ID_KEY = 'transcription_tool_page_load_id';
                
                const now = new Date().getTime();
                const storedVersion = localStorage.getItem(CURRENT_VERSION_KEY);
                const storedPageLoadTime = localStorage.getItem(PAGE_LOAD_TIME_KEY);
                const currentPageLoadId = Date.now().toString() + Math.random().toString();
                const storedPageLoadId = sessionStorage.getItem(PAGE_LOAD_ID_KEY);
                
                // Check if this is a new version (page was updated)
                const isNewVersion = storedVersion !== CURRENT_VERSION;
                
                // Check if this is a fresh page load (new session or reload)
                const isFreshLoad = !storedPageLoadId;
                
                // If it's a new version, reset the page load time
                if (isNewVersion) {
                    localStorage.setItem(CURRENT_VERSION_KEY, CURRENT_VERSION);
                    localStorage.setItem(PAGE_LOAD_TIME_KEY, now.toString());
                    sessionStorage.removeItem(PROMPT_SHOWN_KEY);
                    sessionStorage.setItem(PAGE_LOAD_ID_KEY, currentPageLoadId);
                    return; // Don't prompt on fresh version load
                }
                
                // If this is a fresh page load (not just a periodic check), update the timestamp
                if (isFreshLoad) {
                    localStorage.setItem(PAGE_LOAD_TIME_KEY, now.toString());
                    sessionStorage.setItem(PAGE_LOAD_ID_KEY, currentPageLoadId);
                    return; // Don't prompt on fresh load
                }
                
                // Check how long the page has been loaded (using stored timestamp from when it was first loaded)
                if (!storedPageLoadTime) {
                    // Fallback: if no stored time, set it now
                    localStorage.setItem(PAGE_LOAD_TIME_KEY, now.toString());
                    return;
                }
                
                const pageLoadTime = parseInt(storedPageLoadTime, 10);
                const timeSincePageLoad = now - pageLoadTime;
                const promptShownTime = sessionStorage.getItem(PROMPT_SHOWN_KEY);
                
                // Only show prompt if enough time has passed since page load
                if (timeSincePageLoad > RELOAD_PROMPT_INTERVAL) {
                    // Don't show more than once per 5 minutes in the same session
                    if (!promptShownTime || (now - parseInt(promptShownTime, 10)) > 5 * 60 * 1000) {
                        // Show prompt
                        const shouldReload = confirm(
                            'You\'ve been using this page for a while. For the best experience, please reload the page to make sure you\'re using the latest version of the tool.\n\n' +
                            'Click OK to reload now, or Cancel to continue.'
                        );
                        
                        if (shouldReload) {
                            // Reset page load time on reload (will be set on fresh load after reload)
                            localStorage.setItem(PAGE_LOAD_TIME_KEY, now.toString());
                            location.reload();
                        } else {
                            // Remember we showed the prompt in this session
                            sessionStorage.setItem(PROMPT_SHOWN_KEY, now.toString());
                        }
                    }
                }
            } catch (e) {
                console.error('Error checking version reload:', e);
            }
        }

        // Open BBox drawer for textbook PDF upload
        function openBboxDrawerForTextbook() {
            // Set the target to indicate we want to load a textbook PDF
            window.__embeddedBboxTarget = { 
                inputs: null, 
                isGuide: false,
                isMainFormUpload: true 
            };
            openEmbeddedBboxModal();
        }

        // Open BBox drawer for guide PDF upload
        function openBboxDrawerForGuide() {
            // Set the target to indicate we want to load a guide PDF
            window.__embeddedBboxTarget = { 
                inputs: null, 
                isGuide: true,
                isMainFormUpload: true 
            };
            openEmbeddedBboxModal();
        }

        // Open BBox drawer for PDF uploads (textbook or guide)
        function openBboxDrawerForPDFs() {
            // Open the modal without setting a specific target, allowing user to choose PDF type
            window.__embeddedBboxTarget = { 
                inputs: null, 
                isGuide: null,
                isMainFormUpload: true 
            };
            openEmbeddedBboxModal();
        }

        // Helper function to restore original BBox modal layout
        function restoreBboxModalLayout() {
            const sidebar = document.querySelector('.bbox-sidebar');
            if (sidebar) {
                sidebar.style.display = '';
            }
            const content = document.querySelector('.bbox-content');
            if (content) {
                content.style.gridTemplateColumns = '';
            }
            const drawButtons = document.querySelectorAll('#em-add, #em-clear, #em-undo');
            drawButtons.forEach(btn => btn.style.display = '');
            const confirmBtn = document.getElementById('em-confirm');
            if (confirmBtn) {
                confirmBtn.textContent = 'Use Selected';
            }
        }

        // ===== MAIN PDF VIEWER IMPLEMENTATION =====
        
        // Global PDF Viewer State
        window.__mainPdfViewer = {
            visible: false,
            source: 'textbook', // 'textbook' | 'guide'
            currentPage: 1,
            totalPages: 0,
            scale: 1.0,
            fitToCanvasScale: null, // Scale to fit canvas, calculated per source
            pdfDoc: null,
            canvas: null,
            context: null,
            autoSyncEnabled: localStorage.getItem('pdfAutoNavEnabled') === 'true', // Load from localStorage
            lastSyncedPage: null,
            lastSyncedSource: null,
            lastManualNavTime: 0, // Track manual navigation to avoid interrupting user
            userNavigatedAway: false, // Flag to track if user manually navigated away
            elements: {},
            renderTask: null, // Track ongoing render operation
            isRendering: false // Flag to prevent concurrent renders
        };
        
        // Calculate fit-to-canvas scale for a PDF page
        function calculateFitToCanvasScale(page, container) {
            if (!page || !container) return 1.0;
            
            // Get container dimensions (account for padding)
            const containerWidth = container.clientWidth - 40; // 20px padding on each side
            const containerHeight = container.clientHeight - 40; // 20px padding on each side
            
            // Get page viewport at scale 1.0 to get natural dimensions
            const viewport = page.getViewport({ scale: 1.0 });
            
            if (!viewport || !viewport.width || !viewport.height) return 1.0;
            
            // Calculate scale to fit both width and height (use the smaller one to ensure it fits)
            const scaleX = containerWidth / viewport.width;
            const scaleY = containerHeight / viewport.height;
            const fitScale = Math.min(scaleX, scaleY, 8.0); // Cap at 8x zoom max
            
            // Ensure minimum scale
            return Math.max(fitScale, 0.1);
        }

        // Toggle Functions
        function showPdfViewer() {
            const jsonPanel = document.getElementById('json-preview-panel');
            const pdfPanel = document.getElementById('pdf-viewer-panel');
            const pdfBtn = document.getElementById('toggle-pdf-btn');
            const jsonBtn = document.getElementById('toggle-json-btn');
            
            if (!jsonPanel || !pdfPanel || !pdfBtn || !jsonBtn) return;
            
            jsonPanel.classList.remove('active');
            jsonPanel.style.display = 'none';
            
            pdfPanel.classList.add('active');
            pdfPanel.style.display = 'flex';
            
            pdfBtn.classList.add('active');
            jsonBtn.classList.remove('active');
            
            window.__mainPdfViewer.visible = true;
            
            // Initialize PDF viewer if not already loaded
            if (!window.__mainPdfViewer.canvas) {
                initializePdfViewer();
                // Wait for initialization to complete before loading PDF
                setTimeout(() => {
                    const loaded = loadPdfFromStore();
                    if (!loaded) {
                        const currentSource = window.__mainPdfViewer.source || 'textbook';
                        showPdfUploadPrompt(currentSource);
                    }
                }, 100);
            } else {
                // Viewer already initialized, try to load PDF immediately
                const loaded = loadPdfFromStore();
                if (!loaded) {
                    // Show message to upload PDF with current source
                    const currentSource = window.__mainPdfViewer.source || 'textbook';
                    showPdfUploadPrompt(currentSource);
                }
            }
            
            // Smart navigation to relevant page
            if (window.__mainPdfViewer.autoSyncEnabled) {
                setTimeout(() => navigateToContextPage(), 200);
            }
        }

        function showJsonPreview() {
            const jsonPanel = document.getElementById('json-preview-panel');
            const pdfPanel = document.getElementById('pdf-viewer-panel');
            const pdfBtn = document.getElementById('toggle-pdf-btn');
            const jsonBtn = document.getElementById('toggle-json-btn');
            
            if (!jsonPanel || !pdfPanel || !pdfBtn || !jsonBtn) return;
            
            pdfPanel.classList.remove('active');
            pdfPanel.style.display = 'none';
            
            jsonPanel.classList.add('active');
            jsonPanel.style.display = 'flex';
            
            pdfBtn.classList.remove('active');
            jsonBtn.classList.add('active');
            
            window.__mainPdfViewer.visible = false;
        }

        // Initialize PDF Viewer
        function initializePdfViewer() {
            const pdfPanel = document.getElementById('pdf-viewer-panel');
            if (!pdfPanel) return;
            
            // Create controls HTML
            const controlsHtml = `
                <div class="pdf-viewer-controls">
                    <!-- Source Toggle -->
                    <div class="pdf-source-toggle">
                        <button id="pdf-source-textbook" class="pdf-source-btn active" onclick="switchPdfSource('textbook')" title="Switch to textbook PDF">
                            <i class="fas fa-book"></i> Textbook
                        </button>
                        <button id="pdf-source-guide" class="pdf-source-btn" onclick="switchPdfSource('guide')" title="Switch to guidebook PDF">
                            <i class="fas fa-book-open"></i> Guide
                        </button>
                    </div>
                    
                    <!-- Auto Navigation Toggle -->
                    <div style="display: flex; align-items: center; gap: 6px;">
                        <button id="auto-nav-toggle" class="bbox-btn" type="button" onclick="toggleAutoNavigation()" title="Toggle Auto Page Navigation">
                            <i class="fas fa-magic"></i> <span id="auto-nav-status">Auto Nav: OFF</span>
                        </button>
                    </div>
                    
                    <!-- Zoom Controls -->
                    <div style="display: flex; align-items: center; gap: 6px;">
                        <button id="main-pdf-zoom-out" class="bbox-btn" type="button" title="Zoom out"></button>
                        <span id="main-pdf-zoom-display">100%</span>
                        <button id="main-pdf-zoom-in" class="bbox-btn" type="button" title="Zoom in">+</button>
                        <button id="main-pdf-zoom-reset" class="bbox-btn" type="button" title="Reset zoom to fit canvas"></button>
                    </div>
                    
                    <!-- Page Navigation -->
                    <div style="display: flex; align-items: center; gap: 6px;">
                        <button id="main-pdf-prev" class="bbox-btn" type="button" title="Previous page"></button>
                        <span id="main-pdf-page-display">Page 1/0</span>
                        <button id="main-pdf-next" class="bbox-btn" type="button" title="Next page"></button>
                        <input type="number" id="main-pdf-goto" min="1" placeholder="#" style="width: 60px; padding: 4px; border: 1px solid #dee2e6; border-radius: 4px;" title="Enter page number to jump to">
                        <button id="main-pdf-goto-btn" class="bbox-btn" type="button" title="Go to the specified page">Go</button>
                    </div>
                </div>
                <div class="pdf-canvas-container" id="pdf-canvas-container">
                    <canvas id="main-pdf-canvas"></canvas>
                </div>
            `;
            
            pdfPanel.innerHTML = controlsHtml;
            
            // Store element references - use setTimeout to ensure DOM is updated
            setTimeout(() => {
                const canvas = document.getElementById('main-pdf-canvas');
                if (canvas) {
                    window.__mainPdfViewer.canvas = canvas;
                    window.__mainPdfViewer.context = canvas.getContext('2d', { alpha: false });
                }
                
                window.__mainPdfViewer.elements = {
                    panel: pdfPanel,
                    canvas: canvas,
                    sourceToggle: {
                        textbook: document.getElementById('pdf-source-textbook'),
                        guide: document.getElementById('pdf-source-guide')
                    },
                    pageDisplay: document.getElementById('main-pdf-page-display'),
                    prevBtn: document.getElementById('main-pdf-prev'),
                    nextBtn: document.getElementById('main-pdf-next'),
                    gotoInput: document.getElementById('main-pdf-goto'),
                    gotoBtn: document.getElementById('main-pdf-goto-btn'),
                    zoomOutBtn: document.getElementById('main-pdf-zoom-out'),
                    zoomInBtn: document.getElementById('main-pdf-zoom-in'),
                    zoomResetBtn: document.getElementById('main-pdf-zoom-reset'),
                    zoomDisplay: document.getElementById('main-pdf-zoom-display')
                };
                
                const elements = window.__mainPdfViewer.elements;
                
                // Attach event listeners for zoom controls (use capture phase to ensure we handle first)
                if (elements.zoomInBtn) {
                    elements.zoomInBtn.addEventListener('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                        console.log('PDF Viewer: Zoom In clicked');
                        if (window.__mainPdfViewer && window.__mainPdfViewer.visible) {
                            zoomMainPdf('in');
                        }
                    }, true); // Use capture phase
                }
                if (elements.zoomOutBtn) {
                    elements.zoomOutBtn.addEventListener('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                        console.log('PDF Viewer: Zoom Out clicked');
                        if (window.__mainPdfViewer && window.__mainPdfViewer.visible) {
                            zoomMainPdf('out');
                        }
                    }, true); // Use capture phase
                }
                if (elements.zoomResetBtn) {
                    elements.zoomResetBtn.addEventListener('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                        console.log('PDF Viewer: Zoom Reset clicked');
                        if (window.__mainPdfViewer && window.__mainPdfViewer.visible) {
                            zoomMainPdf('reset');
                        }
                    }, true); // Use capture phase
                }
                
                // Attach event listeners for navigation controls
                if (elements.prevBtn) {
                    elements.prevBtn.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        navigateMainPdf('prev');
                    });
                }
                if (elements.nextBtn) {
                    elements.nextBtn.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        navigateMainPdf('next');
                    });
                }
                if (elements.gotoBtn) {
                    elements.gotoBtn.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        navigateMainPdf('goto');
                    });
                }
                if (elements.gotoInput) {
                    elements.gotoInput.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            e.stopPropagation();
                            navigateMainPdf('goto');
                        }
                    });
                }
                
                // Add scroll listener to save main PDF viewer scroll position automatically
                const mainPdfContainer = document.getElementById('pdf-canvas-container');
                if (mainPdfContainer) {
                    let mainScrollSaveTimeout;
                    mainPdfContainer.addEventListener('scroll', () => {
                        // Don't save scroll if we're currently restoring it or switching sources
                        if (window.__restoreScrollAfterRender || window.__switchingPdfSource) {
                            return;
                        }
                        clearTimeout(mainScrollSaveTimeout);
                        mainScrollSaveTimeout = setTimeout(() => {
                            // Double-check we're not switching (race condition protection)
                            if (window.__switchingPdfSource) {
                                return;
                            }
                            window.__mainPdfScroll = {
                                scrollLeft: mainPdfContainer.scrollLeft,
                                scrollTop: mainPdfContainer.scrollTop
                            };
                            // Persist scroll position to store for the current source
                            updatePdfStore();
                        }, 100);
                    });
                }
                
                // Initialize auto-navigation button UI state
                const statusEl = document.getElementById('auto-nav-status');
                const toggleBtn = document.getElementById('auto-nav-toggle');
                const autoNavEnabled = window.__mainPdfViewer.autoSyncEnabled;
                if (statusEl) {
                    statusEl.textContent = autoNavEnabled ? 'Auto Nav: ON' : 'Auto Nav: OFF';
                }
                if (toggleBtn) {
                    toggleBtn.style.backgroundColor = autoNavEnabled ? '#28a745' : '';
                    toggleBtn.style.color = autoNavEnabled ? 'white' : '';
                }
                
                // Load PDF from existing store if available (now that canvas is ready)
                // Wait a tiny bit more to ensure everything is set
                setTimeout(() => {
                    loadPdfFromStore();
                }, 10);
            }, 0);
        }

        function loadPdfFromStore() {
            // Wait a bit for store to be available
            const store = window.__bboxStore;
            if (!store) {
                console.log('PDF Store: window.__bboxStore not found');
                // Try to wait a bit and retry
                setTimeout(() => {
                    const retryStore = window.__bboxStore;
                    if (retryStore && retryStore.docs) {
                        loadPdfFromStore();
                    }
                }, 100);
                return false;
            }
            
            if (!store.docs) {
                console.log('PDF Store: store.docs not found', { store: store });
                return false;
            }
            
            const state = window.__mainPdfViewer;
            if (!state) {
                console.log('PDF Store: window.__mainPdfViewer not found');
                return false;
            }
            
            const source = state.source;
            const key = source === 'textbook' ? 'text' : 'guide';
            
            console.log('PDF Store: Loading PDF from store', { 
                source, 
                key, 
                hasStore: !!store, 
                hasDocs: !!store.docs, 
                storeKeys: store.docs ? Object.keys(store.docs) : [],
                hasKeyData: !!(store.docs && store.docs[key]),
                keyData: store.docs && store.docs[key] ? {
                    hasPdfDoc: !!store.docs[key].pdfDoc,
                    totalPages: store.docs[key].totalPages,
                    currentPage: store.docs[key].currentPage
                } : null
            });
            
            // Ensure store entry exists for this key with proper defaults
            if (!store.docs[key]) {
                store.docs[key] = {
                    pdfDoc: null,
                    currentPage: 1,
                    totalPages: 0,
                    mainViewerScale: 1.0, // Default scale to prevent white pages
                    scale: 1.0
                };
            }
            
            const docData = store.docs[key];
            
            // Ensure critical properties exist with defaults
            if (!docData.mainViewerScale || docData.mainViewerScale <= 0) {
                docData.mainViewerScale = docData.scale && docData.scale > 0 ? docData.scale : 1.0;
            }
            
            if (docData && docData.pdfDoc) {
                console.log('PDF Store: PDF found, loading...', { 
                    totalPages: docData.totalPages || docData.pdfDoc.numPages,
                    pdfDocType: typeof docData.pdfDoc,
                    hasNumPages: 'numPages' in docData.pdfDoc
                });
                
                // Clear last rendered state if PDF document changed
                if (state.pdfDoc !== docData.pdfDoc) {
                    state._lastRenderedState = null;
                }
                
                state.pdfDoc = docData.pdfDoc;
                state.totalPages = docData.totalPages || (docData.pdfDoc.numPages || 0);
                state.currentPage = docData.currentPage || 1;
                
                // Validate and set scale - ensure it's always a valid number > 0
                // This is critical to prevent white page issues after JSON load
                // Check each value individually to avoid using 0 or invalid values
                let loadedScale = null;
                if (docData.mainViewerScale && !isNaN(docData.mainViewerScale) && docData.mainViewerScale > 0) {
                    loadedScale = docData.mainViewerScale;
                } else if (docData.scale && !isNaN(docData.scale) && docData.scale > 0) {
                    loadedScale = docData.scale;
                } else {
                    // No saved scale - will be calculated as fit-to-canvas on first render
                    loadedScale = null;
                }
                
                // Final validation - should never be needed but just in case
                if (loadedScale !== null && (!loadedScale || isNaN(loadedScale) || loadedScale <= 0)) {
                    console.warn('PDF Store: Invalid scale detected after checks, will calculate fit-to-canvas', { loadedScale, docData });
                    loadedScale = null;
                }
                
                // If no valid scale found, it will be calculated as fit-to-canvas during render
                // For now, set a temporary value that will be replaced
                state.scale = loadedScale || 1.0;
                state.fitToCanvasScale = null; // Will be calculated on first render
                
                // Only save scale to store if we have a valid saved scale
                if (loadedScale) {
                docData.mainViewerScale = loadedScale;
                }
                
                // Ensure currentPage is valid
                if (state.currentPage < 1) state.currentPage = 1;
                if (state.totalPages > 0 && state.currentPage > state.totalPages) {
                    state.currentPage = state.totalPages;
                }
                
                // Restore scroll position for this source
                if (docData.mainViewerScrollLeft !== undefined || docData.mainViewerScrollTop !== undefined) {
                    window.__mainPdfScroll = {
                        scrollLeft: docData.mainViewerScrollLeft || 0,
                        scrollTop: docData.mainViewerScrollTop || 0
                    };
                    window.__restoreScrollAfterRender = true;
                    console.log('PDF Store: Loaded scroll position for restoration', {
                        source: source,
                        key: key,
                        scrollLeft: docData.mainViewerScrollLeft,
                        scrollTop: docData.mainViewerScrollTop
                    });
                } else {
                    // No saved scroll position - clear the restore flag and start fresh
                    window.__mainPdfScroll = null;
                    window.__restoreScrollAfterRender = false;
                    console.log('PDF Store: No saved scroll position found, starting at (0, 0)', {
                        source: source,
                        key: key,
                        docData: docData
                    });
                }
                
                updatePdfControls();
                
                // Force render - clear any upload prompt first
                const pdfPanel = document.getElementById('pdf-viewer-panel');
                const canvasContainer = pdfPanel?.querySelector('.pdf-canvas-container');
                if (canvasContainer) {
                    // Remove any upload prompt content
                    const uploadPrompt = canvasContainer.querySelector('[id*="pdf-upload"]');
                    if (uploadPrompt) {
                        // Restore canvas if it was replaced by upload prompt
                        if (!canvasContainer.querySelector('#main-pdf-canvas')) {
                            canvasContainer.innerHTML = '<canvas id="main-pdf-canvas"></canvas>';
                            // Reinitialize canvas reference
                            const canvas = document.getElementById('main-pdf-canvas');
                            if (canvas) {
                                state.canvas = canvas;
                                state.context = canvas.getContext('2d', { alpha: false });
                                if (state.elements) {
                                    state.elements.canvas = canvas;
                                }
                            }
                        }
                    }
                }
                
                // Only render if viewer is visible and state has actually changed
                if (state.visible) {
                    if (state.canvas && state.context) {
                        // Check if we actually need to render (state might not have changed)
                        const needsRender = !state._lastRenderedState || 
                                           state._lastRenderedState.page !== state.currentPage ||
                                           state._lastRenderedState.scale !== state.scale ||
                                           state._lastRenderedState.source !== state.source ||
                                           state._lastRenderedState.pdfDoc !== state.pdfDoc;
                        
                        if (needsRender) {
                            console.log('PDF Store: Canvas ready, rendering...', {
                                canvasWidth: state.canvas.width,
                                canvasHeight: state.canvas.height,
                                currentPage: state.currentPage,
                                totalPages: state.totalPages
                            });
                            renderMainPdfPage();
                        } else {
                            console.log('PDF Store: State unchanged, skipping render');
                        }
                    } else {
                        console.log('PDF Store: Canvas not ready, waiting...', { 
                            hasCanvas: !!state.canvas, 
                            hasContext: !!state.context,
                            visible: state.visible
                        });
                        // Wait a bit and try again
                        setTimeout(() => {
                            if (state.canvas && state.context && state.pdfDoc) {
                                console.log('PDF Store: Retrying render after canvas ready');
                                renderMainPdfPage();
                            } else {
                                // If still not ready, try to reinitialize
                                console.log('PDF Store: Canvas still not ready, checking initialization');
                                if (!state.canvas && state.elements && state.elements.canvas) {
                                    state.canvas = state.elements.canvas;
                                    state.context = state.canvas ? state.canvas.getContext('2d', { alpha: false }) : null;
                                    if (state.canvas && state.context) {
                                        renderMainPdfPage();
                                    }
                                } else if (state.canvas && !state.context) {
                                    state.context = state.canvas.getContext('2d', { alpha: false });
                                    if (state.context) {
                                        renderMainPdfPage();
                                    }
                                }
                            }
                        }, 200);
                    }
                }
                
                return true;
            } else {
                console.log('PDF Store: No PDF found in store', { 
                    docData: !!docData, 
                    hasPdfDoc: !!(docData && docData.pdfDoc),
                    availableKeys: store.docs ? Object.keys(store.docs) : []
                });
            }
            
            return false;
        }

        async function renderMainPdfPage() {
            const state = window.__mainPdfViewer;
            
            if (!state.pdfDoc) {
                console.warn('No PDF document available');
                showPdfUploadPrompt();
                return;
            }
            
            if (!state.canvas || !state.context) {
                console.warn('Canvas not initialized');
                return;
            }
            
            // Don't render if viewer is not visible (optimization)
            if (!state.visible) {
                return;
            }
            
            // Track last rendered state to avoid unnecessary rerenders
            if (!state._lastRenderedState) {
                state._lastRenderedState = {};
            }
            const lastRendered = state._lastRenderedState;
            const currentPage = state.currentPage || 1;
            const currentScale = state.scale || 1.0;
            const currentSource = state.source || 'textbook';
            
            // Skip render if page, scale, and source haven't changed
            if (lastRendered.page === currentPage && 
                lastRendered.scale === currentScale && 
                lastRendered.source === currentSource &&
                lastRendered.pdfDoc === state.pdfDoc) {
                return; // No changes, skip render
            }
            
            // Cancel any ongoing render operation and properly wait for cancellation
            // This prevents "Cannot use the same canvas during multiple render() operations" error
            if (state.renderTask) {
                console.log('PDF Render: Cancelling existing render task...');
                const oldRenderTask = state.renderTask;
                state.renderTask = null;
                state.isRendering = false; // Clear flag immediately
                
                try {
                    // Cancel the render task
                    oldRenderTask.cancel();
                    
                    // Wait for cancellation to complete - the promise will reject when cancelled
                    // We must wait for this to ensure PDF.js releases the canvas
                    try {
                        await Promise.race([
                            oldRenderTask.promise,
                            new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 1000))
                        ]).catch((error) => {
                            // Expected: cancellation throws RenderingCancelledException or timeout
                            // This is normal, we just need to wait for PDF.js to release the canvas
                            if (error.name !== 'RenderingCancelledException' && error.message !== 'Timeout') {
                                console.warn('PDF Render: Unexpected error during cancellation', error);
                            }
                        });
                    } catch (cancelError) {
                        // Ignore cancellation errors - this is expected when cancelling
                    }
                } catch (e) {
                    // Ignore any errors during cancellation
                    console.warn('PDF Render: Error during render task cancellation', e);
                }
                
                // Wait a bit to ensure canvas is fully released before starting new render
                // This is critical to prevent canvas lock conflicts when uploading new PDFs
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            // Prevent concurrent renders - but add timeout to prevent stuck flag
            if (state.isRendering) {
                console.log('PDF Render: Render already in progress, skipping...', { 
                    hasRenderTask: !!state.renderTask,
                    scale: state.scale 
                });
                // If isRendering is true but no renderTask, clear it (defensive)
                if (!state.renderTask) {
                    console.warn('PDF Render: isRendering flag stuck without renderTask, clearing it');
                    state.isRendering = false;
                } else {
                return;
                }
            }
            
            if (!state.currentPage || state.currentPage < 1) {
                state.currentPage = 1;
            }
            if (state.currentPage > state.totalPages) {
                state.currentPage = state.totalPages;
            }
            
            // Validate scale - ensure it's always a valid number > 0
            // This prevents white page issues when scale is invalid after loading JSON or switching sources
            if (!state.scale || isNaN(state.scale) || state.scale <= 0) {
                console.warn('PDF Render: Invalid scale detected, resetting to 1.0', { scale: state.scale });
                state.scale = 1.0;
                // Save corrected scale to store immediately to prevent state corruption
                const store = window.__bboxStore = window.__bboxStore || {};
                store.docs = store.docs || { text: {}, guide: {} };
                const key = state.source === 'textbook' ? 'text' : 'guide';
                if (store.docs[key]) {
                    store.docs[key].mainViewerScale = 1.0;
                }
            }
            
            state.isRendering = true;
            
            try {
                const page = await state.pdfDoc.getPage(state.currentPage);
                const canvas = state.canvas;
                const context = state.context;
                const container = canvas.parentElement;
                
                // Get container width to constrain canvas size (account for padding)
                const containerWidth = container ? container.clientWidth - 40 : 800;
                
                // Calculate and store fit-to-canvas scale if not already set (do this first)
                if (!state.fitToCanvasScale || state.fitToCanvasScale <= 0) {
                    state.fitToCanvasScale = calculateFitToCanvasScale(page, container);
                    console.log('PDF Render: Calculated fit-to-canvas scale', { 
                        fitToCanvasScale: state.fitToCanvasScale,
                        containerWidth: container ? container.clientWidth : 0,
                        containerHeight: container ? container.clientHeight : 0
                    });
                }
                
                // CRITICAL: Final validation of scale right before creating viewport
                // This prevents white page issues when scale is invalid (e.g., after JSON load)
                if (!state.scale || isNaN(state.scale) || state.scale <= 0 || state.scale === 0) {
                    console.warn('PDF Render: Invalid scale detected before viewport creation, resetting to fit-to-canvas', { scale: state.scale });
                    state.scale = state.fitToCanvasScale || 1.0; // Use fit-to-canvas if available, else fallback to 1.0
                    // Save corrected scale to store
                    const store = window.__bboxStore = window.__bboxStore || {};
                    store.docs = store.docs || { text: {}, guide: {} };
                    const key = state.source === 'textbook' ? 'text' : 'guide';
                    if (store.docs[key]) {
                        store.docs[key].mainViewerScale = state.scale;
                    }
                }
                
                // If scale is still 1.0 (default) and we haven't loaded a saved scale, use fit-to-canvas
                // Check if this is a fresh load by checking if scale hasn't been set from store
                if (state.scale === 1.0 && state.fitToCanvasScale && state.fitToCanvasScale > 0) {
                    // Only use fit-to-canvas if we don't have a saved scale (indicated by checking store)
                    const store = window.__bboxStore;
                    const key = state.source === 'textbook' ? 'text' : 'guide';
                    const hasSavedScale = store && store.docs && store.docs[key] && 
                                        store.docs[key].mainViewerScale && 
                                        store.docs[key].mainViewerScale !== 1.0 &&
                                        store.docs[key].mainViewerScale > 0;
                    
                    if (!hasSavedScale) {
                        state.scale = state.fitToCanvasScale;
                        // Save the fit-to-canvas scale to store
                        if (store && store.docs && store.docs[key]) {
                            store.docs[key].mainViewerScale = state.fitToCanvasScale;
                        }
                        console.log('PDF Render: Using fit-to-canvas scale as default', { 
                            fitToCanvasScale: state.fitToCanvasScale 
                        });
                    }
                }
                
                // Render at the desired scale - this is the actual zoom level
                let viewport = page.getViewport({ scale: state.scale });
                
                // CRITICAL: Validate viewport dimensions - if they're zero or invalid, reset scale and recreate
                if (!viewport || !viewport.width || !viewport.height || viewport.width <= 0 || viewport.height <= 0) {
                    console.error('PDF Render: Invalid viewport dimensions, resetting scale to fit-to-canvas and recreating viewport', {
                        viewportWidth: viewport?.width,
                        viewportHeight: viewport?.height,
                        scale: state.scale,
                        fitToCanvasScale: state.fitToCanvasScale
                    });
                    state.scale = state.fitToCanvasScale || 1.0; // Use fit-to-canvas if available
                    viewport = page.getViewport({ scale: state.scale });
                    // Save corrected scale to store
                    const store = window.__bboxStore = window.__bboxStore || {};
                    store.docs = store.docs || { text: {}, guide: {} };
                    const key = state.source === 'textbook' ? 'text' : 'guide';
                    if (store.docs[key]) {
                        store.docs[key].mainViewerScale = state.scale;
                    }
                }
                
                // Get device pixel ratio for high-DPI rendering (ensures 100% quality at all zoom levels)
                const dpr = window.devicePixelRatio || 1;
                
                // Set canvas internal dimensions with devicePixelRatio for crisp rendering
                canvas.width = Math.floor(viewport.width * dpr);
                canvas.height = Math.floor(viewport.height * dpr);
                
                // Reset transform and scale the context to account for devicePixelRatio
                context.setTransform(1, 0, 0, 1, 0, 0);
                context.scale(dpr, dpr);
                
                // Clear the canvas first
                context.clearRect(0, 0, viewport.width, viewport.height);
                
                // Set canvas CSS display size to actual zoomed size (use viewport dimensions, not multiplied)
                // The container has overflow: auto, so it will scroll when canvas is larger
                // Column width stays fixed because container has max-width: 100% and form-section has overflow: hidden
                canvas.style.width = viewport.width + 'px';
                canvas.style.height = viewport.height + 'px';
                canvas.style.maxWidth = 'none'; // Allow canvas to be larger than container for scrolling
                canvas.style.minWidth = 'none';
                canvas.style.display = 'block'; // Ensure block display
                canvas.style.boxSizing = 'content-box'; // Ensure padding/border don't affect size
                
                console.log('PDF Render: Rendering at zoom level', { 
                    zoomScale: state.scale, 
                    viewportWidth: viewport.width,
                    viewportHeight: viewport.height,
                    containerWidth: containerWidth
                });
                
                const renderContext = {
                    canvasContext: context,
                    viewport: viewport
                };
                
                // Store the render task so we can cancel it if needed
                const renderTask = page.render(renderContext);
                state.renderTask = renderTask;
                
                await renderTask.promise;
                
                // Clear render task after successful completion
                state.renderTask = null;
                state.isRendering = false;
                
                // Update last rendered state to prevent unnecessary rerenders
                state._lastRenderedState = {
                    page: currentPage,
                    scale: currentScale,
                    source: currentSource,
                    pdfDoc: state.pdfDoc
                };
                
                updatePdfControls();
                
                // Restore main PDF viewer scroll position after rendering BEFORE calling updatePdfStore
                // This ensures we don't save the wrong scroll position
                if (window.__mainPdfScroll && (window.__restoreScrollAfterRender || !window.__mainPdfScrollSaved)) {
                    const mainPdfContainer = document.getElementById('pdf-canvas-container');
                    if (mainPdfContainer) {
                        const scrollToRestore = { ...window.__mainPdfScroll };
                        console.log('PDF Viewer: Preparing to restore scroll', {
                            scrollLeft: scrollToRestore.scrollLeft,
                            scrollTop: scrollToRestore.scrollTop,
                            containerReady: !!mainPdfContainer,
                            restoreFlag: window.__restoreScrollAfterRender
                        });
                        
                        // Use triple requestAnimationFrame + small timeout to ensure canvas is fully rendered
                        requestAnimationFrame(() => {
                            requestAnimationFrame(() => {
                                requestAnimationFrame(() => {
                                    // Ensure flag is set to prevent scroll listener from interfering during restoration
                                    window.__restoreScrollAfterRender = true;
                                    
                                    // Small additional delay to ensure canvas dimensions are finalized
                                    setTimeout(() => {
                                mainPdfContainer.scrollLeft = scrollToRestore.scrollLeft || 0;
                                mainPdfContainer.scrollTop = scrollToRestore.scrollTop || 0;
                                        
                                console.log('PDF Viewer: Scroll restored', { 
                                    scrollLeft: scrollToRestore.scrollLeft, 
                                    scrollTop: scrollToRestore.scrollTop,
                                    actualScrollLeft: mainPdfContainer.scrollLeft,
                                    actualScrollTop: mainPdfContainer.scrollTop,
                                    scrollWidth: mainPdfContainer.scrollWidth,
                                    scrollHeight: mainPdfContainer.scrollHeight,
                                    clientWidth: mainPdfContainer.clientWidth,
                                    clientHeight: mainPdfContainer.clientHeight
                                });
                                        
                                        // Wait a bit before clearing the flag and allowing scroll listener to work again
                                        setTimeout(() => {
                                window.__restoreScrollAfterRender = false;
                                            window.__switchingPdfSource = false; // Clear switching flag after restoration
                                
                                // Now save the restored position to store
                                updatePdfStore();
                                        }, 100);
                                    }, 50);
                                });
                            });
                        });
                    } else {
                        // No container, just update store
                        window.__restoreScrollAfterRender = false;
                        updatePdfStore();
                    }
                } else {
                    // No scroll to restore, update store normally
                    window.__restoreScrollAfterRender = false;
                    updatePdfStore();
                }
                
            } catch (error) {
                state.isRendering = false;
                state.renderTask = null;
                
                // Don't show error if it was just a cancellation
                if (error.name === 'RenderingCancelledException') {
                    console.log('PDF Render: Render was cancelled');
                    return;
                }
                
                // Handle canvas conflict error - this can happen when uploading new PDFs
                // Retry after a delay to allow the canvas to be released
                if (error.message && error.message.includes('Cannot use the same canvas')) {
                    console.warn('PDF Render: Canvas conflict detected, retrying after delay...', error);
                    // Wait a bit longer and retry
                    setTimeout(() => {
                        if (state.pdfDoc && state.canvas && state.context && !state.isRendering) {
                            console.log('PDF Render: Retrying render after canvas conflict');
                            renderMainPdfPage();
                        }
                    }, 200);
                    return;
                }
                
                console.error('Error rendering PDF page:', error);
                showPdfError('Failed to render page: ' + (error.message || 'Unknown error'));
            }
        }

        function updatePdfControls() {
            const state = window.__mainPdfViewer;
            const elements = state.elements;
            
            if (!elements.pageDisplay) return;
            
            elements.pageDisplay.textContent = `Page ${state.currentPage}/${state.totalPages}`;
            
            if (elements.zoomDisplay) {
                elements.zoomDisplay.textContent = `${Math.round(state.scale * 100)}%`;
            }
            
            if (elements.gotoInput) {
                elements.gotoInput.value = state.currentPage;
                elements.gotoInput.max = state.totalPages;
            }
            
            if (elements.prevBtn) {
                elements.prevBtn.disabled = state.currentPage <= 1;
            }
            if (elements.nextBtn) {
                elements.nextBtn.disabled = state.currentPage >= state.totalPages;
            }
            
            if (elements.sourceToggle) {
                if (elements.sourceToggle.textbook) {
                    elements.sourceToggle.textbook.classList.toggle('active', state.source === 'textbook');
                }
                if (elements.sourceToggle.guide) {
                    elements.sourceToggle.guide.classList.toggle('active', state.source === 'guide');
                }
            }
        }

        function updatePdfStore() {
            const state = window.__mainPdfViewer;
            const store = window.__bboxStore = window.__bboxStore || {};
            store.docs = store.docs || { text: {}, guide: {} };
            
            // Save main PDF viewer scroll position for the current source
            const mainPdfContainer = document.getElementById('pdf-canvas-container');
            const key = state.source === 'textbook' ? 'text' : 'guide';
            
            if (mainPdfContainer && store.docs[key]) {
                store.docs[key].mainViewerScrollLeft = mainPdfContainer.scrollLeft;
                store.docs[key].mainViewerScrollTop = mainPdfContainer.scrollTop;
                
                console.log('PDF Store: Saving scroll position', {
                    source: state.source,
                    key: key,
                    scrollLeft: mainPdfContainer.scrollLeft,
                    scrollTop: mainPdfContainer.scrollTop
                });
                
                // Don't update window.__mainPdfScroll here - it should only be updated by:
                // 1. The scroll listener (for continuous saving)
                // 2. loadPdfFromStore() (when loading saved position for a source)
                // This prevents overwriting the scroll position when switching sources
            }
            
            // Update store for page/source tracking
            if (store.docs[key]) {
                store.docs[key].currentPage = state.currentPage;
                // Save main viewer scale separately from bbox modal scale
                store.docs[key].mainViewerScale = state.scale;
            }
        }

        function navigateMainPdf(direction) {
            const state = window.__mainPdfViewer;
            
            if (!state.pdfDoc) return;
            
            let newPage = state.currentPage;
            
            switch(direction) {
                case 'prev':
                    if (state.currentPage > 1) {
                        newPage = state.currentPage - 1;
                    }
                    break;
                case 'next':
                    if (state.currentPage < state.totalPages) {
                        newPage = state.currentPage + 1;
                    }
                    break;
                case 'goto':
                    const input = state.elements.gotoInput;
                    if (input) {
                        const targetPage = parseInt(input.value, 10);
                        if (targetPage >= 1 && targetPage <= state.totalPages) {
                            newPage = targetPage;
                        }
                    }
                    break;
            }
            
            if (newPage !== state.currentPage) {
                state.currentPage = newPage;
                state.lastSyncedPage = null; // Disable auto-sync after manual navigation
                state.lastManualNavTime = Date.now(); // Track manual navigation time
                state.userNavigatedAway = true; // Mark that user manually navigated
                renderMainPdfPage();
            }
        }
        
        // Helper function for programmatic navigation (used by auto-navigation)
        function navigateMainPdfToPage(pageNum) {
            const state = window.__mainPdfViewer;
            
            if (!state.pdfDoc) return;
            
            if (pageNum >= 1 && pageNum <= state.totalPages && pageNum !== state.currentPage) {
                state.currentPage = pageNum;
                // Don't mark as user navigated since this is programmatic
                renderMainPdfPage();
                updatePdfControls(); // Ensure controls are updated
            }
        }

        function zoomMainPdf(action) {
            const state = window.__mainPdfViewer;
            
            // Ensure we're only affecting the main viewer, not bbox modal
            if (!state || !state.pdfDoc) {
                console.warn('zoomMainPdf: No PDF doc in main viewer');
                return;
            }
            
            const oldScale = state.scale;
            
            switch(action) {
                case 'in':
                    state.scale = Math.min(state.scale * 1.2, 8.0);
                    break;
                case 'out':
                    state.scale = Math.max(state.scale / 1.2, 0.3);
                    break;
                case 'reset':
                    // Reset to fit-to-canvas scale, recalculate if needed
                    if (state.pdfDoc && state.canvas && state.currentPage) {
                        state.pdfDoc.getPage(state.currentPage).then(page => {
                            const container = state.canvas.parentElement;
                            if (container && page) {
                                state.fitToCanvasScale = calculateFitToCanvasScale(page, container);
                                state.scale = state.fitToCanvasScale;
                            } else {
                                state.scale = state.fitToCanvasScale || 1.0;
                            }
                            renderMainPdfPage();
                        }).catch(err => {
                            console.warn('PDF Viewer: Error calculating fit-to-canvas on reset', err);
                            state.scale = state.fitToCanvasScale || 1.0;
                            renderMainPdfPage();
                        });
                        return; // Early return, renderMainPdfPage will be called in the promise
                    } else {
                        // Fallback to stored fit-to-canvas scale or 1.0
                        state.scale = state.fitToCanvasScale || 1.0;
                        renderMainPdfPage();
                    }
                    break;
            }
            
            console.log('PDF Viewer: Zoom changed', { action, oldScale, newScale: state.scale });
            
            // Save the zoom scale for the current source
            const store = window.__bboxStore = window.__bboxStore || {};
            store.docs = store.docs || { text: {}, guide: {} };
            const key = state.source === 'textbook' ? 'text' : 'guide';
            if (store.docs[key]) {
                store.docs[key].mainViewerScale = state.scale;
            }
            
            // Only update the store's scale for the main viewer, don't affect bbox modal
                renderMainPdfPage();
        }

        function switchPdfSource(source) {
            const state = window.__mainPdfViewer;
            
            if (state.source === source) return;
            
            console.log('PDF Viewer: Switching source', {
                from: state.source,
                to: source
            });
            
            // Set flag to prevent scroll listener from interfering during source switch
            window.__switchingPdfSource = true;
            
            // CRITICAL: Save current scroll/zoom state BEFORE switching
            // Read scroll position directly from DOM to ensure we have the latest value
            const mainPdfContainer = document.getElementById('pdf-canvas-container');
            const oldSource = state.source;
            const oldKey = oldSource === 'textbook' ? 'text' : 'guide';
            const store = window.__bboxStore = window.__bboxStore || {};
            store.docs = store.docs || { text: {}, guide: {} };
            
            // Ensure store entry exists for the old source
            if (!store.docs[oldKey]) {
                store.docs[oldKey] = {};
            }
            
            // Save current scroll position directly from DOM for the source we're leaving
            if (mainPdfContainer) {
                store.docs[oldKey].mainViewerScrollLeft = mainPdfContainer.scrollLeft;
                store.docs[oldKey].mainViewerScrollTop = mainPdfContainer.scrollTop;
                console.log('PDF Store: Saved scroll position for old source', {
                    source: oldSource,
                    key: oldKey,
                    scrollLeft: mainPdfContainer.scrollLeft,
                    scrollTop: mainPdfContainer.scrollTop
                });
            }
            
            // Save current zoom/scale and page for the old source
            store.docs[oldKey].mainViewerScale = state.scale;
            store.docs[oldKey].currentPage = state.currentPage;
            
            // Clear scroll restoration state to ensure we load fresh scroll for new source
            window.__mainPdfScroll = null;
            window.__restoreScrollAfterRender = false;
            
            // Switch source
            state.source = source;
            state.lastSyncedPage = null;
            state.lastSyncedSource = null;
            // Clear last rendered state when switching sources to force render
            state._lastRenderedState = null;
            
            // Update source toggle button visual state
            if (state.elements && state.elements.sourceToggle) {
                if (state.elements.sourceToggle.textbook) {
                    state.elements.sourceToggle.textbook.classList.toggle('active', source === 'textbook');
                }
                if (state.elements.sourceToggle.guide) {
                    state.elements.sourceToggle.guide.classList.toggle('active', source === 'guide');
                }
            }
            
            // Load PDF from store for the new source (this will also trigger render and scroll restoration)
            const loaded = loadPdfFromStore();
            
            if (!loaded) {
                // PDF not found in store, show upload prompt with the correct source
                window.__switchingPdfSource = false; // Clear flag if load failed
                showPdfUploadPrompt(source);
                return;
            }
            
            // CRITICAL: Ensure scale is valid after loading to prevent white page issues
            // loadPdfFromStore() will handle rendering - we just need to validate scale is correct
            // Don't force another render here as it will conflict with loadPdfFromStore()'s render
            if (state.pdfDoc) {
                // Validate scale one more time and save to store if needed
                if (!state.scale || isNaN(state.scale) || state.scale <= 0) {
                    console.warn('PDF Viewer: Invalid scale after source switch, resetting to 1.0', { scale: state.scale, source });
                    state.scale = 1.0;
                    // Save corrected scale to store immediately
                    const store = window.__bboxStore = window.__bboxStore || {};
                    store.docs = store.docs || { text: {}, guide: {} };
                    const key = source === 'textbook' ? 'text' : 'guide';
                    if (store.docs[key]) {
                        store.docs[key].mainViewerScale = 1.0;
                    }
                }
            }
            
            // loadPdfFromStore() will handle rendering and scroll restoration
            // Auto-navigate to the appropriate page after switching sources (only if auto-navigation is enabled)
            if (state.autoSyncEnabled && state.pdfDoc && state.totalPages) {
                if (source === 'guide') {
                    // Navigate to a page within the guidebook range when switching to guidebook
                    const guidebookPage = getGuidebookPageInRange();
                    if (guidebookPage && guidebookPage > 0 && guidebookPage <= state.totalPages) {
                            // Wait for PDF to be fully loaded and rendered, then navigate
                            setTimeout(() => {
                            // Re-check autoSyncEnabled before navigating (user might have turned it off)
                            if (state.autoSyncEnabled) {
                                navigateMainPdfToPage(guidebookPage);
                            }
                            }, 300);
                    }
                } else if (source === 'textbook') {
                    // Navigate to textbook PDF page when switching to textbook
                    const textbookPageInput = document.getElementById('textbook_pdf_page');
                    if (textbookPageInput && textbookPageInput.value) {
                        const textbookPage = parseInt(textbookPageInput.value, 10);
                        if (!isNaN(textbookPage) && textbookPage > 0 && textbookPage <= state.totalPages) {
                            // Wait for PDF to be fully loaded and rendered, then navigate
                            setTimeout(() => {
                                // Re-check autoSyncEnabled before navigating (user might have turned it off)
                                if (state.autoSyncEnabled) {
                                navigateMainPdfToPage(textbookPage);
                                }
                            }, 300);
                        }
                    }
                }
            }
            
            // Clear the switching flag after scroll restoration completes (handled in renderMainPdfPage)
            // Also set a timeout as backup in case restoration doesn't trigger
            setTimeout(() => {
                window.__switchingPdfSource = false;
            }, 500);
        }

        function showPdfUploadPrompt(source) {
            const pdfPanel = document.getElementById('pdf-viewer-panel');
            const canvasContainer = pdfPanel?.querySelector('.pdf-canvas-container');
            const state = window.__mainPdfViewer;
            const pdfSource = source || state?.source || 'textbook';
            
            if (canvasContainer) {
                const isTextbook = pdfSource === 'textbook';
                const uploadBtnId = isTextbook ? 'pdf-upload-textbook-btn' : 'pdf-upload-guide-btn';
                
                canvasContainer.innerHTML = `
                    <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; color: #6c757d; padding: 20px;">
                        <i class="fas fa-file-pdf" style="font-size: 48px; margin-bottom: 16px; opacity: 0.5;"></i>
                        <p style="font-size: 16px; margin-bottom: 8px;">No ${isTextbook ? 'Textbook' : 'Guide'} PDF loaded</p>
                        <p style="font-size: 14px; margin-bottom: 16px;">Upload a ${isTextbook ? 'Textbook' : 'Guide'} PDF to view it here</p>
                        <button id="${uploadBtnId}" class="add-btn" style="margin: 8px;">
                            <i class="fas fa-file-upload"></i> Upload ${isTextbook ? 'Textbook' : 'Guide'} PDF
                        </button>
                    </div>
                `;
                
                // Attach event listener
                const uploadBtn = document.getElementById(uploadBtnId);
                if (uploadBtn) {
                    uploadBtn.addEventListener('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        if (isTextbook) {
                            openBboxDrawerForTextbook();
                        } else {
                            openBboxDrawerForGuide();
                        }
                    });
                }
            }
        }

        function showPdfError(message) {
            const pdfPanel = document.getElementById('pdf-viewer-panel');
            const canvasContainer = pdfPanel?.querySelector('.pdf-canvas-container');
            
            if (canvasContainer) {
                canvasContainer.innerHTML = `
                    <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; color: #dc3545; padding: 20px;">
                        <i class="fas fa-exclamation-triangle" style="font-size: 48px; margin-bottom: 16px;"></i>
                        <p style="font-size: 16px; text-align: center;">${message}</p>
                    </div>
                `;
            }
        }

        // Smart Context-Aware Navigation
        function detectFormContext() {
            const context = {
                activeTab: null,
                activeSection: null,
                activeQuestion: null,
                focusedField: null,
                page: null,
                source: 'textbook',
                questionPage: null,  // For questions: textbook page
                answerPage: null     // For questions: guide page
            };
            
            // Detect active tab
            const activeTab = document.querySelector('.tab.active');
            if (activeTab) {
                context.activeTab = activeTab.textContent.trim().toLowerCase();
            }
            
            // Detect focused element
            const focused = document.activeElement;
            if (focused) {
                context.focusedField = focused;
                
                // Find parent section/question
                const section = focused.closest('.array-item');
                if (section) {
                    // Check if it's a content section
                    if (section.closest('#content_sections_container')) {
                        context.activeSection = getSectionIndex(section);
                        context.page = extractPageFromSection(section, 'content');
                    }
                    // Check if it's a question
                    else if (section.closest('#questions_container')) {
                        context.activeQuestion = getQuestionIndex(section);
                        
                        // Extract both question and answer pages for questions
                        context.questionPage = extractPageFromQuestion(section, 'question');
                        context.answerPage = extractPageFromQuestion(section, 'answer');
                        
                        // Determine if we're editing question or answer fields
                        const fieldType = detectQuestionFieldType(focused, section);
                        if (fieldType === 'answer') {
                            context.source = 'guide';
                            context.page = context.answerPage;
                        } else {
                            context.source = 'textbook';
                            context.page = context.questionPage;
                        }
                    }
                }
            }
            
            // Fallback: Check current tab and use appropriate default
            if (!context.page) {
                // Get default page based on current viewer source
                const viewerSource = window.__mainPdfViewer?.source || 'textbook';
                const defaultPages = getDefaultPageForTab(context.activeTab);
                
                if (defaultPages) {
                    if (viewerSource === 'guide' && defaultPages.guidePage) {
                        context.page = defaultPages.guidePage;
                        context.source = 'guide';
                    } else if (defaultPages.textbookPage) {
                        context.page = defaultPages.textbookPage;
                        context.source = 'textbook';
                    }
                }
            }
            
            return context;
        }

        function extractPageFromSection(section, type) {
            const bboxContainer = section.querySelector('.bbox-container');
            if (!bboxContainer) return null;
            
            const firstBboxItem = bboxContainer.querySelector('.array-item');
            if (!firstBboxItem) return null;
            
            const pageInput = firstBboxItem.querySelector('.bbox-page');
            if (pageInput && pageInput.value) {
                return parseInt(pageInput.value, 10);
            }
            
            return null;
        }

        function extractPageFromQuestion(questionEl, type) {
            let selector;
            if (type === 'question') {
                const questionBboxLabel = Array.from(questionEl.querySelectorAll('label')).find(
                    label => label.textContent.includes('Question Images')
                );
                if (questionBboxLabel) {
                    const container = questionBboxLabel.closest('.form-group')?.querySelector('.bbox-container');
                    if (container) {
                        const firstBbox = container.querySelector('.array-item .bbox-page');
                        if (firstBbox && firstBbox.value) {
                            return parseInt(firstBbox.value, 10);
                        }
                    }
                }
            } else if (type === 'answer') {
                const answerBboxLabel = Array.from(questionEl.querySelectorAll('label')).find(
                    label => label.textContent.includes('Answer Images')
                );
                if (answerBboxLabel) {
                    const container = answerBboxLabel.closest('.form-group')?.querySelector('.bbox-container');
                    if (container) {
                        const firstBbox = container.querySelector('.array-item .bbox-page');
                        if (firstBbox && firstBbox.value) {
                            return parseInt(firstBbox.value, 10);
                        }
                    }
                }
                
                // Also check guide_pdf_page field
                const guidePdfPageInput = questionEl.querySelector('input[placeholder*="Guide PDF Page"]') ||
                                        Array.from(questionEl.querySelectorAll('input')).find(
                                            input => input.previousElementSibling?.textContent?.includes('Guide PDF Page')
                                        );
                if (guidePdfPageInput && guidePdfPageInput.value) {
                    return parseInt(guidePdfPageInput.value, 10);
                }
            }
            
            return null;
        }

        function detectQuestionFieldType(focused, questionEl) {
            const answerLabels = ['Guide Answer', 'Answer Images'];
            const parentLabel = focused.closest('.form-group')?.querySelector('label');
            
            if (parentLabel) {
                const labelText = parentLabel.textContent;
                if (answerLabels.some(answerLabel => labelText.includes(answerLabel))) {
                    return 'answer';
                }
            }
            
            return 'question';
        }

        function getDefaultPageForTab(tabName) {
            if (!tabName) return null;
            
            const result = {
                textbookPage: null,
                guidePage: null
            };
            
            switch(tabName) {
                case 'basic':
                case 'preamble':
                    // Get textbook page from PDF Page Number field
                    const textbookPdfPage = document.getElementById('textbook_pdf_page');
                    if (textbookPdfPage && textbookPdfPage.value) {
                        result.textbookPage = parseInt(textbookPdfPage.value, 10);
                    }
                    
                    // Get guidebook page from Guidebook Start Page field
                    const guidebookStartPage = document.getElementById('guidebook_start_page');
                    if (guidebookStartPage && guidebookStartPage.value) {
                        result.guidePage = parseInt(guidebookStartPage.value, 10);
                    }
                    break;
                    
                case 'content':
                    const firstSection = document.querySelector('#content_sections_container > .array-item');
                    if (firstSection) {
                        const page = extractPageFromSection(firstSection, 'content');
                        if (page) {
                            result.textbookPage = page;
                            return result; // Content is textbook only
                        }
                    }
                    return getDefaultPageForTab('basic');
                    
                case 'questions':
                    const firstQuestion = document.querySelector('#questions_container > .array-item');
                    if (firstQuestion) {
                        const questionPage = extractPageFromQuestion(firstQuestion, 'question');
                        const answerPage = extractPageFromQuestion(firstQuestion, 'answer');
                        if (questionPage || answerPage) {
                            result.textbookPage = questionPage;
                            result.guidePage = answerPage;
                            return result;
                        }
                    }
                    return getDefaultPageForTab('basic');
                    
                default:
                    return getDefaultPageForTab('basic');
            }
            
            return result;
        }

        function getSectionIndex(section) {
            const container = section.closest('#content_sections_container');
            const sections = container.querySelectorAll(':scope > .array-item');
            return Array.from(sections).indexOf(section);
        }

        function getQuestionIndex(question) {
            const container = question.closest('#questions_container');
            const questions = container.querySelectorAll(':scope > .array-item');
            return Array.from(questions).indexOf(question);
        }

        function toggleAutoNavigation() {
            const state = window.__mainPdfViewer;
            state.autoSyncEnabled = !state.autoSyncEnabled;
            
            // Save to localStorage
            localStorage.setItem('pdfAutoNavEnabled', state.autoSyncEnabled);
            
            // Update UI
            const statusEl = document.getElementById('auto-nav-status');
            const toggleBtn = document.getElementById('auto-nav-toggle');
            if (statusEl) {
                statusEl.textContent = state.autoSyncEnabled ? 'Auto Nav: ON' : 'Auto Nav: OFF';
            }
            if (toggleBtn) {
                toggleBtn.style.backgroundColor = state.autoSyncEnabled ? '#28a745' : '';
                toggleBtn.style.color = state.autoSyncEnabled ? 'white' : '';
            }
            
            // Reset navigation state when enabling
            if (state.autoSyncEnabled) {
                state.userNavigatedAway = false;
                navigateToContextPage();
            }
        }

        /**
         * Get the appropriate guidebook page within the range
         * @returns {number|null} Page number within the range, or null if range is invalid
         */
        function getGuidebookPageInRange() {
            const startPageInput = document.getElementById('guidebook_start_page');
            const endPageInput = document.getElementById('guidebook_end_page');
            
            if (!startPageInput || !endPageInput || !startPageInput.value || !endPageInput.value) {
                return null;
            }
            
            const startPage = parseInt(startPageInput.value, 10);
            const endPage = parseInt(endPageInput.value, 10);
            
            if (isNaN(startPage) || isNaN(endPage) || startPage <= 0 || endPage <= 0 || startPage > endPage) {
                return null;
            }
            
            const state = window.__mainPdfViewer;
            
            // If we have a current page and it's within the range, use it
            if (state.currentPage && state.currentPage >= startPage && state.currentPage <= endPage) {
                return state.currentPage;
            }
            
            // If current page is before the range, use start page
            if (state.currentPage && state.currentPage < startPage) {
                return startPage;
            }
            
            // If current page is after the range, use end page
            if (state.currentPage && state.currentPage > endPage) {
                return endPage;
            }
            
            // If no current page context, default to start page
            return startPage;
        }

        function navigateToContextPage() {
            const state = window.__mainPdfViewer;
            
            // Don't navigate if disabled
            if (!state.autoSyncEnabled) return;
            
            // Don't navigate if no PDF loaded
            if (!state.pdfDoc) return;
            
            // Don't navigate if user recently navigated manually (within 5 seconds)
            const timeSinceManualNav = Date.now() - state.lastManualNavTime;
            if (timeSinceManualNav < 5000 && state.userNavigatedAway) {
                return;
            }
            
            const context = detectFormContext();
            
            // Determine target page and source
            let targetPage = null;
            let targetSource = null;
            let useRangeCheck = false; // Flag to enable range checking
            const TEXTBOOK_RANGE = 1; // Pages before/after for textbook range
            
            // Content tab: use textbook with PDF Page Number
            if (context.activeTab === 'content') {
                targetSource = 'textbook';
                const textbookPageInput = document.getElementById('textbook_pdf_page');
                if (textbookPageInput && textbookPageInput.value) {
                    targetPage = parseInt(textbookPageInput.value, 10);
                    useRangeCheck = true;
                }
            }
            // Questions tab: use guidebook when guide answer box is active
            else if (context.activeTab === 'questions') {
                // Check if we're in a guide answer field
                const focused = document.activeElement;
                let isGuideField = false;
                
                if (focused) {
                    const formGroup = focused.closest('.form-group');
                    if (formGroup) {
                        const label = formGroup.querySelector('label');
                        if (label) {
                            const labelText = label.textContent;
                            // Removed 'Answer Images' - no longer switches to guidebook
                            isGuideField = labelText.includes('Guide') || 
                                         labelText.includes('Answer Bounding');
                        }
                    }
                }
                
                if (isGuideField) {
                    targetSource = 'guide';
                    
                    // Check if this is specifically a Guide PDF Page field
                    const formGroup = focused.closest('.form-group');
                    const isGuidePdfPageField = formGroup && formGroup.querySelector('label')?.textContent?.includes('Guide PDF Page');
                    
                    if (isGuidePdfPageField) {
                        // For Guide PDF Page field, use its value if available
                        if (focused.value) {
                            targetPage = parseInt(focused.value, 10);
                        }
                    } else {
                    // For other guide fields (Guide Answer), 
                    // use any page within the guidebook range
                    // Note: Answer Images no longer triggers guidebook switching
                    targetPage = getGuidebookPageInRange();
                    }
                    
                    // If still no target page, fallback to guidebook range logic
                    if (!targetPage) {
                        targetPage = getGuidebookPageInRange();
                    }
                } else {
                    // Not in a guide field - only switch to textbook if we're not already on guide
                    // This prevents unwanted switching when user is using guide PDF and clicks elsewhere
                    if (state.source === 'guide') {
                        // Stay on guide if user manually switched to it, unless explicitly in textbook field
                        const focused = document.activeElement;
                        const isTextbookField = focused && (
                            focused.id === 'textbook_page' || 
                            focused.id === 'textbook_pdf_page' ||
                            focused.closest('.form-group')?.querySelector('label')?.textContent?.includes('Textbook')
                        );
                        
                        if (isTextbookField) {
                            targetSource = 'textbook';
                            const textbookPageInput = document.getElementById('textbook_pdf_page');
                            if (textbookPageInput && textbookPageInput.value) {
                                targetPage = parseInt(textbookPageInput.value, 10);
                                useRangeCheck = true;
                            }
                        } else {
                            // Stay on guide - no auto-switching
                            return;
                        }
                    } else {
                        // Currently on textbook, navigate within textbook
                        targetSource = 'textbook';
                        const textbookPageInput = document.getElementById('textbook_pdf_page');
                        if (textbookPageInput && textbookPageInput.value) {
                            targetPage = parseInt(textbookPageInput.value, 10);
                            useRangeCheck = true;
                        }
                    }
                }
            }
            // Basic/Preamble tabs: use textbook page, but don't force switch if on guide
            else {
                // Only switch to textbook if explicitly in textbook field or not on guide
                const focused = document.activeElement;
                const isTextbookField = focused && (
                    focused.id === 'textbook_page' || 
                    focused.id === 'textbook_pdf_page' ||
                    focused.closest('.form-group')?.querySelector('label')?.textContent?.includes('Textbook')
                );
                
                if (state.source === 'guide' && !isTextbookField) {
                    // Stay on guide if user is there and not explicitly in textbook field
                    return;
                }
                
                targetSource = 'textbook';
                const textbookPageInput = document.getElementById('textbook_pdf_page');
                if (textbookPageInput && textbookPageInput.value) {
                    targetPage = parseInt(textbookPageInput.value, 10);
                    useRangeCheck = true;
                }
            }
            
            // Only navigate if we have a valid target
            if (!targetPage || !targetSource) return;
            
            // Switch source if needed (always switch to correct source)
            // BUT: Don't switch if BBox modal is open from a Draw button (prevents unwanted source switching)
            if (state.source !== targetSource && !window.__bboxModalOpen) {
                switchPdfSource(targetSource);
                // After switching source, we might need to wait for PDF to load
                // The current page might not be valid, so force navigation
                navigateMainPdfToPage(targetPage);
                state.userNavigatedAway = false;
                return;
            }
            
            // If modal is open, don't switch sources even if they don't match
            if (state.source !== targetSource && window.__bboxModalOpen) {
                return;
            }
            
            // If using range check for textbook, check if current page is within acceptable range
            if (useRangeCheck && targetSource === 'textbook') {
                const rangeStart = Math.max(1, targetPage - TEXTBOOK_RANGE);
                const rangeEnd = Math.min(state.totalPages || targetPage, targetPage + TEXTBOOK_RANGE);
                
                // If current page is within range, don't navigate
                if (state.currentPage >= rangeStart && state.currentPage <= rangeEnd) {
                    return;
                }
            }
            
            // Only navigate if different from current page
            if (state.currentPage === targetPage) {
                return;
            }
            
            // Navigate to page (this will preserve zoom and scroll position)
            navigateMainPdfToPage(targetPage);
            
            // Reset user navigated away flag since we just auto-navigated
            state.userNavigatedAway = false;
        }

        function toggleAutoSync(enabled) {
            window.__mainPdfViewer.autoSyncEnabled = enabled;
            
            // Update UI
            const statusEl = document.getElementById('auto-nav-status');
            const toggleBtn = document.getElementById('auto-nav-toggle');
            if (statusEl) {
                statusEl.textContent = enabled ? 'Auto Nav: ON' : 'Auto Nav: OFF';
            }
            if (toggleBtn) {
                toggleBtn.style.backgroundColor = enabled ? '#28a745' : '';
                toggleBtn.style.color = enabled ? 'white' : '';
            }
            
            if (enabled) {
                navigateToContextPage();
            }
        }

        // Helper function to determine if a field is guide-related
        function isGuideRelatedField(element) {
            if (!element) return false;
            
            // Specific guide-related field IDs
            const guideFieldIds = ['guidebook_start_page', 'guidebook_end_page'];
            if (guideFieldIds.includes(element.id)) return true;
            
            // Check for specific field classes that should navigate to guidebook
            if (element.classList.contains('choice-text') ||
                element.classList.contains('choice-id') ||
                element.classList.contains('blank-answer-input') ||
                element.classList.contains('relationship-left') ||
                element.classList.contains('relationship-right')) {
                return true;
            }
            
            // Check if the field is in a form group with guide-related labels
            const formGroup = element.closest('.form-group');
            if (formGroup) {
                const label = formGroup.querySelector('label');
                if (label) {
                    const labelText = label.textContent || '';
                    // Guide-related labels
                    // Removed 'Answer Images' - no longer switches to guidebook
                    if (labelText.includes('Guide Answer') ||
                        labelText.includes('Guide PDF Page') ||
                        labelText.includes('Choice Text') ||
                        labelText.includes('Choice ID') ||
                        labelText.includes('Blank Answers') ||
                        labelText.includes('Relationships')) {
                        return true;
                    }
                }
            }
            
            // Check parent containers for relationships section (in case element is inside relationships container)
            const relationshipsSection = element.closest('div[id^="relationships-list-"]');
            if (relationshipsSection) {
                // Check if there's a "Relationships" label in a parent container
                const parentContainer = relationshipsSection.closest('div[style*="border"]');
                if (parentContainer) {
                    const relationshipsLabel = parentContainer.querySelector('label');
                    if (relationshipsLabel && relationshipsLabel.textContent.includes('Relationships')) {
                        return true;
                    }
                }
            }
            
            // Check if element has placeholder or attributes that indicate guide fields
            const placeholder = element.placeholder || '';
            if (placeholder.includes('Guide PDF Page')) return true;
            
            return false;
        }
        
        // Helper function to determine if a field is textbook-related
        function isTextbookRelatedField(element) {
            if (!element) return false;
            
            // Specific textbook-related field IDs
            const textbookFieldIds = [
                'textbook_page', 'textbook_pdf_page', 'lesson_id', 'lesson_title', 
                'lesson_text', 'page_type'
            ];
            if (textbookFieldIds.includes(element.id)) return true;
            
            // Check if the field is in a form group with textbook-related labels
            const formGroup = element.closest('.form-group');
            if (formGroup) {
                const label = formGroup.querySelector('label');
                if (label) {
                    const labelText = label.textContent || '';
                    // Textbook-related labels (most content fields)
                    // Removed 'Section Images' and 'Question Images' - no longer trigger source switching
                    if (labelText.includes('Textbook') ||
                        labelText.includes('Section Title') ||
                        labelText.includes('Content (Markdown') ||
                        labelText.includes('Question ID') ||
                        labelText.includes('Set-up Text') ||
                        labelText.includes('Question Text') ||
                        labelText.includes('Related Question') ||
                        labelText.includes('Lesson Standards') ||
                        labelText.includes('Terminology') ||
                        labelText.includes('Lesson Text') ||
                        labelText.includes('Page Type')) {
                        return true;
                    }
                }
            }
            
            // Check for content/question section indicators
            if (element.closest('.content-section') || 
                element.closest('.questions-container') ||
                element.closest('#lesson_standards') ||
                element.closest('#terminology')) {
                // But exclude guide answer fields within questions
                const isInGuideField = element.closest('.form-group')?.querySelector('label')?.textContent?.includes('Guide');
                return !isInGuideField;
            }
            
            return false;
        }

        function attachContextListeners() {
            // Listen to focus events on form fields (but ignore PDF canvas and its container)
            document.addEventListener('focusin', (e) => {
                if (window.__mainPdfViewer.visible && window.__mainPdfViewer.autoSyncEnabled) {
                    // Don't trigger auto-switching when clicking on the PDF canvas or its container
                    const isCanvasOrContainer = e.target.id === 'main-pdf-canvas' || 
                                               e.target.classList.contains('pdf-canvas-container') ||
                                               e.target.closest('.pdf-canvas-container') ||
                                               e.target.closest('#pdf-viewer-panel .pdf-viewer-controls') ||
                                               e.target.id === 'json_input' ||
                                               e.target.closest('.json-controls');
                    
                    if (!isCanvasOrContainer) {
                        // Determine if this field should switch to textbook or guidebook
                        const shouldSwitchToGuide = isGuideRelatedField(e.target);
                        const shouldSwitchToTextbook = isTextbookRelatedField(e.target);
                        
                        if (shouldSwitchToGuide && window.__mainPdfViewer.source !== 'guide') {
                            switchPdfSource('guide');
                        } else if (shouldSwitchToTextbook && window.__mainPdfViewer.source !== 'textbook') {
                            switchPdfSource('textbook');
                        }
                        
                        clearTimeout(window.__contextSyncTimeout);
                        window.__contextSyncTimeout = setTimeout(() => {
                            // Re-check autoSyncEnabled before navigating (user might have turned it off)
                            if (window.__mainPdfViewer.autoSyncEnabled) {
                            navigateToContextPage();
                            }
                        }, 300);
                    }
                }
            }, true);
            
            // Listen to tab changes
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    if (window.__mainPdfViewer.visible && window.__mainPdfViewer.autoSyncEnabled) {
                        setTimeout(() => {
                            // Re-check autoSyncEnabled before navigating (user might have turned it off)
                            if (window.__mainPdfViewer.autoSyncEnabled) {
                                navigateToContextPage();
                            }
                        }, 100);
                    }
                });
            });
            
            // Listen to bbox page input changes
            document.addEventListener('input', (e) => {
                if (e.target.classList.contains('bbox-page') && 
                    window.__mainPdfViewer.visible && 
                    window.__mainPdfViewer.autoSyncEnabled) {
                    clearTimeout(window.__contextSyncTimeout);
                    window.__contextSyncTimeout = setTimeout(() => {
                        // Re-check autoSyncEnabled before navigating (user might have turned it off)
                        if (window.__mainPdfViewer.autoSyncEnabled) {
                        navigateToContextPage();
                        }
                    }, 500);
                }
            });
            
            // Listen to guidebook start/end page input changes for navigation
            document.addEventListener('input', (e) => {
                if (window.__mainPdfViewer.visible && window.__mainPdfViewer.autoSyncEnabled) {
                    const isGuidebookField = e.target.id === 'guidebook_start_page' || e.target.id === 'guidebook_end_page';
                    
                    if (isGuidebookField) {
                        // Switch to guide PDF if not already there
                        if (window.__mainPdfViewer.source !== 'guide') {
                            switchPdfSource('guide');
                        }
                        
                        // Navigate to the entered page
                        const pageValue = e.target.value;
                        if (pageValue) {
                            const page = parseInt(pageValue, 10);
                            if (page > 0) {
                                const state = window.__mainPdfViewer;
                                // Don't check totalPages here since PDF might not be loaded yet after source switch
                                clearTimeout(window.__guidebookInputTimeout);
                                window.__guidebookInputTimeout = setTimeout(() => {
                                    // Re-check autoSyncEnabled before navigating (user might have turned it off)
                                    if (state.autoSyncEnabled && state.pdfDoc && page <= state.pdfDoc.numPages) {
                                        // Use proper navigation function that updates controls and state
                                        navigateMainPdfToPage(page);
                                    }
                                }, 800); // Longer delay for typing
                            }
                        }
                    }
                }
            });
            
            // Listen to guide PDF page changes in questions
            document.addEventListener('input', (e) => {
                const inputs = Array.from(document.querySelectorAll('input'));
                const guidePdfInput = inputs.find(input => {
                    const label = input.closest('.form-group')?.querySelector('label');
                    return label && label.textContent.includes('Guide PDF Page');
                });
                
                if (e.target === guidePdfInput && 
                    window.__mainPdfViewer.visible && 
                    window.__mainPdfViewer.autoSyncEnabled) {
                    clearTimeout(window.__contextSyncTimeout);
                    window.__contextSyncTimeout = setTimeout(() => {
                        // Re-check autoSyncEnabled before navigating (user might have turned it off)
                        if (window.__mainPdfViewer.autoSyncEnabled) {
                        navigateToContextPage();
                        }
                    }, 500);
                }
            });
            
            // Listen to guidebook start/end page field focus events to auto-switch to guide and navigate
            document.addEventListener('focusin', (e) => {
                if (window.__mainPdfViewer.visible && window.__mainPdfViewer.autoSyncEnabled) {
                    const isGuidebookField = e.target.id === 'guidebook_start_page' || e.target.id === 'guidebook_end_page';
                    
                    if (isGuidebookField) {
                        const state = window.__mainPdfViewer;
                        // Switch to guide PDF when focusing on guidebook page fields
                        if (state.source !== 'guide') {
                            switchPdfSource('guide');
                            // Wait a moment for source switch to complete before navigating
                            setTimeout(() => {
                                // Re-check autoSyncEnabled before navigating (user might have turned it off)
                                if (!state.autoSyncEnabled) return;
                                // Navigate to a page within the guidebook range
                                const guidebookPage = getGuidebookPageInRange();
                                if (guidebookPage && guidebookPage > 0) {
                                        // Use proper navigation function that updates controls and state
                                    navigateMainPdfToPage(guidebookPage);
                                }
                            }, 100);
                            return; // Don't call navigateToContextPage as we're handling navigation above
                        } else {
                            // Already on guide, navigate immediately (but check autoSyncEnabled first)
                            if (state.autoSyncEnabled) {
                                const guidebookPage = getGuidebookPageInRange();
                                if (guidebookPage && guidebookPage > 0) {
                                    // Use proper navigation function that updates controls and state
                                    navigateMainPdfToPage(guidebookPage);
                                    return; // Don't call navigateToContextPage as we already navigated
                                }
                            }
                        }
                        
                        clearTimeout(window.__contextSyncTimeout);
                        window.__contextSyncTimeout = setTimeout(() => {
                            // Re-check autoSyncEnabled before navigating (user might have turned it off)
                            if (window.__mainPdfViewer.autoSyncEnabled) {
                            navigateToContextPage();
                            }
                        }, 300);
                    }
                }
            }, true);
        }

        function attachPdfKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                // Only handle shortcuts when PDF viewer is visible
                if (!window.__mainPdfViewer.visible) return;
                
                // Check if input/textarea is focused (don't interfere with typing)
                const activeTag = document.activeElement.tagName.toLowerCase();
                if (activeTag === 'input' || activeTag === 'textarea') {
                    // Allow shortcuts only with modifiers
                    if (!e.ctrlKey && !e.metaKey && !e.altKey) {
                        return;
                    }
                }
                
                // Page navigation
                if (e.key === 'ArrowLeft' && (e.ctrlKey || e.metaKey)) {
                    e.preventDefault();
                    navigateMainPdf('prev');
                } else if (e.key === 'ArrowRight' && (e.ctrlKey || e.metaKey)) {
                    e.preventDefault();
                    navigateMainPdf('next');
                }
                
                // Zoom
                if (e.key === '+' && (e.ctrlKey || e.metaKey)) {
                    e.preventDefault();
                    zoomMainPdf('in');
                } else if (e.key === '-' && (e.ctrlKey || e.metaKey)) {
                    e.preventDefault();
                    zoomMainPdf('out');
                } else if (e.key === '0' && (e.ctrlKey || e.metaKey)) {
                    e.preventDefault();
                    zoomMainPdf('reset');
                }
                
                // Toggle PDF/JSON (Alt+P or Cmd/Ctrl+P)
                if ((e.key === 'p' || e.key === 'P') && (e.ctrlKey || e.metaKey)) {
                    e.preventDefault();
                    if (window.__mainPdfViewer.visible) {
                        showJsonPreview();
                    } else {
                        showPdfViewer();
                    }
                }
            });
        }

        // This function is no longer needed - we read directly from window.__bboxStore
        // Keeping empty function for backward compatibility in case it's called elsewhere
        function syncPdfToMainViewer(source, pdfDoc) {
            // PDFs are stored in window.__bboxStore and read directly by loadPdfFromStore()
            // No sync needed - just load from store when viewer is shown
        }
        
        // Auto-resize all textareas on page load (for saved/restored content)
        // Only if auto-resize is enabled
        setTimeout(() => {
            if (autoResizeEnabled) {
                autoResizeAllTextareas();
                // Repeat after a delay in case some content loads asynchronously
                setTimeout(() => {
                    if (autoResizeEnabled) {
                        autoResizeAllTextareas();
                    }
                }, 500);
            }
        }, 100);
        // ===== WHAT'S NEW MODAL =====
        // Note: CURRENT_VERSION and VERSION_SEEN_KEY are defined above (see line ~16527)
        
        function openWhatsNew() {
            const modal = document.getElementById('whats-new-modal');
            if (modal) {
                modal.style.display = 'flex';
                // Mark this version as seen
                try {
                    localStorage.setItem(VERSION_SEEN_KEY, CURRENT_VERSION);
                } catch (e) {
                    console.error('Failed to save version seen:', e);
                }
            }
        }
        
        function closeWhatsNew() {
            const modal = document.getElementById('whats-new-modal');
            if (modal) {
                modal.style.display = 'none';
            }
        }
        
        // Check if we should auto-open What's New modal on page load
        function checkAndOpenWhatsNew() {
            try {
                const lastSeenVersion = localStorage.getItem(VERSION_SEEN_KEY);
                console.log('[What\'s New] Checking version - Last seen:', lastSeenVersion, 'Current:', CURRENT_VERSION);
                // If no version has been seen, or if current version is different, show the modal
                if (!lastSeenVersion || lastSeenVersion !== CURRENT_VERSION) {
                    console.log('[What\'s New] Version mismatch detected - will open modal');
                    // Wait a bit for the page to fully load before showing
                    setTimeout(() => {
                        const modal = document.getElementById('whats-new-modal');
                        if (modal) {
                            console.log('[What\'s New] Opening modal');
                            modal.style.display = 'flex';
                            // Mark this version as seen immediately when auto-opening
                            try {
                                localStorage.setItem(VERSION_SEEN_KEY, CURRENT_VERSION);
                                console.log('[What\'s New] Saved version', CURRENT_VERSION, 'to localStorage');
                            } catch (e) {
                                console.error('Failed to save version seen:', e);
                            }
                        } else {
                            console.error('[What\'s New] Modal element not found!');
                        }
                    }, 500);
                } else {
                    console.log('[What\'s New] Version already seen - skipping auto-open');
                }
            } catch (e) {
                console.error('[What\'s New] Failed to check version:', e);
            }
        }
        
        // Close modal when clicking outside
        window.addEventListener('click', function(event) {
            const modal = document.getElementById('whats-new-modal');
            if (event.target === modal) {
                closeWhatsNew();
            }
        });
    </script>
    
    <!-- What's New Modal -->
    <div id="whats-new-modal" style="display: none; position: fixed; z-index: 10000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); justify-content: center; align-items: center; padding: 20px;">
        <div class="whats-new-modal-content">
            <!-- Header -->
            <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 24px; border-radius: 12px 12px 0 0; display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <h2 style="margin: 0; font-size: 1.8rem; display: flex; align-items: center; gap: 10px;">
                        <i class="fas fa-sparkles"></i> What's New
                    </h2>
                    <p style="margin: 5px 0 0 0; opacity: 0.9; font-size: 0.95rem;">Latest updates and improvements</p>
                </div>
                <button onclick="closeWhatsNew()" style="background: rgba(255,255,255,0.2); border: none; color: white; width: 36px; height: 36px; border-radius: 50%; cursor: pointer; font-size: 1.2rem; display: flex; align-items: center; justify-content: center; transition: all 0.3s; padding: 0;">
                    <i class="fas fa-times" style="line-height: 1; display: block; transform: translateY(2px);"></i>
                </button>
            </div>
            
            <!-- Content -->
            <div class="whats-new-modal-body">
                <!-- Version (dynamically set) -->
                <div style="margin-bottom: 40px;">
                    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 20px;">
                        <span id="whats-new-current-version" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 6px 16px; border-radius: 20px; font-weight: 600; font-size: 0.9rem;">Version <span id="whats-new-version-number"></span></span>
                        <span class="whats-new-version-badge">Current Version</span>
                    </div>
                    
                    <!-- Enhancements -->
                    <div style="margin-bottom: 25px;">
                        <h3 class="whats-new-modal-header" style="margin: 0 0 12px 0; font-size: 1.1rem; display: flex; align-items: center; gap: 8px;">
                            <i class="fas fa-arrow-up" style="color: #28a745;"></i> Enhancements
                        </h3>
                        <ul class="whats-new-modal-list">
                            <li><strong>Increased Maximum Zoom:</strong> The maximum zoom level has been increased to 8x (800%) for both the bounding box drawing modal and the PDF viewer. This allows for much more detailed work when drawing bounding boxes or examining PDF pages at high magnification.</li>
                            <li><strong>Zoom Indicator in Bounding Box Modal:</strong> A zoom percentage display has been added to the bounding box drawing modal, matching the functionality in the main PDF viewer. You can now see the current zoom level at a glance while drawing bounding boxes.</li>
                            <li><strong>Optimized Layout for Better Space Usage:</strong> The UI has been enhanced to make better use of available screen space. Both the left and right columns now utilize the full vertical and horizontal real estate, adapting responsively to different zoom levels and screen sizes. This makes the interface more efficient and provides more room for your work.</li>
                            <li><strong>Expanded Font Size Options:</strong> Additional larger font sizes have been added to the font size selector. You can now choose from sizes up to 48px, giving you more flexibility to customize the text size for better readability.</li>
                            <li><strong>Font Size Persistence:</strong> The tool now remembers and automatically applies your last selected font size when you reload or refresh the page. Your font size preference is saved and restored automatically, so you don't have to adjust it every time.</li>
                        </ul>
                    </div>
                    
                    <!-- Bug Fixes -->
                    <div style="margin-bottom: 25px;">
                        <h3 class="whats-new-modal-header" style="margin: 0 0 12px 0; font-size: 1.1rem; display: flex; align-items: center; gap: 8px;">
                            <i class="fas fa-bug" style="color: #dc3545;"></i> Bug Fixes
                        </h3>
                        <ul class="whats-new-modal-list">
                            <li><strong>Fixed Collapsed Section Navigation:</strong> Fixed an issue where clicking an edit button in the Final Preview tab to navigate to a collapsed section would not automatically expand that section. Now, when you click an edit button, the target section will automatically uncollapse so you can see and edit the field immediately.</li>
                        </ul>
                    </div>
                </div>
                
                <!-- Version 6.7 -->
                <div style="margin-bottom: 40px;">
                    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 20px;">
                        <span style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 6px 16px; border-radius: 20px; font-weight: 600; font-size: 0.9rem;">Version 6.7</span>
                        <span class="whats-new-version-badge">Previous Version</span>
                    </div>
                    
                    <!-- New Features -->
                    <div style="margin-bottom: 25px;">
                        <h3 class="whats-new-modal-header" style="margin: 0 0 12px 0; font-size: 1.1rem; display: flex; align-items: center; gap: 8px;">
                            <i class="fas fa-star" style="color: #ffd700;"></i> New Features
                        </h3>
                        <ul class="whats-new-modal-list">
                            <li><strong>Final Preview Tab:</strong> A new "Final Preview" tab provides a comprehensive preview of all your content sections and questions in one place. This consolidated view shows everything exactly as it will appear in the final output, making it easy to review your work. Each preview box includes an edit button that takes you directly to the corresponding input field for quick editing.</li>
                            <li><strong>Collapsible Sections:</strong> You can now collapse and expand content and question sections to manage your workspace more easily. Click the <i class="fas fa-chevron-down"></i> button in the section header to hide or show its content. The button rotates when collapsed to indicate its state.</li>
                            <li><strong>Image Description Text Direction:</strong> All image descriptions in the preview now always display from left to right, regardless of the preview's text direction setting. This ensures consistent and readable image descriptions for all users.</li>
                        </ul>
                    </div>
                </div>
                
                <!-- Version 6.6 -->
                <div style="margin-bottom: 40px;">
                    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 20px;">
                        <span style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 6px 16px; border-radius: 20px; font-weight: 600; font-size: 0.9rem;">Version 6.6</span>
                        <span class="whats-new-version-badge">Previous Version</span>
                    </div>
                    
                    <!-- New Features -->
                    <div style="margin-bottom: 25px;">
                        <h3 class="whats-new-modal-header" style="margin: 0 0 12px 0; font-size: 1.1rem; display: flex; align-items: center; gap: 8px;">
                            <i class="fas fa-star" style="color: #ffd700;"></i> New Features
                        </h3>
                        <ul class="whats-new-modal-list">
                            <li><strong>Smart Bbox Zoom & Centering:</strong> When you press the Draw button for a bounding box that already has coordinates, the PDF viewer now automatically zooms to show the entire bounding box clearly and centers it in the middle of the screen. The zoom level is calculated to fit the bbox with optimal padding, making it easy to see and edit existing bounding boxes. This saves time when reviewing or adjusting previously drawn boxes.</li>
                            <li><strong>Form-Level Undo/Redo Buttons:</strong> New undo and redo buttons at the top of the page let you reverse or redo actions throughout the form. These buttons affect structural changes like adding or removing sections, questions, terminology, choices, matching items, bounding boxes, and images. They can save your work if you accidentally remove a section or even if you clear the entire form using the "Clear Form" button or load a JSON file. <strong>Important:</strong> This is completely different from the undo/redo buttons in each text field (which only affect markdown formatting operations like bold, italic, lists, etc.). The form-level undo/redo buttons work independently and track all major form actions, giving you a safety net for your work.</li>
                            <li><strong>Smart Search:</strong> Find anything instantly across all your content sections and questions. As you type, a dropdown shows matching results with a preview of the text and highlights your search term. Each result clearly shows whether it's a section title, content text, question answer, choice, or other field. Click any result to jump directly to it, or use arrow keys to navigate. The search bar shows how many results were found and keeps your search term so you can easily check multiple matches.</li>
                        </ul>
                    </div>
                </div>
                
                <!-- Version 6.5 -->
                <div style="margin-bottom: 40px;">
                    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 20px;">
                        <span style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 6px 16px; border-radius: 20px; font-weight: 600; font-size: 0.9rem;">Version 6.5</span>
                        <span class="whats-new-version-badge">Previous Version</span>
                    </div>
                    
                    <!-- New Features -->
                    <div style="margin-bottom: 25px;">
                        <h3 class="whats-new-modal-header" style="margin: 0 0 12px 0; font-size: 1.1rem; display: flex; align-items: center; gap: 8px;">
                            <i class="fas fa-star" style="color: #ffd700;"></i> New Features
                        </h3>
                        <ul class="whats-new-modal-list">
                            <li><strong>Auto-Save:</strong> Your work is now automatically saved as you edit! The form saves your changes automatically after you finish editing a field, so you won't lose your progress. You'll see "Saving..." and "All saved" indicators to track the save status.</li>
                            <li><strong>Blockquote Formatting Button:</strong> A new blockquote button in the markdown toolbar makes it easy to format quotes. Select your text and click the quote button, or click it on an empty line to start typing a quote.</li>
                            <li><strong>Blockquote Format Validation:</strong> The form now checks that blockquotes use the correct format (one space after the ">" character). This ensures your quotes are properly formatted and prevents formatting issues when generating the final output.</li>
                            <li><strong>Blank in LaTeX Validation:</strong> The tool now prevents you from writing blanks (<code>___1___</code>, <code>___2___</code>, etc.) inside LaTeX expressions. If you try to use a blank inside inline LaTeX (<code>$...$</code>) or block LaTeX (<code>$$\n...\n$$</code>), you'll see an error message and won't be able to save or generate the JSON until you move the blank outside the LaTeX expression.</li>
                            <li><strong>LaTeX Always Reads Left-to-Right:</strong> Math formulas in the preview now always display from left to right, even when your text is set to right-to-left (RTL). This makes math expressions easier to read and ensures they display correctly regardless of the text direction you've chosen.</li>
                            <li><strong>Reload Button & Reminder:</strong> A new reload button in the top bar lets you quickly refresh the page. The tool will also remind you to reload every few days to make sure you're using the latest version of the tool and getting all the newest features and improvements. This is especially important since the tool is updated regularly with new capabilities and bug fixes.</li>
                        </ul>
                    </div>
                </div>
                
                <!-- Version 6.4 -->
                <div style="margin-bottom: 40px;">
                    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 20px;">
                        <span style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 6px 16px; border-radius: 20px; font-weight: 600; font-size: 0.9rem;">Version 6.4</span>
                        <span class="whats-new-version-badge">Previous Version</span>
                    </div>
                    
                    <!-- Enhancements -->
                    <div style="margin-bottom: 25px;">
                        <h3 class="whats-new-modal-header" style="margin: 0 0 12px 0; font-size: 1.1rem; display: flex; align-items: center; gap: 8px;">
                            <i class="fas fa-arrow-up" style="color: #28a745;"></i> Enhancements
                        </h3>
                        <ul class="whats-new-modal-list">
                            <li><strong>Smarter Table Validation:</strong> Table validation now correctly handles LaTeX expressions inside table cells. Pipes inside LaTeX formulas (like <code>$\cancel{||||}$</code>) are no longer counted as table delimiters, preventing false validation errors.</li>
                            <li><strong>Improved Image Description Validation:</strong> Image description validation now correctly handles LaTeX commands. LaTeX commands like <code>\neq</code> or <code>\right(</code> that contain <code>\n</code> or <code>\r</code> are no longer flagged as errors. Block LaTeX (<code>$$\n...\n$$</code>) in image descriptions is now properly detected and blocked with a helpful error message suggesting to use inline LaTeX instead.</li>
                            <li><strong>Fixed Direction Button Issue:</strong> Direction buttons (RTL/LTR) now work correctly even after validation errors appear. Previously, clicking the direction button after an error would not update the preview, but this has been fixed.</li>
                        </ul>
                    </div>
                </div>
                
                <!-- Version 6.3 -->
                <div style="margin-bottom: 40px;">
                    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 20px;">
                        <span style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 6px 16px; border-radius: 20px; font-weight: 600; font-size: 0.9rem;">Version 6.3</span>
                        <span class="whats-new-version-badge">Previous Version</span>
                    </div>
                    
                    <!-- New Features -->
                    <div style="margin-bottom: 25px;">
                        <h3 class="whats-new-modal-header" style="margin: 0 0 12px 0; font-size: 1.1rem; display: flex; align-items: center; gap: 8px;">
                            <i class="fas fa-star" style="color: #ffc107;"></i> New Features
                        </h3>
                        <ul class="whats-new-modal-list">
                            <li><strong>Multi-Line Table Cells:</strong> You can now press Enter inside table cells to create line breaks. The preview will show your content on multiple lines within the same cell.</li>
                            <li><strong>List Validation:</strong> The tool now reminds you to add an empty line after lists. If you forget, you'll see a helpful error message to fix it.</li>
                            <li><strong>Blockquote Validation:</strong> The tool now reminds you to add an empty line after blockquotes. If you forget, you'll see a helpful error message to fix it.</li>
                        </ul>
                    </div>
                    
                    <!-- Enhancements -->
                    <div style="margin-bottom: 25px;">
                        <h3 class="whats-new-modal-header" style="margin: 0 0 12px 0; font-size: 1.1rem; display: flex; align-items: center; gap: 8px;">
                            <i class="fas fa-arrow-up" style="color: #28a745;"></i> Enhancements
                        </h3>
                        <ul class="whats-new-modal-list">
                            <li><strong>Better Table Validation:</strong> Table validation is now smarter and won't show errors when you use line breaks inside cells.</li>
                            <li><strong>Unified Error Display:</strong> All validation errors (tables, lists, blockquotes, LaTeX, images, quotes, and HTML tags) now appear in a consistent format and are displayed right after the input box for easier visibility.</li>
                            <li><strong>Customizable Font Settings:</strong> You can now adjust font size and line height directly from the top bar. Your preferences are saved and apply to all text inputs and previews for both Arabic and English text.</li>
                        </ul>
                    </div>
                </div>
                
                <!-- Version 6.2 -->
                <div style="margin-bottom: 40px;">
                    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 20px;">
                        <span style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 6px 16px; border-radius: 20px; font-weight: 600; font-size: 0.9rem;">Version 6.2</span>
                        <span class="whats-new-version-badge">Previous Version</span>
                    </div>
                    
                    <!-- Enhancements -->
                    <div style="margin-bottom: 25px;">
                        <h3 class="whats-new-modal-header" style="margin: 0 0 12px 0; font-size: 1.1rem; display: flex; align-items: center; gap: 8px;">
                            <i class="fas fa-arrow-up" style="color: #28a745;"></i> Enhancements
                        </h3>
                        <ul class="whats-new-modal-list">
                            <li><strong>Simplified PDF Upload:</strong> The two separate buttons "Upload Textbook PDF" and "Upload Guide PDF" in the JSON Preview tab have been combined into a single "Upload PDFs" button for a cleaner interface. You can still upload both types of PDFs from the modal.</li>
                            <li><strong>Improved PDF Viewer Stability:</strong> The PDF viewer now stays exactly where you left it when using the Draw button or working with image fields. It won't change pages, zoom levels, or switch between books unexpectedly, making it much easier to work with multiple images without losing your place.</li>
                            <li><strong>Better Performance:</strong> The tool now renders PDFs more efficiently, only updating the display when necessary for smoother interactions and faster response times.</li>
                        </ul>
                    </div>
                </div>
                
                <!-- Version 6.1 -->
                <div style="margin-bottom: 40px;">
                    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 20px;">
                        <span style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 6px 16px; border-radius: 20px; font-weight: 600; font-size: 0.9rem;">Version 6.1</span>
                        <span class="whats-new-version-badge">Previous Version</span>
                    </div>
                    
                    <!-- New Features -->
                    <div style="margin-bottom: 25px;">
                        <h3 class="whats-new-modal-header" style="margin: 0 0 12px 0; font-size: 1.1rem; display: flex; align-items: center; gap: 8px;">
                            <i class="fas fa-star" style="color: #ffc107;"></i> New Features
                        </h3>
                        <ul class="whats-new-modal-list">
                            <li><strong>Markdown Toolbar:</strong> New formatting buttons (Bold, Italic, Bullet List, Numbered List, Inline LaTeX $, Block LaTeX $$) in all text fields let you quickly format text without typing markdown syntax. Select text and click a button, or click to insert formatting placeholders. Undo and Redo buttons let you reverse or reapply your last formatting operations.</li>
                            <li><strong>Search/Filter:</strong> New search box in the top bar lets you quickly find content sections and questions by searching through titles, content text, question IDs, question text, and answers. Matching items are highlighted with a colored border.</li>
                            <li><strong>Auto-Resize Toggle:</strong> New circular button () in the top bar lets you control whether text boxes grow automatically as you type. Green = auto-resize on, red = off. Your preference is saved.</li>
                            <li><strong>HTML Tag Validation:</strong> The tool now prevents using <code>&lt;br&gt;</code> tags in your content. You'll see a red error message if you try to use them, and you won't be able to save until they're removed.</li>
                            <li><strong>Helpful Tooltips:</strong> All buttons and form fields now have tooltips that appear when you hover over them, making it easier to understand what each feature does.</li>
                        </ul>
                    </div>
                    
                    <!-- Enhancements -->
                    <div style="margin-bottom: 25px;">
                        <h3 class="whats-new-modal-header" style="margin: 0 0 12px 0; font-size: 1.1rem; display: flex; align-items: center; gap: 8px;">
                            <i class="fas fa-arrow-up" style="color: #28a745;"></i> Enhancements
                        </h3>
                        <ul class="whats-new-modal-list">
                            <li><strong>Button Improvements:</strong> All buttons now have the same size for a cleaner look.</li>
                        </ul>
                    </div>
                </div>
                
                <!-- Version 6.0 -->
                <div style="margin-bottom: 40px;">
                    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 20px;">
                        <span style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 6px 16px; border-radius: 20px; font-weight: 600; font-size: 0.9rem;">Version 6.0</span>
                        <span class="whats-new-version-badge">Previous Version</span>
                    </div>
                    
                    <!-- Bug Fixes & Improvements -->
                    <div style="margin-bottom: 25px;">
                        <h3 class="whats-new-modal-header" style="margin: 0 0 12px 0; font-size: 1.1rem; display: flex; align-items: center; gap: 8px;">
                            <i class="fas fa-bug" style="color: #dc3545;"></i> Fixes & Improvements
                        </h3>
                        <ul class="whats-new-modal-list">
                            <li><strong>LaTeX in Image Descriptions:</strong> Fixed an issue where using math formulas in image descriptions (like <code>$\sqrt[3]{16}$</code>) was incorrectly flagged as an error. The tool now correctly recognizes LaTeX syntax in image descriptions.</li>
                        </ul>
                    </div>
                </div>
                
                <!-- Version 5.9 -->
                <div style="margin-bottom: 40px;">
                    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 20px;">
                        <span style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 6px 16px; border-radius: 20px; font-weight: 600; font-size: 0.9rem;">Version 5.9</span>
                        <span class="whats-new-version-badge">Previous Version</span>
                    </div>
                    
                    <!-- New Features -->
                    <div style="margin-bottom: 25px;">
                        <h3 class="whats-new-modal-header" style="margin: 0 0 12px 0; font-size: 1.1rem; display: flex; align-items: center; gap: 8px;">
                            <i class="fas fa-star" style="color: #ffc107;"></i> New Features
                        </h3>
                        <ul class="whats-new-modal-list">
                            <li><strong>Extended Auto-Navigation:</strong> Auto-navigation now works for more fields including choices, blank answers, and relationships. The PDF automatically jumps to the correct page when you click these fields.</li>
                            <li><strong>Guide PDF Page Validation:</strong> The tool now checks that guide page numbers are within the correct range. You'll get an error if the page number is outside the range, and you won't be able to save until it's fixed.</li>
                        </ul>
                    </div>
                    
                    <!-- Enhancements -->
                    <div style="margin-bottom: 25px;">
                        <h3 class="whats-new-modal-header" style="margin: 0 0 12px 0; font-size: 1.1rem; display: flex; align-items: center; gap: 8px;">
                            <i class="fas fa-arrow-up" style="color: #28a745;"></i> Enhancements
                        </h3>
                        <ul class="whats-new-modal-list">
                            <li><strong>Smart Guidebook Navigation:</strong> The guidebook can now navigate to any page in the range, not just the start page. It stays on your current page if you're already in range.</li>
                            <li><strong>Auto-Navigation Toggle:</strong> When auto-navigation is turned off, the PDF won't jump around when you type page numbers.</li>
                            <li><strong>Answer Preview:</strong> The answer preview now displays math formulas the same way as the choice preview, and updates as you type.</li>
                        </ul>
                    </div>
                </div>
                
                <!-- Version 5.8 -->
                <div style="margin-bottom: 40px;">
                    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 20px;">
                        <span style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 6px 16px; border-radius: 20px; font-weight: 600; font-size: 0.9rem;">Version 5.8</span>
                        <span class="whats-new-version-badge">Previous Version</span>
                    </div>
                    
                    <!-- Bug Fixes & Improvements -->
                    <div style="margin-bottom: 25px;">
                        <h3 class="whats-new-modal-header" style="margin: 0 0 12px 0; font-size: 1.1rem; display: flex; align-items: center; gap: 8px;">
                            <i class="fas fa-bug" style="color: #dc3545;"></i> Fixes & Improvements
                        </h3>
                        <ul class="whats-new-modal-list">
                            <li><strong>Fill-in-the-Blanks Formatting:</strong> Fixed an issue where spaces between blanks were incorrectly flagged as errors.</li>
                            <li><strong>Preview with Answers:</strong> The answer preview now displays math formulas correctly, matching the question preview.</li>
                            <li><strong>Answer Position Direction:</strong> The direction buttons for answer position now work consistently with the choice text buttons.</li>
                            <li><strong>Dark Mode Support:</strong> The What's New dialog now works properly in dark mode.</li>
                        </ul>
                    </div>
                </div>
                
                <!-- Version 5.7 -->
                <div style="margin-bottom: 40px;">
                    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 20px;">
                        <span style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 6px 16px; border-radius: 20px; font-weight: 600; font-size: 0.9rem;">Version 5.7</span>
                        <span class="whats-new-version-badge">Previous Version</span>
                    </div>
                    
                    <!-- New Features -->
                    <div style="margin-bottom: 25px;">
                        <h3 class="whats-new-modal-header" style="margin: 0 0 12px 0; font-size: 1.1rem; display: flex; align-items: center; gap: 8px;">
                            <i class="fas fa-star" style="color: #ffc107;"></i> New Features
                        </h3>
                        <ul class="whats-new-modal-list">
                            <li><strong>What's New Modal:</strong> Stay informed about the latest updates and improvements with the new "What's New" button in the header. Click it anytime to see what's changed!</li>
                            <li><strong>One-Click Duplicate:</strong> Quickly duplicate any content section, question, or image box by clicking the purple duplicate icon <i class="fas fa-clone" style="color: #6f42c1;"></i>. The duplicated section appears right below the original with all data intact.</li>
                            <li><strong>Question ID Validation:</strong> The tool now checks for duplicate question IDs and warns you if you use the same ID twice.</li>
                        </ul>
                    </div>
                    
                    <!-- Enhancements -->
                    <div style="margin-bottom: 25px;">
                        <h3 class="whats-new-modal-header" style="margin: 0 0 12px 0; font-size: 1.1rem; display: flex; align-items: center; gap: 8px;">
                            <i class="fas fa-arrow-up" style="color: #28a745;"></i> Enhancements
                        </h3>
                        <ul class="whats-new-modal-list">
                            <li><strong>Persistent Guide Answer:</strong> Your guide answer is now saved when you switch between question types.</li>
                        </ul>
                    </div>
                    
                    <!-- Bug Fixes -->
                    <div>
                        <h3 class="whats-new-modal-header" style="margin: 0 0 12px 0; font-size: 1.1rem; display: flex; align-items: center; gap: 8px;">
                            <i class="fas fa-bug" style="color: #dc3545;"></i> Bug Fixes
                        </h3>
                        <ul class="whats-new-modal-list">
                            <li><strong>Improved Table Detection:</strong> Fixed an issue where single pipe symbols or math notation were incorrectly flagged as table errors.</li>
                        </ul>
                    </div>
                </div>
                
                <!-- Footer -->
                <div class="whats-new-modal-footer">
                    <p style="margin: 0;">Have questions or suggestions? <a href="https://forms.gle/UJKozfjrWP7sfxTC8" target="_blank" rel="noopener noreferrer" style="color: #667eea; text-decoration: none; font-weight: 600;">Share your feedback</a> - We're always improving!</p>
                </div>
            </div>
        </div>
    </div>

</body>
</html>

