<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-3DP5ZC653Y" onerror="console.debug('Google Analytics script failed to load (expected if offline)')"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-3DP5ZC653Y');
        
        // ===== VERSION CONFIGURATION =====
        // DISPLAY_VERSION: The version shown in the UI (header and What's New modal)
        // Update this when you want to change what version is displayed to users
        const DISPLAY_VERSION = '6.9';
        
        // CURRENT_VERSION: Internal version number that triggers the What's New modal
        // Update this when you release a new version to trigger:
        //   - Auto-open of What's New modal (only if user hasn't seen this version)
        //   - Version reload checks
        // This can be different from DISPLAY_VERSION (e.g., use "6.6.1" for minor updates)
        // Example: Change '6.8' to '6.9' when releasing version 6.9
        const CURRENT_VERSION = '6.9.2';
        const VERSION_SEEN_KEY = 'whatsNewVersionSeen';
        
        // ===== UNDO/REDO SYSTEM =====
        const formUndoHistory = [];
        const formRedoHistory = [];
        const MAX_HISTORY_SIZE = 100;
        let isFormUndoRedoInProgress = false;
        
        // Action types
        const ACTION_TYPES = {
            ADD_ITEM: 'add_item',
            REMOVE_ITEM: 'remove_item',
            DUPLICATE_ITEM: 'duplicate_item',
            FIELD_CHANGE: 'field_change',
            MOVE_ITEM: 'move_item',
            CLEAR_FORM: 'clear_form',
            LOAD_JSON: 'load_json',
            PASTE: 'paste',
            PASTE_SECTION: 'paste_section',
            PASTE_QUESTION: 'paste_question',
            PASTE_BBOX: 'paste_bbox'
        };
        
        // Record an action for undo/redo
        function recordFormAction(action) {
            if (isFormUndoRedoInProgress) return;
            
            // Clear redo history when new action is recorded
            formRedoHistory.length = 0;
            
            // Add to undo history
            formUndoHistory.push(action);
            
            // Limit history size
            if (formUndoHistory.length > MAX_HISTORY_SIZE) {
                formUndoHistory.shift();
            }
            
            updateUndoRedoButtons();
        }
        
        // Update undo/redo button states
        function updateUndoRedoButtons() {
            const undoBtn = document.getElementById('undo-btn');
            const redoBtn = document.getElementById('redo-btn');
            
            if (undoBtn) {
                undoBtn.disabled = formUndoHistory.length === 0;
                undoBtn.style.opacity = formUndoHistory.length === 0 ? '0.5' : '1';
                undoBtn.style.cursor = formUndoHistory.length === 0 ? 'not-allowed' : 'pointer';
            }
            
            if (redoBtn) {
                redoBtn.disabled = formRedoHistory.length === 0;
                redoBtn.style.opacity = formRedoHistory.length === 0 ? '0.5' : '1';
                redoBtn.style.cursor = formRedoHistory.length === 0 ? 'not-allowed' : 'pointer';
            }
        }
        
        // Undo last action
        function undoAction() {
            if (formUndoHistory.length === 0 || isFormUndoRedoInProgress) return;
            
            isFormUndoRedoInProgress = true;
            const action = formUndoHistory.pop();
            
            try {
                executeUndo(action);
                // Move to redo history
                formRedoHistory.push(action);
                updateUndoRedoButtons();
            } catch (e) {
                console.error('Error undoing action:', e);
                // Put action back if undo failed
                formUndoHistory.push(action);
            } finally {
                isFormUndoRedoInProgress = false;
            }
        }
        
        // Redo last undone action
        function redoAction() {
            if (formRedoHistory.length === 0 || isFormUndoRedoInProgress) return;
            
            isFormUndoRedoInProgress = true;
            const action = formRedoHistory.pop();
            
            try {
                executeRedo(action);
                // Move back to undo history
                formUndoHistory.push(action);
                updateUndoRedoButtons();
            } catch (e) {
                console.error('Error redoing action:', e);
                // Put action back if redo failed
                formRedoHistory.push(action);
            } finally {
                isFormUndoRedoInProgress = false;
            }
        }
        
        // Execute undo for an action
        function executeUndo(action) {
            switch (action.type) {
                case ACTION_TYPES.ADD_ITEM:
                    // Undo add = remove
                    if (action.element && action.element.parentNode) {
                        // Check if this is a choice item BEFORE removing it
                        const isChoiceItem = action.element.classList.contains('choice-item') || 
                                           (action.element.closest && action.element.closest('[id^="choices-list-"]') !== null);
                        let questionEl = null;
                        if (isChoiceItem) {
                            // Find the parent question element before removing
                            const choicesList = action.element.closest('[id^="choices-list-"]');
                            questionEl = choicesList ? choicesList.closest('.array-item') : 
                                        (action.element.closest('.array-item[data-type="question"]') || 
                                         action.element.closest('.array-item'));
                        }
                        
                        // For matching items, find question element before removing
                        const isMatchingItem = action.element.classList.contains('matching-item') || 
                                             (action && action.isMatchingItem === true);
                        let matchingQuestionEl = null;
                        if (isMatchingItem && action.questionEl) {
                            matchingQuestionEl = action.questionEl;
                        } else if (isMatchingItem) {
                            const matchingContainer = action.element.closest('#matching-container');
                            matchingQuestionEl = matchingContainer ? matchingContainer.closest('.array-item') : 
                                                 action.element.closest('.array-item');
                        }
                        
                        action.element.remove();
                        // Always update numbering after remove
                        afterListMutation(action.containerId);
                        
                        // Update choice UI if this was a choice item (use the questionEl we found before removal)
                        if (isChoiceItem && questionEl) {
                            syncChoiceUI(questionEl);
                        }
                        
                        // Update matching UI if this was a matching item (use the questionEl we found before removal)
                        if (isMatchingItem && matchingQuestionEl) {
                            setTimeout(() => {
                                if (!matchingQuestionEl.isConnected) return;
                                if (action.side) {
                                    updateMatchingItemNumbers(matchingQuestionEl, action.side);
                                } else {
                                    updateMatchingItemNumbers(matchingQuestionEl, 'left');
                                }
                                syncMatchingUI(matchingQuestionEl);
                            }, 0);
                        }
                    }
                    break;
                    
                case ACTION_TYPES.REMOVE_ITEM:
                    // CRITICAL: For questions, rebuild from state instead of reinserting DOM clone
                    if (action.containerId === 'questions_container' && action.snapshotState) {
                        // Build fresh question from state
                        const newQuestion = buildQuestionFromState(action.snapshotState);
                        
                        // Insert at recorded position
                        const container = document.getElementById('questions_container');
                        if (action.nextSibling && action.nextSibling.parentNode === container) {
                            container.insertBefore(newQuestion, action.nextSibling);
                        } else if (action.questionIndex !== null && action.questionIndex < container.children.length) {
                            const referenceNode = container.children[action.questionIndex];
                            container.insertBefore(newQuestion, referenceNode);
                        } else if (action.parent) {
                            // Fallback: append to end
                            action.parent.appendChild(newQuestion);
                        } else {
                            container.appendChild(newQuestion);
                        }
                        
                        // Update numbering
                        afterListMutation('questions_container');
                    } else if (action.element && action.parent) {
                        // For nested lists (choices, matching items) and other items, restore the element
                        if (action.nextSibling && action.nextSibling.parentNode === action.parent) {
                            action.parent.insertBefore(action.element, action.nextSibling);
                        } else {
                            action.parent.appendChild(action.element);
                        }
                        
                        // Reattach previews and font settings for restored items
                        // Use canonical postUndoRedoRestore which handles all element types
                        if (action.isRelationship) {
                            // For relationships, finalize and remove placeholder if exists
                            finalizeMatchingListItem(action.element);
                            if (action.parent) {
                                const placeholder = action.parent.querySelector('p');
                                if (placeholder && !placeholder.classList.contains('relationship-item')) {
                                    placeholder.remove();
                                }
                            }
                        } else {
                            // For all other items (choices, matching, content sections, questions)
                            // postUndoRedoRestore handles type detection and calls appropriate finalizer
                            postUndoRedoRestore(action.element);
                        }
                        
                        // Update numbering/labels for nested lists using centralized hook
                        if (action.questionEl) {
                            afterQuestionTypeListMutation(action.questionEl);
                        }
                        if (action.isMatching && action.questionEl && action.side) {
                            const matchingContainer = action.questionEl.querySelector('#matching-container');
                            if (matchingContainer) {
                                const list = matchingContainer.querySelector(`[id^="matching-${action.side}-list-"]`);
                                if (list) {
                                    renumberMatchingItems(list);
                                }
                            }
                            updateMatchingItemNumbers(action.questionEl, action.side);
                        }
                        if (!action.isChoice && !action.isMatching && !action.isRelationship) {
                            // Top-level items
                            afterListMutation(action.containerId);
                        }
                    }
                    break;
                    
                case ACTION_TYPES.DUPLICATE_ITEM:
                    // Undo duplicate = remove duplicated element
                    if (action.duplicatedElement && action.duplicatedElement.parentNode) {
                        action.duplicatedElement.remove();
                        // Always update numbering after remove
                        afterListMutation(action.containerId);
                    }
                    break;
                    
                case ACTION_TYPES.FIELD_CHANGE:
                    // Undo field change = restore old value
                    if (action.field) {
                        action.field.value = action.oldValue;
                        // Trigger input event to update previews
                        action.field.dispatchEvent(new Event('input', { bubbles: true }));
                    }
                    break;
                    
                case ACTION_TYPES.MOVE_ITEM:
                    // Undo move = move back
                    if (action.element && action.oldParent && action.oldNextSibling) {
                        action.oldParent.insertBefore(action.element, action.oldNextSibling);
                    } else if (action.element && action.oldParent) {
                        action.oldParent.appendChild(action.element);
                    }
                    // Update numbering/labels for nested lists using centralized sync
                    if (action.isChoice && action.questionEl) {
                        syncChoiceUI(action.questionEl);
                    } else if (action.isMatching && action.questionEl) {
                        if (action.side) {
                            const matchingContainer = action.questionEl.querySelector('#matching-container');
                            if (matchingContainer) {
                                const list = matchingContainer.querySelector(`[id^="matching-${action.side}-list-"]`);
                                if (list) {
                                    renumberMatchingItems(list);
                                }
                            }
                            updateMatchingItemNumbers(action.questionEl, action.side);
                        }
                        syncMatchingUI(action.questionEl);
                    } else {
                        // Top-level items (questions, content sections)
                        afterListMutation(action.containerId);
                    }
                    break;
                    
                case ACTION_TYPES.CLEAR_FORM:
                    // Undo clear = restore form state
                    if (action.savedState) {
                        isFormUndoRedoInProgress = true;
                        try {
                            populateFormFromJSON(action.savedState);
                        } finally {
                            isFormUndoRedoInProgress = false;
                        }
                    }
                    break;
                    
                case ACTION_TYPES.LOAD_JSON:
                    // Undo load = restore previous form state
                    if (action.previousState) {
                        isFormUndoRedoInProgress = true;
                        try {
                            populateFormFromJSON(action.previousState);
                        } finally {
                            isFormUndoRedoInProgress = false;
                        }
                    }
                    break;
                    
                case ACTION_TYPES.PASTE:
                    // Undo paste = restore old element content
                    if (action.pastedElement && action.oldElement && action.parent) {
                        // Restore the content from the old element, preserving all field values
                        restoreSectionContent(action.pastedElement, action.oldElement);
                        // Reinitialize the element (calls toggleQuestionType for questions, etc.)
                        postUndoRedoRestore(action.pastedElement);
                        attachBboxValidation(action.pastedElement);
                        // Always update numbering after paste restore
                        afterListMutation(action.containerId);
                    }
                    break;
                    
                case ACTION_TYPES.PASTE_SECTION:
                case ACTION_TYPES.PASTE_QUESTION:
                    // Undo paste = remove pasted element
                    if (action.pastedElement && action.pastedElement.parentNode) {
                        action.pastedElement.remove();
                        // Always update numbering after remove
                        afterListMutation(action.containerId);
                    }
                    break;
                    
                case ACTION_TYPES.PASTE_BBOX:
                    // Undo bbox paste = restore old values
                    if (action.targetRow && action.oldState) {
                        const pageInput = action.targetRow.querySelector('.bbox-page');
                        const x0Input = action.targetRow.querySelector('.bbox-x0');
                        const y0Input = action.targetRow.querySelector('.bbox-y0');
                        const x1Input = action.targetRow.querySelector('.bbox-x1');
                        const y1Input = action.targetRow.querySelector('.bbox-y1');
                        
                        if (pageInput) pageInput.value = action.oldState.page || '';
                        if (x0Input) x0Input.value = action.oldState.x0 || '';
                        if (y0Input) y0Input.value = action.oldState.y0 || '';
                        if (x1Input) x1Input.value = action.oldState.x1 || '';
                        if (y1Input) y1Input.value = action.oldState.y1 || '';
                        
                        // Trigger validation
                        validateAndNormalizeBbox(action.targetRow);
                    }
                    break;
            }
        }
        
        // Execute redo for an action
        function executeRedo(action) {
            switch (action.type) {
                case ACTION_TYPES.ADD_ITEM:
                    // CRITICAL: For questions, rebuild from state if snapshotState exists
                    if (action.containerId === 'questions_container' && action.snapshotState) {
                        // Build fresh question from state
                        const newQuestion = buildQuestionFromState(action.snapshotState);
                        
                        // Insert at recorded position
                        const container = document.getElementById('questions_container');
                        if (action.nextSibling && action.nextSibling.parentNode === container) {
                            container.insertBefore(newQuestion, action.nextSibling);
                        } else if (action.parent) {
                            action.parent.appendChild(newQuestion);
                        } else {
                            container.appendChild(newQuestion);
                        }
                        
                        // Update numbering
                        afterListMutation('questions_container');
                    } else if (action.element && action.parent) {
                        // For non-question items, use existing DOM restore
                        if (action.nextSibling) {
                            action.parent.insertBefore(action.element, action.nextSibling);
                        } else {
                            action.parent.appendChild(action.element);
                        }
                        
                        // Finalize matching items: apply font settings, RTL, previews
                        if (action.isMatchingItem || action.element.classList.contains('matching-item')) {
                            finalizeMatchingListItem(action.element);
                        } else if (action.isRelationship || action.element.classList.contains('relationship-item')) {
                            // For relationships, finalize: apply font settings
                            finalizeMatchingListItem(action.element);
                        } else {
                            postUndoRedoRestore(action.element);
                        }
                        
                        afterListMutation(action.containerId);
                        
                        // Update UI using centralized hook
                        if (action.questionEl) {
                            afterQuestionTypeListMutation(action.questionEl);
                        }
                        
                        // Update choice UI if this was a choice item (after element is added back)
                        setTimeout(() => {
                            updateChoiceUIIfNeeded(action.element);
                        }, 0);
                        // Update matching UI if this was a matching item (after element is added back)
                        setTimeout(() => {
                            updateMatchingUIIfNeeded(action.element, action);
                        }, 0);
                    }
                    break;
                    
                case ACTION_TYPES.REMOVE_ITEM:
                    // Redo remove = remove again
                    if (action.element && action.element.parentNode) {
                        // Use recorded properties if available, otherwise detect
                        const isChoiceItem = action.isChoice !== undefined ? action.isChoice : 
                                           (action.element.classList.contains('choice-item') || 
                                            (action.element.closest && action.element.closest('[id^="choices-list-"]') !== null));
                        const isMatchingItem = action.isMatching !== undefined ? action.isMatching :
                                             action.element.classList.contains('matching-item');
                        const isRelationship = action.isRelationship !== undefined ? action.isRelationship :
                                             action.element.classList.contains('relationship-item');
                        const questionEl = action.questionEl || (isChoiceItem || isMatchingItem || isRelationship ? 
                                           action.element.closest('.array-item') : null);
                        
                        action.element.remove();
                        
                        // Handle placeholder for relationships
                        if (isRelationship && questionEl) {
                            const relationshipsList = action.parent;
                            if (relationshipsList && relationshipsList.querySelectorAll('.relationship-item').length === 0) {
                                relationshipsList.innerHTML = '<p style="color: var(--text-secondary); font-style: italic; margin: 0;">No relationships added yet. Click "Add Relationship" to connect items.</p>';
                            }
                        }
                        
                        // Update numbering/labels for nested lists using centralized hook
                        if (questionEl) {
                            afterQuestionTypeListMutation(questionEl);
                        }
                        if (isMatchingItem && questionEl && action.side) {
                            const matchingContainer = questionEl.querySelector('#matching-container');
                            if (matchingContainer) {
                                const list = matchingContainer.querySelector(`[id^="matching-${action.side}-list-"]`);
                                if (list) {
                                    renumberMatchingItems(list);
                                }
                            }
                            updateMatchingItemNumbers(questionEl, action.side);
                        }
                        if (!isChoiceItem && !isMatchingItem && !isRelationship) {
                            // Top-level items
                            afterListMutation(action.containerId);
                        }
                    }
                    break;
                    
                case ACTION_TYPES.DUPLICATE_ITEM:
                    // Redo duplicate = restore duplicated element deterministically from snapshotState
                    if (action.parent && action.snapshotState) {
                        let elementToRestore = null;
                        
                        // Rebuild from snapshotState using canonical builders (NEVER rely on cloneNode)
                        if (action.isBbox) {
                            // Rebuild bbox row from saved values
                            const state = action.snapshotState;
                            const handlers = action.bboxHandlers || {};
                            elementToRestore = buildBBoxRow({
                                values: state,
                                beforeHandler: handlers.beforeFunc || 'addContentImageBefore',
                                afterHandler: handlers.afterFunc || 'addContentImageAfter',
                                buttonOrder: handlers.buttonOrder || 'reorderFirst'
                            });
                        } else if (action.isQuestion) {
                            // Rebuild question from serialized state
                            elementToRestore = buildQuestionFromState(action.snapshotState);
                        } else {
                            // Rebuild content section from serialized state
                            const container = action.parent;
                            const sectionCount = container.querySelectorAll(':scope > .array-item').length + 1;
                            elementToRestore = buildContentSectionItem(sectionCount);
                            
                            // Populate with saved data
                            const state = action.snapshotState;
                            const sectionTitleInput = findFieldByLabel(elementToRestore, 'Section Title', 'input');
                            if (sectionTitleInput) {
                                sectionTitleInput.value = state.section_title || '';
                            }
                            const sectionTextTextarea = findFieldByLabel(elementToRestore, 'Content (Markdown + LaTeX)', 'textarea');
                            if (sectionTextTextarea) {
                                sectionTextTextarea.value = state.text || '';
                            }
                            // Fill bbox data
                            const imagesGroup = findFormGroupByLabel(elementToRestore, 'Section Images');
                            if (imagesGroup && state.images) {
                                fillBboxGroup(imagesGroup, state.images);
                            }
                        }
                        
                        if (elementToRestore) {
                            // Insert at correct position
                            if (action.nextSibling && action.nextSibling.parentNode === action.parent) {
                                action.parent.insertBefore(elementToRestore, action.nextSibling);
                            } else {
                                // nextSibling may be gone; append to parent
                                action.parent.appendChild(elementToRestore);
                            }
                            
                            // Finalize based on type using canonical helpers
                            if (action.isBbox) {
                                finalizeBBoxRow(elementToRestore);
                            } else {
                                // Use canonical postUndoRedoRestore which handles all finalization
                                // (previews, fonts, bbox, refresh, autosize, question type toggling)
                                postUndoRedoRestore(elementToRestore);
                            }
                            
                            // Update the action to reference the restored element
                            action.duplicatedElement = elementToRestore;
                            
                            // Update numbering if needed
                            if (action.containerId) {
                        afterListMutation(action.containerId);
                            }
                        }
                    }
                    break;
                    
                case ACTION_TYPES.FIELD_CHANGE:
                    // Redo field change = apply new value
                    if (action.field) {
                        action.field.value = action.newValue;
                        // Trigger input event to update previews
                        action.field.dispatchEvent(new Event('input', { bubbles: true }));
                    }
                    break;
                    
                case ACTION_TYPES.MOVE_ITEM:
                    // Redo move = move again
                    if (action.element && action.newParent && action.newNextSibling) {
                        action.newParent.insertBefore(action.element, action.newNextSibling);
                    } else if (action.element && action.newParent) {
                        action.newParent.appendChild(action.element);
                    }
                    // Update numbering/labels for nested lists using centralized sync
                    if (action.isChoice && action.questionEl) {
                        syncChoiceUI(action.questionEl);
                    } else if (action.isMatching && action.questionEl) {
                        if (action.side) {
                            const matchingContainer = action.questionEl.querySelector('#matching-container');
                            if (matchingContainer) {
                                const list = matchingContainer.querySelector(`[id^="matching-${action.side}-list-"]`);
                                if (list) {
                                    renumberMatchingItems(list);
                                }
                            }
                            updateMatchingItemNumbers(action.questionEl, action.side);
                        }
                        syncMatchingUI(action.questionEl);
                    } else {
                        // Top-level items (questions, content sections)
                        afterListMutation(action.containerId);
                    }
                    break;
                    
                case ACTION_TYPES.CLEAR_FORM:
                    // Redo clear = clear form again
                    if (action.clearFunction) {
                        isFormUndoRedoInProgress = true;
                        try {
                            action.clearFunction(true); // Pass true to indicate internal call
                        } finally {
                            isFormUndoRedoInProgress = false;
                        }
                    }
                    break;
                    
                case ACTION_TYPES.LOAD_JSON:
                    // Redo load = load JSON again
                    if (action.jsonData) {
                        isFormUndoRedoInProgress = true;
                        try {
                            populateFormFromJSON(action.jsonData);
                        } finally {
                            isFormUndoRedoInProgress = false;
                        }
                    }
                    break;
                    
                case ACTION_TYPES.PASTE:
                    // Redo paste = restore pasted content
                    if (action.pastedElement && action.pastedState && action.parent) {
                        // Save the current state as the new oldElement for future undo
                        const currentState = action.pastedElement.cloneNode(true);
                        // Restore the pasted content from the saved pastedState, preserving all field values
                        restoreSectionContent(action.pastedElement, action.pastedState);
                        // Reinitialize the element (calls toggleQuestionType for questions, etc.)
                        postUndoRedoRestore(action.pastedElement);
                        attachBboxValidation(action.pastedElement);
                        // Update oldElement for future undo (current state becomes the old state)
                        action.oldElement = currentState;
                        // Always update numbering after paste
                        afterListMutation(action.containerId);
                    }
                    break;
                    
                case ACTION_TYPES.PASTE_SECTION:
                case ACTION_TYPES.PASTE_QUESTION:
                    // Redo paste = paste again
                    if (action.pastedElement && action.parent && action.nextSibling) {
                        // Clone the element since it may have been removed during undo
                        const cloned = action.pastedElement.cloneNode(true);
                        action.parent.insertBefore(cloned, action.nextSibling);
                        // Update the action to reference the new cloned element
                        action.pastedElement = cloned;
                        
                        // Initialize pasted element (includes previews, fonts, bbox, autosize)
                        postUndoRedoRestore(cloned);
                        afterListMutation(action.containerId);
                    } else if (action.pastedElement && action.parent) {
                        // Clone the element since it may have been removed during undo
                        const cloned = action.pastedElement.cloneNode(true);
                        action.parent.appendChild(cloned);
                        // Update the action to reference the new cloned element
                        action.pastedElement = cloned;
                        
                        // Initialize pasted element (includes previews, fonts, bbox, autosize)
                        postUndoRedoRestore(cloned);
                        afterListMutation(action.containerId);
                    }
                    break;
                    
                case ACTION_TYPES.PASTE_BBOX:
                    // Redo bbox paste = restore pasted values
                    if (action.targetRow && action.pastedState) {
                        // Save current state as new oldState for future undo
                        const currentState = {
                            page: action.targetRow.querySelector('.bbox-page')?.value || '',
                            x0: action.targetRow.querySelector('.bbox-x0')?.value || '',
                            y0: action.targetRow.querySelector('.bbox-y0')?.value || '',
                            x1: action.targetRow.querySelector('.bbox-x1')?.value || '',
                            y1: action.targetRow.querySelector('.bbox-y1')?.value || ''
                        };
                        
                        const pageInput = action.targetRow.querySelector('.bbox-page');
                        const x0Input = action.targetRow.querySelector('.bbox-x0');
                        const y0Input = action.targetRow.querySelector('.bbox-y0');
                        const x1Input = action.targetRow.querySelector('.bbox-x1');
                        const y1Input = action.targetRow.querySelector('.bbox-y1');
                        
                        if (pageInput) pageInput.value = action.pastedState.page || '';
                        if (x0Input) x0Input.value = action.pastedState.x0 || '';
                        if (y0Input) y0Input.value = action.pastedState.y0 || '';
                        if (x1Input) x1Input.value = action.pastedState.x1 || '';
                        if (y1Input) y1Input.value = action.pastedState.y1 || '';
                        
                        // Update oldState for future undo
                        action.oldState = currentState;
                        
                        // Trigger validation
                        validateAndNormalizeBbox(action.targetRow);
                    }
                    break;
            }
        }
        
        // Helper to update numbers for a container (content sections, questions, etc.)
        function updateNumbersForContainer(containerId) {
            if (containerId === 'content_sections_container') {
                updateContentSectionNumbers();
            } else if (containerId === 'questions_container') {
                updateQuestionNumbers();
            }
        }

        // Centralized hook called after any list mutation (add/remove/reorder)
        // Ensures numbering is always correct after operations
        function afterListMutation(containerId) {
            if (containerId) {
                updateNumbersForContainer(containerId);
            }
        }
        
        // Helper to finalize a newly created matching list item (left/right/relationship)
        // Applies font settings, attaches previews, and sets RTL direction
        // Must be called AFTER the item is inserted into the DOM
        /**
         * Finalize a matching list item (left/right item or relationship).
         * Thin wrapper around finalizeElement for matching-specific behavior.
         */
        function finalizeMatchingListItem(itemEl) {
            if (!itemEl) return;
            
            // Set RTL direction for textareas in matching items
            const textarea = itemEl.querySelector('textarea');
            if (textarea && !textarea.hasAttribute('dir')) {
                textarea.setAttribute('dir', 'rtl');
            }
            
            // Determine if this is a matching item (vs relationship which has no textarea previews)
            const isMatchingItem = itemEl.classList.contains('matching-item');
            
            // Delegate to canonical finalizer
            finalizeElement(itemEl, {
                previews: isMatchingItem,  // Only attach previews to matching items, not relationships
                fonts: true,
                bbox: false,  // Matching items don't use bbox validation
                refresh: isMatchingItem,
                autoSize: isMatchingItem  // Only autosize matching items with textareas
            });
        }
        
        // ========== UID-BASED STATE MANAGEMENT HELPERS ==========
        
        // Generate a stable UID for an element
        function generateElementUid() {
            return `uid-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        }
        
        // Ensure all choice items have stable UIDs
        function ensureChoiceUids(questionEl) {
            if (!questionEl) return;
            const choicesList = questionEl.querySelector('[id^="choices-list-"]');
            if (!choicesList) return;
            
            const choices = choicesList.querySelectorAll('.choice-item');
            choices.forEach(choiceItem => {
                if (!choiceItem.dataset.choiceUid) {
                    choiceItem.dataset.choiceUid = generateElementUid();
                }
            });
        }
        
        // Ensure all matching items have stable UIDs
        function ensureMatchingUids(questionEl) {
            if (!questionEl) return;
            const matchingContainer = questionEl.querySelector('#matching-container');
            if (!matchingContainer) return;
            
            // Left items
            const leftList = matchingContainer.querySelector('[id^="matching-left-list-"]');
            if (leftList) {
                const leftItems = leftList.querySelectorAll('.matching-item');
                leftItems.forEach(item => {
                    if (!item.dataset.leftUid) {
                        item.dataset.leftUid = generateElementUid();
                    }
                });
            }
            
            // Right items
            const rightList = matchingContainer.querySelector('[id^="matching-right-list-"]');
            if (rightList) {
                const rightItems = rightList.querySelectorAll('.matching-item');
                rightItems.forEach(item => {
                    if (!item.dataset.rightUid) {
                        item.dataset.rightUid = generateElementUid();
                    }
                });
            }
            
            // Relationship items
            const relationshipsList = matchingContainer.querySelector('[id^="relationships-list-"]');
            if (relationshipsList) {
                const relationships = relationshipsList.querySelectorAll('.relationship-item');
                relationships.forEach(rel => {
                    if (!rel.dataset.relationshipUid) {
                        rel.dataset.relationshipUid = generateElementUid();
                    }
                });
            }
        }
        
        // Get correct choice UID from question element (for multiple choice)
        function getCorrectChoiceUid(questionEl) {
            if (!questionEl) return null;
            return questionEl.dataset.correctChoiceUid || null;
        }
        
        // Set correct choice UID on question element (for multiple choice)
        function setCorrectChoiceUid(questionEl, choiceUid) {
            if (!questionEl) return;
            if (choiceUid) {
                questionEl.dataset.correctChoiceUid = choiceUid;
            } else {
                delete questionEl.dataset.correctChoiceUid;
            }
        }
        
        // Get set of correct choice UIDs (for checkbox)
        function getCorrectChoiceUids(questionEl) {
            if (!questionEl) return new Set();
            const uidsStr = questionEl.dataset.correctChoiceUids;
            if (!uidsStr) return new Set();
            return new Set(uidsStr.split(',').filter(uid => uid));
        }
        
        // Set correct choice UIDs (for checkbox)
        function setCorrectChoiceUids(questionEl, uidsSet) {
            if (!questionEl) return;
            if (uidsSet && uidsSet.size > 0) {
                questionEl.dataset.correctChoiceUids = Array.from(uidsSet).join(',');
            } else {
                delete questionEl.dataset.correctChoiceUids;
            }
        }
        
        /**
         * Unified Action Button System
         * 
         * This system provides a single source of truth for rendering and wiring action buttons
         * across all contexts (sections, nested list items, bbox rows, relationships).
         * 
         * Supported contexts:
         * - LIST_ITEM: Choices, matching items (left/right), relationships
         * - SECTION: Content sections, questions (includes copy/paste/collapse)
         * - BBOX: BBox rows (includes draw/paste/copy/duplicate)
         * - SIMPLE: Standards, terminology (move up/down/remove only)
         * 
         * To add a new context:
         * 1. Define a config preset in ACTION_BUTTON_CONFIGS
         * 2. Call buildActionButtonsHTML(config) to generate HTML
         * 3. Ensure handlers are defined in onclick attributes and follow existing patterns
         */

        /**
         * Unified Editor Action Button System
         * 
         * Provides a single source of truth for "Add / Insert / Paste" action buttons
         * used throughout the editor (e.g., "Add Term", "Add Question", "Add Choice", etc.)
         * 
         * Supports both DOM-based creation (preferred) and HTML string generation (for templates).
         */

        /**
         * Build an action button element (DOM-based, preferred)
         * @param {Object} config - Button configuration
         * @param {string} config.label - Button label text
         * @param {string} config.onClick - onclick handler string (e.g., "addChoice(this)")
         * @param {string} [config.iconClass] - FontAwesome icon class (e.g., "fa-plus", "fa-paste")
         * @param {string} [config.className] - CSS class(es), defaults to "add-btn"
         * @param {string} [config.title] - Tooltip title
         * @param {string} [config.type] - Button type, defaults to "button"
         * @param {string} [config.style] - Inline styles
         * @param {Object} [config.attrs] - Additional attributes as key-value pairs
         * @returns {HTMLButtonElement} Button element
         */
        /**
         * Universal button factory - creates buttons consistently across the entire tool
         * @param {Object} config - Button configuration
         * @param {string} [config.label] - Button text label
         * @param {string|Function} [config.onClick] - onClick handler (string for onclick attr, function for event listener)
         * @param {string} [config.iconClass] - FontAwesome icon class (without 'fas' prefix, or full class like 'fas fa-icon')
         * @param {string} [config.className] - CSS class(es), defaults to "add-btn"
         * @param {string} [config.title] - Tooltip title
         * @param {string} [config.type] - Button type, defaults to "button"
         * @param {string} [config.style] - Inline styles
         * @param {Object} [config.attrs] - Additional attributes as key-value pairs
         * @param {Object} [config.dataset] - Data attributes (will be prefixed with 'data-')
         * @param {boolean} [config.disabled] - Whether button is disabled
         * @param {string} [config.id] - Button ID
         * @returns {HTMLButtonElement} Button element
         */
        function createButton(config) {
            const {
                label,
                onClick,
                iconClass = null,
                className = 'add-btn',
                title = '',
                type = 'button',
                style = '',
                attrs = {},
                dataset = {},
                disabled = false,
                id = null
            } = config;

            const button = document.createElement('button');
            button.type = type;
            button.className = className;
            if (title) button.title = title;
            if (style) button.style.cssText = style;
            if (id) button.id = id;
            button.disabled = disabled;

            // Handle onClick - prefer event listener for functions, onclick attr for strings
            if (onClick) {
                if (typeof onClick === 'function') {
                    button.addEventListener('click', onClick);
                } else {
                    button.setAttribute('onclick', onClick);
                }
            }

            // Handle special case: if attrs has innerHTML, use it as the ONLY content source
            // This must be checked FIRST to avoid adding icon/label and then overwriting
            if (attrs.innerHTML) {
                button.innerHTML = attrs.innerHTML;
                delete attrs.innerHTML;
            } else {
                // Normal path: build content from iconClass + label
                // Add icon if provided
                if (iconClass) {
                    const icon = document.createElement('i');
                    // Support both 'fa-icon' and 'fas fa-icon' formats
                    icon.className = iconClass.startsWith('fas ') ? iconClass : `fas ${iconClass}`;
                    // Support icon style override via attrs.iconStyle (for DOM version)
                    if (attrs.iconStyle) {
                        icon.style.cssText = attrs.iconStyle;
                        // Remove iconStyle from attrs to avoid adding it as a regular attribute
                        delete attrs.iconStyle;
                    }
                    button.appendChild(icon);
                }

                // Add label text
                if (label) {
                    if (iconClass) {
                        // If there's an icon, add space and then label
                        button.appendChild(document.createTextNode(' ' + label));
                    } else {
                        button.textContent = label;
                    }
                }
            }

            // Add data attributes
            for (const [key, value] of Object.entries(dataset)) {
                button.dataset[key] = value;
            }

            // Add additional attributes
            for (const [key, value] of Object.entries(attrs)) {
                button.setAttribute(key, value);
            }

            return button;
        }

        /**
         * Get action button HTML string (for template strings)
         * @param {Object} config - Button configuration (same as createButton)
         * @returns {string} HTML string
         */
        function getActionButtonHTML(config) {
            const {
                label,
                onClick,
                iconClass = null,
                className = 'add-btn',
                title = '',
                type = 'button',
                style = '',
                attrs = {},
                dataset = {},
                disabled = false,
                id = null
            } = config;

            let attrsStr = '';
            for (const [key, value] of Object.entries(attrs)) {
                attrsStr += ` ${key}="${value}"`;
            }

            // Add data attributes
            for (const [key, value] of Object.entries(dataset)) {
                attrsStr += ` data-${key}="${value}"`;
            }

            // Handle innerHTML first - if provided, it's the ONLY content source
            let buttonContent = '';
            if (attrs.innerHTML) {
                buttonContent = attrs.innerHTML;
                // Remove innerHTML from attrs to avoid adding it as an attribute
                const { innerHTML: _, ...cleanAttrs } = attrs;
                attrsStr = '';
                for (const [key, value] of Object.entries(cleanAttrs)) {
                    attrsStr += ` ${key}="${value}"`;
                }
            } else {
                // Normal path: build content from iconClass + label
                // Support icon style override via attrs.iconStyle (for HTML string version)
                const iconStyle = attrs.iconStyle ? ` style="${attrs.iconStyle}"` : '';
                const iconHTML = iconClass ? `<i class="${iconClass.startsWith('fas ') ? iconClass : `fas ${iconClass}`}"${iconStyle}></i>` : '';
                const labelHTML = label ? (iconClass ? ` ${label}` : label) : '';
                buttonContent = iconHTML + labelHTML;
                
                // Remove iconStyle from attrsStr to avoid adding it as a regular attribute
                if (attrs.iconStyle) {
                    const { iconStyle: _, ...cleanAttrs } = attrs;
                    attrsStr = '';
                    for (const [key, value] of Object.entries(cleanAttrs)) {
                        attrsStr += ` ${key}="${value}"`;
                    }
                }
            }
            
            const styleAttr = style ? ` style="${style}"` : '';
            const onclickAttr = onClick ? ` onclick="${typeof onClick === 'function' ? onClick.toString() : onClick}"` : '';
            const titleAttr = title ? ` title="${title}"` : '';
            const idAttr = id ? ` id="${id}"` : '';
            const disabledAttr = disabled ? ` disabled` : '';

            return `<button type="${type}" class="${className}"${idAttr}${onclickAttr}${titleAttr}${styleAttr}${disabledAttr}${attrsStr}>${buttonContent}</button>`;
        }

        /**
         * Action button configuration map for static HTML hydration
         */
        const ACTION_BUTTON_CONFIGS_STATIC = {
            'addLessonStandard': {
                label: 'Add Standard',
                onClick: 'addLessonStandard()',
                iconClass: 'fa-plus',
                title: 'Add a new lesson standard'
            },
            'addTerminology': {
                label: 'Add Term',
                onClick: 'addTerminology()',
                iconClass: 'fa-plus',
                title: 'Add a new terminology term'
            },
            'addContentSection': {
                label: 'Add Content Section',
                onClick: 'addContentSection()',
                iconClass: 'fa-plus',
                title: 'Add a new instructional content section'
            },
            'pasteSectionAtEnd': {
                label: 'Paste Section',
                onClick: (param) => `pasteSectionAtEnd('${param}')`,
                iconClass: 'fa-paste',
                className: 'add-btn paste-section-btn',
                title: (param) => `Paste a copied ${param === 'content' ? 'content section' : 'question'} at the end`
            },
            'addQuestion': {
                label: 'Add Question',
                onClick: 'addQuestion()',
                iconClass: 'fa-plus',
                title: 'Add a new practice question'
            }
        };

        /**
         * Hydrate static action buttons from placeholders
         * Replaces <div class="js-action-button" data-action="..."> with actual buttons
         */
        function hydrateStaticActionButtons() {
            if (window.__hydrateStaticActionButtonsDone) return;
            window.__hydrateStaticActionButtonsDone = true;
            const placeholders = document.querySelectorAll('.js-action-button');
            placeholders.forEach(placeholder => {
                const action = placeholder.getAttribute('data-action');
                const param = placeholder.getAttribute('data-param');
                
                if (!action || !ACTION_BUTTON_CONFIGS_STATIC[action]) {
                    return; // Unknown action, skip silently
                }
                
                const config = ACTION_BUTTON_CONFIGS_STATIC[action];
                let buttonConfig = { ...config };
                
                // Handle parameterized actions
                if (typeof config.onClick === 'function') {
                    buttonConfig.onClick = config.onClick(param);
                }
                if (typeof config.title === 'function') {
                    buttonConfig.title = config.title(param);
                }
                
                const button = createButton(buttonConfig);
                placeholder.parentNode.replaceChild(button, placeholder);
            });
        }

        // Action button configuration presets
        const ACTION_BUTTON_CONFIGS = {
            // Nested list items: choices, matching items
            LIST_ITEM: {
                buttons: ['before', 'after', 'moveUp', 'moveDown', 'remove'],
                buttonClasses: {
                    before: 'add-bbox-btn',
                    after: 'add-bbox-btn',
                    moveUp: 'reorder-btn',
                    moveDown: 'reorder-btn',
                    remove: 'remove-btn'
                },
                buttonLabels: {
                    before: 'Before',
                    after: 'After',
                    moveUp: '',
                    moveDown: '',
                    remove: ''
                },
                buttonIcons: {
                    before: 'fa-plus',
                    after: 'fa-plus',
                    moveUp: 'fa-arrow-up',
                    moveDown: 'fa-arrow-down',
                    remove: ''
                },
                buttonTitles: {
                    before: (ctx) => `Add ${ctx.itemLabel || 'Item'} Before`,
                    after: (ctx) => `Add ${ctx.itemLabel || 'Item'} After`,
                    moveUp: 'Move Up',
                    moveDown: 'Move Down',
                    remove: (ctx) => `Remove ${ctx.itemLabel || 'Item'}`
                },
                handlers: {
                    before: null, // Set per context
                    after: null, // Set per context
                    moveUp: null, // Set per context
                    moveDown: null, // Set per context
                    remove: null // Set per context
                },
                containerClass: 'array-item-header-controls',
                customStyles: {} // Can override per context
            },
            
            // Top-level sections: content sections, questions
            SECTION: {
                buttons: ['before', 'after', 'copy', 'paste', 'duplicate', 'moveUp', 'moveDown', 'collapse', 'remove'],
                buttonClasses: {
                    before: 'add-section-btn',
                    after: 'add-section-btn',
                    copy: 'copy-section-btn',
                    paste: 'copy-section-btn paste-replace-btn',
                    duplicate: 'duplicate-btn',
                    moveUp: 'reorder-btn',
                    moveDown: 'reorder-btn',
                    collapse: 'collapse-btn',
                    remove: 'remove-btn'
                },
                buttonLabels: {
                    before: 'Before',
                    after: 'After',
                    copy: '',
                    paste: '',
                    duplicate: '',
                    moveUp: '',
                    moveDown: '',
                    collapse: '',
                    remove: ''
                },
                buttonIcons: {
                    before: 'fa-plus',
                    after: 'fa-plus',
                    copy: 'fa-copy',
                    paste: 'fa-paste',
                    duplicate: 'fa-clone',
                    moveUp: 'fa-arrow-up',
                    moveDown: 'fa-arrow-down',
                    collapse: 'fa-chevron-down',
                    remove: ''
                },
                buttonTitles: {
                    before: (ctx) => `Add ${ctx.sectionLabel || 'Section'} Before`,
                    after: (ctx) => `Add ${ctx.sectionLabel || 'Section'} After`,
                    copy: (ctx) => `Copy ${ctx.sectionLabel || 'Section'}`,
                    paste: (ctx) => `Paste & Replace ${ctx.sectionLabel || 'Section'}`,
                    duplicate: (ctx) => `Duplicate ${ctx.sectionLabel || 'Section'}`,
                    moveUp: 'Move Up',
                    moveDown: 'Move Down',
                    collapse: 'Collapse/Expand Section',
                    remove: (ctx) => `Remove ${ctx.sectionLabel || 'Section'}`
                },
                handlers: {
                    before: null,
                    after: null,
                    copy: 'copySection',
                    paste: 'pasteIntoSection',
                    duplicate: 'duplicateSection',
                    moveUp: 'moveItemUp',
                    moveDown: 'moveItemDown',
                    collapse: 'toggleSectionCollapse',
                    remove: 'removeArrayItem'
                },
                containerClass: 'array-item-header-controls'
            },
            
            // BBox rows
            BBOX: {
                buttons: ['moveUp', 'moveDown', 'before', 'after', 'draw', 'paste', 'copy', 'duplicate', 'remove'],
                buttonClasses: {
                    moveUp: 'reorder-btn',
                    moveDown: 'reorder-btn',
                    before: 'add-bbox-btn',
                    after: 'add-bbox-btn',
                    draw: 'add-btn',
                    paste: 'add-btn',
                    copy: 'add-btn',
                    duplicate: 'duplicate-btn',
                    remove: 'remove-btn'
                },
                buttonLabels: {
                    moveUp: '',
                    moveDown: '',
                    before: 'Before',
                    after: 'After',
                    draw: 'Draw',
                    paste: 'Paste',
                    copy: 'Copy',
                    duplicate: '',
                    remove: ''
                },
                buttonIcons: {
                    moveUp: 'fa-arrow-up',
                    moveDown: 'fa-arrow-down',
                    before: 'fa-plus',
                    after: 'fa-plus',
                    draw: 'fa-pen-square',
                    paste: 'fa-paste',
                    copy: 'fa-copy',
                    duplicate: 'fa-clone',
                    remove: ''
                },
                buttonTitles: {
                    moveUp: 'Move Up',
                    moveDown: 'Move Down',
                    before: 'Add Image Before',
                    after: 'Add Image After',
                    draw: 'Open PDF viewer to draw bounding box',
                    paste: 'Paste bounding box coordinates from clipboard',
                    copy: 'Copy bounding box coordinates to clipboard',
                    duplicate: 'Duplicate BBox',
                    remove: 'Remove'
                },
                handlers: {
                    moveUp: 'moveItemUp',
                    moveDown: 'moveItemDown',
                    before: null, // Set per context
                    after: null, // Set per context
                    draw: 'openBboxDrawer',
                    paste: 'pasteBboxJson',
                    copy: 'copyBboxJson',
                    duplicate: 'duplicateBbox',
                    remove: 'removeArrayItem'
                },
                containerClass: 'row-actions'
            },
            
            // Simple items: standards, terminology
            SIMPLE: {
                buttons: ['moveUp', 'moveDown', 'remove'],
                buttonClasses: {
                    moveUp: 'reorder-btn',
                    moveDown: 'reorder-btn',
                    remove: 'remove-btn'
                },
                buttonLabels: {
                    moveUp: '',
                    moveDown: '',
                    remove: ''
                },
                buttonIcons: {
                    moveUp: 'fa-arrow-up',
                    moveDown: 'fa-arrow-down',
                    remove: ''
                },
                buttonTitles: {
                    moveUp: 'Move Up',
                    moveDown: 'Move Down',
                    remove: (ctx) => `Remove ${ctx.itemLabel || 'Item'}`
                },
                handlers: {
                    moveUp: 'moveItemUp',
                    moveDown: 'moveItemDown',
                    remove: 'removeArrayItem'
                },
                containerClass: 'array-item-header-controls'
            },
            
            // Relationship rows (minimal)
            RELATIONSHIP: {
                buttons: ['remove'],
                buttonClasses: {
                    remove: 'remove-btn'
                },
                buttonLabels: {
                    remove: ''
                },
                buttonIcons: {
                    remove: ''
                },
                buttonTitles: {
                    remove: 'Remove Relationship'
                },
                handlers: {
                    remove: 'removeRelationship'
                },
                containerClass: null, // Inline in relationship row
                customStyles: {
                    remove: 'padding: 4px 10px;'
                }
            }
        };

        // Button configuration for static HTML areas (top bar, tabs, JSON controls)
        const STATIC_BUTTON_CONFIGS = {
            // Top bar undo/redo buttons
            TOPBAR_UNDO_REDO: [
                { id: 'undo-btn', onClick: 'undoAction()', title: 'Undo', className: 'dark-mode-toggle', iconClass: 'fa-undo', disabled: true },
                { id: 'redo-btn', onClick: 'redoAction()', title: 'Redo', className: 'dark-mode-toggle', iconClass: 'fa-redo', disabled: true }
            ],
            
            // Top bar action buttons
            TOPBAR_ACTIONS: [
                { id: 'saveBtn', className: 'dark-mode-toggle', onClick: 'saveProgress()', title: 'Save Progress (Ctrl+S)', iconClass: 'fa-save' },
                { className: 'dark-mode-toggle', onClick: 'location.reload()', title: 'Reload Page', iconClass: 'fa-sync-alt' },
                { className: 'dark-mode-toggle', onClick: 'scrollToTop()', title: 'Scroll to Top', iconClass: 'fa-arrow-up' },
                { id: 'autoResizeToggle', className: 'dark-mode-toggle', onClick: 'toggleAutoResize()', title: 'Toggle Auto-Resize Textareas', iconClass: 'fa-arrows-alt-v' },
                { id: 'trailingSpacesToggle', className: 'dark-mode-toggle', onClick: 'toggleTrailingSpacesIndicator()', title: 'Show trailing spaces indicator in preview boxes', iconClass: 'fa-exclamation-triangle' },
                { id: 'darkModeToggle', className: 'dark-mode-toggle', onClick: 'toggleDarkMode()', iconClass: 'fa-moon' }
            ],
            
            // Clear search button
            CLEAR_SEARCH: [
                { id: 'clearSearchBtn', onClick: 'clearSearch()', title: 'Clear search', className: '', iconClass: 'fa-times', style: 'display: none; padding: 6px 10px; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-secondary); color: var(--text-primary); cursor: pointer; font-size: 0.9rem;' }
            ],
            
            // Main tabs (Input Form / Final Preview)
            MAIN_TABS: [
                { className: 'tab active', id: 'main-tab-input', onClick: "showMainTab('input-form')", title: 'Edit the form data', label: 'Input Form' },
                { className: 'tab', id: 'main-tab-preview', onClick: "showMainTab('final-preview')", title: 'Preview all sections and questions', label: 'Final Preview' }
            ],
            
            // Sub tabs (Basic Info, Lesson Preamble, Content, Questions)
            SUB_TABS: [
                { className: 'tab active', onClick: "showTab('basic')", title: 'Basic page information (page numbers, page type)', label: 'Basic Info' },
                { className: 'tab', onClick: "showTab('preamble')", title: 'Lesson metadata (ID, title, standards, terminology)', label: 'Lesson Preamble' },
                { className: 'tab', onClick: "showTab('content')", title: 'Instructional content sections', label: 'Content' },
                { className: 'tab', onClick: "showTab('questions')", title: 'Practice questions', label: 'Questions' }
            ],
            
            // Generate JSON button
            GENERATE_JSON: [
                { className: 'generate-btn', onClick: 'generateJSON()', style: 'width:auto;', title: 'Generate JSON from all form data (validates before generating)', label: 'Generate JSON', iconClass: 'fa-magic', attrs: { iconStyle: 'font-size: 0.75rem;' } }
            ],
            
            // JSON import controls
            JSON_IMPORT_CONTROLS: [
                { className: 'add-btn', type: 'button', onClick: 'event.stopPropagation(); loadJSON()', title: 'Load JSON or Python dictionary from the text area below to populate the form', label: 'Load JSON/Dict', iconClass: 'fa-file-upload' },
                { className: 'add-btn', type: 'button', onClick: 'event.stopPropagation(); restoreLatest()', title: 'Restore the latest saved work from storage (overwrites current form)', label: 'Restore Latest', iconClass: 'fa-history' },
                { className: 'add-btn', type: 'button', onClick: 'event.stopPropagation(); confirmClearForm()', title: 'Clear all form data and start fresh', label: 'Clear Form', iconClass: 'fa-broom' },
                { className: 'add-btn', type: 'button', onClick: 'event.stopPropagation(); openBboxDrawerForPDFs()', title: 'Upload textbook or guidebook PDF for drawing bounding boxes', label: 'Upload PDFs', iconClass: 'fa-file-pdf' }
            ],
            
            // JSON export controls
            JSON_EXPORT_CONTROLS: [
                { className: 'add-btn', onClick: 'copyJSON()', title: 'Copy the generated JSON to clipboard', label: 'Copy JSON', iconClass: 'fa-copy' }
            ],
            
            // BBox modal prev button
            BBOX_NAV_PREV_BUTTON: [
                { id: 'em-prev', className: 'bbox-btn', title: 'Previous page', label: '' }
            ],
            
            // BBox modal next button
            BBOX_NAV_NEXT_BUTTON: [
                { id: 'em-next', className: 'bbox-btn', title: 'Next page', label: '' }
            ],
            
            // BBox modal goto button
            BBOX_GOTO_BUTTON: [
                { id: 'em-goto-btn', className: 'bbox-btn', title: 'Go to page', label: 'Go' }
            ],
            
            // BBox modal zoom buttons (split for layout)
            BBOX_ZOOM_OUT: [
                { id: 'em-zoom-out', className: 'bbox-btn', title: 'Zoom out', label: '' }
            ],
            BBOX_ZOOM_IN: [
                { id: 'em-zoom-in', className: 'bbox-btn', title: 'Zoom in', label: '+' }
            ],
            BBOX_ZOOM_RESET: [
                { id: 'em-zoom-reset', className: 'bbox-btn', title: 'Reset zoom to default', label: 'Reset' }
            ],
            
            // BBox modal drawing buttons
            BBOX_DRAWING_BUTTONS: [
                { id: 'em-undo', className: 'bbox-btn', title: 'Undo last bounding box', label: 'Undo' },
                { id: 'em-add', className: 'bbox-btn', title: 'Add a new bounding box', label: 'Add BBox' },
                { id: 'em-clear', className: 'bbox-btn danger', title: 'Clear all bounding boxes on current page', label: 'Clear Page' }
            ],
            
            // BBox modal close button
            BBOX_CLOSE_BUTTON: [
                { id: 'em-close', className: 'bbox-btn danger', title: 'Close', label: '' }
            ],
            
            // BBox modal footer buttons
            BBOX_FOOTER_BUTTONS: [
                { id: 'em-cancel', className: 'bbox-btn', label: 'Cancel' },
                { id: 'em-confirm', className: 'bbox-btn primary', label: 'Use Selected' }
            ],
            
            // View toggle buttons (PDF/JSON)
            VIEW_TOGGLE_BUTTONS: [
                { id: 'toggle-pdf-btn', className: 'view-toggle-btn', onClick: 'showPdfViewer()', title: 'View and navigate PDF pages', label: 'PDF Viewer', iconClass: 'fa-file-pdf' },
                { id: 'toggle-json-btn', className: 'view-toggle-btn active', onClick: 'showJsonPreview()', title: 'View generated JSON output', label: 'JSON Preview', iconClass: 'fa-code' }
            ],
            
            // Main PDF auto navigation toggle (label removed - status span will contain text)
            MAIN_PDF_AUTO_NAV: [
                { id: 'auto-nav-toggle', className: 'bbox-btn', type: 'button', onClick: 'toggleAutoNavigation()', title: 'Toggle Auto Page Navigation', iconClass: 'fa-magic' }
            ],
            
            // Main PDF zoom buttons (split for layout)
            MAIN_PDF_ZOOM_OUT: [
                { id: 'main-pdf-zoom-out', className: 'bbox-btn', type: 'button', title: 'Zoom out', label: '' }
            ],
            MAIN_PDF_ZOOM_IN: [
                { id: 'main-pdf-zoom-in', className: 'bbox-btn', type: 'button', title: 'Zoom in', label: '+' }
            ],
            MAIN_PDF_ZOOM_RESET: [
                { id: 'main-pdf-zoom-reset', className: 'bbox-btn', type: 'button', title: 'Reset zoom to fit canvas', label: '' }
            ],
            
            // Main PDF navigation buttons (split for layout)
            MAIN_PDF_NAV_PREV: [
                { id: 'main-pdf-prev', className: 'bbox-btn', type: 'button', title: 'Previous page', label: '' }
            ],
            MAIN_PDF_NAV_NEXT: [
                { id: 'main-pdf-next', className: 'bbox-btn', type: 'button', title: 'Next page', label: '' }
            ],
            
            // Main PDF goto button
            MAIN_PDF_GOTO_BUTTON: [
                { id: 'main-pdf-goto-btn', className: 'bbox-btn', type: 'button', title: 'Go to the specified page', label: 'Go' }
            ],
            
            // PDF source toggle buttons (textbook/guide)
            PDF_SOURCE_TOGGLE: [
                { id: 'pdf-source-textbook', className: 'pdf-source-btn active', onClick: "switchPdfSource('textbook')", title: 'Switch to textbook PDF', label: 'Textbook', iconClass: 'fa-book' },
                { id: 'pdf-source-guide', className: 'pdf-source-btn', onClick: "switchPdfSource('guide')", title: 'Switch to guidebook PDF', label: 'Guide', iconClass: 'fa-book-open' }
            ]
        };

        /**
         * Render button group from config array into container
         * @param {HTMLElement|string} container - Container element or ID
         * @param {Array<Object>} buttonConfigs - Array of button configs
         * @param {Object} options - Optional settings
         * @param {boolean} options.preserveExisting - If true, append instead of clearing (default: false)
         */
        function renderButtonGroup(container, buttonConfigs, options = {}) {
            const containerEl = typeof container === 'string' ? document.getElementById(container) : container;
            if (!containerEl || !Array.isArray(buttonConfigs)) return;
            
            // Clear existing content only if not preserving
            // This ensures we don't have duplicates from old hardcoded buttons
            if (!options.preserveExisting) {
                containerEl.innerHTML = ''; // Clear existing
            }
            
            buttonConfigs.forEach(config => {
                const button = createButton(config);
                containerEl.appendChild(button);
            });
        }

        /**
         * Hydrate all static button groups on page load
         */
        function hydrateStaticButtons() {
            if (window.__hydrateStaticButtonsDone) return;
            window.__hydrateStaticButtonsDone = true;
            // Top bar undo/redo
            renderButtonGroup('topbar-undo-redo', STATIC_BUTTON_CONFIGS.TOPBAR_UNDO_REDO);
            
            // Top bar actions
            renderButtonGroup('topbar-actions', STATIC_BUTTON_CONFIGS.TOPBAR_ACTIONS);
            
            // Clear search
            renderButtonGroup('topbar-clear-search', STATIC_BUTTON_CONFIGS.CLEAR_SEARCH);
            
            // Main tabs
            renderButtonGroup('main-tabs-container', STATIC_BUTTON_CONFIGS.MAIN_TABS);
            
            // Sub tabs
            renderButtonGroup('sub-tabs-container', STATIC_BUTTON_CONFIGS.SUB_TABS);
            
            // Generate JSON
            renderButtonGroup('generate-json-container', STATIC_BUTTON_CONFIGS.GENERATE_JSON);
            
            // JSON import controls
            renderButtonGroup('json-import-controls', STATIC_BUTTON_CONFIGS.JSON_IMPORT_CONTROLS);
            
            // JSON export controls
            renderButtonGroup('json-export-controls', STATIC_BUTTON_CONFIGS.JSON_EXPORT_CONTROLS);
            
            // View toggle buttons (PDF/JSON)
            renderButtonGroup('view-toggle-buttons-container', STATIC_BUTTON_CONFIGS.VIEW_TOGGLE_BUTTONS);
            
            // BBox modal buttons (in correct order)
            renderButtonGroup('bbox-nav-prev-button', STATIC_BUTTON_CONFIGS.BBOX_NAV_PREV_BUTTON);
            renderButtonGroup('bbox-nav-next-button', STATIC_BUTTON_CONFIGS.BBOX_NAV_NEXT_BUTTON);
            renderButtonGroup('bbox-goto-button', STATIC_BUTTON_CONFIGS.BBOX_GOTO_BUTTON);
            renderButtonGroup('bbox-zoom-out-button', STATIC_BUTTON_CONFIGS.BBOX_ZOOM_OUT);
            renderButtonGroup('bbox-zoom-in-button', STATIC_BUTTON_CONFIGS.BBOX_ZOOM_IN);
            renderButtonGroup('bbox-zoom-reset-button', STATIC_BUTTON_CONFIGS.BBOX_ZOOM_RESET);
            renderButtonGroup('bbox-drawing-buttons', STATIC_BUTTON_CONFIGS.BBOX_DRAWING_BUTTONS);
            renderButtonGroup('bbox-close-button', STATIC_BUTTON_CONFIGS.BBOX_CLOSE_BUTTON);
            renderButtonGroup('bbox-footer-buttons', STATIC_BUTTON_CONFIGS.BBOX_FOOTER_BUTTONS);
            
            // Note: PDF viewer buttons are hydrated in initializePdfViewer() when the viewer is initialized.
            // They are not hydrated here to avoid duplication since initializePdfViewer creates the HTML dynamically.
        }

        /**
         * Build action buttons HTML from config
         * @param {Object} config - Button configuration (from ACTION_BUTTON_CONFIGS or custom)
         * @param {Object} context - Context object for dynamic labels/titles (optional)
         * @returns {string} HTML string for button container
         */
        function buildActionButtonsHTML(config, context = {}) {
            let buttonsHTML = '';
            
            for (const buttonKey of config.buttons) {
                const cls = config.buttonClasses[buttonKey] || '';
                const label = config.buttonLabels[buttonKey] || '';
                const icon = config.buttonIcons[buttonKey] || '';
                const titleFn = config.buttonTitles[buttonKey];
                const title = typeof titleFn === 'function' ? titleFn(context) : (titleFn || '');
                const customStyle = config.customStyles?.[buttonKey] || '';
                const handler = config.handlers[buttonKey];
                
                // Build icon HTML if present
                const iconHTML = icon ? `<i class="fas ${icon}"></i>` : '';
                
                // Build onclick attribute if handler exists
                const onclickAttr = handler ? ` onclick="${handler}(this)"` : '';
                
                // Build button HTML
                const buttonHTML = `
                    <button class="${cls}"${onclickAttr} title="${title}"${customStyle ? ` style="${customStyle}"` : ''}>
                        ${iconHTML}${label ? ` ${label}` : ''}
                    </button>
                `;
                
                buttonsHTML += buttonHTML;
            }
            
            // Wrap in container if specified
            if (config.containerClass) {
                return `<div class="${config.containerClass}">${buttonsHTML}</div>`;
            }
            
            return buttonsHTML;
        }

        // Helper to get list context for nested lists (choices, matching items)
        // Returns: { containerEl, containerId, questionEl, updateNumbersFn }
        function getListContext(buttonOrItemEl) {
            const itemEl = buttonOrItemEl.classList && buttonOrItemEl.classList.contains('choice-item') 
                ? buttonOrItemEl 
                : buttonOrItemEl.classList && buttonOrItemEl.classList.contains('matching-item')
                ? buttonOrItemEl
                : buttonOrItemEl.closest('.choice-item') || buttonOrItemEl.closest('.matching-item');
            
            if (!itemEl) return null;
            
            const isChoice = itemEl.classList.contains('choice-item');
            const isMatching = itemEl.classList.contains('matching-item');
            
            const containerEl = itemEl.parentElement; // The list container (choices-list-* or matching-list)
            const questionEl = containerEl ? containerEl.closest('.array-item') : null;
            
            let containerId = null;
            let updateNumbersFn = null;
            
            if (isChoice) {
                // For choices, use the choices list ID as containerId
                containerId = containerEl ? containerEl.id : null;
                updateNumbersFn = function() {
                    if (questionEl) {
                        updateCorrectAnswerRadios(questionEl);
                        updateCheckboxSummary(questionEl);
                    }
                };
            } else if (isMatching) {
                // For matching items, use side-specific containerId
                const side = itemEl.dataset.side || (containerEl && containerEl.id.includes('left') ? 'left' : 'right');
                const listId = containerEl ? containerEl.id : null;
                containerId = listId || `matching-${side}-${questionEl ? questionEl.dataset.questionId || 'unknown' : 'unknown'}`;
                updateNumbersFn = function() {
                    if (containerEl) {
                        renumberMatchingItems(containerEl);
                    }
                    if (questionEl) {
                        updateRelationshipUI(questionEl);
                    }
                };
            }
            
            return {
                containerEl,
                containerId,
                questionEl,
                updateNumbersFn,
                isChoice,
                isMatching
            };
        }

        /**
         * Centralized hook called after undo/redo restores an element.
         * Initializes the element's state based on its type using the canonical finalizer.
         */
        function postUndoRedoRestore(element) {
            if (!element) return;

            // Check if this is a question element by looking for the question_type select
            const hasQuestionTypeSelect = element.querySelector && element.querySelector('select[onchange*="toggleQuestionType"]');
            const isArrayItem = element.classList && element.classList.contains('array-item');
            const isQuestion = hasQuestionTypeSelect && isArrayItem;
            
            // Check if this is a content section element (has section title input but no question type select)
            const hasSectionTitle = element.querySelector && element.querySelector('input[placeholder*="Section title"]');
            const isContentSection = hasSectionTitle && isArrayItem && !hasQuestionTypeSelect;
            
            // Check for other element types
            const isChoiceItem = element.classList && element.classList.contains('choice-item');
            const isMatchingItem = element.classList && element.classList.contains('matching-item');

            if (isQuestion) {
                // For questions restored from DOM, ensure type is synced
                const questionTypeSelect = element.querySelector('select.question-type-select, select[onchange*="toggleQuestionType"]');
                if (questionTypeSelect) {
                    const currentType = getQuestionType(element);
                    setQuestionType(element, currentType);
                    toggleQuestionType(questionTypeSelect);
                }
                // Use canonical finalizer for the rest
                finalizeElement(element, { previews: true, fonts: true, bbox: true, refresh: true, autoSize: true });
            } else if (isContentSection) {
                // Use canonical finalizer for content sections
                finalizeElement(element, { previews: true, fonts: true, bbox: true, refresh: true, autoSize: true });
            } else if (isMatchingItem) {
                // Use specialized matching item finalizer
                finalizeMatchingListItem(element);
            } else if (isChoiceItem) {
                // Use canonical finalizer for choice items
                finalizeElement(element, { previews: true, fonts: true, bbox: false, refresh: true, autoSize: true });
            }
        }
        
        // Helper to update choice UI if the element is a choice item
        function updateChoiceUIIfNeeded(element) {
            if (!element || !element.isConnected) return;
            
            // Check if this is a choice item - choice items have class 'choice-item'
            // or are inside a choices-list container
            const isChoiceItem = element.classList.contains('choice-item') || 
                                 (element.closest && element.closest('[id^="choices-list-"]') !== null);
            
            if (isChoiceItem) {
                // Find the parent question element
                // Choices are inside choices-list which is inside a question
                const choicesList = element.closest('[id^="choices-list-"]');
                const questionEl = choicesList ? choicesList.closest('.array-item') : 
                                  (element.closest('.array-item[data-type="question"]') || 
                                   element.closest('.array-item'));
                
                if (questionEl) {
                    // Use setTimeout to ensure DOM is fully updated before updating UI
                    setTimeout(() => {
                        if (!questionEl.isConnected) return;
                        // Update correct answer UI
                        updateCorrectAnswerRadios(questionEl);
                        updateCheckboxSummary(questionEl);
                    }, 0);
                }
            }
        }
        
        // Helper to update matching relationship UI if the element is a matching item
        // ===== QUESTION TYPE DATASET HELPERS (SINGLE SOURCE OF TRUTH) =====
        // Get question type from dataset (canonical source of truth)
        function getQuestionType(questionEl) {
            if (!questionEl) return 'free_form';
            // Dataset is the canonical source
            if (questionEl.dataset.questionType) {
                return questionEl.dataset.questionType;
            }
            // Fallback: read from select and set dataset once
            const select = questionEl.querySelector('select.question-type-select, select[onchange*="toggleQuestionType"]');
            if (select) {
                const type = select.value || 'free_form';
                questionEl.dataset.questionType = type;
                return type;
            }
            return 'free_form';
        }
        
        // Set question type in both dataset and select (keeps them in sync)
        function setQuestionType(questionEl, type) {
            if (!questionEl || !type) return;
            // Set dataset first (canonical source)
            questionEl.dataset.questionType = type;
            // Then set select value
            const select = questionEl.querySelector('select.question-type-select, select[onchange*="toggleQuestionType"]');
            if (select) {
                select.value = type;
                // Verify it was set correctly
                if (select.value !== type) {
                    const options = Array.from(select.options);
                    const targetIndex = options.findIndex(opt => opt.value === type);
                    if (targetIndex >= 0) {
                        select.selectedIndex = targetIndex;
                    }
                }
            }
        }
        
        // ===== QUESTION STATE SERIALIZATION/RESTORATION =====
        // Serialize complete question state for undo/redo (captures actual values, not just DOM)
        function serializeQuestionState(questionEl) {
            if (!questionEl) return null;
            
            const state = {};
            
            // Header fields
            const questionIdInput = findFieldByLabel(questionEl, 'Question ID', 'input');
            const guidePdfPageInput = findFieldByLabel(questionEl, 'Guide PDF Page', 'input');
            const relatedQuestionInput = findFieldByLabel(questionEl, 'Related Question', 'input');
            
            state.id = questionIdInput ? questionIdInput.value : '';
            state.guide_pdf_page = guidePdfPageInput ? guidePdfPageInput.value : '';
            state.related_question = relatedQuestionInput ? relatedQuestionInput.value : '';
            
            // CRITICAL: Use dataset as source of truth, not select value
            // Ensure dataset is set if missing
            const scopedSelect = questionEl.querySelector('select.question-type-select, select[onchange*="toggleQuestionType"]');
            if (scopedSelect) {
                // If dataset exists and differs from select, force select to match dataset
                if (questionEl.dataset.questionType && questionEl.dataset.questionType !== scopedSelect.value) {
                    scopedSelect.value = questionEl.dataset.questionType;
                    // If still wrong, set selectedIndex
                    if (scopedSelect.value !== questionEl.dataset.questionType) {
                        const options = Array.from(scopedSelect.options);
                        const targetIndex = options.findIndex(opt => opt.value === questionEl.dataset.questionType);
                        if (targetIndex >= 0) {
                            scopedSelect.selectedIndex = targetIndex;
                        }
                    }
                }
                // If dataset is missing, set it from select
                if (!questionEl.dataset.questionType) {
                    questionEl.dataset.questionType = scopedSelect.value || 'free_form';
                }
            }
            // Use dataset as source of truth
            state.question_type = questionEl.dataset.questionType || getQuestionType(questionEl);
            
            // Text fields
            const setupTextarea = findFieldByLabel(questionEl, 'Set-up Text', 'textarea');
            const questionTextarea = findFieldByLabel(questionEl, 'Question Text', 'textarea');
            state.set_up_text = setupTextarea ? setupTextarea.value : '';
            state.question_text = questionTextarea ? questionTextarea.value : '';
            
            // Guide answer (varies by type)
            const guideAnswerContainer = questionEl.querySelector('#guide-answer-container');
            const guideAnswerTextarea = guideAnswerContainer?.querySelector('textarea');
            if (guideAnswerTextarea) {
                state.guide_answer = guideAnswerTextarea.value;
            } else {
                // Check type-specific containers
                const blanksContainer = questionEl.querySelector('#blanks-container');
                const blanksGuideAnswer = blanksContainer?.querySelector('.guide-answer-notes');
                if (blanksGuideAnswer) {
                    state.guide_answer = blanksGuideAnswer.value;
                } else {
                    const matchingContainer = questionEl.querySelector('#matching-container');
                    const matchingGuideAnswer = matchingContainer?.querySelector('.guide-answer-notes');
                    if (matchingGuideAnswer) {
                        state.guide_answer = matchingGuideAnswer.value;
                    } else {
                        const choicesContainer = questionEl.querySelector('#choices-container');
                        const choicesGuideAnswer = choicesContainer?.querySelector('.guide-answer-notes');
                        if (choicesGuideAnswer) {
                            state.guide_answer = choicesGuideAnswer.value;
                        } else {
                            state.guide_answer = '';
                        }
                    }
                }
            }
            
            // Type-specific data
            if (state.question_type === 'fill_in_the_blanks') {
                const blankItems = questionEl.querySelectorAll('.blank-answer-item');
                state.values = Array.from(blankItems).map(item => {
                    const textarea = item.querySelector('.blank-answer-input');
                    return textarea ? textarea.value : '';
                });
            } else if (state.question_type === 'matching') {
                const leftList = questionEl.querySelector('[id^="matching-left-list-"]');
                const rightList = questionEl.querySelector('[id^="matching-right-list-"]');
                state.left = leftList ? Array.from(leftList.querySelectorAll('.matching-item')).map(item => {
                    const textarea = item.querySelector('.matching-item-text');
                    return textarea ? textarea.value : '';
                }) : [];
                state.right = rightList ? Array.from(rightList.querySelectorAll('.matching-item')).map(item => {
                    const textarea = item.querySelector('.matching-item-text');
                    return textarea ? textarea.value : '';
                }) : [];
                const relationshipsList = questionEl.querySelector('[id^="relationships-list-"]');
                // Store relationships by UID internally, convert to indices for export
                ensureMatchingUids(questionEl);
                const leftItems = leftList ? Array.from(leftList.querySelectorAll('.matching-item')) : [];
                const rightItems = rightList ? Array.from(rightList.querySelectorAll('.matching-item')) : [];
                const leftUidToIndex = new Map();
                const rightUidToIndex = new Map();
                leftItems.forEach((item, index) => {
                    const uid = item.dataset.leftUid;
                    if (uid) leftUidToIndex.set(uid, index + 1);
                });
                rightItems.forEach((item, index) => {
                    const uid = item.dataset.rightUid;
                    if (uid) rightUidToIndex.set(uid, index + 1);
                });
                state.relationship = relationshipsList ? Array.from(relationshipsList.querySelectorAll('.relationship-item')).map(item => {
                    const leftUid = item.dataset.leftUid;
                    const rightUid = item.dataset.rightUid;
                    // Convert UIDs to indices for export
                    const leftIndex = leftUid ? (leftUidToIndex.get(leftUid) || 0) : 0;
                    const rightIndex = rightUid ? (rightUidToIndex.get(rightUid) || 0) : 0;
                    return [leftIndex, rightIndex];
                }) : [];
            } else if (state.question_type === 'multiple_choice' || state.question_type === 'checkbox') {
                const choicesList = questionEl.querySelector('[id^="choices-list-"]');
                ensureChoiceUids(questionEl);
                const choices = choicesList ? Array.from(choicesList.querySelectorAll('.choice-item')) : [];
                const choiceUidToIndex = new Map();
                choices.forEach((item, index) => {
                    const uid = item.dataset.choiceUid;
                    if (uid) choiceUidToIndex.set(uid, index + 1);
                });
                state.choices = choices.map(item => {
                    const choiceIdInput = item.querySelector('.choice-id');
                    const choiceTextArea = item.querySelector('.choice-text');
                    const choiceCorrectInput = item.querySelector('.choice-correct');
                    return {
                        id: choiceIdInput ? choiceIdInput.value : '',
                        text: choiceTextArea ? choiceTextArea.value : '',
                        checked: choiceCorrectInput ? choiceCorrectInput.checked : false
                    };
                });
                // Store correct answer: for multiple_choice use index, for checkbox derive from UIDs
                if (state.question_type === 'multiple_choice') {
                    const correctChoiceUid = getCorrectChoiceUid(questionEl);
                    if (correctChoiceUid) {
                        const correctIndex = choiceUidToIndex.get(correctChoiceUid) || 0;
                        state.correct_answer_index = correctIndex; // Store as index for export
                    }
                } else if (state.question_type === 'checkbox') {
                    // Derive checked state from UIDs (canonical source of truth)
                    const correctUids = getCorrectChoiceUids(questionEl);
                    state.choices = choices.map((item, index) => {
                        const choiceIdInput = item.querySelector('.choice-id');
                        const choiceTextArea = item.querySelector('.choice-text');
                        const choiceUid = item.dataset.choiceUid;
                        const isChecked = choiceUid ? correctUids.has(choiceUid) : false;
                        return {
                            id: choiceIdInput ? choiceIdInput.value : '',
                            text: choiceTextArea ? choiceTextArea.value : '',
                            checked: isChecked
                        };
                    });
                }
            }
            
            // BBox data
            const questionImagesGroup = findFormGroupByLabel(questionEl, 'Question Images');
            const answerImagesGroup = findFormGroupByLabel(questionEl, 'Answer Images');
            state.question_images = questionImagesGroup ? serializeBboxGroup(questionImagesGroup) : [];
            state.guide_answer_images = answerImagesGroup ? serializeBboxGroup(answerImagesGroup) : [];
            
            return state;
        }
        
        // Helper: Serialize bbox group
        function serializeBboxGroup(bboxGroup) {
            const bboxRows = bboxGroup.querySelectorAll('.bbox-item');
            return Array.from(bboxRows).map(row => {
                const pageInput = row.querySelector('.bbox-page');
                const x0Input = row.querySelector('.bbox-x0');
                const y0Input = row.querySelector('.bbox-y0');
                const x1Input = row.querySelector('.bbox-x1');
                const y1Input = row.querySelector('.bbox-y1');
                return {
                    page: pageInput ? pageInput.value : '',
                    x0: x0Input ? x0Input.value : '',
                    y0: y0Input ? y0Input.value : '',
                    x1: x1Input ? x1Input.value : '',
                    y1: y1Input ? y1Input.value : ''
                };
            });
        }
        
        // Build a complete question element from serialized state (ONLY place that rebuilds questions from state)
        function buildQuestionFromState(state) {
            if (!state) return null;
            
            const container = document.getElementById('questions_container');
            const questionCount = container ? container.querySelectorAll(':scope > .array-item').length + 1 : 1;
            
            // Build fresh question DOM
            const newQuestion = document.createElement('div');
            newQuestion.className = 'array-item';
            newQuestion.setAttribute('data-item-type', 'question');
            // Mark as a true section for navigation (canonical section marker)
            newQuestion.setAttribute('data-section-id', `question-${questionCount}`);
            newQuestion.innerHTML = getQuestionHTML(questionCount);
            
            // CRITICAL: Set dataset FIRST (canonical source of truth)
            const targetType = state.question_type || 'free_form';
            newQuestion.dataset.questionType = targetType;
            
            // Set header fields
            const questionIdInput = findFieldByLabel(newQuestion, 'Question ID', 'input');
            const guidePdfPageInput = findFieldByLabel(newQuestion, 'Guide PDF Page', 'input');
            const relatedQuestionInput = findFieldByLabel(newQuestion, 'Related Question', 'input');
            
            if (questionIdInput) questionIdInput.value = state.id || '';
            if (guidePdfPageInput) guidePdfPageInput.value = state.guide_pdf_page || '';
            if (relatedQuestionInput) relatedQuestionInput.value = state.related_question || '';
            
            // CRITICAL: Set select value to match dataset, then call toggleQuestionType
            const questionTypeSelect = newQuestion.querySelector('select.question-type-select, select[onchange*="toggleQuestionType"]');
            if (questionTypeSelect) {
                questionTypeSelect.value = targetType;
                
                // Verify value was set correctly
                if (questionTypeSelect.value !== targetType) {
                    const options = Array.from(questionTypeSelect.options);
                    const targetIndex = options.findIndex(opt => opt.value === targetType);
                    if (targetIndex >= 0) {
                        questionTypeSelect.selectedIndex = targetIndex;
                    }
                }
                
                // Call toggleQuestionType to rebuild UI correctly (it will keep dataset in sync)
                toggleQuestionType(questionTypeSelect);
            }
            
            // Render previews for this restored question only (scoped)
            if (typeof PreviewBox !== 'undefined' && PreviewBox.ensureRendered) {
                PreviewBox.ensureRendered(newQuestion);
            }
            
            // Set text fields
            const setupTextarea = findFieldByLabel(newQuestion, 'Set-up Text', 'textarea');
            const questionTextarea = findFieldByLabel(newQuestion, 'Question Text', 'textarea');
            if (setupTextarea) setupTextarea.value = state.set_up_text || '';
            if (questionTextarea) questionTextarea.value = state.question_text || '';
            
            // Handle type-specific data based on state.question_type
            const questionType = state.question_type || 'free_form';
            
            if (questionType === 'fill_in_the_blanks') {
                // Update blanks UI first
                updateBlankAnswersUI(newQuestion);
                
                // Then populate values
                if (state.values && Array.isArray(state.values)) {
                    const blankItems = newQuestion.querySelectorAll('.blank-answer-item');
                    blankItems.forEach((item, index) => {
                        const textarea = item.querySelector('.blank-answer-input');
                        if (textarea && state.values[index] !== undefined) {
                            textarea.value = state.values[index];
                        }
                    });
                    updateFilledBlanksPreview(newQuestion);
                }
                
                // Set guide answer in blanks container
                const blanksContainer = newQuestion.querySelector('#blanks-container');
                const guideAnswerNotes = blanksContainer?.querySelector('.guide-answer-notes');
                if (guideAnswerNotes) {
                    guideAnswerNotes.value = state.guide_answer || '';
                }
            } else if (questionType === 'matching') {
                // Populate left items
                const leftList = newQuestion.querySelector('[id^="matching-left-list-"]');
                if (leftList && state.left && Array.isArray(state.left)) {
                    leftList.innerHTML = '';
                    state.left.forEach((itemText) => {
                        const addLeftBtn = newQuestion.querySelector('button[onclick*="addMatchingItem"][onclick*="left"]');
                        if (addLeftBtn) {
                            addMatchingItem(addLeftBtn, 'left');
                            const lastItem = leftList.lastElementChild;
                            if (lastItem) {
                                const textarea = lastItem.querySelector('.matching-item-text');
                                if (textarea) textarea.value = itemText;
                            }
                        }
                    });
                }
                
                // Populate right items
                const rightList = newQuestion.querySelector('[id^="matching-right-list-"]');
                if (rightList && state.right && Array.isArray(state.right)) {
                    rightList.innerHTML = '';
                    state.right.forEach((itemText) => {
                        const addRightBtn = newQuestion.querySelector('button[onclick*="addMatchingItem"][onclick*="right"]');
                        if (addRightBtn) {
                            addMatchingItem(addRightBtn, 'right');
                            const lastItem = rightList.lastElementChild;
                            if (lastItem) {
                                const textarea = lastItem.querySelector('.matching-item-text');
                                if (textarea) textarea.value = itemText;
                            }
                        }
                    });
                }
                
                // Populate relationships (convert indices to UIDs)
                const relationshipsList = newQuestion.querySelector('[id^="relationships-list-"]');
                if (relationshipsList && state.relationship && Array.isArray(state.relationship)) {
                    relationshipsList.innerHTML = '';
                    ensureMatchingUids(newQuestion);
                    const leftItems = newQuestion.querySelectorAll('[id^="matching-left-list-"] .matching-item');
                    const rightItems = newQuestion.querySelectorAll('[id^="matching-right-list-"] .matching-item');
                    const leftIndexToUid = new Map();
                    const rightIndexToUid = new Map();
                    leftItems.forEach((item, index) => {
                        const uid = item.dataset.leftUid;
                        if (uid) leftIndexToUid.set(index + 1, uid);
                    });
                    rightItems.forEach((item, index) => {
                        const uid = item.dataset.rightUid;
                        if (uid) rightIndexToUid.set(index + 1, uid);
                    });
                    state.relationship.forEach(([leftIdx, rightIdx]) => {
                        const addRelBtn = newQuestion.querySelector('button[onclick*="addRelationship"]');
                        if (addRelBtn) {
                            addRelationship(addRelBtn);
                            const lastRel = relationshipsList.lastElementChild;
                            if (lastRel) {
                                const leftUid = leftIndexToUid.get(leftIdx);
                                const rightUid = rightIndexToUid.get(rightIdx);
                                if (leftUid) lastRel.dataset.leftUid = leftUid;
                                if (rightUid) lastRel.dataset.rightUid = rightUid;
                            }
                        }
                    });
                    // Rebuild UI to show correct selections
                    afterQuestionTypeListMutation(newQuestion);
                }
                
                // Set guide answer in matching container
                const matchingContainer = newQuestion.querySelector('#matching-container');
                const matchingGuideAnswer = matchingContainer?.querySelector('.guide-answer-notes');
                if (matchingGuideAnswer) {
                    matchingGuideAnswer.value = state.guide_answer || '';
                }
            } else if (questionType === 'multiple_choice' || questionType === 'checkbox') {
                // Populate choices
                const choicesList = newQuestion.querySelector('[id^="choices-list-"]');
                if (choicesList && state.choices && Array.isArray(state.choices)) {
                    choicesList.innerHTML = '';
                    state.choices.forEach((choice) => {
                        addChoice(choicesList.parentElement.querySelector('.add-btn'), 'end', questionType);
                        const lastChoice = choicesList.lastElementChild;
                        if (lastChoice) {
                            const choiceIdInput = lastChoice.querySelector('.choice-id');
                            const choiceTextArea = lastChoice.querySelector('.choice-text');
                            const choiceCorrectInput = lastChoice.querySelector('.choice-correct');
                            if (choiceIdInput) {
                                choiceIdInput.value = choice.id || '';
                                updateChoiceHeader(choiceIdInput);
                            }
                            if (choiceTextArea) {
                                choiceTextArea.value = choice.text || '';
                            }
                            if (choiceCorrectInput && choice.checked !== undefined) {
                                choiceCorrectInput.checked = choice.checked;
                            }
                        }
                    });
                    // Ensure UIDs exist and restore correct answer state
                    ensureChoiceUids(newQuestion);
                    if (questionType === 'multiple_choice' && state.correct_answer_index) {
                        // Convert index to UID
                        const choices = choicesList.querySelectorAll('.choice-item');
                        const correctChoice = choices[state.correct_answer_index - 1];
                        if (correctChoice && correctChoice.dataset.choiceUid) {
                            setCorrectChoiceUid(newQuestion, correctChoice.dataset.choiceUid);
                        }
                    } else if (questionType === 'checkbox') {
                        // Restore checkbox correctness from choices[].checked
                        const correctUids = new Set();
                        const choices = choicesList.querySelectorAll('.choice-item');
                        choices.forEach((choiceItem, index) => {
                            if (state.choices[index] && state.choices[index].checked) {
                                const uid = choiceItem.dataset.choiceUid;
                                if (uid) correctUids.add(uid);
                            }
                        });
                        setCorrectChoiceUids(newQuestion, correctUids);
                    }
                    // Rebuild UI using centralized sync (handles both multiple_choice and checkbox)
                    afterQuestionTypeListMutation(newQuestion);
                }
            } else {
                // Free form or other types - set guide answer in main container
                const guideAnswerContainer = newQuestion.querySelector('#guide-answer-container');
                const guideAnswerTextarea = guideAnswerContainer?.querySelector('textarea');
                if (guideAnswerTextarea) {
                    guideAnswerTextarea.value = state.guide_answer || '';
                }
            }
            
            // Restore bbox data
            if (state.question_images && state.question_images.length > 0) {
                const questionImagesGroup = findFormGroupByLabel(newQuestion, 'Question Images');
                if (questionImagesGroup) {
                    fillBboxGroup(questionImagesGroup, state.question_images);
                }
            }
            if (state.guide_answer_images && state.guide_answer_images.length > 0) {
                const answerImagesGroup = findFormGroupByLabel(newQuestion, 'Answer Images');
                if (answerImagesGroup) {
                    fillBboxGroup(answerImagesGroup, state.guide_answer_images);
                }
            }
            
            // Use canonical finalizer (previews, fonts, bbox, refresh, autosize)
            finalizeElement(newQuestion, { previews: true, fonts: true, bbox: true, refresh: true, autoSize: true });
            
            return newQuestion;
        }
        

        function updateMatchingUIIfNeeded(element, action) {
            if (!element || !element.isConnected) return;
            
            // Check if this is a matching item or if action has the flag
            const isMatchingItem = element.classList.contains('matching-item') || 
                                  (action && action.isMatchingItem === true);
            
            if (isMatchingItem) {
                // Finalize the matching item (font settings, previews)
                finalizeMatchingListItem(element);
                
                // Get question element from action if available, otherwise find it
                let questionEl = null;
                if (action && action.questionEl) {
                    questionEl = action.questionEl;
            } else {
                    const matchingContainer = element.closest('#matching-container');
                    questionEl = matchingContainer ? matchingContainer.closest('.array-item') : 
                                element.closest('.array-item');
                }
                
                if (questionEl && questionEl.isConnected) {
                    // Update matching item numbers if we have the side
                    if (action && action.side) {
                        updateMatchingItemNumbers(questionEl, action.side);
                    }
                    // Update relationship UI to refresh dropdown options (uses centralized sync)
                    syncMatchingUI(questionEl);
                }
            }
        }
        
        // Helper function to restore section content from a cloned element
        function restoreSectionContent(targetElement, sourceElement) {
            // Replace innerHTML to restore structure
            targetElement.innerHTML = sourceElement.innerHTML;
            
            // Restore all input, textarea, and select values
            // We need to match them carefully since structure might be the same
            const sourceInputs = Array.from(sourceElement.querySelectorAll('input, textarea, select'));
            const targetInputs = Array.from(targetElement.querySelectorAll('input, textarea, select'));
            
            // Match inputs by their position in the DOM tree
            sourceInputs.forEach((sourceInput, index) => {
                if (index < targetInputs.length) {
                    const targetInput = targetInputs[index];
                    const sourceType = sourceInput.type || '';
                    const sourceTag = sourceInput.tagName.toLowerCase();
                    
                    // Restore value based on input type
                    if (sourceType === 'checkbox' || sourceType === 'radio') {
                        targetInput.checked = sourceInput.checked;
                        // Trigger change event
                        targetInput.dispatchEvent(new Event('change', { bubbles: true }));
                    } else if (sourceTag === 'select') {
                        targetInput.value = sourceInput.value;
                        // Trigger change event for selects (important for question type toggles)
                        targetInput.dispatchEvent(new Event('change', { bubbles: true }));
                    } else {
                        // For text inputs and textareas
                        targetInput.value = sourceInput.value;
                        // Trigger input event to update previews
                        targetInput.dispatchEvent(new Event('input', { bubbles: true }));
                }
            }
        });
        }
        
        // Initialize undo/redo buttons on page load
        updateUndoRedoButtons();
        
        // Get current form statistics with section sizes
        function getFormStats() {
            const questions = document.querySelectorAll('#questions_container > .array-item');
            const contentSections = document.querySelectorAll('#content_sections_container > .array-item');
            
            const questionTypes = {};
            const questionSizes = [];
            const contentSectionSizes = [];
            
            questions.forEach(q => {
                const typeSelect = q.querySelector('select[onchange*="toggleQuestionType"]');
                const type = typeSelect ? typeSelect.value : 'unknown';
                questionTypes[type] = (questionTypes[type] || 0) + 1;
                
                // Calculate question size (sum of all text fields)
                let questionSize = 0;
                const questionText = q.querySelector('textarea[placeholder*="Enter question text"]');
                const setupText = q.querySelector('textarea[placeholder*="Enter set-up text"]');
                const guideAnswer = q.querySelector('#guide-answer-container textarea, .guide-answer-notes');
                
                if (questionText) questionSize += (questionText.value || '').length;
                if (setupText) questionSize += (setupText.value || '').length;
                if (guideAnswer) questionSize += (guideAnswer.value || '').length;
                
                questionSizes.push(questionSize);
            });
            
            contentSections.forEach(section => {
                // Calculate content section size
                let sectionSize = 0;
                const sectionTitle = section.querySelector('input[placeholder="Section title"]');
                const sectionText = section.querySelector('textarea[placeholder*="Enter content"]');
                
                if (sectionTitle) sectionSize += (sectionTitle.value || '').length;
                if (sectionText) sectionSize += (sectionText.value || '').length;
                
                contentSectionSizes.push(sectionSize);
            });
            
            // Calculate averages
            const avgQuestionSize = questionSizes.length > 0 
                ? Math.round(questionSizes.reduce((a, b) => a + b, 0) / questionSizes.length) 
                : 0;
            const avgContentSectionSize = contentSectionSizes.length > 0 
                ? Math.round(contentSectionSizes.reduce((a, b) => a + b, 0) / contentSectionSizes.length) 
                : 0;
            
            return {
                totalQuestions: questions.length,
                totalContentSections: contentSections.length,
                questionTypes: questionTypes,
                avgQuestionSize: avgQuestionSize,
                avgContentSectionSize: avgContentSectionSize,
                totalQuestionSize: questionSizes.reduce((a, b) => a + b, 0),
                totalContentSectionSize: contentSectionSizes.reduce((a, b) => a + b, 0)
            };
        }
    </script>
    
    <title>Math Textbook Transcription Workflow</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet" onerror="this.onerror=null; console.debug('Font Awesome CSS failed to load (expected if offline)')">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" onerror="this.onerror=null; console.debug('KaTeX CSS failed to load (expected if offline)')">
    <script src="https://cdn.jsdelivr.net/npm/marked@12.0.2/lib/marked.umd.min.js" onerror="this.onerror=null; console.debug('Marked.js failed to load (expected if offline)'); window.marked = { parse: (text) => text }"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" onerror="this.onerror=null; console.debug('KaTeX script failed to load (expected if offline)')"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" onerror="this.onerror=null; console.debug('KaTeX auto-render failed to load (expected if offline)')"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            height: 100%;
            width: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden !important; /* absolute: no page scroll */
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-primary);
            height: 100%;
            width: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden !important; /* absolute: no page scroll */
        }

        .container {
            height: 100vh;
            width: 100vw;
            margin: 0;
            padding: 0;
            background: white;
            border-radius: 0;
            box-shadow: none;
            overflow: hidden; /* app itself doesn't scroll */
            display: flex;
            flex-direction: column; /* top bar + workspace */
            min-height: 0; /* critical */
            min-width: 0; /* critical */
        }

        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 4px 15px;
            text-align: center;
            flex: 0 0 auto; /* non-scrolling top area */
            overflow: hidden; /* no scroll, must wrap/collapse */
            min-width: 0;
        }

        .header-content {
            display: flex;
            flex-wrap: wrap; /* critical for zoom */
            justify-content: space-between;
            align-items: center;
            width: 100%;
            padding: 0 min(10px, 1vw); /* Responsive padding */
            max-width: 100%;
            margin: 0;
            gap: min(15px, 1.5vw); /* Responsive gap */
            min-width: 0;
        }
        
        /* Toolbar items that should wrap */
        .header-content > div {
            flex: 0 1 auto;
            min-width: 0;
            max-width: 100%;
        }
        
        /* Search input wrapper: only this one grows so Quick Jump + Save stay tight; cap width */
        .header-content .quick-jump:has(#searchFilter) {
            flex: 1 1 220px;
            min-width: 0;
            max-width: 270px;
        }
        /* Quick Jump dropdown: do not grow, avoid dead space between Search and Save */
        .header-content .quick-jump:has(#quickJumpSelect) {
            flex: 0 0 auto;
        }
        
        .header-content .quick-jump > div {
            min-width: 0;
        }
        
        .header-content .quick-jump input[type="text"] {
            max-width: 100%;
            box-sizing: border-box;
        }
        
        /* Button clusters */
        .header-content #topbar-actions,
        .header-content #topbar-undo-redo {
            flex: 0 1 auto;
            max-width: 100%;
        }
        
        /* Optimize header spacing for zoomed states */
        @media (max-width: 1400px) {
            .header-content {
                padding: 0 8px;
                gap: 10px;
            }
        }
        
        @media (max-width: 1200px) {
            .header-content {
                padding: 0 6px;
                gap: 8px;
            }
        }

        .header-text {
            flex: 1 1 220px; /* allows shrinking instead of overflow */
            min-width: 0;
            text-align: left;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .header-title {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .header-meta {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.65rem;
            opacity: 0.8;
        }

        /* CSS variables for icon buttons - ensures consistent styling across themes */
        :root {
            --icon-btn-border: 1px solid rgba(255, 255, 255, 0.3);
            --icon-btn-bg: rgba(255, 255, 255, 0.1);
            --icon-btn-fg: white;
            --icon-btn-hover-bg: rgba(255, 255, 255, 0.2);
            --icon-btn-hover-border: rgba(255, 255, 255, 0.5);
            --icon-btn-focus-outline: 2px solid rgba(255, 255, 255, 0.5);
        }
        
        [data-theme="dark"] {
            --icon-btn-border: 1px solid rgba(255, 255, 255, 0.3);
            --icon-btn-bg: rgba(255, 255, 255, 0.1);
            --icon-btn-fg: white;
            --icon-btn-hover-bg: rgba(255, 255, 255, 0.2);
            --icon-btn-hover-border: rgba(255, 255, 255, 0.5);
            --icon-btn-focus-outline: 2px solid rgba(255, 255, 255, 0.5);
        }
        
        .dark-mode-toggle {
            background: var(--icon-btn-bg);
            border: var(--icon-btn-border);
            color: var(--icon-btn-fg);
            width: 32px;
            height: 32px;
            padding: 0;
            border-radius: 50%;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        
        .dark-mode-toggle i {
            font-size: 0.85rem;
            line-height: 1;
            color: currentColor;
        }

        .dark-mode-toggle:hover {
            background: var(--icon-btn-hover-bg);
            border: var(--icon-btn-hover-border);
            transform: scale(1.1);
        }

        .dark-mode-toggle:active {
            transform: scale(0.95);
        }
        
        .dark-mode-toggle:focus-visible {
            outline: var(--icon-btn-focus-outline);
            outline-offset: 2px;
        }

        .auto-save-indicator {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.7rem;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .auto-save-indicator.saving {
            background: rgba(255, 193, 7, 0.2);
            border-color: rgba(255, 193, 7, 0.5);
            color: #ffc107;
            font-weight: 600;
            animation: pulse 2s infinite;
        }

        .auto-save-indicator.saved {
            background: rgba(40, 167, 69, 0.2);
            border-color: rgba(40, 167, 69, 0.5);
            color: #28a745;
            font-weight: 600;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .header h1 {
            font-size: 0.9rem;
            margin: 0;
            font-weight: 700;
        }

        .header p {
            font-size: 0.7rem;
            opacity: 0.85;
            margin: 0;
            white-space: nowrap;
        }

        .workflow-container {
            flex: 1 1 auto; /* main workspace area */
            min-height: 0; /* critical */
            min-width: 0; /* critical */
            overflow: hidden; /* columns own scroll */
            display: flex;
            gap: min(15px, 1.5vw); /* Responsive gap that scales with viewport */
            padding: min(15px, 1.5vw); /* Responsive padding */
            box-sizing: border-box;
        }
        
        /* Ensure columns don't grow beyond their allocated space */
        .workflow-container > * {
            min-width: 0; /* Allow flex/grid children to shrink below content size */
            min-height: 0;
            max-width: 100%;
            box-sizing: border-box;
        }
        
        /* Left column - scrollable */
        .workflow-container > .form-section:not(.toggle-section) {
            flex: 1 1 0;
            min-width: 0;
            min-height: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            /* Ensure solid background behind sticky bars */
            background: var(--tabs-bg, #f8f9fa);
            /* Top padding for breathing room above main tabs */
            padding-top: var(--workspace-top-pad);
        }
        
        /* Make the main tab content area use flex layout (not scrollable itself) */
        .workflow-container > .form-section:not(.toggle-section) .main-tab-content.active {
            flex: 1 1 auto;
            min-height: 0;
            overflow: hidden; /* No scrolling on main-tab-content */
            display: flex;
            flex-direction: column;
        }
        
        /* Universal scroll container for all Input Form sub-tabs */
        .input-form-scroll {
            flex: 1 1 auto;
            min-height: 0;
            overflow-y: auto;
            overflow-x: hidden;
            /* Disable scroll anchoring to prevent auto-scroll to bottom when content height changes */
            overflow-anchor: none;
        }
        
        /* Tab content panels must NOT scroll independently */
        .workflow-container > .form-section:not(.toggle-section) .tab-content {
            overflow: visible; /* No independent scrolling */
            min-height: 0;
        }
        
        .workflow-container > .form-section:not(.toggle-section) .tab-content.active {
            display: block; /* Show active panel */
        }
        
        /* Right column - independently scrollable */
        .workflow-container > .form-section.toggle-section {
            flex: 1 1 0;
            min-width: 0;
            min-height: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        /* Right column view panels and preview content scroll */
        .workflow-container > .form-section.toggle-section .view-panel.active,
        .workflow-container > .form-section.toggle-section #final-preview-content,
        .workflow-container > .form-section.toggle-section .final-preview-container {
            flex: 1 1 auto;
            min-height: 0;
            overflow-y: auto;
            overflow-x: hidden;
        }
        
        /* Guardrail: prevent accidental global overflow from any child */
        .workflow-container, .workflow-container > .form-section {
            min-width: 0;
            min-height: 0;
        }
        
        /* Ensure code blocks don't overflow */
        pre, code, .json-preview {
            max-width: 100%;
            overflow-x: auto; /* inside right column only */
        }
        
        /* Use full width at all zoom levels - remove max-width restrictions */
        @media (min-width: 1920px) {
            .workflow-container {
                padding: min(20px, 2vw); /* Slightly more padding on very large screens */
            }
            
            .header-content {
                padding: 0 min(30px, 3vw); /* Responsive padding */
            }
        }
        
        /* Optimize for zoomed-in states (smaller effective viewport) */
        @media (max-width: 1400px) {
            .workflow-container {
                gap: 10px;
                padding: 10px;
            }
        }
        
        /* Further optimize for highly zoomed states */
        @media (max-width: 1200px) {
            .workflow-container {
                gap: 8px;
                padding: 8px;
            }
        }
        

        .form-section {
            background: #f8f9fa;
            border-radius: 12px;
            /* Remove top padding to allow sticky tabs to stick flush at top */
            padding: 0 min(15px, 1.5vw) min(15px, 1.5vw) min(15px, 1.5vw); /* top, right, bottom, left */
            border: 2px solid #e9ecef;
            min-width: 0; /* Allow flex/grid children to shrink */
            max-width: 100%; /* Prevent expansion beyond column */
            box-sizing: border-box;
        }
        
        /* Reduce padding on smaller viewports (zoomed in) */
        @media (max-width: 1400px) {
            .form-section {
                padding: 0 10px 10px 10px; /* top, right, bottom, left */
            }
        }
        
        @media (max-width: 1200px) {
            .form-section {
                padding: 0 8px 8px 8px; /* top, right, bottom, left */
            }
        }

        .form-section h2 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 1rem;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .form-section h2 i {
            font-size: 0.9rem;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #495057;
        }

        .form-group input, .form-group textarea, .form-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            font-size: 14px;
            line-height: 1.5;
            transition: border-color 0.3s ease;
            font-feature-settings: "kern" 1, "liga" 1; /* Better character spacing */
            text-rendering: optimizeLegibility; /* Better diacritic rendering */
        }

        .form-group input[type="checkbox"] {
            width: auto;
            height: 18px;
            width: 18px;
            margin: 0;
            cursor: pointer;
            accent-color: #667eea;
        }

        .form-group.checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
        }

        .form-group.checkbox-group label {
            margin: 0;
            cursor: pointer;
            font-weight: 600;
            color: #495057;
            user-select: none;
        }

        .form-group input:focus, .form-group textarea:focus, .form-group select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        /* Default RTL direction for content textareas (Arabic content) */
        .form-group textarea:not([data-ltr="true"]), 
        .form-group input[type="text"]:not([data-ltr="true"]) {
            direction: rtl !important;
            text-align: right !important;
        }
        
        /* Default LTR direction for ID fields and standards (English/technical content) */
        .form-group textarea[data-ltr="true"], 
        .form-group input[type="text"][data-ltr="true"] {
            direction: ltr !important;
            text-align: left !important;
        }

        .form-group textarea {
            min-height: 80px;
            max-height: none;
            resize: vertical;
            overflow-y: auto; /* Show scrollbar when content exceeds height */
            box-sizing: border-box;
        }

        .array-item {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            position: relative;
        }

        .array-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .row-actions { display: inline-flex; gap: 8px; align-items: center; margin-top: 8px; }

        .remove-btn {
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
        }

        .reorder-btn {
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            transition: background-color 0.3s ease;
        }

        .reorder-btn:hover {
            background: #5a6268;
        }

        .reorder-btn:disabled {
            background: #adb5bd;
            cursor: not-allowed;
            opacity: 0.5;
        }

        .array-item-header-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .collapse-btn {
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }

        .collapse-btn:hover {
            background: #5a6268;
        }

        .array-item.collapsed .section-content {
            display: none;
        }

        .array-item.collapsed .collapse-btn i {
            transform: rotate(-90deg);
        }

        .copy-section-btn {
            background: #17a2b8;
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            transition: background-color 0.3s ease;
        }

        .copy-section-btn:hover {
            background: #138496;
        }

        .paste-section-btn {
            background: #17a2b8;
        }

        .paste-section-btn:hover {
            background: #138496;
        }

        .paste-replace-btn {
            background: #ffc107;
        }

        .paste-replace-btn:hover {
            background: #e0a800;
        }

        .duplicate-btn {
            background: #6f42c1;
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            transition: background-color 0.3s ease;
        }

        .duplicate-btn:hover {
            background: #5a32a3;
        }

        .add-btn {
            background: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 12px;
            cursor: pointer;
            font-weight: 500;
            font-size: 0.7rem;
            display: inline-flex;
            align-items: center;
            gap: 3px;
            transition: background-color 0.3s ease;
        }
        
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-top: 15px;
            margin-bottom: 15px;
        }

        .add-btn:hover {
            background: #218838;
        }

        /* Add-bbox-btn and add-section-btn inherit from add-btn but can be customized */
        .add-bbox-btn,
        .add-section-btn {
            background: #17a2b8;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 12px;
            cursor: pointer;
            font-weight: 500;
            font-size: 0.7rem;
            display: inline-flex;
            align-items: center;
            gap: 3px;
            transition: background-color 0.3s ease;
        }

        .add-bbox-btn:hover,
        .add-section-btn:hover {
            background: #138496;
        }

        .bbox-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr 1fr;
            gap: 8px;
            margin-bottom: 10px;
        }

        .bbox-inputs input {
            padding: 8px;
            font-size: 12px;
        }

        .bbox-container {
            margin-bottom: 15px;
        }

        .text-field-container {
            position: relative;
        }

        .text-field-container textarea {
            margin-bottom: 8px;
        }

        /* Live rendered preview under each textarea */
        .live-preview {
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 12px;
            background: #ffffff;
            color: #212529;
            font-size: 14px;
            line-height: 1.5;
            position: relative;
            min-height: 80px;
            height: auto; /* Match content size, managed by JS */
            max-height: none; /* Allow unlimited expansion */
            resize: vertical;
            overflow-y: auto;
            overflow-x: hidden;
            font-feature-settings: "kern" 1, "liga" 1; /* Better character spacing */
            text-rendering: optimizeLegibility; /* Better diacritic rendering */
        }
        
        /* Trailing spaces indicator */
        .live-preview.has-trailing-spaces {
            border: 2px solid #ffc107;
            border-left: 4px solid #ffc107;
            background: #fffbf0;
        }
        
        .live-preview.has-trailing-spaces::before {
            content: " Trailing/leading spaces/empty lines detected";
            position: absolute;
            top: 4px;
            right: 8px;
            font-size: 10px;
            font-weight: 600;
            color: #856404;
            background: #ffc107;
            padding: 2px 6px;
            border-radius: 4px;
            z-index: 10;
            pointer-events: none;
        }
        
        .live-preview[dir="rtl"].has-trailing-spaces::before {
            right: auto;
            left: 8px;
        }
        
        /* Highlighted trailing spaces */
        .leading-space {
            background-color: rgba(255, 0, 0, 0.25);
            border-top: 2px dotted rgba(255, 0, 0, 0.6);
            position: relative;
            display: inline;
            padding: 0 1px;
        }
        
        .trailing-space {
            background-color: rgba(255, 0, 0, 0.25);
            border-bottom: 2px dotted rgba(255, 0, 0, 0.6);
            position: relative;
            display: inline;
            padding: 0 1px;
        }
        
        .consecutive-space {
            background-color: rgba(255, 0, 0, 0.25);
            border-top: 1px dotted rgba(255, 0, 0, 0.6);
            border-bottom: 1px dotted rgba(255, 0, 0, 0.6);
            position: relative;
            display: inline;
            padding: 0 1px;
        }
        
        /* Trailing empty lines indicator */
        .trailing-empty-line {
            display: block;
            min-height: 1.5em;
            background-color: rgba(255, 193, 7, 0.15);
            border-left: 3px solid #ffc107;
            margin: 4px 0;
            position: relative;
        }
        
        .trailing-empty-line::before {
            content: "Empty line";
            position: absolute;
            left: 8px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 10px;
            color: #856404;
            font-weight: 600;
            background: rgba(255, 193, 7, 0.3);
            padding: 2px 4px;
            border-radius: 3px;
        }
        
        .preview-label {
            font-size: 11px;
            font-weight: 600;
            color: #667eea !important;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
            display: block;
            opacity: 0.9;
        }
        
        /* Prevent required asterisk on preview labels */
        .preview-label::after {
            content: none !important;
        }
        
        .input-label {
            font-size: 11px;
            font-weight: 600;
            color: #667eea;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
            display: block;
            opacity: 0.9;
        }
        .live-preview table { border-collapse: collapse; width: 100%; margin: 8px 0; }
        .live-preview th, .live-preview td { border: 1px solid #ccc; padding: 6px 8px; }
        /* Respect markdown alignment; provide a default only when none specified */
        .live-preview th:not([align]), .live-preview td:not([align]) { text-align: start; }
        /* Default direction will be set dynamically based on content type */
        .live-preview blockquote { border-left: 4px solid #667eea; margin: 8px 0; padding: 6px 10px; color: #495057; background: #f8f9fa; }
        /* List styling to ensure proper visibility */
        .live-preview ul, .live-preview ol { margin: 8px 0; padding-left: 30px; }
        .live-preview ul { list-style-type: disc; }
        .live-preview ol { list-style-type: decimal; }
        .live-preview li { margin: 4px 0; display: list-item; }
        .live-preview ul ul { list-style-type: circle; margin: 4px 0; }
        .live-preview ul ul ul { list-style-type: square; }
        .live-preview ol ol { list-style-type: lower-alpha; }
        .live-preview ol ol ol { list-style-type: lower-roman; }
        /* RTL list styling */
        .live-preview[dir="rtl"] ul,
        .live-preview[dir="rtl"] ol { padding-left: 0; padding-right: 30px; }
        .live-preview[dir="rtl"] ul ul,
        .live-preview[dir="rtl"] ol ol { padding-left: 0; padding-right: 30px; }
        /* Force LTR ordering at the KaTeX level to preserve source order */
        /* Use bidi-override to completely prevent browser bidi reordering */
        .live-preview .katex-html,
        .live-preview .katex-display .katex-html,
        .live-preview[dir="rtl"] .katex-html,
        .live-preview[dir="rtl"] .katex-display .katex-html {
            direction: ltr !important;
            unicode-bidi: bidi-override !important;
        }
        /* Allow .mtext spans to have their own direction based on content */
        /* isolate-override creates isolated context where direction is determined by first strong char */
        .live-preview .katex .mtext,
        .live-preview .katex-display .mtext,
        .live-preview[dir="rtl"] .katex .mtext,
        .live-preview[dir="rtl"] .katex-display .mtext {
            unicode-bidi: isolate !important;
        }
        /* Force image descriptions to always be LTR regardless of parent direction */
        .live-preview .image-description-math,
        .live-preview[dir="rtl"] .image-description-math {
            direction: ltr !important;
            unicode-bidi: isolate !important;
        }
        /* Center LaTeX block math */
        .live-preview .__math_block {
            text-align: center !important;
            margin: 1em auto !important;
            display: block !important;
            direction: ltr !important;
            unicode-bidi: isolate !important;
        }
        .live-preview .katex-display {
            text-align: center !important;
            margin: 1em auto !important;
            display: block !important;
        }
        /* Ensure KaTeX math blocks are centered even in RTL containers */
        .live-preview[dir="rtl"] .__math_block,
        .live-preview[dir="rtl"] .katex-display {
            text-align: center !important;
            margin: 1em auto !important;
            direction: ltr !important;
            unicode-bidi: isolate !important;
        }
        /* Force centering for math container elements, but allow array cells to respect their alignment */
        .live-preview .katex {
            text-align: center !important;
        }
        /* Exclude array cells (table cells) from center alignment to respect array column specifiers */
        .live-preview .katex table td,
        .live-preview .katex table th {
            text-align: inherit !important;
        }
        /* Override any inherited text alignment for math blocks */
        .live-preview div[class*="math"],
        .live-preview div[class*="katex"] {
            text-align: center !important;
            margin: 1em auto !important;
        }
        /* Additional centering for math containers */
        .live-preview .__math_block {
            width: 100% !important;
            text-align: center !important;
        }
        /* Math block error styling */
        .live-preview .__math_block_error {
            color: #d32f2f !important;
            background-color: #ffebee !important;
            border: 2px solid #f44336 !important;
            padding: 12px !important;
            margin: 10px 0 !important;
            border-radius: 6px !important;
            font-family: 'Courier New', monospace !important;
            font-size: 14px !important;
            line-height: 1.4 !important;
            text-align: left !important;
        }
        .live-preview .__math_block_error strong {
            color: #b71c1c !important;
        }
        .live-preview .__math_block_error code {
            background-color: #f5f5f5 !important;
            padding: 2px 4px !important;
            border-radius: 3px !important;
            font-family: 'Courier New', monospace !important;
            color: #d32f2f !important;
        }
        .live-preview .katex-display {
            width: 100% !important;
            text-align: center !important;
        }
        /* Make math reflect Markdown emphasis when wrapped by <strong>/<em> */
        .live-preview strong .katex, .live-preview b .katex { font-weight: 700; }
        .live-preview em .katex, .live-preview i .katex { font-style: italic; }

        .markdown-btn {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.7rem;
            font-weight: 500;
            transition: background-color 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 3px;
            line-height: 1;
            height: auto;
            min-height: auto;
        }
        .markdown-btn:hover {
            background: var(--bg-tertiary);
            border-color: var(--accent);
        }
        .markdown-btn:active {
            transform: scale(0.95);
        }
        .table-btn {
            background: #17a2b8;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 0.7rem;
            font-weight: 500;
            display: inline-flex;
            align-items: center;
            gap: 3px;
            transition: background-color 0.3s ease;
            line-height: 1;
            height: auto;
            min-height: auto;
        }

        .table-btn:hover {
            background: #138496;
        }

        .image-btn {
            background: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 0.7rem;
            font-weight: 500;
            display: inline-flex;
            align-items: center;
            gap: 3px;
            transition: background-color 0.3s ease;
            line-height: 1;
            height: auto;
            min-height: auto;
        }

        /* Buttons between textarea and preview styling */
        .text-field-container button {
            margin-top: 8px;
            margin-bottom: 8px;
            margin-right: 5px;
        }
        
        /* First button should have more left margin to space from red line */
        .text-field-container button:first-of-type {
            margin-left: 8px;
        }
        
        /* Last button should not have right margin */
        .text-field-container button:last-of-type {
            margin-right: 0;
        }
        
        .text-field-container textarea {
            margin-top: 0;
            margin-bottom: 0;
        }

        .image-btn:hover {
            background: #1e7e34;
        }

        .blank-btn {
            background: #17a2b8;
            color: white;
            border: none;
            padding: 4px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.7rem;
            font-weight: 500;
            display: inline-flex;
            align-items: center;
            gap: 3px;
            transition: background-color 0.3s ease;
        }

        .blank-btn:hover {
            background: #138496;
        }

        .dir-btn {
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 0.7rem;
            font-weight: 500;
            display: inline-flex;
            align-items: center;
            gap: 3px;
            transition: background-color 0.3s ease;
            line-height: 1;
            height: auto;
            min-height: auto;
        }
        .dir-btn:hover { background: #5a6268; }

        .json-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }


        .json-preview {
            background: #2d3748;
            color: #e2e8f0;
            border-radius: 15px;
            padding: 25px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.6;
            overflow-x: auto; /* inside right column only */
            overflow-y: auto;
            border: 1px solid #4a5568;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
            white-space: pre-wrap;
            word-wrap: break-word;
            text-align: left;
            display: block;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
        }

        .json-key {
            color: #81e6d9;
        }

        .json-string {
            color: #feb2b2;
        }

        .json-number {
            color: #90cdf4;
        }

        .json-boolean {
            color: #fbb6ce;
        }

        .json-null {
            color: #a0aec0;
        }

        .json-preview-content {
            color: #e2e8f0;
            line-height: 1.6;
        }
        
        /* Enhanced JSON formatting styles */
        .json-bracket {
            color: #e2e8f0;
            font-weight: bold;
        }
        
        .json-colon {
            color: #e2e8f0;
            margin: 0 2px;
        }
        
        .json-comma {
            color: #e2e8f0;
            margin-right: 4px;
        }
        
        .json-indent {
            color: transparent;
            user-select: none;
        }
        
        
        /* JSON syntax highlighting improvements */
        .json-key {
            color: #81e6d9;
            font-weight: 600;
        }
        
        .json-string {
            color: #feb2b2;
        }
        
        .json-number {
            color: #90cdf4;
            font-weight: 600;
        }
        
        .json-boolean {
            color: #fbb6ce;
            font-weight: 600;
        }
        
        .json-null {
            color: #a0aec0;
            font-style: italic;
        }
        
        /* Hover effects for better interaction */
        .json-preview:hover {
            border-color: #4a5568;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.4);
        }

        .preview-section {
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            border-left: 3px solid #667eea;
        }

        .preview-indent {
            margin-left: 20px;
            margin-bottom: 8px;
            padding: 5px 0;
        }

        .preview-indent-double {
            margin-left: 40px;
            margin-bottom: 8px;
            padding: 5px 0;
            color: #cbd5e0;
            font-style: italic;
        }

        .validation-error {
            border-color: #dc3545 !important;
            box-shadow: 0 0 0 0.2rem rgba(220, 53, 69, 0.25);
        }

        /* Validation success styling removed per user request - green checkmark indicator removed */

        .required-field {
            border-left: 3px solid #dc3545;
        }

        .required-field label::after {
            content: " *";
            color: #dc3545;
            font-weight: bold;
        }

        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 2px solid #e9ecef;
        }
        .tabs.main-tabs {
            border-bottom: 3px solid #667eea;
            margin-bottom: 20px;
        }

        .tab {
            padding: 6px 14px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 600;
            color: #6c757d;
            border-bottom: 2px solid transparent;
            transition: all 0.3s ease;
        }

        .tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
        }

        /* ============================================================
         * STICKY TABS SYSTEM
         * Main tabs (Input Form / Final Preview) are sticky at form-section level.
         * Sub tabs (Basic Info / Lesson Preamble / Content / Questions) are sticky 
         * inside Input Form only, wrapped in .sticky-tabs-stack.
         * 
         * Structure:
         *   - .sticky-tab-bar--main: Main tab bar (sticky at top of form-section)
         *   - #input-form .sticky-tabs-stack: Sub-tabs wrapper (sticky inside Input Form)
         *   - .sticky-tab-bar--sub: Sub tab bar (inside stack, normal flow)
         * 
         * The scroll container is .form-section:not(.toggle-section) with overflow-y: auto.
         * Sub-tabs are scoped to Input Form only and do not appear in Final Preview.
         * 
         * JS sets --sticky-stack-height on :root for scroll offset calculations.
         * ============================================================ */
        :root {
            /* Shared background for tab bars */
            --tabs-bg: var(--bg-secondary, #f8f9fa);
            /* Spacing below sub-tabs - applied to content, not bars */
            --subtabs-content-pad: 20px;
            /* Top padding for workspace (above main tabs) */
            --workspace-top-pad: 16px;
            /* Gap between main tabs and sub tabs */
            --main-to-subtabs-gap: 6px;
        }
        
        /* Main tab bar - sticky at top of form section */
        .sticky-tab-bar--main {
            position: sticky;
            top: 0;
            z-index: 60;
            background: var(--tabs-bg) !important;
            margin: 0;
            padding: 0;
            /* Extend background to full width by using negative margin + padding */
            margin-left: calc(-1 * min(15px, 1.5vw));
            margin-right: calc(-1 * min(15px, 1.5vw));
            padding-left: min(15px, 1.5vw);
            padding-right: min(15px, 1.5vw);
            /* Extend background upward to cover top edge and workspace padding */
            margin-top: calc(-1 * (min(15px, 1.5vw) + var(--workspace-top-pad)));
            padding-top: calc(min(15px, 1.5vw) + var(--workspace-top-pad));
            /* Controlled gap between main tabs and sub tabs */
            margin-bottom: var(--main-to-subtabs-gap);
            padding-bottom: 0;
            border-bottom: 3px solid #667eea; /* Keep main tab border */
        }
        
        /* Sticky tabs stack - sub-tabs only, scoped to Input Form */
        #input-form .sticky-tabs-stack {
            position: sticky;
            top: 0; /* Sticky within the left column scroll container */
            z-index: 30;
            background: var(--tabs-bg);
            margin: 0;
            padding: 0;
            /* Extend background to full width by using negative margin + padding */
            margin-left: calc(-1 * min(15px, 1.5vw));
            margin-right: calc(-1 * min(15px, 1.5vw));
            padding-left: min(15px, 1.5vw);
            padding-right: min(15px, 1.5vw);
            /* No top margin/padding - gap is controlled by main tabs margin-bottom */
            margin-top: 0;
            padding-top: 0;
        }
        
        /* Tab bars inside stack - normal flow, not sticky */
        .sticky-tab-bar {
            position: relative; /* NOT sticky */
            top: auto;
            background: var(--tabs-bg);
            margin: 0;
            padding: 0;
            /* Extend background to full width */
            margin-left: 0;
            margin-right: 0;
            padding-left: 0;
            padding-right: 0;
        }
        
        /* Sub tab bar - no vertical spacing, no top border */
        .sticky-tab-bar--sub {
            margin-top: 0;
            padding-top: 0;
            padding-bottom: 0;
            border-top: none; /* No border between bars */
            border-bottom: 2px solid #e9ecef; /* Keep sub tab border */
            box-shadow: 0 2px 4px -2px rgba(0, 0, 0, 0.1);
        }
        
        /* Dark mode background for sticky stack */
        [data-theme="dark"] {
            --tabs-bg: var(--bg-secondary, #2d3748);
        }
        [data-theme="dark"] .sticky-tab-bar--sub {
            box-shadow: 0 2px 4px -2px rgba(0, 0, 0, 0.3);
        }
        
        /* Responsive adjustments for main tab bar */
        @media (max-width: 1400px) {
            .sticky-tab-bar--main {
                margin-left: -10px;
                margin-right: -10px;
                padding-left: 10px;
                padding-right: 10px;
                /* Account for workspace top padding in upward extension */
                margin-top: calc(-1 * (10px + var(--workspace-top-pad)));
                padding-top: calc(10px + var(--workspace-top-pad));
            }
            #input-form .sticky-tabs-stack {
                margin-left: -10px;
                margin-right: -10px;
                padding-left: 10px;
                padding-right: 10px;
            }
        }
        
        @media (max-width: 1200px) {
            .sticky-tab-bar--main {
                margin-left: -8px;
                margin-right: -8px;
                padding-left: 8px;
                padding-right: 8px;
                /* Account for workspace top padding in upward extension */
                margin-top: calc(-1 * (8px + var(--workspace-top-pad)));
                padding-top: calc(8px + var(--workspace-top-pad));
            }
            #input-form .sticky-tabs-stack {
                margin-left: -8px;
                margin-right: -8px;
                padding-left: 8px;
                padding-right: 8px;
            }
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }
        
        /* Spacing below sub-tabs - applied to first tab content in input-form-scroll */
        .input-form-scroll > .tab-content.active {
            padding-top: var(--subtabs-content-pad);
        }
        .main-tab-content {
            display: none;
        }
        .main-tab-content.active {
            display: block;
            /* No top padding - spacing comes from tab content below */
            padding-top: 0;
        }
        
        /* Override for left column - use flex for scrolling */
        .workflow-container > .form-section:not(.toggle-section) .main-tab-content.active {
            display: flex;
            flex-direction: column;
        }
        /* Final Preview achieves "sticky" header behavior through structure:
           The main tabs are outside .final-preview-container (the scroll container),
           so they naturally stay visible while preview content scrolls.
           This matches the Input Form's CSS sticky approach - both use the shared
           .sticky-tab-bar system defined above. */
        .main-tab-content#final-preview.active {
            display: flex;
            flex-direction: column;
            flex: 1 1 auto;
            min-height: 0;
        }
        .final-preview-container {
            flex: 1 1 auto;
            min-height: 0;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 16px;
            background: var(--bg-primary);
            /* Disable scroll anchoring to prevent auto-scroll when content height changes */
            overflow-anchor: none;
        }
        /* Final Preview bbox replacement container (auto-replace, no click) */
        .final-preview-container .fp-bbox-replacement {
            max-width: 320px;
            padding: 6px;
            border-radius: 4px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            font-size: 0.8rem;
            color: var(--text-secondary);
        }
        /* Bbox preview ~50% width, responsive; caption stays below */
        .live-preview .image-placeholder-container.has-bbox-preview,
        .final-preview-container .image-placeholder-container.has-bbox-preview {
            display: block;
            width: min(50%, 640px);
            max-width: 100%;
        }
        .live-preview .image-placeholder-container.has-bbox-preview .image-placeholder-box,
        .final-preview-container .image-placeholder-container.has-bbox-preview .image-placeholder-box {
            width: 100% !important; /* override inline 200px without JS */
        }
        .final-preview-section {
            margin-bottom: 32px;
            padding: 20px;
            background: var(--bg-secondary);
            border-radius: 8px;
            border: 2px solid var(--border-color);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        [data-theme="dark"] .final-preview-section {
            border: 2px solid #4a5568;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            background: #2d3748;
        }
        .final-preview-section h3 {
            margin-top: 0;
            margin-bottom: 16px;
            color: var(--accent);
            font-size: 1.2rem;
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 8px;
        }
        .final-preview-section h4 {
            margin-top: 0;
            margin-bottom: 12px;
            color: var(--text-primary);
            font-size: 1.1rem;
        }
        .final-preview-question {
            margin-bottom: 24px;
            padding: 16px;
            background: white;
            border-radius: 6px;
            border: 2px solid #e0e0e0;
            border-left: 4px solid var(--accent);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12);
        }
        .final-preview-question h4 {
            margin-top: 0;
            margin-bottom: 12px;
            color: var(--accent);
        }
        .final-preview-question .question-type-badge {
            display: inline-block;
            padding: 4px 8px;
            background: var(--accent);
            color: white;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
            margin-top: 4px;
            margin-bottom: 12px;
        }
        .final-preview-question .preview-section {
            margin-bottom: 16px;
        }
        .final-preview-question .preview-section-label {
            margin: 0 0 8px 0;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .final-preview-section .preview-section-label {
            margin: 0 0 8px 0;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .final-preview-section .preview-section {
            margin-bottom: 16px;
        }
        .final-preview-section .setup-text {
            margin-bottom: 0;
            padding: 0;
            background: none;
            border-radius: 0;
            border: none;
        }
        .final-preview-question .setup-text {
            margin-bottom: 0;
            padding: 0;
            background: none;
            border-radius: 0;
            border: none;
        }
        .final-preview-question .question-text {
            margin-bottom: 0;
            padding: 0;
            font-weight: normal;
            color: var(--text-primary);
        }
        .final-preview-question .choices-container {
            margin: 0;
        }
        /* ========================================
           SHARED PREVIEW BOX LAYOUT (All Preview Types)
           ========================================
           Ensures consistent spacing and prevents overlap of interactive elements
           Applies to MCQ, Checkbox, and any other preview types using preview boxes */
        .preview-section {
            position: relative;
            z-index: 1; /* Ensure content is above any background overlays */
            overflow: visible; /* Never clip interactive elements */
        }
        .preview-section > * {
            position: relative;
            z-index: 1; /* Ensure all direct children are above background */
        }
        /* Edit pen in Final Preview: on top and fully clickable (buildPreviewBox output) */
        .preview-section .preview-edit-pen {
            z-index: 10;
            pointer-events: auto;
        }
        
        /* Choice row layout - flex container with dedicated actions column */
        .preview-choice-row {
            display: flex !important; /* Override any existing display */
            align-items: flex-start;
            gap: 8px;
            padding: 8px;
            margin: 8px 0;
            position: relative;
            z-index: 2; /* Ensure choice rows are above background */
            overflow: visible; /* Never clip the edit pen */
        }
        
        /* Marker icon (radio/checkbox) */
        .preview-choice-marker {
            flex-shrink: 0;
            margin-top: 2px;
            z-index: 1;
        }
        
        /* Main content area - flex:1 with padding-right to prevent overlap */
        .preview-choice-main {
            flex: 1;
            min-width: 0; /* Allow text wrapping */
            padding-right: 32px; /* Space for actions column (edit pen) */
            position: relative;
            z-index: 1;
            overflow-wrap: break-word; /* Prevent long text from overflowing */
            word-wrap: break-word;
        }
        
        /* Actions column (edit pen) - fixed width, always visible and clickable */
        .preview-choice-actions {
            flex: 0 0 auto;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--accent);
            font-size: 0.85rem;
            opacity: 0.7;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: all 0.2s ease;
            position: relative;
            z-index: 10; /* High z-index to ensure clickability */
            background: transparent;
            pointer-events: auto; /* Ensure clicks work */
        }
        .preview-choice-actions:hover {
            opacity: 1;
            background: var(--bg-tertiary);
        }
        
        /* Legacy support: maintain existing choice-item styling when not using new layout */
        .final-preview-question .choice-item:not(.preview-choice-row) {
            padding: 8px 12px;
            margin: 8px 0;
            background: #f8f9fa;
            border-radius: 4px;
            border-left: 3px solid #dee2e6;
        }
        .final-preview-question .choice-item.correct:not(.preview-choice-row) {
            background: #d4edda;
            border-left-color: #28a745;
        }
        .final-preview-question .choice-item .choice-id {
            font-weight: 600;
            color: var(--accent);
            margin-right: 8px;
        }
        .final-preview-question .blanks-container {
            margin: 0;
        }
        .final-preview-question .choices-container {
            margin: 0;
        }
        .final-preview-question .blank-answer {
            padding: 8px 12px;
            margin: 8px 0;
            background: #fff3cd;
            border-radius: 4px;
            border-left: 3px solid #ffc107;
        }
        .final-preview-question .blank-answer .blank-number {
            font-weight: 600;
            color: #856404;
            margin-right: 8px;
        }
        .final-preview-question .blank-answer {
            text-decoration: none;
        }
        .final-preview-question .blank-answer * {
            text-decoration: none;
        }
        .final-preview-question .matching-container {
            margin: 16px 0;
        }
        .final-preview-question .matching-item-compact {
            padding: 6px 8px;
            margin: 0;
            font-size: 0.9rem;
        }
        .final-preview-question .matching-item-compact .live-preview {
            margin: 0;
        }
        .final-preview-question .matching-items {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            margin: 16px 0;
        }
        .final-preview-question .matching-side {
            padding: 12px;
            background: #f8f9fa;
            border-radius: 4px;
        }
        .final-preview-question .matching-side h5 {
            margin-top: 0;
            margin-bottom: 12px;
            font-size: 0.9rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            font-weight: 600;
        }
        .final-preview-question .matching-item {
            padding: 8px;
            margin: 6px 0;
            background: white;
            border-radius: 4px;
            border: 1px solid #dee2e6;
            word-wrap: break-word;
            overflow-wrap: break-word;
            word-break: break-word;
            max-width: 100%;
            box-sizing: border-box;
        }
        .final-preview-question .matching-item .live-preview {
            max-width: 100%;
            overflow-wrap: break-word;
            word-wrap: break-word;
            word-break: break-word;
        }
        .final-preview-question .matching-side {
            min-width: 0;
            overflow: hidden;
        }
        .final-preview-question .matching-items {
            overflow: hidden;
        }
        .final-preview-question .matching-relationships {
            margin-top: 16px;
            padding: 12px;
            background: #e7f3ff;
            border-radius: 4px;
        }
        .final-preview-question .matching-relationships h5 {
            margin-top: 0;
            margin-bottom: 8px;
            font-size: 0.9rem;
            color: #0056b3;
        }
        .final-preview-question .relationship-item {
            padding: 6px;
            margin: 4px 0;
            background: white;
            border-radius: 4px;
        }
        .final-preview-question .guide-answer {
            margin-top: 0;
            margin-bottom: 0;
            padding: 0;
            background: none;
            border-radius: 0;
            border: none;
        }
        .final-preview-question .guide-answer .preview-section-label {
            margin: 0 0 8px 0;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        [data-theme="dark"] .final-preview-question {
            background: #2d3748;
            color: var(--text-primary);
            border: 2px solid #4a5568;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.4);
        }
        [data-theme="dark"] .final-preview-question .setup-text {
            background: none;
            border: none;
        }
        [data-theme="dark"] .final-preview-question .preview-section-label {
            color: #a0aec0;
        }
        [data-theme="dark"] .final-preview-question .choice-item {
            background: #2d3238;
            border-left-color: #6c757d;
        }
        [data-theme="dark"] .final-preview-question .choice-item.correct {
            background: #1e4620;
            border-left-color: #28a745;
        }
        [data-theme="dark"] .final-preview-question .blank-answer {
            background: #3d3520;
            border-left-color: #ffc107;
        }
        [data-theme="dark"] .final-preview-question .matching-side {
            background: #2d3238;
        }
        [data-theme="dark"] .final-preview-question .matching-item {
            background: #1e1e1e;
            border-color: #6c757d;
        }
        [data-theme="dark"] .final-preview-question .matching-relationships {
            background: #1a3d52;
        }
        [data-theme="dark"] .final-preview-question .relationship-item {
            background: #1e1e1e;
        }
        [data-theme="dark"] .final-preview-question .guide-answer {
            background: none;
            border: none;
        }

        .highlight {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }

        .highlight h4 {
            color: #856404;
            margin-bottom: 10px;
        }

        .highlight p {
            color: #856404;
            margin: 0;
        }

        .generate-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 6px;
            padding: 5px 12px;
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
            width: auto;
            margin-top: 0;
            transition: transform 0.3s ease;
        }

        .generate-btn:hover {
            transform: translateY(-2px);
        }

        /* Embedded BBox Drawer Modal */
        .bbox-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.55); display: none; align-items: center; justify-content: center; z-index: 9999; }
        .bbox-modal.show { display: flex; }
        .bbox-dialog { width: 90vw; height: 88vh; background: var(--bg-primary); color: var(--text-primary); border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,0.4); display: flex; flex-direction: column; overflow: hidden; border: 1px solid var(--border-color); }
        .bbox-toolbar { padding: 10px; background: var(--bg-secondary); display: flex; flex-wrap: wrap; gap: 8px; align-items: center; border-bottom: 1px solid var(--border-color); }
        .bbox-toolbar .group { display:flex; align-items:center; gap:8px; padding-right: 10px; border-right: 1px solid var(--border-color); }
        .bbox-toolbar .group:last-child { border-right: none; }
        .bbox-btn { background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); padding: 4px 8px; border-radius: 6px; cursor: pointer; font-size: 0.8rem; }
        .bbox-btn.primary { background: var(--accent); border-color: var(--accent); }
        .bbox-btn.danger { background: #dc2626; border-color: #dc2626; }
        .bbox-content { flex: 1; display: grid; grid-template-columns: 1fr 340px; gap: 10px; padding: 10px; }
        .bbox-canvas-wrap { position: relative; overflow:auto; background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 10px; }
        .bbox-canvas-wrap canvas { display:block; }
        #em-pdf { background: #ffffff; }
        #em-draw { position:absolute; top:0; left:0; pointer-events:auto; }
        .bbox-sidebar { background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 10px; padding: 10px; display: flex; flex-direction: column; gap: 8px; }
        .bbox-bbox-list { flex:1; overflow:auto; display:flex; flex-direction:column; gap:6px; }
        .bbox-item { padding:6px; border: 1px solid var(--border-color); border-radius: 8px; background: var(--bg-primary); display: flex; justify-content: space-between; align-items: center; gap: 8px; }
        .bbox-footer { padding: 10px; background: var(--bg-secondary); border-top: 1px solid var(--border-color); display: flex; justify-content: flex-end; gap: 10px; position: sticky; bottom: 0; z-index: 2; }
        /* Ensure the PDF area scrolls independently while footer stays visible */
        .bbox-content { overflow: hidden; }
        .bbox-canvas-wrap { height: 100%; overscroll-behavior: contain; }

        @media (max-width: 768px) {
            .workflow-container {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2rem;
            }

            .header-content {
                flex-direction: column;
                gap: 20px;
            }
        }

        /* Dark Mode Styles */
        :root {
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --bg-tertiary: #e9ecef;
            --text-primary: #212529;
            --text-secondary: #6c757d;
            --border-color: #dee2e6;
            --shadow: rgba(0,0,0,0.1);
            --accent: #667eea;
            --accent-dark: #764ba2;
        }

        [data-theme="dark"] {
            --bg-primary: #1a1a1a;
            --bg-secondary: #2d2d2d;
            --bg-tertiary: #3d3d3d;
            --text-primary: #ffffff;
            --text-secondary: #b0b0b0;
            --border-color: #4a4a4a;
            --shadow: rgba(0,0,0,0.3);
            --accent: #667eea;
            --accent-dark: #764ba2;
        }

        [data-theme="dark"] body {
            background: #000000;
        }

        [data-theme="dark"] .container {
            background: #000000;
            color: var(--text-primary);
        }

        [data-theme="dark"] .form-section,
        [data-theme="dark"] .preview-section {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
        }

        [data-theme="dark"] .form-group input,
        [data-theme="dark"] .form-group textarea,
        [data-theme="dark"] .form-group select {
            background: var(--bg-primary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        [data-theme="dark"] .form-group input:focus,
        [data-theme="dark"] .form-group textarea:focus,
        [data-theme="dark"] .form-group select:focus {
            border-color: var(--accent);
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.2);
        }

        [data-theme="dark"] .form-group.checkbox-group label {
            color: var(--text-primary);
        }

        [data-theme="dark"] .btn {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        [data-theme="dark"] .btn:hover {
            background: var(--accent);
            color: white;
        }

        [data-theme="dark"] .btn.primary {
            background: var(--accent);
            color: white;
        }

        [data-theme="dark"] .btn.primary:hover {
            background: var(--accent-dark);
        }

        [data-theme="dark"] .highlight {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
        }

        [data-theme="dark"] .array-item {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
        }

        [data-theme="dark"] .bbox-container {
            background: var(--bg-secondary);
        }

        [data-theme="dark"] .bbox-item {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
        }

        [data-theme="dark"] .reorder-btn {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        [data-theme="dark"] .reorder-btn:hover {
            background: #5a6268;
        }

        [data-theme="dark"] .reorder-btn:disabled {
            background: var(--bg-secondary);
            opacity: 0.4;
        }

        [data-theme="dark"] .copy-section-btn {
            background: #17a2b8;
            border: 1px solid var(--border-color);
        }

        [data-theme="dark"] .copy-section-btn:hover {
            background: #138496;
        }

        [data-theme="dark"] .paste-section-btn {
            background: #17a2b8;
        }

        [data-theme="dark"] .paste-section-btn:hover {
            background: #138496;
        }

        [data-theme="dark"] .paste-replace-btn {
            background: #ffc107;
        }

        [data-theme="dark"] .paste-replace-btn:hover {
            background: #e0a800;
        }

        [data-theme="dark"] .duplicate-btn {
            background: #6f42c1;
            border: 1px solid var(--border-color);
        }

        [data-theme="dark"] .duplicate-btn:hover {
            background: #5a32a3;
        }

        [data-theme="dark"] .preview-content {
            background: var(--bg-primary);
            color: var(--text-primary);
        }

        [data-theme="dark"] .json-preview {
            background: var(--bg-primary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        [data-theme="dark"] .json-preview-content {
            color: var(--text-primary);
        }

        [data-theme="dark"] .json-key {
            color: #ff79c6;
        }

        [data-theme="dark"] .json-string {
            color: #f1fa8c;
        }

        [data-theme="dark"] .json-number {
            color: #bd93f9;
        }

        [data-theme="dark"] .json-boolean {
            color: #8be9fd;
        }

        [data-theme="dark"] .json-null {
            color: #6272a4;
        }

        [data-theme="dark"] .preview-indent {
            color: var(--text-secondary);
        }

        [data-theme="dark"] .preview-indent-double {
            color: var(--text-secondary);
        }

        /* Dark mode icon buttons use CSS variables defined above - no override needed */

        /* BBox Modal Dark Mode */
        [data-theme="dark"] .bbox-modal {
            background: rgba(0, 0, 0, 0.8);
        }

        [data-theme="dark"] .bbox-dialog {
            background: var(--bg-primary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        [data-theme="dark"] .bbox-toolbar {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
        }

        [data-theme="dark"] .bbox-toolbar .group {
            border-right: 1px solid var(--border-color);
        }

        [data-theme="dark"] .bbox-btn {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        [data-theme="dark"] .bbox-btn:hover {
            background: var(--accent);
            color: white;
        }

        [data-theme="dark"] .bbox-btn.primary {
            background: var(--accent);
            border-color: var(--accent);
        }

        [data-theme="dark"] .bbox-btn.primary:hover {
            background: var(--accent-dark);
        }

        [data-theme="dark"] .bbox-btn.danger {
            background: #dc2626;
            border-color: #dc2626;
        }

        [data-theme="dark"] .bbox-btn.danger:hover {
            background: #b91c1c;
        }

        [data-theme="dark"] .bbox-content {
            background: var(--bg-primary);
        }

        [data-theme="dark"] .bbox-footer {
            background: var(--bg-secondary);
        }

        /* Improved Title Contrast for Dark Mode */
        [data-theme="dark"] h1,
        [data-theme="dark"] h2,
        [data-theme="dark"] h3,
        [data-theme="dark"] h4,
        [data-theme="dark"] h5,
        [data-theme="dark"] h6 {
            color: #ffffff;
            font-weight: 600;
        }

        [data-theme="dark"] .header h1 {
            color: #ffffff;
            font-weight: 700;
        }

        [data-theme="dark"] .header p {
            color: #e5e7eb;
        }
        
        /* What's New Button Styles */
        #whats-new-btn {
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            text-align: center !important;
            padding-left: 8px !important;
            padding-right: 12px !important;
        }
        
        #whats-new-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        
        #whats-new-btn:active {
            transform: translateY(0);
        }
        
        /* What's New Modal Styles */
        .whats-new-modal-content {
            background: white;
            border-radius: 12px;
            max-width: 800px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }
        
        .whats-new-modal-body {
            padding: 30px;
        }
        
        .whats-new-modal-header {
            color: #2c3e50;
        }
        
        .whats-new-modal-list {
            margin: 0;
            padding-left: 25px;
            line-height: 1.8;
            color: #495057;
        }
        
        .whats-new-version-badge {
            color: #666;
            font-size: 0.9rem;
        }
        
        .whats-new-modal-footer {
            border-top: 2px solid #e9ecef;
            padding-top: 20px;
            text-align: center;
            color: #6c757d;
            font-size: 0.9rem;
        }
        
        /* What's New Modal Dark Mode */
        [data-theme="dark"] .whats-new-modal-content {
            background: var(--bg-primary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }
        
        [data-theme="dark"] .whats-new-modal-header {
            color: var(--text-primary);
        }
        
        [data-theme="dark"] .whats-new-modal-list {
            color: var(--text-secondary);
        }
        
        [data-theme="dark"] .whats-new-version-badge {
            color: var(--text-secondary);
        }
        
        [data-theme="dark"] .whats-new-modal-footer {
            border-top-color: var(--border-color);
            color: var(--text-secondary);
        }
        
        [data-theme="dark"] .whats-new-modal-footer a {
            color: var(--accent);
        }
        
        [data-theme="dark"] .whats-new-modal-footer a:hover {
            color: var(--accent-dark);
        }

        [data-theme="dark"] .form-section h3 {
            color: #ffffff;
            font-weight: 600;
        }

        [data-theme="dark"] .form-section h4 {
            color: #f3f4f6;
            font-weight: 600;
        }

        [data-theme="dark"] .form-section label {
            color: #f9fafb;
            font-weight: 500;
        }

        [data-theme="dark"] .tab-button {
            color: #d1d5db;
            font-weight: 500;
        }

        [data-theme="dark"] .tab-button.active {
            color: #ffffff;
            font-weight: 600;
        }

        [data-theme="dark"] .tab-button:hover {
            color: #ffffff;
        }

        /* Live Preview Dark Mode */
        [data-theme="dark"] .live-preview {
            background: var(--bg-primary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            min-height: 80px;
            height: auto; /* Match content size, managed by JS */
            max-height: none; /* Allow unlimited expansion */
            resize: vertical;
            overflow-y: auto;
            overflow-x: hidden;
        }
        
        /* Trailing spaces indicator in dark mode */
        [data-theme="dark"] .live-preview.has-trailing-spaces {
            border: 2px solid #ffc107;
            border-left: 4px solid #ffc107;
            background: rgba(255, 193, 7, 0.1);
        }
        
        [data-theme="dark"] .live-preview.has-trailing-spaces::before {
            color: #ffc107;
            background: rgba(255, 193, 7, 0.2);
        }
        
        [data-theme="dark"] .leading-space {
            background-color: rgba(255, 0, 0, 0.2);
            border-top-color: rgba(255, 0, 0, 0.5);
        }
        
        [data-theme="dark"] .trailing-space {
            background-color: rgba(255, 0, 0, 0.2);
            border-bottom-color: rgba(255, 0, 0, 0.5);
        }
        
        [data-theme="dark"] .consecutive-space {
            background-color: rgba(255, 0, 0, 0.2);
            border-top-color: rgba(255, 0, 0, 0.5);
            border-bottom-color: rgba(255, 0, 0, 0.5);
        }
        
        [data-theme="dark"] .trailing-empty-line {
            background-color: rgba(255, 193, 7, 0.1);
            border-left-color: #ffc107;
        }
        
        [data-theme="dark"] .trailing-empty-line::before {
            color: #ffc107;
            background: rgba(255, 193, 7, 0.25);
        }
        
        [data-theme="dark"] .preview-label {
            color: #818cf8 !important;
            opacity: 0.9;
        }
        
        /* Prevent required asterisk on preview labels in dark mode */
        [data-theme="dark"] .preview-label::after {
            content: none !important;
        }
        
        [data-theme="dark"] .input-label {
            color: #818cf8;
        }

        [data-theme="dark"] .live-preview table {
            border-collapse: collapse;
            width: 100%;
            margin: 8px 0;
        }

        [data-theme="dark"] .live-preview th,
        [data-theme="dark"] .live-preview td {
            border: 1px solid var(--border-color);
            padding: 6px 8px;
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        [data-theme="dark"] .live-preview th {
            background: var(--bg-tertiary);
            font-weight: bold;
        }

        [data-theme="dark"] .live-preview blockquote {
            border-left: 4px solid var(--accent);
            margin: 8px 0;
            padding: 6px 10px;
            color: var(--text-secondary);
            background: var(--bg-secondary);
        }

        [data-theme="dark"] .live-preview ul,
        [data-theme="dark"] .live-preview ol {
            margin: 8px 0;
            padding-left: 30px;
        }
        [data-theme="dark"] .live-preview ul { list-style-type: disc; }
        [data-theme="dark"] .live-preview ol { list-style-type: decimal; }
        [data-theme="dark"] .live-preview li { margin: 4px 0; display: list-item; }
        [data-theme="dark"] .live-preview ul ul { list-style-type: circle; margin: 4px 0; }
        [data-theme="dark"] .live-preview ul ul ul { list-style-type: square; }
        [data-theme="dark"] .live-preview ol ol { list-style-type: lower-alpha; }
        [data-theme="dark"] .live-preview ol ol ol { list-style-type: lower-roman; }
        /* RTL list styling in dark mode */
        [data-theme="dark"] .live-preview[dir="rtl"] ul,
        [data-theme="dark"] .live-preview[dir="rtl"] ol { padding-left: 0; padding-right: 30px; }
        [data-theme="dark"] .live-preview[dir="rtl"] ul ul,
        [data-theme="dark"] .live-preview[dir="rtl"] ol ol { padding-left: 0; padding-right: 30px; }

        /* Save indicator dark mode */
        [data-theme="dark"] .auto-save-indicator {
            background: rgba(255, 255, 255, 0.05);
            border-color: rgba(255, 255, 255, 0.2);
        }

        [data-theme="dark"] .auto-save-indicator.saving {
            background: rgba(255, 193, 7, 0.15);
            border-color: rgba(255, 193, 7, 0.4);
            color: #ffc107;
            font-weight: 600;
        }

        [data-theme="dark"] .auto-save-indicator.saved {
            background: rgba(40, 167, 69, 0.15);
            border-color: rgba(40, 167, 69, 0.4);
            color: #4caf50;
            font-weight: 600;
        }

        /* Save button styling */
        #saveBtn {
            transition: all 0.3s ease;
        }

        #saveBtn:hover {
            background: rgba(102, 126, 234, 0.3);
            border-color: rgba(102, 126, 234, 0.5);
        }

        #saveBtn:active {
            transform: scale(0.95);
        }
        
        /* Undo/Redo button styling - match save button style */
        #undo-btn:disabled,
        #redo-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        #undo-btn:not(:disabled):hover,
        #redo-btn:not(:disabled):hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
            transform: scale(1.1);
        }
        
        #undo-btn:not(:disabled):active,
        #redo-btn:not(:disabled):active {
            transform: scale(0.95);
        }

        /* Form Header and Navigation Styles */
        .form-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .navigation-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }


        /* Quick Jump Menu */
        /* Search Results Dropdown */
        /* Search input placeholder styling */
        #searchFilter {
            text-align: left !important;
            direction: ltr !important;
        }
        
        #searchFilter::placeholder {
            text-align: left !important;
            direction: ltr !important;
            font-size: 0.9rem !important; /* Fixed font size for placeholder */
        }
        
        /* Fix font size for search input (not affected by font size selector) */
        #searchFilter {
            font-size: 0.9rem !important; /* Fixed font size to match default */
        }
        
        /* Fix font size for JSON input and its placeholder */
        #json_input {
            font-size: 14px !important; /* Fixed font size to match default */
        }
        
        #json_input::placeholder {
            font-size: 14px !important; /* Fixed font size for placeholder */
        }
        
        .search-results-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            margin-top: 4px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            max-height: 400px;
            overflow-y: auto;
            z-index: 10000;
            font-size: 0.9rem;
        }
        
        .search-result-item {
            padding: 12px;
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .search-result-item:last-child {
            border-bottom: none;
        }
        
        .search-result-item:hover,
        .search-result-item.highlighted {
            background-color: var(--bg-secondary);
        }
        
        .search-result-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .search-result-type {
            font-size: 0.75rem;
            padding: 2px 6px;
            border-radius: 4px;
            background: var(--accent);
            color: white;
            font-weight: 500;
        }
        
        .search-result-preview {
            font-size: 0.85rem;
            color: var(--text-secondary);
            line-height: 1.4;
            margin-top: 4px;
        }
        
        .search-result-preview .highlight {
            background-color: #ffd700;
            color: #000;
            padding: 2px 4px;
            border-radius: 3px;
            font-weight: 600;
        }
        
        .search-result-empty {
            padding: 16px;
            text-align: center;
            color: var(--text-secondary);
            font-style: italic;
        }
        
        [data-theme="dark"] .search-result-preview .highlight {
            background-color: #ffd700;
            color: #000;
        }
        
        .quick-jump select {
            padding: 4px 8px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            background: white;
            color: #495057;
            font-size: 0.75rem;
            cursor: pointer;
            transition: border-color 0.2s ease;
            min-width: 120px;
            max-width: 180px;
        }
        
        /* Quick jump in header - ensure it doesn't expand header */
        .header-content .quick-jump select {
            max-width: 150px;
        }

        .quick-jump select:hover {
            border-color: #667eea;
        }

        .quick-jump select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        /* Header select styling (font size and line height) */
        .header-select {
            background: rgba(255, 255, 255, 0.2) !important;
            border: 1px solid rgba(255, 255, 255, 0.3) !important;
            border-radius: 4px;
            color: white !important;
        }
        
        .header-select option {
            background: #2c3e50;
            color: white;
        }

        /* Dark mode navigation styles */
        [data-theme="dark"] .quick-jump select {
            background: #2d3748 !important;
            border-color: #4a5568 !important;
            color: #e2e8f0 !important;
        }

        [data-theme="dark"] .quick-jump select:hover {
            border-color: #667eea !important;
        }
        
        [data-theme="dark"] .quick-jump select option {
            background: #2d3748;
            color: #e2e8f0;
        }

        /* Dark mode header select styling */
        [data-theme="dark"] .header-select {
            background: rgba(255, 255, 255, 0.15) !important;
            border: 1px solid rgba(255, 255, 255, 0.25) !important;
            color: white !important;
        }
        
        [data-theme="dark"] .header-select option {
            background: #2d3748;
            color: #e2e8f0;
        }

        /* Responsive navigation */
        @media (max-width: 768px) {
            .form-header {
                flex-direction: column;
                align-items: stretch;
            }

            .navigation-controls {
                justify-content: space-between;
            }

            .quick-jump select {
                min-width: 100px;
                max-width: 130px;
                font-size: 0.7rem;
                padding: 3px 6px;
            }
            
            .header-content .quick-jump select {
                max-width: 120px;
            }
        }


        /* Visual Field Validation */
        .form-group {
            position: relative;
        }

        /* Green checkmark removed per user request - .form-group.valid styling removed */

        .form-group.invalid input,
        .form-group.invalid textarea,
        .form-group.invalid select {
            border-color: #dc3545;
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 12 12' width='12' height='12' fill='none' stroke='%23dc3545'%3e%3ccircle cx='6' cy='6' r='4.5'/%3e%3cpath d='m5.5 5.5 1 1m0-1-1 1'/%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 12px center;
            background-size: 16px;
            padding-right: 40px;
        }

        .form-group.required label::after {
            content: " *";
            color: #dc3545;
            font-weight: bold;
        }

        .form-group.required:not(.valid):not(.invalid) input,
        .form-group.required:not(.valid):not(.invalid) textarea,
        .form-group.required:not(.valid):not(.invalid) select {
            border-left: 4px solid #ffc107;
        }

        /* Validation message */
        .validation-message {
            font-size: 0.8rem;
            margin-top: 4px;
            padding: 4px 8px;
            border-radius: 4px;
            display: none;
        }

        .validation-message.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
            display: block;
        }

        .validation-message.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
            display: block;
        }

        /* Dark mode field validation */
        body.dark-mode .form-group.valid input,
        body.dark-mode .form-group.valid textarea,
        body.dark-mode .form-group.valid select {
            border-color: #28a745;
            background-color: #2d3748;
        }

        body.dark-mode .form-group.invalid input,
        body.dark-mode .form-group.invalid textarea,
        body.dark-mode .form-group.invalid select {
            border-color: #dc3545;
            background-color: #2d3748;
        }

        body.dark-mode .validation-message.error {
            background: #2d3748;
            color: #feb2b2;
            border-color: #4a5568;
        }

        body.dark-mode .validation-message.success {
            background: #2d3748;
            color: #68d391;
            border-color: #4a5568;
        }

        /* Floating Action Buttons - Hidden */
        .floating-actions {
            display: none;
        }

        .fab-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
            align-items: center;
        }

        .fab {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9rem;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.15);
            transition: all 0.3s ease;
            position: relative;
        }

        .fab:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
        }

        .fab:active {
            transform: translateY(0);
        }

        .fab-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .fab-primary:hover {
            background: linear-gradient(135deg, #5a6fd8 0%, #6a4190 100%);
        }

        .fab-secondary {
            background: #f8f9fa;
            color: #495057;
            border: 1px solid #dee2e6;
        }

        .fab-secondary:hover {
            background: #e9ecef;
            border-color: #adb5bd;
        }

        /* FAB animations */
        .fab {
            animation: fabSlideIn 0.3s ease-out;
        }

        @keyframes fabSlideIn {
            from {
                opacity: 0;
                transform: translateX(100px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        /* Dark mode FABs */
        body.dark-mode .fab-secondary {
            background: #2d3748;
            color: #e2e8f0;
            border-color: #4a5568;
        }

        body.dark-mode .fab-secondary:hover {
            background: #4a5568;
            border-color: #718096;
        }

        /* Responsive FABs */
        @media (max-width: 768px) {
            .floating-actions {
                bottom: 20px;
                right: 20px;
            }

            .fab {
                width: 36px;
                height: 36px;
                font-size: 0.85rem;
            }

            .fab-container {
                gap: 10px;
            }
        }

        /* Hide FABs when printing */
        @media print {
            .floating-actions {
                display: none;
            }
        }

        /* PDF Viewer Toggle Styles */
        .toggle-section {
            display: flex;
            flex-direction: column;
        }

        .view-toggle-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
            padding-top: min(15px, 1.5vw);
            padding-bottom: 4px;
            border-bottom: 1px solid #dee2e6;
        }
        
        /* Responsive padding-top for view-toggle-header */
        @media (max-width: 1400px) {
            .view-toggle-header {
                padding-top: 10px;
            }
        }
        
        @media (max-width: 1200px) {
            .view-toggle-header {
                padding-top: 8px;
            }
        }

        .view-toggle-buttons {
            display: flex;
            gap: 6px;
        }

        .view-toggle-btn {
            padding: 5px 10px;
            border: 1px solid #dee2e6;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 4px;
            font-weight: 500;
            font-size: 0.8rem;
        }

        .view-toggle-btn:hover {
            border-color: #667eea;
            background: #f8f9fa;
        }

        .view-toggle-btn.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .view-panel {
            display: none;
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            flex-direction: column;
            min-height: 0; /* Allow flex child to shrink */
        }

        .view-panel.active {
            display: flex;
        }
        
        /* Ensure JSON preview panel content is scrollable */
        #json-preview-panel {
            min-height: 0;
            max-height: none; /* Allow unlimited expansion */
        }
        
        #json-preview-panel .json-preview {
            flex: 1 1 auto;
            min-height: 200px;
            max-height: 2000px; /* Allow expansion up to 2000px (much larger than before) */
            overflow-y: auto;
            resize: vertical; /* Allow manual resizing */
        }

        /* PDF Viewer Specific */
        #pdf-viewer-panel {
            background: #f8f9fa;
            border-radius: 6px;
            padding: 8px;
            display: flex;
            flex-direction: column;
            flex: 1;
            min-height: 0; /* Allow flex child to shrink */
            overflow: hidden; /* Prevent panel from scrolling, let canvas container handle it */
        }

        .pdf-viewer-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            align-items: center;
            margin-bottom: 8px;
            padding: 6px;
            background: white;
            border-radius: 6px;
            border: 1px solid #dee2e6;
            flex-shrink: 0; /* Prevent controls from shrinking */
        }

        .pdf-source-toggle {
            display: flex;
            gap: 4px;
        }

        .pdf-source-btn {
            padding: 4px 8px;
            border: 1px solid #dee2e6;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 3px;
        }

        .pdf-source-btn:hover {
            border-color: #667eea;
            background: #f8f9fa;
        }

        .pdf-source-btn.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .pdf-canvas-container {
            position: relative;
            background: #e9ecef;
            border-radius: 6px;
            overflow: auto;
            flex: 1; /* Fill remaining vertical space */
            min-height: 0; /* Allow flex child to shrink below content size */
            width: 100%;
            max-width: 100%;
            display: flex;
            justify-content: flex-start;
            align-items: flex-start;
            padding: 10px;
            box-sizing: border-box;
            overflow-x: auto; /* Horizontal scroll when zoomed */
            overflow-y: auto; /* Vertical scroll when needed */
        }

        #main-pdf-canvas {
            display: block;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            background: white;
            flex-shrink: 0; /* Prevent canvas from shrinking */
            margin: 0 auto; /* Center when smaller than container */
        }

        /* Dark mode for PDF viewer */
        [data-theme="dark"] .view-toggle-btn {
            background: var(--bg-primary);
            color: var(--text-primary);
            border-color: var(--border-color);
        }

        [data-theme="dark"] .view-toggle-btn:hover {
            background: var(--bg-secondary);
            border-color: #667eea;
        }

        [data-theme="dark"] .view-toggle-btn.active {
            background: #667eea;
            color: white;
        }

        [data-theme="dark"] #pdf-viewer-panel {
            background: var(--bg-secondary);
        }

        [data-theme="dark"] .pdf-viewer-controls {
            background: var(--bg-primary);
            border-color: var(--border-color);
        }

        [data-theme="dark"] .pdf-source-btn {
            background: var(--bg-primary);
            color: var(--text-primary);
            border-color: var(--border-color);
        }

        [data-theme="dark"] .pdf-source-btn:hover {
            background: var(--bg-secondary);
            border-color: #667eea;
        }

        [data-theme="dark"] .pdf-source-btn.active {
            background: #667eea;
            color: white;
        }

        [data-theme="dark"] .pdf-canvas-container {
            background: var(--bg-tertiary);
        }

    </style>
</head>
<body>
    <!-- Embedded BBox Drawer Modal -->
    <div id="bboxModal" class="bbox-modal" aria-hidden="true">
        <div class="bbox-dialog">
            <div class="bbox-toolbar">
                <!-- Upload buttons first -->
                <div class="group">
                    <label class="bbox-btn">
                        <input id="em-text-pdf-file" type="file" accept="application/pdf" style="display:none" />
                        Upload Textbook PDF
                    </label>
                    <label class="bbox-btn">
                        <input id="em-guide-pdf-file" type="file" accept="application/pdf" style="display:none" />
                        Upload Answers PDF
                    </label>
                </div>
                <!-- Doc label -->
                <div class="group">
                    <div class="muted">Doc: <span id="em-doc-label">Textbook</span></div>
                </div>
                <!-- Page Navigation: prev, page indicator, next, goto input, goto button -->
                <div class="group">
                    <div id="bbox-nav-prev-button" style="display: flex; gap: 4px; align-items: center;"></div>
                    <div class="muted">Page <span id="em-page-num">0</span>/<span id="em-page-count">0</span></div>
                    <div id="bbox-nav-next-button" style="display: flex; gap: 4px; align-items: center;"></div>
                    <input id="em-goto" type="number" min="1" step="1" placeholder="#" title="Go to page" style="width:80px" />
                    <div id="bbox-goto-button"></div>
                </div>
                <!-- Zoom: zoom-out, display, zoom-in, reset -->
                <div class="group">
                    <div id="bbox-zoom-out-button" style="display: flex; gap: 4px; align-items: center;"></div>
                    <span id="em-zoom-display" style="color: var(--text-secondary); font-size: 0.9rem; padding: 0 8px;">100%</span>
                    <div id="bbox-zoom-in-button" style="display: flex; gap: 4px; align-items: center;"></div>
                    <div id="bbox-zoom-reset-button" style="display: flex; gap: 4px; align-items: center;"></div>
                </div>
                <!-- Drawing status + drawing actions -->
                <div class="group">
                    <span class="muted">Drawing: Always On</span>
                    <div id="bbox-drawing-buttons" style="display: flex; gap: 4px; align-items: center;"></div>
                </div>
                <!-- Coords display -->
                <div class="group">
                    <div class="muted">Coords</div>
                    <div id="em-coords" class="muted"></div>
                </div>
                <!-- Close button at far right -->
                <div class="group" style="margin-left:auto">
                    <div id="bbox-close-button"></div>
                </div>
            </div>
            <div class="bbox-content">
                <div class="bbox-canvas-wrap" id="em-canvas-wrap">
                    <canvas id="em-pdf"></canvas>
                    <canvas id="em-draw"></canvas>
                </div>
                <div class="bbox-sidebar">
                    <h3 style="margin:0 0 6px">Bounding Boxes</h3>
                    <div class="muted">Per current page</div>
                    <div id="em-list" class="bbox-bbox-list"></div>
                </div>
            </div>
            <div class="bbox-footer">
                <div id="bbox-footer-buttons" style="display: flex; gap: 8px;"></div>
            </div>
        </div>
    </div>
                    <div class="container">
            <div class="header">
                <div class="header-content">
                    <div class="header-text">
                        <div class="header-title">
                            <i class="fas fa-book-open" style="font-size: 0.85rem;"></i>
                            <h1>Math Textbook Transcription</h1>
                        </div>
                        <div class="header-meta">
                            <span id="version-display">v<span id="version-number"></span></span>
                            <span></span>
                            <button id="whats-new-btn" onclick="openWhatsNew()" title="View latest updates and improvements" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border: none; color: white; padding: 4px 10px; border-radius: 12px; cursor: pointer; font-size: 0.65rem; font-weight: 600; display: flex; align-items: center; justify-content: center; gap: 5px; transition: all 0.3s; box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);">
                                <i class="fas fa-sparkles"></i> What's New
                            </button>
                            <span></span>
                            <span>DUKU</span>
                        </div>
                    </div>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <!-- Undo/Redo Buttons -->
                        <div id="topbar-undo-redo" style="display: flex; gap: 8px;"></div>
                        <!-- Font Settings -->
                        <div class="font-settings" style="display: flex; gap: 6px; align-items: center; background: rgba(255, 255, 255, 0.1); padding: 4px 8px; border-radius: 6px;">
                            <label style="font-size: 0.7rem; opacity: 0.9;">Font:</label>
                            <select id="fontSizeSelect" onchange="changeFontSize(this.value)" title="Change font size" class="header-select" style="padding: 2px 6px; font-size: 0.7rem; cursor: pointer; outline: none;">
                                <option value="14" selected>14px</option>
                                <option value="16">16px</option>
                                <option value="18">18px</option>
                                <option value="20">20px</option>
                                <option value="22">22px</option>
                                <option value="24">24px</option>
                                <option value="26">26px</option>
                                <option value="28">28px</option>
                                <option value="30">30px</option>
                                <option value="32">32px</option>
                                <option value="36">36px</option>
                                <option value="40">40px</option>
                                <option value="44">44px</option>
                                <option value="48">48px</option>
                            </select>
                            <label style="font-size: 0.7rem; opacity: 0.9; margin-left: 4px;">Line:</label>
                            <select id="lineHeightSelect" onchange="changeLineHeight(this.value)" title="Change line height" class="header-select" style="padding: 2px 6px; font-size: 0.7rem; cursor: pointer; outline: none;">
                                <option value="1.5" selected>1.5</option>
                                <option value="1.8">1.8</option>
                                <option value="2.0">2.0</option>
                                <option value="2.2">2.2</option>
                                <option value="2.5">2.5</option>
                            </select>
                        </div>
                        <span></span>
                        <div id="saveIndicator" class="auto-save-indicator">
                            <span>No changes</span>
                        </div>
                        <div class="quick-jump" style="display: flex; gap: 8px; align-items: center; position: relative;">
                            <div style="position: relative; width: 270px;">
                                <div style="position: relative;">
                                    <input type="text" id="searchFilter" placeholder="Search content & questions..." title="Search across all content sections and questions" style="padding: 6px 12px; padding-right: 80px; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary); font-size: 0.9rem; width: 100%; outline: none; text-align: left; direction: ltr;" oninput="performSearch(this.value)" onfocus="handleSearchFocus()" onblur="handleSearchBlur()" onkeydown="handleSearchKeydown(event)">
                                    <span id="searchResultsCount" style="position: absolute; right: 12px; top: 50%; transform: translateY(-50%); color: var(--text-secondary); font-size: 0.85rem; pointer-events: none; display: none;"></span>
                                </div>
                                <div id="searchResultsDropdown" class="search-results-dropdown" style="display: none;"></div>
                            </div>
                            <div id="topbar-clear-search"></div>
                        </div>
                        <div class="quick-jump">
                            <select id="quickJumpSelect" onchange="quickJumpTo(this.value)" title="Quickly jump to any form section, content section, or question">
                                <option value="">Quick Jump...</option>
                                <optgroup label="Form Sections">
                                    <option value="basic">Basic Info</option>
                                    <option value="preamble">Lesson Preamble</option>
                                    <option value="content">Content Sections</option>
                                    <option value="questions">Questions</option>
                                </optgroup>
                                <optgroup label="Content Sections" id="contentSectionsGroup">
                                    <!-- Dynamically populated -->
                                </optgroup>
                                <optgroup label="Questions" id="questionsGroup">
                                    <!-- Dynamically populated -->
                                </optgroup>
                            </select>
                        </div>
                        <div id="topbar-actions" style="display: flex; gap: 8px;"></div>
                    </div>
                </div>
            </div>
            

        <div class="workflow-container">
            <!-- Form Section -->
            <div class="form-section">
                <!-- Main Tab Navigation: Input Form / Final Preview -->
                <div class="tabs main-tabs sticky-tab-bar sticky-tab-bar--main" id="main-tabs-container">
                    <!-- Buttons will be hydrated by JS -->
                </div>
                
                <!-- Input Form Tab Content -->
                <div id="input-form" class="main-tab-content active">
                    <!-- Sticky Tabs Stack: Sub tabs only, inside Input Form (outside scroll container) -->
                    <div class="sticky-tabs-stack">
                        <!-- Sub Tab Navigation: Basic Info / Lesson Preamble / Content / Questions -->
                        <div class="tabs sticky-tab-bar sticky-tab-bar--sub" id="sub-tabs-container">
                            <!-- Buttons will be hydrated by JS -->
                        </div>
                    </div>
                    
                    <!-- Universal scroll container for all sub-tab panels -->
                    <div class="input-form-scroll">
                        <!-- Basic Info Tab -->
                        <div id="basic" class="tab-content active">
                    <!-- Textbook Page Number - Refactored to use createFormControl -->
                    <div id="textbook_page_container"></div>
                     
                    <!-- PDF Page Number - Refactored to use createFormControl -->
                    <div id="textbook_pdf_page_container"></div>
                    
                    <!-- Guidebook PDF Pages - Refactored to use createFormControl -->
                     <div class="form-group required-field">
                         <label>Guidebook PDF Pages (Start - End)</label>
                         <div class="bbox-inputs" style="grid-template-columns: 1fr 1fr;">
                            <div id="guidebook_start_page_container"></div>
                            <div id="guidebook_end_page_container"></div>
                         </div>
                         <small style="color: #6c757d; font-size: 12px;">Will generate array from start to end page (inclusive)</small>
                     </div>
                    
                    <!-- Page Type - Refactored to use createFormControl -->
                    <div id="page_type_container"></div>
                    
                    <div class="highlight">
                        <h4><i class="fas fa-lightbulb"></i> Basic Info Tips</h4>
                        <p> Textbook page: The actual page number in the physical book</p>
                        <p> PDF page: The page number in the digital PDF file</p>
                        <p> Guidebook pages: Range of pages in the teacher's guide</p>
                        <p> Page type: Categorizes the content type for organization</p>
                    </div>
                </div>

                <!-- Lesson Preamble Tab -->
                <div id="preamble" class="tab-content">
                    <!-- Lesson ID - Refactored to use createFormControl -->
                    <div id="lesson_id_container"></div>
                    
                    <div class="form-group">
                        <label>Lesson Title</label>
                        <span class="input-label">Input Markdown</span>
                        <div id="lesson_title_container"></div>
                    </div>
                    
                    <div class="form-group">
                        <label>Lesson Standards</label>
                        <div id="lesson_standards">
                            <div class="array-item">
                                <div class="text-field-container">
                                    <span class="input-label">Input Markdown</span>
                                    <textarea placeholder="e.g., CCSS.MATH.CONTENT.8.G.A.1" title="Educational standard code (e.g., Common Core State Standards)"></textarea>
                                    <div class="js-markdown-toolbar" data-include-image="false" data-include-table="false"></div>
                                </div>
                                <div class="row-actions">
                                    <button class="add-bbox-btn" onclick="addLessonStandardBefore(this)" title="Add Standard Before">
                                        <i class="fas fa-plus"></i> Before
                                    </button>
                                    <button class="add-bbox-btn" onclick="addLessonStandardAfter(this)" title="Add Standard After">
                                        <i class="fas fa-plus"></i> After
                                    </button>
                                    <button class="reorder-btn" onclick="moveItemUp(this)" title="Move Up"><i class="fas fa-arrow-up"></i></button>
                                    <button class="reorder-btn" onclick="moveItemDown(this)" title="Move Down"><i class="fas fa-arrow-down"></i></button>
                                    <button class="remove-btn" onclick="removeArrayItem(this)"></button>
                                </div>
                            </div>
                        </div>
                        <div class="js-action-button" data-action="addLessonStandard"></div>
                    </div>
                    
                    <div class="form-group">
                        <label>Terminology</label>
                        <div id="terminology">
                            <div class="array-item">
                                <div class="text-field-container">
                                <span class="input-label">Input Markdown</span>
                                    <textarea placeholder="e.g., Parallel Lines" title="Terminology term with definition (supports markdown formatting)"></textarea>
                                    <div class="js-markdown-toolbar" data-include-image="false" data-include-table="false"></div>
                                </div>
                                <div class="row-actions">
                                    <button class="add-bbox-btn" onclick="addTerminologyBefore(this)" title="Add Term Before">
                                        <i class="fas fa-plus"></i> Before
                                    </button>
                                    <button class="add-bbox-btn" onclick="addTerminologyAfter(this)" title="Add Term After">
                                        <i class="fas fa-plus"></i> After
                                    </button>
                                    <button class="reorder-btn" onclick="moveItemUp(this)" title="Move Up"><i class="fas fa-arrow-up"></i></button>
                                    <button class="reorder-btn" onclick="moveItemDown(this)" title="Move Down"><i class="fas fa-arrow-down"></i></button>
                                    <button class="remove-btn" onclick="removeArrayItem(this)"></button>
                                </div>
                            </div>
                        </div>
                        <div class="js-action-button" data-action="addTerminology"></div>
                    </div>
                    
                    <div class="form-group">
                        <label>Lesson Text</label>
                        <div id="lesson_text_container"></div>
                    </div>
                    
                    <div class="highlight">
                        <h4><i class="fas fa-lightbulb"></i> Lesson Preamble Tips</h4>
                        <p> Lesson ID: Use format like "2-1" for Unit 2, Lesson 1</p>
                        <p> Lesson Title: Brief, descriptive title for the lesson</p>
                        <p> Standards: Educational standards this lesson addresses</p>
                        <p> Terminology: Key mathematical terms students need to know</p>
                        <p> Lesson Text: Additional context not captured in other fields</p>
                        <p> <strong>Note:</strong> Tables and images are not allowed in this section</p>
                    </div>
                </div>

                <!-- Content Tab -->
                <div id="content" class="tab-content">
                    <div id="content_sections_container">
                    </div>
                    
                    <div class="button-group">
                        <div class="js-action-button" data-action="addContentSection"></div>
                        <div class="js-action-button" data-action="pasteSectionAtEnd" data-param="content"></div>
                    </div>
                    
                    <div class="highlight">
                        <h4><i class="fas fa-lightbulb"></i> Content Section Tips</h4>
                        <p> Use **bold** and *italic* for emphasis</p>
                        <p> Include LaTeX with $$ for math expressions</p>
                        <p> Insert tables with the <i class="fas fa-table"></i> button</p>
                        <p> Insert images with the <i class="fas fa-image"></i> button</p>
                        <p> <strong>Coordinate System:</strong> [x0, y0] = top-right, [x1, y1] = bottom-left</p>
                        <p> <strong>Auto-validation:</strong> Coordinates are automatically normalized when you finish entering them</p>
                        <p> <strong>Reordering:</strong> Use <i class="fas fa-arrow-up"></i> <i class="fas fa-arrow-down"></i> to reorder sections and bboxes</p>
                        <p> <strong>Copy/Paste:</strong> Use <i class="fas fa-copy"></i> to copy a section. Yellow <i class="fas fa-paste"></i> replaces current section, blue Paste button adds new section</p>
                    </div>
                </div>

                <!-- Questions Tab -->
                <div id="questions" class="tab-content">
                    <div id="questions_container">
                    </div>
                    
                    <div class="button-group">
                        <div class="js-action-button" data-action="addQuestion"></div>
                        <div class="js-action-button" data-action="pasteSectionAtEnd" data-param="question"></div>
                    </div>
                    
                    <div class="highlight">
                        <h4><i class="fas fa-lightbulb"></i> Question Tips</h4>
                        <p> Question Text: The main question students need to answer</p>
                        <p> Guide Answer: Step-by-step solution or answer key</p>
                        <p> Set-up Text: Context or information shared across multiple questions</p>
                        <p> Insert tables and images using the buttons in each text field</p>
                        <p> <strong>Important:</strong> Setup text and question text share the same image array</p>
                        <p> <strong>Coordinate System:</strong> [x0, y0] = top-right, [x1, y1] = bottom-left</p>
                        <p> <strong>Auto-validation:</strong> Coordinates are automatically normalized when you finish entering them</p>
                        <p> <strong>Reordering:</strong> Use <i class="fas fa-arrow-up"></i> <i class="fas fa-arrow-down"></i> to reorder questions and bboxes</p>
                        <p> <strong>Copy/Paste:</strong> Use <i class="fas fa-copy"></i> to copy a question. Yellow <i class="fas fa-paste"></i> replaces current question, blue Paste button adds new question</p>
                    </div>
                </div>
                    </div>
                    <!-- End universal scroll container -->
                </div>
                <!-- End Input Form Tab Content -->

                <!-- Final Preview Tab Content -->
                <div id="final-preview" class="main-tab-content">
                    <div id="final-preview-content" class="final-preview-container">
                        <!-- Preview content will be generated dynamically -->
                    </div>
                </div>
                <!-- End Final Preview Tab Content -->

                
            </div>

            <!-- JSON Preview / PDF Viewer Section -->
            <div class="form-section toggle-section">
                <!-- Toggle Header -->
                <div class="view-toggle-header">
                    <div class="view-toggle-buttons" id="view-toggle-buttons-container">
                        <!-- Buttons will be hydrated by JS -->
                    </div>
                    <div id="generate-json-container"></div>
                </div>
                
                <!-- PDF Viewer Panel (hidden by default) -->
                <div id="pdf-viewer-panel" class="view-panel" style="display: none;">
                    <!-- PDF controls and canvas will be inserted here by JavaScript -->
                </div>
                
                <!-- JSON Preview Panel (visible by default) -->
                <div id="json-preview-panel" class="view-panel active">
                    <!-- Input JSON (Import Area) -->
                    <div class="form-group">
                        <label>Load JSON or Python Dict to populate the form</label>
                        <div class="json-controls" id="json-import-controls" style="margin-bottom:8px;">
                            <!-- Buttons will be hydrated by JS -->
                        </div>
                        <textarea id="json_input" placeholder="Paste JSON or Python dict here..." data-ltr="true" title="Paste JSON or Python dictionary here, then click 'Load JSON/Dict' to populate the form"></textarea>
                    </div>
                    <!-- Output JSON (Preview Area) -->
                    <div class="json-controls" id="json-export-controls" style="margin-bottom:8px;">
                        <!-- Buttons will be hydrated by JS -->
                    </div>
                    <div class="json-preview" id="json_output">
                        <span class="json-key">//</span> <span class="json-string">JSON will be generated here...</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // KaTeX: suppress noisy warnings (Arabic/diacritics, character metrics) in production; keep in dev.
        var SUPPRESS_KATEX_WARNINGS = true;
        try {
            if (typeof window !== 'undefined' && window.location) {
                if (/^localhost$/i.test(window.location.hostname) || /^127\.0\.0\.1$/.test(window.location.hostname) || /[?&]katex_warn=1/.test(window.location.search || ''))
                    SUPPRESS_KATEX_WARNINGS = false;
            }
        } catch (e) {}
        function runWithKatexWarnSuppressed(fn) {
            if (!SUPPRESS_KATEX_WARNINGS) return fn();
            var origWarn = console.warn;
            console.warn = function(msg) {
                if (typeof msg === 'string' && (/LaTeX-incompatible input and strict mode is set to 'warn'/.test(msg) || /No character metrics for/.test(msg)))
                    return;
                origWarn.apply(console, arguments);
            };
            try { return fn(); } finally { console.warn = origWarn; }
        }
        function getKatexRenderOptions(overrides) {
            var o = { throwOnError: false, strict: 'ignore', output: 'html' };
            if (overrides) for (var k in overrides) if (overrides.hasOwnProperty(k)) o[k] = overrides[k];
            return o;
        }
        function safeKatexRender(tex, node, options) {
            if (!window.katex) return;
            runWithKatexWarnSuppressed(function() {
                window.katex.render(tex, node, getKatexRenderOptions(options));
            });
        }
        function safeRenderMathInElement(element, options) {
            if (!window.renderMathInElement) return;
            var opts = options ? Object.assign({}, options) : {};
            opts.strict = 'ignore';
            opts.throwOnError = false;
            runWithKatexWarnSuppressed(function() { window.renderMathInElement(element, opts); });
        }

        // ========================================
        // Universal Form Control Factory
        // ========================================
        /**
         * Creates a reusable form control with consistent structure and behavior
         * @param {Object} config - Configuration object
         * @param {string} config.id - Element ID
         * @param {string} config.name - Element name attribute
         * @param {string} config.label - Label text
         * @param {string} config.type - Input type: 'text', 'number', 'textarea', 'select'
         * @param {string} [config.value] - Initial value
         * @param {string} [config.placeholder] - Placeholder text
         * @param {boolean} [config.required] - Whether field is required
         * @param {boolean} [config.disabled] - Whether field is disabled
         * @param {string|string[]} [config.classes] - Additional CSS classes
         * @param {Object} [config.dataset] - Data attributes (e.g., {ltr: "true"})
         * @param {Object} [config.attrs] - Additional HTML attributes
         * @param {Array} [config.options] - Options for select (array of {value, text} or strings)
         * @param {Function} [config.onInput] - Input event handler
         * @param {Function} [config.onChange] - Change event handler
         * @param {Function} [config.onKeydown] - Keydown event handler
         * @returns {Object} {rootEl, controlEl, getValue, setValue, setError}
         */
        // Helper: Create a required number input with integer validation
        function createRequiredNumberInput(config) {
            const control = createFormControl({
                id: config.id,
                label: config.label,
                type: 'number',
                placeholder: config.placeholder,
                required: true,
                attrs: {
                    min: '1',
                    step: '1',
                    title: config.title
                },
                onInput: function(e) {
                    validateInteger(e.target);
                }
            });
            // Attach keypress handler for integer-only input (matches original onkeypress behavior)
            control.controlEl.addEventListener('keypress', function(e) {
                // Only allow digits (0-9), charCode 48-57
                if (e.charCode < 48 || e.charCode > 57) {
                    e.preventDefault();
                }
            });
            return control;
        }
        
        function createFormControl(config) {
            // Default RTL for content text, LTR for IDs/technical (when data-ltr="true")
            const isLTR = config.dataset && config.dataset.ltr === 'true';
            const defaultDir = isLTR ? 'ltr' : 'rtl';
            
            // Create form-group wrapper
            const formGroup = document.createElement('div');
            formGroup.className = 'form-group';
            if (config.required) {
                formGroup.classList.add('required-field', 'required');
            }
            if (config.classes) {
                const classes = Array.isArray(config.classes) ? config.classes : [config.classes];
                classes.forEach(cls => formGroup.classList.add(cls));
            }
            
            // Create label
            if (config.label) {
                const label = document.createElement('label');
                if (config.id) label.setAttribute('for', config.id);
                label.textContent = config.label;
                formGroup.appendChild(label);
            }
            
            // Create control element
            let controlEl;
            if (config.type === 'textarea') {
                controlEl = document.createElement('textarea');
                if (config.id) controlEl.id = config.id;
                if (config.name) controlEl.name = config.name;
                if (config.placeholder) controlEl.placeholder = config.placeholder;
                if (config.value !== undefined) controlEl.value = config.value;
                if (config.disabled) controlEl.disabled = true;
                if (config.required) controlEl.required = true;
                // Apply RTL/LTR: default RTL unless data-ltr="true"
                if (isLTR) {
                    controlEl.setAttribute('data-ltr', 'true');
                    controlEl.setAttribute('dir', 'ltr');
                } else {
                    controlEl.setAttribute('dir', 'rtl');
                }
            } else if (config.type === 'select') {
                controlEl = document.createElement('select');
                if (config.id) controlEl.id = config.id;
                if (config.name) controlEl.name = config.name;
                if (config.disabled) controlEl.disabled = true;
                if (config.required) controlEl.required = true;
                // Add options
                if (config.options) {
                    config.options.forEach(opt => {
                        const option = document.createElement('option');
                        if (typeof opt === 'string') {
                            option.value = opt;
                            option.textContent = opt;
                        } else {
                            option.value = opt.value;
                            option.textContent = opt.text || opt.value;
                            if (opt.selected) option.selected = true;
                        }
                        controlEl.appendChild(option);
                    });
                }
                if (config.value !== undefined) controlEl.value = config.value;
            } else {
                // Input (text, number, etc.)
                controlEl = document.createElement('input');
                controlEl.type = config.type || 'text';
                if (config.id) controlEl.id = config.id;
                if (config.name) controlEl.name = config.name;
                if (config.placeholder) controlEl.placeholder = config.placeholder;
                if (config.value !== undefined) controlEl.value = config.value;
                if (config.disabled) controlEl.disabled = true;
                if (config.required) controlEl.required = true;
                // Apply RTL/LTR: default RTL unless data-ltr="true"
                if (isLTR) {
                    controlEl.setAttribute('data-ltr', 'true');
                    controlEl.setAttribute('dir', 'ltr');
                } else {
                    controlEl.setAttribute('dir', 'rtl');
                }
            }
            
            // Apply dataset attributes
            if (config.dataset) {
                Object.keys(config.dataset).forEach(key => {
                    controlEl.setAttribute(`data-${key}`, config.dataset[key]);
                });
            }
            
            // Apply additional attributes
            if (config.attrs) {
                Object.keys(config.attrs).forEach(key => {
                    controlEl.setAttribute(key, config.attrs[key]);
                });
            }
            
            // Apply additional classes to control
            if (config.controlClasses) {
                const classes = Array.isArray(config.controlClasses) ? config.controlClasses : [config.controlClasses];
                classes.forEach(cls => controlEl.classList.add(cls));
            }
            
            // Attach event handlers
            if (config.onInput) {
                controlEl.addEventListener('input', config.onInput);
            }
            if (config.onChange) {
                controlEl.addEventListener('change', config.onChange);
            }
            if (config.onKeydown) {
                controlEl.addEventListener('keydown', config.onKeydown);
            }
            
            formGroup.appendChild(controlEl);
            
            // Return API
            return {
                rootEl: formGroup,
                controlEl: controlEl,
                getValue: () => controlEl.value,
                setValue: (val) => { controlEl.value = val; },
                setError: (msg) => {
                    if (msg === false || !msg) {
                        controlEl.classList.remove('validation-error');
                        formGroup.classList.remove('invalid');
                    } else {
                        controlEl.classList.add('validation-error');
                        formGroup.classList.add('invalid');
                    }
                }
            };
        }
        
        // ========================================
        // User-Friendly Error Messages
        // ========================================
        const ErrorMessages = {
            // Location formatters
            contentSection: (index) => ` Content Section ${index + 1}`,
            question: (index, isMCQ) => ` Question ${index + 1}${isMCQ ? ' (MCQ)' : ''}`,
            
            // Missing images
            missingImageContent: (sIndex, imgNum) => 
                `${ErrorMessages.contentSection(sIndex)} - Problem: You used image #${imgNum} in your text, but you haven't added any image boxes for this section yet.\n    Fix: Click "+ Add Image" and draw the box for this image on the PDF.`,
            
            missingImageQuestion: (qIndex, imgNum) => 
                `${ErrorMessages.question(qIndex, false)} - Problem: You used image #${imgNum} in your question, but you haven't added any image boxes in "Question Images" yet.\n    Fix: Scroll to "Question Images" section and add the image box.`,
            
            missingImageAnswer: (qIndex, imgNum) => 
                `${ErrorMessages.question(qIndex, false)} - Problem: You used image #${imgNum} in your answer, but you haven't added any image boxes in "Answer Images" yet.\n    Fix: Scroll to "Answer Images" section and add the image box.`,
            
            missingImageChoice: (qIndex, imgNum) => 
                `${ErrorMessages.question(qIndex, true)} - Problem: You used image #${imgNum} in choice text, but you haven't added any image boxes in "Question Images" yet.\n    Fix: Scroll to "Question Images" section and add the image box.`,
            
            missingTableImageContent: (sIndex, imgNum) => 
                `${ErrorMessages.contentSection(sIndex)} - Problem: Your table uses image #${imgNum}, but you haven't added any image boxes for this section yet.\n    Fix: Click "+ Add Image" and draw the box for this image on the PDF.`,
            
            missingTableImageQuestion: (qIndex, imgNum) => 
                `${ErrorMessages.question(qIndex, false)} - Problem: Your table uses image #${imgNum}, but you haven't added any image boxes in "Question Images" yet.\n    Fix: Scroll to "Question Images" section and add the image box.`,
            
            missingTableImageAnswer: (qIndex, imgNum) => 
                `${ErrorMessages.question(qIndex, false)} - Problem: Your answer table uses image #${imgNum}, but you haven't added any image boxes in "Answer Images" yet.\n    Fix: Scroll to "Answer Images" section and add the image box.`,
            
            // Unused images
            unusedImageContent: (sIndex, imgNum) => 
                `${ErrorMessages.contentSection(sIndex)} - Problem: You have an image box (#${imgNum}) that's not being used in your text.\n    Fix: Either delete this image box or add ![image description](${imgNum}) in your text where you want the image to appear.`,
            
            unusedImageQuestion: (qIndex, imgNum, isMCQ) => 
                isMCQ
                    ? `${ErrorMessages.question(qIndex, true)} - Problem: You have an image box (#${imgNum}) in "Question Images" that's not being used in your question or choices.\n    Fix: Either delete this image box or add the image to your question or one of your choices.`
                    : `${ErrorMessages.question(qIndex, false)} - Problem: You have an image box (#${imgNum}) in "Question Images" that's not being used in your question text.\n    Fix: Either delete this image box or add the image to your question using the "Insert Image" button.`,
            
            unusedImageAnswer: (qIndex, imgNum) => 
                `${ErrorMessages.question(qIndex, false)} - Problem: You have an image box (#${imgNum}) in "Answer Images" that's not being used in your answer.\n    Fix: Either delete this image box or add the image to your answer using the "Insert Image" button.`,
            
            // Duplicate indices
            duplicateImagesContent: (sIndex, numbers) => 
                `${ErrorMessages.contentSection(sIndex)} - Problem: You used the same image numbers more than once: ${numbers.map(n => '#' + n).join(', ')}\n    Fix: Each image should have a unique number. Change duplicate images to use the next available numbers.`,
            
            duplicateImagesQuestion: (qIndex, numbers, isMCQ) => 
                isMCQ
                    ? `${ErrorMessages.question(qIndex, true)} - Problem: You used the same image numbers more than once in your question or choices: ${numbers.map(n => '#' + n).join(', ')}\n    Fix: Each image should have a unique number across your question and all choices. Use: 0, 1, 2, 3...`
                    : `${ErrorMessages.question(qIndex, false)} - Problem: You used the same image numbers more than once in your question: ${numbers.map(n => '#' + n).join(', ')}\n    Fix: Each image in your question should have a unique number (starting from 0). The images should go: 0, 1, 2, 3...`,
            
            duplicateImagesAnswer: (qIndex, numbers) => 
                `${ErrorMessages.question(qIndex, false)} - Problem: You used the same image numbers more than once in your answer: ${numbers.map(n => '#' + n).join(', ')}\n    Fix: Each image in your answer should have a unique number (starting from 0). Use: 0, 1, 2, 3...`,
            
            // Count mismatch
            countMismatchContent: (sIndex, textCount, boxCount) => 
                `${ErrorMessages.contentSection(sIndex)} - Problem: Your text uses ${textCount} image${textCount !== 1 ? 's' : ''}, but you have ${boxCount} image box${boxCount !== 1 ? 'es' : ''} drawn.\n    Fix: ${textCount > boxCount ? 'Add more image boxes to match your text.' : 'Either delete the extra image boxes or use all your images in the text.'}`,
            
            countMismatchQuestion: (qIndex, textCount, boxCount, isMCQ) => 
                isMCQ
                    ? `${ErrorMessages.question(qIndex, true)} - Problem: Your question and choices use ${textCount} image${textCount !== 1 ? 's' : ''} total, but you have ${boxCount} image box${boxCount !== 1 ? 'es' : ''} in "Question Images".\n    Fix: Make sure the number of image boxes matches the total number of images across your question and all choices (${textCount}).`
                    : `${ErrorMessages.question(qIndex, false)} - Problem: Your question uses ${textCount} image${textCount !== 1 ? 's' : ''}, but you have ${boxCount} image box${boxCount !== 1 ? 'es' : ''} in "Question Images".\n    Fix: Make sure the number of image boxes matches the number of images you used (${textCount}).`,
            
            countMismatchAnswer: (qIndex, textCount, boxCount) => 
                `${ErrorMessages.question(qIndex, false)} - Problem: Your answer uses ${textCount} image${textCount !== 1 ? 's' : ''}, but you have ${boxCount} image box${boxCount !== 1 ? 'es' : ''} in "Answer Images".\n    Fix: Make sure the number of image boxes matches the number of images you used in your answer (${textCount}).`,
            
            // Must start from 0
            mustStartFromZeroContent: (sIndex, startNum) => 
                `${ErrorMessages.contentSection(sIndex)} - Problem: Your images should start from number 0, but you started from #${startNum}.\n    Fix: Rename your first image to #0, second image to #1, and so on.`,
            
            mustStartFromZeroQuestion: (qIndex, startNum) => 
                `${ErrorMessages.question(qIndex, false)} - Problem: Your question images should start from number 0, but you started from #${startNum}.\n    Fix: Change your images to start from 0: use ![description](0) for the first image.`,
            
            mustStartFromZeroAnswer: (qIndex, startNum) => 
                `${ErrorMessages.question(qIndex, false)} - Problem: Your answer images should start from number 0, but you started from #${startNum}.\n    Fix: Change your images to start from 0: use ![description](0) for the first image in your answer.`,
            
            // Gaps in sequence
            gapInSequenceContent: (sIndex, before, after) => 
                `${ErrorMessages.contentSection(sIndex)} - Problem: Your image numbers skip from #${before} to #${after}. You're missing #${before + 1}.\n    Fix: Use image numbers in order without skipping: 0, 1, 2, 3, 4...`,
            
            gapInSequenceQuestion: (qIndex, before, after) => 
                `${ErrorMessages.question(qIndex, false)} - Problem: Your question image numbers skip from #${before} to #${after}. You're missing #${before + 1}.\n    Fix: Use image numbers in order without skipping: 0, 1, 2, 3, 4...`,
            
            gapInSequenceAnswer: (qIndex, before, after) => 
                `${ErrorMessages.question(qIndex, false)} - Problem: Your answer image numbers skip from #${before} to #${after}. You're missing #${before + 1}.\n    Fix: Use image numbers in order without skipping: 0, 1, 2, 3, 4...`,
            
            // Wrong order
            wrongOrderContent: (sIndex, foundOrder) => 
                `${ErrorMessages.contentSection(sIndex)} - Problem: Your images appear in wrong order. They should go 0, 1, 2, 3... but you have: ${foundOrder.join(', ')}\n    Fix: Rearrange your images in your text so they appear in order from top to bottom: 0, then 1, then 2, etc.`,
            
            wrongOrderQuestion: (qIndex, foundOrder, isMCQ) => 
                isMCQ
                    ? `${ErrorMessages.question(qIndex, true)} - Problem: Your images appear in wrong order across question and choices. They should go 0, 1, 2, 3... but you have: ${foundOrder.join(', ')}\n    Fix: Images should appear in order: first in setup text, then question text, then choice A, then choice B, etc.`
                    : `${ErrorMessages.question(qIndex, false)} - Problem: Your images appear in wrong order. They should go 0, 1, 2, 3... but you have: ${foundOrder.join(', ')}\n    Fix: Images should appear in order as you read the question from top to bottom.`,
            
            wrongOrderAnswer: (qIndex, foundOrder) => 
                `${ErrorMessages.question(qIndex, false)} - Problem: Your answer images appear in wrong order. They should go 0, 1, 2, 3... but you have: ${foundOrder.join(', ')}\n    Fix: Rearrange the images in your answer so they appear in order from top to bottom.`,
            
            // Out of range
            outOfRangeContent: (sIndex, imgNum, maxNum) => 
                `${ErrorMessages.contentSection(sIndex)} - Problem: Your table tries to use image #${imgNum}, but you only have images #0 to #${maxNum} (${maxNum + 1} image${maxNum !== 0 ? 's' : ''} total).\n    Fix: Either add more image boxes or change the table to use an existing image number (0 to ${maxNum}).`,
            
            outOfRangeQuestion: (qIndex, imgNum, maxNum, isChoice) => 
                isChoice
                    ? `${ErrorMessages.question(qIndex, true)} - Problem: Your choice text tries to use image #${imgNum}, but you only have images #0 to #${maxNum} in "Question Images".\n    Fix: Either add more image boxes or change the choice to use an existing image number (0 to ${maxNum}).`
                    : `${ErrorMessages.question(qIndex, false)} - Problem: Your table tries to use image #${imgNum}, but you only have images #0 to #${maxNum} in "Question Images".\n    Fix: Either add more image boxes or change the table to use an existing image number (0 to ${maxNum}).`,
            
            outOfRangeAnswer: (qIndex, imgNum, maxNum) => 
                `${ErrorMessages.question(qIndex, false)} - Problem: Your answer table tries to use image #${imgNum}, but you only have images #0 to #${maxNum} in "Answer Images".\n    Fix: Either add more image boxes or change the table to use an existing image number (0 to ${maxNum}).`,
            
            // Required fields
            requiredContent: (sIndex) => 
                `${ErrorMessages.contentSection(sIndex)} - Problem: This section is empty.\n    Fix: Add some content text for this section or delete it if you don't need it.`,
            
            requiredQuestionID: (qIndex) => 
                `${ErrorMessages.question(qIndex, false)} - Problem: Question ID is missing.\n    Fix: Enter a question number or ID (for example: 1, 2, 3...).`,
            
            requiredQuestionText: (qIndex) => 
                `${ErrorMessages.question(qIndex, false)} - Problem: Question text is missing.\n    Fix: Type the question text in the "Question Text" field.`,
            
            requiredAnswer: (qIndex) => 
                `${ErrorMessages.question(qIndex, false)} - Problem: Answer is missing.\n    Fix: Type the answer in the "Guide Answer" field.`,
            
            requiredGuidePage: (qIndex) => 
                `${ErrorMessages.question(qIndex, false)} - Problem: Guide PDF page number is missing.\n    Fix: Enter the page number from the teacher guide where this answer appears (for example: 78).`,
            
            invalidGuidePage: (qIndex) => 
                `${ErrorMessages.question(qIndex, false)} - Problem: Guide PDF page must be a whole number (like 1, 2, 3... not 1.5 or text).\n    Fix: Enter a valid page number like 78.`,
            
            guidePageOutOfRange: (qIndex, guidePage, startPage, endPage) => 
                `${ErrorMessages.question(qIndex, false)} - Problem: Guide PDF page (${guidePage}) is outside the guidebook range (${startPage}-${endPage}).\n    Fix: Enter a page number between ${startPage} and ${endPage} (inclusive).`,
            
            requiredChoices: (qIndex) => 
                `${ErrorMessages.question(qIndex, true)} - Problem: You haven't added any answer choices yet.\n    Fix: Click "+ Add Choice" to add answer options (A, B, C, D...).`,
            
            requiredCheckboxChoices: (qIndex) => 
                ` Question ${qIndex + 1} (Checkbox) - Problem: You haven't added any answer choices yet.\n    Fix: Click "+ Add Choice" to add checkbox options.`,
            
            requiredCorrectAnswer: (qIndex) => 
                `${ErrorMessages.question(qIndex, true)} - Problem: You haven't selected which choice is the correct answer.\n    Fix: Click one of the radio buttons to select the correct answer position.`,
            
            requiredCheckedChoice: (qIndex) => 
                ` Question ${qIndex + 1} (Checkbox) - Problem: At least one choice must be marked as correct.\n    Fix: Check at least one " Correct Answer" checkbox to indicate which choice(s) are correct.`,

            inconsistentChoiceIDs: (qIndex, questionType) =>
                `${ErrorMessages.question(qIndex, questionType === 'checkbox')} - Problem: Choice IDs are inconsistent. Either all choices should have IDs or none should.\n    Fix: Fill in all choice IDs (A, B, C...) or leave them all empty.`,

            // Fill in the blanks errors
            noBlanksFound: (qIndex) =>
                ` Question ${qIndex + 1} (Fill in the Blanks) - Problem: No blanks found in question text.\n    Fix: Add blanks using the format ___1___, ___2___, ___3___, etc. (exactly 3 underscores on each side).`,

            invalidBlankFormat: (qIndex, details) =>
                ` Question ${qIndex + 1} (Fill in the Blanks) - Problem: Invalid blank format detected.\n   ${details}\n    Fix: Use exactly ___1___, ___2___, etc. (3 underscores, number, 3 underscores, no spaces or dashes).`,

            blankAnswerMismatch: (qIndex, blanksCount, answersCount) =>
                ` Question ${qIndex + 1} (Fill in the Blanks) - Problem: Number of blanks (${blanksCount}) doesn't match number of answers (${answersCount}).\n    Fix: Provide an answer for each blank in your question text.`,

            missingBlankAnswers: (qIndex, missingBlanks) =>
                ` Question ${qIndex + 1} (Fill in the Blanks) - Problem: Missing answers for blanks: ${missingBlanks.join(', ')}.\n    Fix: Fill in the answer for each blank.`,

            // Matching errors
            matchingNoLeftItems: (qIndex) =>
                ` Question ${qIndex + 1} (Matching) - Problem: No left items added.\n    Fix: Click "+ Add Left Item" to add items to the left column.`,

            matchingNoRightItems: (qIndex) =>
                ` Question ${qIndex + 1} (Matching) - Problem: No right items added.\n    Fix: Click "+ Add Right Item" to add items to the right column.`,

            matchingEmptyLeftItem: (qIndex, itemNum) =>
                ` Question ${qIndex + 1} (Matching) - Problem: Left item L${itemNum} is empty.\n    Fix: Enter text for this left item or remove it.`,

            matchingEmptyRightItem: (qIndex, itemNum) =>
                ` Question ${qIndex + 1} (Matching) - Problem: Right item R${itemNum} is empty.\n    Fix: Enter text for this right item or remove it.`,

            matchingInvalidRelationship: (qIndex, leftIdx, rightIdx, leftCount, rightCount) =>
                ` Question ${qIndex + 1} (Matching) - Problem: Invalid relationship [${leftIdx}, ${rightIdx}]. Left index out of range (1-${leftCount}) or right index out of range (1-${rightCount}).\n    Fix: Make sure all relationships reference valid item positions.`,

            matchingIncompleteRelationship: (qIndex, relNum) =>
                ` Question ${qIndex + 1} (Matching) - Problem: Relationship #${relNum} is incomplete (missing left or right selection).\n    Fix: Select both left and right items for this relationship or remove it.`,
            
            // Annotate errors
            annotateNoImageOrTable: (qIndex) =>
                ` Question ${qIndex + 1} (Annotate) - Problem: Guide answer must contain either an image or a table.\n    Fix: Click "Insert Image" or "Insert Table" in the guide answer field to add content that students will annotate.`,
            
            // Create table errors
            createTableNoTable: (qIndex) =>
                ` Question ${qIndex + 1} (Create Table) - Problem: Guide answer must contain a table.\n    Fix: Click "Insert Table" in the guide answer field to add the table structure students should create.`,
            
            // Warnings
            warningSectionTitle: (sIndex) => 
                ` Content Section ${sIndex + 1} - Suggestion: You might want to add a section title to make it easier to organize your content.\n    Tip: A good title helps identify what this section is about.`,
            
            // Bbox validation
            invalidBboxPage: (location, imgNum) => 
                `${location}, Image #${imgNum} - Problem: Page number must be a whole number between 1 and 9999.\n    Fix: Enter a valid page number (like 23, not 23.5 or text).`,
            
            invalidBboxX0: (location, imgNum) => 
                `${location}, Image #${imgNum} - Problem: Left position (x0) must be a whole number.\n    Fix: Make sure this field contains only numbers.`,
            
            invalidBboxY0: (location, imgNum) => 
                `${location}, Image #${imgNum} - Problem: Top position (y0) must be a whole number.\n    Fix: Make sure this field contains only numbers.`,
            
            invalidBboxX1: (location, imgNum) => 
                `${location}, Image #${imgNum} - Problem: Right position (x1) must be a whole number.\n    Fix: Make sure this field contains only numbers.`,
            
            invalidBboxY1: (location, imgNum) => 
                `${location}, Image #${imgNum} - Problem: Bottom position (y1) must be a whole number.\n    Fix: Make sure this field contains only numbers.`,
            
            invalidBboxX0X1: (location, imgNum) => 
                `${location}, Image #${imgNum} - Problem: The left edge must be to the left of the right edge.\n    Fix: Check your box coordinates - left (x0) should be smaller than right (x1).`,
            
            invalidBboxY0Y1: (location, imgNum) => 
                `${location}, Image #${imgNum} - Problem: The top edge must be above the bottom edge.\n    Fix: Check your box coordinates - top (y0) should be smaller than bottom (y1).`
        };

        // ============================================================================
        // AutoSizeManager: Single canonical autosize system
        // Handles all textarea and preview sizing with layout-change awareness
        // ============================================================================
        const AutoSizeManager = (function() {
            const FUDGE_PX = 8; // Single source of truth for sizing padding
            const registeredTargets = new WeakSet();
            const fittedOnce = new WeakSet();    // Tracks elements that have ever been successfully fitted
            const pendingFit = new Set();        // Elements waiting for first measurable fit (small, iterable set)
            
            // Resolve the autosize root container for an element
            function resolveRootFor(el) {
                if (!el || !el.isConnected) return null;
                const inner = el.closest('.tab-content');
                if (inner) return inner;
                const main = el.closest('.main-tab-content');
                if (main) return main;
                return document.body;
            }
            
            // Check if element is measurable (visible in layout)
            function isMeasurable(el) {
                if (!el || !el.isConnected) return false;
                const rects = el.getClientRects();
                return !!el.offsetParent || (rects && rects.length > 0);
            }
            
            // Single sizing primitive - used for BOTH textareas and previews
            function fitHeightToContent(el) {
                if (!el || !isMeasurable(el)) return false;
                el.style.height = 'auto';
                const scrollH = el.scrollHeight || 0;
                el.style.height = (scrollH + FUDGE_PX) + 'px';
                return true;
            }
            
            // Find coupled .live-preview for a textarea (same form-group / text-field-container)
            function findCoupledPreview(textarea) {
                if (!textarea || textarea.tagName !== 'TEXTAREA') return null;
                const container = textarea.closest('.form-group') || textarea.closest('.text-field-container');
                if (!container) return null;
                const pv = container.querySelector('.live-preview');
                return pv && pv.isConnected ? pv : null;
            }
            
            function markFitted(el) {
                if (!el) return;
                fittedOnce.add(el);
                pendingFit.delete(el);
            }
            
            // Force one element to be fitted with current content (used after spawn/replace when values are set).
            // If measurable: fit and mark fitted. If not: add to pendingFit. Does not skip if already fittedOnce.
            function forceFitNow(el) {
                if (!el || !el.isConnected) return;
                registeredTargets.add(el);
                if (isMeasurable(el)) {
                    if (fitHeightToContent(el)) markFitted(el);
                } else {
                    pendingFit.add(el);
                }
            }
            
            // Canonical spawn finalization: call after DOM is built, values set, and previews attached.
            // Registers subtree then force-fits all textareas and previews with current content (ignores fittedOnce).
            function finalizeSpawn(rootSubtree) {
                if (!autoResizeEnabled || !rootSubtree || !rootSubtree.querySelectorAll) return;
                register(rootSubtree);
                const textareas = rootSubtree.querySelectorAll('textarea:not(#json_input)');
                const previews = rootSubtree.querySelectorAll('.live-preview');
                const seen = new Set();
                textareas.forEach(ta => {
                    if (!ta.isConnected || seen.has(ta)) return;
                    seen.add(ta);
                    forceFitNow(ta);
                    const coupled = findCoupledPreview(ta);
                    if (coupled && !seen.has(coupled)) {
                        seen.add(coupled);
                        forceFitNow(coupled);
                    }
                });
                previews.forEach(pv => {
                    if (!pv.isConnected || seen.has(pv)) return;
                    seen.add(pv);
                    forceFitNow(pv);
                });
            }
            
            // Register a subtree: scan only that subtree, add eligible elements to set,
            // and ensure every target is fitted at least once when measurable.
            function register(rootSubtree) {
                if (!autoResizeEnabled || !rootSubtree || !rootSubtree.querySelectorAll) return;
                const textareas = rootSubtree.querySelectorAll('textarea:not(#json_input)');
                const previews = rootSubtree.querySelectorAll('.live-preview');
                const seen = new Set();
                
                textareas.forEach(ta => {
                    if (!ta.isConnected || seen.has(ta)) return;
                    seen.add(ta);
                    registeredTargets.add(ta); // idempotent
                    
                    if (fittedOnce.has(ta)) {
                        // Already had a correct first fit at some point
                        return;
                    }
                    
                    if (isMeasurable(ta)) {
                        if (fitHeightToContent(ta)) {
                            markFitted(ta);
                        }
                    } else {
                        // Defer first fit until it becomes measurable
                        pendingFit.add(ta);
                    }
                });
                
                previews.forEach(pv => {
                    if (!pv.isConnected || seen.has(pv)) return;
                    seen.add(pv);
                    registeredTargets.add(pv); // idempotent
                    
                    if (fittedOnce.has(pv)) {
                        return;
                    }
                    
                    if (isMeasurable(pv)) {
                        if (fitHeightToContent(pv)) {
                            markFitted(pv);
                        }
                    } else {
                        pendingFit.add(pv);
                    }
                });
            }
            
            // Mark one element dirty and fit it immediately (and coupled preview if textarea). No root scan.
            function markDirty(el) {
                if (!autoResizeEnabled || !el) return;
                
                if (el.tagName === 'TEXTAREA' && el.id !== 'json_input') {
                    if (isMeasurable(el) && fitHeightToContent(el)) {
                        markFitted(el);
                    }
                    const coupled = findCoupledPreview(el);
                    if (coupled && isMeasurable(coupled) && fitHeightToContent(coupled)) {
                        markFitted(coupled);
                    }
                    return;
                }
                
                if (el.classList && el.classList.contains('live-preview') && isMeasurable(el)) {
                    if (fitHeightToContent(el)) {
                        markFitted(el);
                    }
                }
            }
            
            // Re-fit only already-registered targets within root (for style changes). No new scan for "all" targets.
            function refreshStyleChange(rootEl) {
                if (!autoResizeEnabled || !rootEl) return;
                const textareas = rootEl.querySelectorAll('textarea:not(#json_input)');
                const previews = rootEl.querySelectorAll('.live-preview');
                
                textareas.forEach(ta => {
                    if (registeredTargets.has(ta) && isMeasurable(ta) && fitHeightToContent(ta)) {
                        markFitted(ta);
                    }
                });
                previews.forEach(pv => {
                    if (registeredTargets.has(pv) && isMeasurable(pv) && fitHeightToContent(pv)) {
                        markFitted(pv);
                    }
                });
            }
            
            // Fit only elements that are pending their first measurable fit within a specific root.
            // This is used when a panel becomes visible (e.g., on tab activation).
            function fitPending(rootSubtree) {
                if (!autoResizeEnabled || !rootSubtree || pendingFit.size === 0) return;
                
                // Iterate ONLY the small pending set, never scan entire DOM.
                pendingFit.forEach(el => {
                    if (!el || !el.isConnected) {
                        pendingFit.delete(el);
                        return;
                    }
                    if (!rootSubtree.contains(el)) return;
                    
                    if (isMeasurable(el) && fitHeightToContent(el)) {
                        markFitted(el);
                    }
                });
            }
            
            // No-op for tab switch: do not scan or fit. Tab switching must not trigger full autosize.
            function refresh(rootEl) {
                // Intentionally empty: callers use register() for new subtrees and refreshStyleChange() for style changes only
            }
            
            // Expose FUDGE_PX for backward compatibility with any external code
            return {
                refresh: refresh,
                register: register,
                finalizeSpawn: finalizeSpawn,
                markDirty: markDirty,
                refreshStyleChange: refreshStyleChange,
                fitPending: fitPending,
                FUDGE_PX: FUDGE_PX,
                fitHeightToContent: fitHeightToContent
            };
        })();

        // ========== SCROLL PERSISTENCE SYSTEM ==========
        // Single source of truth for all scroll positions
        const scrollState = {
            main: { input: 0, preview: 0 },
            sub: { basic: 0, preamble: 0, content: 0, questions: 0 }
        };
        
        // Hydration flag: true ONLY during loadJSON() and initial restore flow
        let isDocumentHydrating = false;
        
        // Get Input Form scroll container (for quick jump - uses universal scroller)
        function getInputFormScrollContainer() {
            // Use the universal scroller for Input Form
            return getInputFormScroller();
        }
        
        // Get Final Preview scroll container
        function getFinalPreviewScrollContainer() {
            return document.getElementById('final-preview-content');
        }
        
        // ========================================
        // UNIVERSAL SCROLL HELPERS FOR QUICK JUMP
        // ========================================
        // Single source of truth for scrolling to sections with proper sticky header offsets
        
        /**
         * Get the scroll container for the current context (Input Form or Final Preview)
         * @returns {HTMLElement|null} The scroll container element, or null if not found
         */
        function getScrollContainerForContext() {
            // Check if we're in Final Preview
            const finalPreview = document.getElementById('final-preview');
            if (finalPreview && finalPreview.classList.contains('active')) {
                return getFinalPreviewScrollContainer();
            }
            
            // Otherwise, we're in Input Form
            return getInputFormScrollContainer();
        }
        
        /**
         * Calculate the total sticky offset (header + tab bars) for the current context
         * @returns {number} Total offset in pixels
         */
        function getStickyOffsetForContext() {
            // For Final Preview: main tabs are outside the scroll container, so offset is 0
            const finalPreview = document.getElementById('final-preview');
            if (finalPreview && finalPreview.classList.contains('active')) {
                return 0; // Main tabs are outside .final-preview-container
            }
            
            // For Input Form: calculate main tabs + sub tabs height
            let offset = 0;
            
            // Get main tabs height (stored in CSS variable)
            // Get sticky stack height for scroll offset calculation
            const stickyStackHeight = parseFloat(getComputedStyle(document.documentElement)
                .getPropertyValue('--sticky-stack-height')) || 0;
            if (stickyStackHeight > 0) {
                offset += stickyStackHeight;
            } else {
                // Fallback: measure stack directly if variable not set
                const stickyStack = document.querySelector('.sticky-tabs-stack');
                if (stickyStack) {
                    const stackRect = stickyStack.getBoundingClientRect();
                    offset += stackRect.height;
                }
            }
            
            // Add a small padding for visual spacing
            offset += 4;
            
            return offset;
        }
        
        /**
         * Scroll an element to the top of its scroll container, accounting for sticky headers
         * @param {HTMLElement} element - The element to scroll to
         * @param {HTMLElement|null} container - The scroll container (if null, will be auto-detected)
         * @param {number|null} offset - The sticky offset (if null, will be auto-calculated)
         * @returns {boolean} True if scroll was successful, false if element/container not found
         */
        function scrollElementToTop(element, container = null, offset = null) {
            if (!element) {
                return false; // Guard: element not found, do nothing
            }
            
            // Auto-detect container if not provided
            if (!container) {
                container = getScrollContainerForContext();
            }
            
            if (!container) {
                return false; // Guard: container not found, do nothing
            }
            
            // Auto-calculate offset if not provided
            if (offset === null) {
                offset = getStickyOffsetForContext();
            }
            
            // Get element position relative to container
            const containerRect = container.getBoundingClientRect();
            const elementRect = element.getBoundingClientRect();
            
            // Calculate the scroll position needed to place element at top (accounting for offset)
            const elementTopRelativeToContainer = elementRect.top - containerRect.top + container.scrollTop;
            const targetScrollTop = elementTopRelativeToContainer - offset;
            
            // Ensure scroll position is valid
            const maxScroll = Math.max(0, container.scrollHeight - container.clientHeight);
            const finalScrollTop = Math.max(0, Math.min(targetScrollTop, maxScroll));
            
            // Perform smooth scroll
            container.scrollTo({
                top: finalScrollTop,
                behavior: 'smooth'
            });
            
            return true;
        }
        
        // Get active main tab key ('input' or 'preview')
        function getActiveMainTabKey() {
            const activeMainTab = document.querySelector('.main-tab-content.active');
            if (!activeMainTab) return null;
            return activeMainTab.id === 'input-form' ? 'input' : 'preview';
        }
        
        // Get active sub tab key ('basic', 'preamble', 'content', or 'questions')
        // Uses the sub-tab BUTTONS to avoid confusion with nested tab-content elements
        function getActiveSubTabKey() {
            const subTabsContainer = document.getElementById('sub-tabs-container');
            if (!subTabsContainer) return null;
            
            // Find the active button in the sub-tabs container
            const activeButton = subTabsContainer.querySelector('.tab.active');
            if (!activeButton) return null;
            
            // Parse the onclick attribute to get the tab name
            const onclick = activeButton.getAttribute('onclick');
            if (!onclick) return null;
            
            // Extract the tab name from onclick="showTab('tabname')"
            const match = onclick.match(/showTab\(['"]([^'"]+)['"]\)/);
            if (!match) return null;
            
            const tabName = match[1];
            
            // Only return if it's one of the four main sub-tabs
            if (tabName === 'basic' || tabName === 'preamble' || 
                tabName === 'content' || tabName === 'questions') {
                return tabName;
            }
            
            return null;
        }
        
        // Save current scroll positions BEFORE switching tabs
        function saveActiveScrollPositions() {
            const mainKey = getActiveMainTabKey();
            if (!mainKey) return;
            
            if (mainKey === 'input') {
                // Save sub-tab scroll position using the universal scroller
                saveSubTabScrollPosition();
                // Also save the universal scroller position for main tab switching
                const scroller = getInputFormScroller();
                if (scroller) {
                    scrollState.main.input = scroller.scrollTop;
                }
            } else if (mainKey === 'preview') {
                const previewScroller = getFinalPreviewScrollContainer();
                if (previewScroller) {
                    scrollState.main.preview = previewScroller.scrollTop;
                }
            }
        }
        
        // Restore scroll positions AFTER switching tabs (uses NEW active tab/sub-tab)
        function restoreActiveScrollPositions() {
            requestAnimationFrame(() => {
                const mainKey = getActiveMainTabKey();
                if (!mainKey) return;
                
                if (mainKey === 'input') {
                    // Restore sub-tab scroll position using the universal scroller
                    const subKey = getActiveSubTabKey();
                    if (subKey) {
                        restoreSubTabScrollPosition(subKey);
                    }
                    // Also restore the universal scroller position (for main tab switching)
                    const scroller = getInputFormScroller();
                    if (scroller) {
                        const maxScroll = Math.max(0, scroller.scrollHeight - scroller.clientHeight);
                        scroller.scrollTop = Math.min(Math.max(0, scrollState.main.input), maxScroll);
                    }
                } else if (mainKey === 'preview') {
                    const previewScroller = getFinalPreviewScrollContainer();
                    if (previewScroller) {
                        const maxScroll = Math.max(0, previewScroller.scrollHeight - previewScroller.clientHeight);
                        previewScroller.scrollTop = Math.min(Math.max(0, scrollState.main.preview), maxScroll);
                    }
                }
            });
        }
        
        // Reset all scroll state and force scrollers to top (ONLY called during hydration)
        function resetScrollOnHydration() {
            // Clear ALL scroll memories
            scrollState.main.input = 0;
            scrollState.main.preview = 0;
            scrollState.sub.basic = 0;
            scrollState.sub.preamble = 0;
            scrollState.sub.content = 0;
            scrollState.sub.questions = 0;
            
            // Force actual scrollers to top immediately (even if currently visible)
            const inputScroller = getInputFormScroller();
            const previewScroller = getFinalPreviewScrollContainer();
            
            if (inputScroller) inputScroller.scrollTop = 0;
            if (previewScroller) previewScroller.scrollTop = 0;
            
            // Also reset window scroll as safety
            window.scrollTo(0, 0);
        }
        
        // Get the universal Input Form scroll container (single source of truth)
        function getInputFormScroller() {
            const scroller = document.querySelector('.input-form-scroll');
            if (!scroller) {
                console.error('Input Form scroller (.input-form-scroll) not found');
                return null;
            }
            return scroller;
        }
        
        // Save scroll position for the currently active sub-tab
        function saveSubTabScrollPosition() {
            const activeSubTabKey = getActiveSubTabKey();
            if (!activeSubTabKey) return;
            
            const scroller = getInputFormScroller();
            if (scroller) {
                scrollState.sub[activeSubTabKey] = scroller.scrollTop;
            }
        }
        
        // Restore scroll position for a specific sub-tab
        function restoreSubTabScrollPosition(tabName) {
            if (!tabName || !(tabName in scrollState.sub)) return;
            
            const scroller = getInputFormScroller();
            if (!scroller) return;
            
            // Use requestAnimationFrame to ensure DOM updates are complete
            requestAnimationFrame(() => {
                const savedScroll = scrollState.sub[tabName];
                if (savedScroll !== undefined) {
                    // Clamp scroll position to valid range
                    const maxScroll = Math.max(0, scroller.scrollHeight - scroller.clientHeight);
                    const clampedScroll = Math.min(Math.max(0, savedScroll), maxScroll);
                    scroller.scrollTop = clampedScroll;
                }
            });
        }
        
        function resolveActivePanelRoot() {
            const mainActive = document.querySelector('.main-tab-content.active');
            if (!mainActive) return document.body;
            if (mainActive.id === 'input-form') {
                const innerActive = mainActive.querySelector('.tab-content.active');
                return innerActive || mainActive;
            }
            return mainActive;
        }
        
        function refreshActivePanel(rootEl) {
            const root = rootEl || resolveActivePanelRoot();
            // Tab switch: only ensure previews are rendered. Do NOT run autosize (no full scan).
            if (typeof PreviewBox !== 'undefined' && PreviewBox.ensureRendered) {
                PreviewBox.ensureRendered(root);
            }
        }

        // Debounced autosize recalc after bbox canvas render; no-op if autosize toggle is OFF.
        function triggerAutoSizeRecalc() {
            if (typeof autoResizeEnabled === 'undefined' || !autoResizeEnabled) return;
            if (window.__autosizeRecalcScheduled) return;
            window.__autosizeRecalcScheduled = true;
            requestAnimationFrame(function () {
                requestAnimationFrame(function () {
                    window.__autosizeRecalcScheduled = false;
                    if (typeof autoResizeEnabled !== 'undefined' && !autoResizeEnabled) return;
                    if (typeof AutoSizeManager !== 'undefined' && AutoSizeManager.finalizeSpawn) {
                        var activeRoot = resolveActivePanelRoot();
                        if (activeRoot) AutoSizeManager.finalizeSpawn(activeRoot);
                        var fpContent = document.getElementById('final-preview-content');
                        if (fpContent) AutoSizeManager.finalizeSpawn(fpContent);
                    }
                });
            });
        }

        function showTab(tabName) {
            // Get the universal scroller (single source of truth)
            const scroller = getInputFormScroller();
            if (!scroller) return;
            
            // Save scroll position of currently active sub-tab (skip during hydration)
            if (!isDocumentHydrating) {
                saveSubTabScrollPosition();
            }
            
            // Switch sub tab UI - scoped to Input Form only
            const inputFormTab = document.getElementById('input-form');
            if (!inputFormTab) return;
            
            // Hide all tab contents inside .input-form-scroll (avoid nested .tab-content inside questions)
            const scrollContainer = inputFormTab.querySelector('.input-form-scroll');
            if (scrollContainer) {
                const tabContents = scrollContainer.querySelectorAll('.tab-content');
                tabContents.forEach(content => {
                    // Only toggle direct children of .input-form-scroll (avoid nested tabs)
                    if (content.parentElement === scrollContainer) {
                        content.classList.remove('active');
                    }
                });
            }
            
            // Remove active class from all sub-tab buttons within #sub-tabs-container
            const subTabsContainer = document.getElementById('sub-tabs-container');
            if (subTabsContainer) {
                const subTabButtons = subTabsContainer.querySelectorAll('.tab');
                subTabButtons.forEach(tab => tab.classList.remove('active'));
            }
            
            // Show selected tab content (must be inside .input-form-scroll)
            const targetTabContent = document.getElementById(tabName);
            if (targetTabContent && scrollContainer && targetTabContent.parentElement === scrollContainer) {
                targetTabContent.classList.add('active');
                refreshActivePanel(targetTabContent);
                // Cheap first-fit for any pending autosize targets in this newly activated panel
                if (typeof AutoSizeManager !== 'undefined' && AutoSizeManager.fitPending) {
                    AutoSizeManager.fitPending(targetTabContent);
                }
            }
            
            // Add active class to corresponding sub-tab button
            if (subTabsContainer) {
                const subTabButtons = subTabsContainer.querySelectorAll('.tab');
                subTabButtons.forEach(tab => {
                    if (tab.getAttribute('onclick')?.includes(`'${tabName}'`) || 
                        tab.getAttribute('onclick')?.includes(`"${tabName}"`)) {
                        tab.classList.add('active');
                    }
                });
            }
            
            // Restore scroll position for the newly active sub-tab (skip during hydration)
            // Only restore scrollTop on the universal scroller - no scrollIntoView, no focus
            if (!isDocumentHydrating) {
                restoreSubTabScrollPosition(tabName);
            }
        }

        function showMainTab(tabName) {
            // Save current scroll position (skip during hydration)
            if (!isDocumentHydrating) {
                saveActiveScrollPositions();
            }
            
            // Switch main tab UI
            const mainTabContents = document.querySelectorAll('.main-tab-content');
            mainTabContents.forEach(content => content.classList.remove('active'));
            
            const mainTabs = document.querySelectorAll('.main-tabs .tab');
            mainTabs.forEach(tab => tab.classList.remove('active'));
            
            // Show selected main tab content
            const targetMainTabContent = document.getElementById(tabName);
            if (targetMainTabContent) {
                targetMainTabContent.classList.add('active');
                
                // If showing final preview, generate it
                if (tabName === 'final-preview') {
                    generateFinalPreview();
                }
                const activeRoot = resolveActivePanelRoot();
                refreshActivePanel(activeRoot);
                // When switching back to Input Form, cheaply first-fit any pending autosize targets in the active panel
                if (tabName === 'input-form' && typeof AutoSizeManager !== 'undefined' && AutoSizeManager.fitPending) {
                    AutoSizeManager.fitPending(activeRoot);
                }
            }
            
            // Add active class to corresponding main tab button
            mainTabs.forEach(tab => {
                if (tab.id === `main-tab-${tabName === 'input-form' ? 'input' : 'preview'}`) {
                    tab.classList.add('active');
                }
            });
            
            // Restore scroll position (skip during hydration)
            if (!isDocumentHydrating) {
                restoreActiveScrollPositions();
            }
        }

        // Navigate to input field from preview
        function navigateToInput(element) {
            if (!element) return;
            
            // Determine which inner tab to switch to based on the element's location
            let targetTab = 'basic'; // default
            
            // Check if element is in content sections
            if (element.closest('#content_sections_container')) {
                targetTab = 'content';
            }
            // Check if element is in questions
            else if (element.closest('#questions_container')) {
                targetTab = 'questions';
            }
            // Check if element is in preamble
            else if (element.closest('#preamble')) {
                targetTab = 'preamble';
            }
            
            // Find the closest array-item (section/question) and expand it if collapsed
            const arrayItem = element.closest('.array-item');
            if (arrayItem && arrayItem.classList.contains('collapsed')) {
                arrayItem.classList.remove('collapsed');
            }
            
            // Switch to input form main tab first
            showMainTab('input-form');
            
            // Wait a bit, then switch to the correct inner tab
            setTimeout(function() {
                showTab(targetTab);
                
                // Wait for tab switch, then scroll to element
                setTimeout(function() {
                    if (element && element.scrollIntoView) {
                        element.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        // Highlight the element briefly
                        const originalBg = element.style.backgroundColor;
                        element.style.backgroundColor = '#fff3cd';
                        element.style.transition = 'background-color 0.3s ease';
                        setTimeout(function() {
                            element.style.backgroundColor = originalBg;
                            setTimeout(function() {
                                element.style.transition = '';
                            }, 300);
                        }, 2000);
                        // Focus the input if it's an input or textarea
                        if (element.tagName === 'INPUT' || element.tagName === 'TEXTAREA') {
                            element.focus();
                        } else {
                            // Try to find and focus the input/textarea within
                            const input = element.querySelector('input, textarea');
                            if (input) input.focus();
                        }
                    }
                }, 100);
            }, 50);
        }

        // Final Preview bbox-check: page canvas cache (reuse across checks)
        function getFpBboxPageCache() {
            if (!window.__fpBboxPageCache) window.__fpBboxPageCache = new Map();
            return window.__fpBboxPageCache;
        }
        // Resolve bbox record by key from state-derived map (no tab DOM)
        function resolveBboxForFinalPreviewKey(key) {
            if (!key || !window.__fpBboxMap || !window.__fpBboxMap[key]) return null;
            return window.__fpBboxMap[key];
        }
        // Resolve bbox record from placeholder element (uses data-fp-key)
        function resolveBboxForFinalPreviewPlaceholder(el) {
            const key = el && el.getAttribute && el.getAttribute('data-fp-key');
            return resolveBboxForFinalPreviewKey(key);
        }
        // Build bbox map from form state (instructional_content[].images, practice_questions[].question_images / guide_answer_images)
        function buildFpBboxMapFromState(state) {
            const map = {};
            if (!state) return map;
            const toRecord = function (item) {
                if (!item || !item.position || !Array.isArray(item.position)) return null;
                const p0 = item.position[0], p1 = item.position[1];
                if (!p0 || !p1 || p0.length < 2 || p1.length < 2) return null;
                const pageNum = item.page != null ? parseInt(item.page, 10) : 0;
                return { pageNum: pageNum, x0: p0[0], y0: p0[1], x1: p1[0], y1: p1[1] };
            };
            const content = Array.isArray(state.instructional_content) ? state.instructional_content : [];
            content.forEach(function (sec, i) {
                const images = Array.isArray(sec.images) ? sec.images : [];
                images.forEach(function (img, j) {
                    const rec = toRecord(img);
                    if (rec) map['content-' + i + '-' + j] = rec;
                });
            });
            const questions = Array.isArray(state.practice_questions) ? state.practice_questions : [];
            questions.forEach(function (q, i) {
                const qImgs = Array.isArray(q.question_images) ? q.question_images : [];
                qImgs.forEach(function (img, j) {
                    const rec = toRecord(img);
                    if (rec) map['question-' + i + '-' + j] = rec;
                });
                const aImgs = Array.isArray(q.guide_answer_images) ? q.guide_answer_images : [];
                aImgs.forEach(function (img, j) {
                    const rec = toRecord(img);
                    if (rec) map['answer-' + i + '-' + j] = rec;
                });
            });
            return map;
        }
        // Infer bbox key prefix from textarea position (content / question / answer). Used when creating placeholders.
        function getBboxKeyPrefixForTextarea(textarea) {
            if (!textarea || !textarea.closest) return null;
            const contentSection = textarea.closest('#content_sections_container .array-item');
            if (contentSection) {
                const sections = document.querySelectorAll('#content_sections_container > .array-item');
                const idx = Array.prototype.indexOf.call(sections, contentSection);
                if (idx >= 0) return 'content-' + idx;
            }
            const questionEl = textarea.closest('#questions_container .array-item');
            if (questionEl) {
                const questions = document.querySelectorAll('#questions_container > .array-item');
                const qIdx = Array.prototype.indexOf.call(questions, questionEl);
                if (qIdx < 0) return null;
                const formGroup = textarea.closest('.form-group');
                let isAnswer = false;
                if (formGroup) {
                    const label = formGroup.querySelector('label');
                    if (label && /guide\s*answer|answer\s*images/i.test(label.textContent)) isAnswer = true;
                }
                return (isAnswer ? 'answer' : 'question') + '-' + qIdx;
            }
            return null;
        }
        // Produce crop canvas at native crop size (same crop logic: scale 1.5, padding 8, red rect). Does not append. Uses normalized record.
        async function getBboxCropCanvas(bboxRecord) {
            if (!bboxRecord) return null;
            var rec = normalizeBboxRecord(bboxRecord);
            if (!rec || !isValidBboxRecord(rec)) return null;
            try {
                var store = window.__bboxStore;
                if (!store || !store.docs || !store.docs.text) return null;
                var pdfDoc = store.docs.text.pdfDoc;
                if (!pdfDoc) return null;
                var pageNum = rec.pageNum;
                var x0 = rec.x0, y0 = rec.y0, x1 = rec.x1, y1 = rec.y1;
                var scale = 1.5;
                var padding = 8;
                var cache = getFpBboxPageCache();
                var cacheKey = 'text-' + pageNum + '-' + scale;
                var pageCanvas = cache.get(cacheKey);
                if (!pageCanvas) {
                    var page = null;
                    try {
                        page = await pdfDoc.getPage(pageNum);
                    } catch (err) {
                        if (pageNum > 0 && (err && (err.message || '').indexOf('Invalid') !== -1)) {
                            page = await pdfDoc.getPage(pageNum - 1);
                            pageNum = pageNum - 1;
                            cacheKey = 'text-' + pageNum + '-' + scale;
                        } else throw err;
                    }
                    var viewport = page.getViewport({ scale: scale });
                    var w = Math.floor(viewport.width);
                    var h = Math.floor(viewport.height);
                    var c = document.createElement('canvas');
                    c.width = w;
                    c.height = h;
                    var ctx = c.getContext('2d');
                    await page.render({ canvasContext: ctx, viewport: viewport }).promise;
                    pageCanvas = { canvas: c, scale: scale };
                    cache.set(cacheKey, pageCanvas);
                }
                var full = pageCanvas.canvas;
                var s = pageCanvas.scale;
                var left = Math.min(x0, x1) * s;
                var right = Math.max(x0, x1) * s;
                var top = Math.min(y0, y1) * s;
                var bottom = Math.max(y0, y1) * s;
                var bboxW = right - left;
                var bboxH = bottom - top;
                var cropL = Math.max(0, left - padding);
                var cropT = Math.max(0, top - padding);
                var cropR = Math.min(full.width, right + padding);
                var cropB = Math.min(full.height, bottom + padding);
                var cropW = cropR - cropL;
                var cropH = cropB - cropT;
                var out = document.createElement('canvas');
                out.width = cropW;
                out.height = cropH;
                var outCtx = out.getContext('2d');
                outCtx.drawImage(full, cropL, cropT, cropW, cropH, 0, 0, cropW, cropH);
                var rx = left - cropL;
                var ry = top - cropT;
                outCtx.strokeStyle = '#cc0000';
                outCtx.lineWidth = 2;
                outCtx.strokeRect(rx, ry, bboxW, bboxH);
                return out;
            } catch (err) {
                if (window.__DEBUG_BBOX_PREVIEW) console.debug('bbox-preview crop failed', err);
                return null;
            }
        }

        // Default inner box content when no bbox (dashed box + icon).
        var __fpDefaultInnerHtml = '<span style="color: #999; font-size: 14px;"> Image</span>';

        // ResizeObserver: one global, WeakMap innerBox -> { bboxRecord }. Debounced re-render on resize.
        var __fpBoxResizeMap = typeof WeakMap !== 'undefined' ? new WeakMap() : null;
        var __fpResizeObserver = null;
        function getFpResizeObserver() {
            if (__fpResizeObserver) return __fpResizeObserver;
            if (typeof ResizeObserver === 'undefined') return null;
            __fpResizeObserver = new ResizeObserver(function (entries) {
                for (var i = 0; i < entries.length; i++) {
                    var innerBox = entries[i].target;
                    var data = __fpBoxResizeMap && __fpBoxResizeMap.get(innerBox);
                    if (!data || !data.bboxRecord) continue;
                    if (innerBox.__fpResizeTimeout) clearTimeout(innerBox.__fpResizeTimeout);
                    innerBox.__fpResizeTimeout = setTimeout(function () {
                        innerBox.__fpResizeTimeout = null;
                        if (innerBox.querySelector('.fp-bbox-canvas')) renderBboxIntoBoxWhenSized(innerBox, data.bboxRecord);
                        if (__fpBoxResizeMap) __fpBoxResizeMap.delete(innerBox);
                    }, 100);
                }
            });
            return __fpResizeObserver;
        }

        // Render bbox crop into innerBox when it has size. Preserve crop aspect ratio; avoid scaling into fixed box.
        async function renderBboxIntoBoxWhenSized(innerBox, bboxRecord) {
            if (!innerBox || !bboxRecord) return;
            innerBox.__fpRenderToken = (innerBox.__fpRenderToken || 0) + 1;
            var token = innerBox.__fpRenderToken;
            var frame = 0;
            var maxFrames = 10;
            function waitSize() {
                if (innerBox.__fpRenderToken !== token) return;
                var rect = innerBox.getBoundingClientRect();
                if (rect.width > 0 && rect.height > 0) {
                    doRender();
                    return;
                }
                frame++;
                if (frame < maxFrames) requestAnimationFrame(waitSize);
            }
            function doRender() {
                if (innerBox.__fpRenderToken !== token) return;
                if (innerBox.__fpOriginalHtml == null) innerBox.__fpOriginalHtml = innerBox.innerHTML || __fpDefaultInnerHtml;
                innerBox.querySelectorAll('.fp-bbox-canvas').forEach(function (el) { el.remove(); });
                innerBox.innerHTML = '';
                getBboxCropCanvas(bboxRecord).then(function (cropCanvas) {
                    if (innerBox.__fpRenderToken !== token) return;
                    if (!cropCanvas || !innerBox.parentNode) {
                        innerBox.innerHTML = (innerBox.__fpOriginalHtml != null ? innerBox.__fpOriginalHtml : __fpDefaultInnerHtml);
                        innerBox.style.height = '150px';
                        innerBox.style.display = 'flex';
                        if (window.__DEBUG_BBOX_PREVIEW) console.debug('bbox-preview crop result', false);
                        return;
                    }
                    cropCanvas.className = 'fp-bbox-canvas';
                    // Preserve crop aspect ratio; avoid scaling into fixed box.
                    cropCanvas.style.width = '100%';
                    cropCanvas.style.height = 'auto';
                    cropCanvas.style.display = 'block';
                    cropCanvas.style.borderRadius = '4px';
                    innerBox.style.height = 'auto';
                    innerBox.style.display = 'block';
                    innerBox.appendChild(cropCanvas);
                    var ro = getFpResizeObserver();
                    if (ro && __fpBoxResizeMap) {
                        __fpBoxResizeMap.set(innerBox, { bboxRecord: bboxRecord });
                        ro.observe(innerBox);
                    }
                    triggerAutoSizeRecalc();
                    if (window.__DEBUG_BBOX_PREVIEW) console.debug('bbox-preview crop result', true);
                });
            }
            requestAnimationFrame(waitSize);
        }

        // Legacy: render into container (used as fallback). Preserve crop aspect ratio; avoid scaling into fixed box.
        async function renderBboxCheckPreview(bboxRecord, container) {
            if (!container) return;
            var crop = await getBboxCropCanvas(bboxRecord);
            if (!crop) return;
            container.innerHTML = '';
            crop.className = 'fp-bbox-canvas';
            crop.style.width = '100%';
            crop.style.height = 'auto';
            crop.style.display = 'block';
            crop.style.borderRadius = '4px';
            container.appendChild(crop);
        }

        // Visibility check: skip rendering into hidden elements to avoid truncation when tab becomes visible.
        function isElementVisible(el) {
            if (!el || !el.offsetParent) return false;
            var r = el.getBoundingClientRect();
            return r.width > 0 && r.height > 0;
        }

        // Shared: get the inner image rectangle element of a placeholder container (preserves caption as sibling).
        function getPlaceholderInnerBox(container) {
            if (!container || !container.classList.contains('image-placeholder-container')) return null;
            const first = container.firstElementChild;
            if (!first) return null;
            if (first.classList && first.classList.contains('image-description-math')) return null;
            return first;
        }
        function getFpPlaceholderInnerBox(container) { return getPlaceholderInnerBox(container); }

        // Shared: render bbox crop into inner box (size-aware, waits for layout). Same crop logic, scaled to box.
        function renderBboxCropIntoInnerBox(bboxRecord, innerBox) {
            return renderBboxIntoBoxWhenSized(innerBox, bboxRecord);
        }

        function normalizeBboxRecord(rec) {
            if (rec == null || typeof rec !== 'object') return null;
            var pageNum = parseInt(rec.pageNum, 10);
            var x0 = Number(rec.x0), y0 = Number(rec.y0), x1 = Number(rec.x1), y1 = Number(rec.y1);
            return { pageNum: pageNum, x0: x0, y0: y0, x1: x1, y1: y1 };
        }

        function isValidBboxRecord(rec) {
            if (!rec || typeof rec !== 'object') return false;
            var p = rec.pageNum;
            var x0 = rec.x0, y0 = rec.y0, x1 = rec.x1, y1 = rec.y1;
            if (!Number.isFinite(p) || p < 0) return false;
            if (!Number.isFinite(x0) || !Number.isFinite(y0) || !Number.isFinite(x1) || !Number.isFinite(y1)) return false;
            var minX = Math.min(x0, x1), maxX = Math.max(x0, x1);
            var minY = Math.min(y0, y1), maxY = Math.max(y0, y1);
            if (minX >= maxX || minY >= maxY) return false;
            return true;
        }

        // Recompute data-fp-key for placeholders under root so keys match current bbox order/indices.
        function retagPreviewPlaceholdersUnder(rootEl) {
            if (!rootEl) return;
            if (rootEl.id === 'final-preview-content') {
                rootEl.querySelectorAll('.preview-section[data-target-element="content"]').forEach(function (previewSection) {
                    var navigateTo = previewSection.getAttribute('data-navigate-to');
                    if (!navigateTo || navigateTo.indexOf('content-section-') !== 0) return;
                    var sectionIndex = parseInt(navigateTo.replace('content-section-', ''), 10);
                    var livePreview = previewSection.querySelector('.live-preview');
                    if (!livePreview) return;
                    livePreview.querySelectorAll('.image-placeholder-container').forEach(function (container, idx) {
                        var imageIndex = container.hasAttribute('data-image-index') ? container.getAttribute('data-image-index') : String(idx);
                        container.setAttribute('data-fp-key', 'content-' + sectionIndex + '-' + imageIndex);
                    });
                });
                rootEl.querySelectorAll('.final-preview-question').forEach(function (questionBlock, questionIndex) {
                    var questionImgIndex = 0;
                    var answerImgIndex = 0;
                    questionBlock.querySelectorAll('.preview-section').forEach(function (previewSection) {
                        var labelEl = previewSection.querySelector('.preview-section-label');
                        var isGuideAnswer = !!(previewSection.querySelector('.guide-answer') || (labelEl && labelEl.textContent && labelEl.textContent.indexOf('Guide Answer') !== -1));
                        var scope = isGuideAnswer ? 'answer' : 'question';
                        previewSection.querySelectorAll('.live-preview').forEach(function (livePreview) {
                            livePreview.querySelectorAll('.image-placeholder-container').forEach(function (container) {
                                var imageIndex = isGuideAnswer ? answerImgIndex : questionImgIndex;
                                container.setAttribute('data-fp-key', scope + '-' + questionIndex + '-' + imageIndex);
                                if (isGuideAnswer) answerImgIndex++; else questionImgIndex++;
                            });
                        });
                    });
                });
                return;
            }
            var textarea = null;
            var el = rootEl.previousElementSibling;
            while (el) {
                if (el.tagName === 'TEXTAREA') { textarea = el; break; }
                el = el.previousElementSibling;
            }
            if (!textarea && rootEl.closest) {
                var container = rootEl.closest('.form-group') || rootEl.closest('.text-field-container');
                if (container) textarea = container.querySelector('textarea');
            }
            if (!textarea) return;
            var prefix = getBboxKeyPrefixForTextarea(textarea);
            if (prefix == null) return;
            rootEl.querySelectorAll('.image-placeholder-container').forEach(function (container, idx) {
                var imageIndex = container.getAttribute('data-image-index');
                if (imageIndex === null || imageIndex === '') imageIndex = String(idx);
                container.setAttribute('data-fp-key', prefix + '-' + imageIndex);
            });
        }

        // Ensure __fpFormState and __fpBboxMap from state (collect when DOM has content, else use cache).
        function ensureFpFormStateAndBboxMap() {
            try {
                if (typeof collectFormDataWithoutValidation === 'function') {
                    const state = collectFormDataWithoutValidation();
                    if (state && (state.instructional_content && state.instructional_content.length > 0 || state.practice_questions && state.practice_questions.length > 0)) {
                        window.__fpFormState = state;
                    }
                }
            } catch (e) { /* ignore */ }
            const state = window.__fpFormState || null;
            window.__fpBboxMap = typeof buildFpBboxMapFromState === 'function' ? buildFpBboxMapFromState(state) : {};
        }

        window.__DEBUG_BBOX_PREVIEW = false;

        const FORCE_PLACEHOLDER_IMAGES = true; // TEMP: set true to disable bbox previews everywhere

        // Shared: scan root for .image-placeholder-container[data-fp-key]. Valid bbox -> render into inner box. Invalid/missing -> restore placeholder.
        function applyBboxesToPreviewRoot(rootEl) {
            if (!rootEl) return;
            if (FORCE_PLACEHOLDER_IMAGES) {
                rootEl.querySelectorAll('.image-placeholder-container').forEach(function (container) {
                    var innerBox = getPlaceholderInnerBox(container);
                    if (!innerBox) return;
                    container.classList.remove('has-bbox-preview');
                    innerBox.querySelectorAll('.fp-bbox-canvas').forEach(function (el) { el.remove(); });
                    innerBox.innerHTML = (innerBox.__fpOriginalHtml != null ? innerBox.__fpOriginalHtml : __fpDefaultInnerHtml);
                    innerBox.style.height = '150px';
                    innerBox.style.display = 'flex';
                    var ro = getFpResizeObserver();
                    if (ro && __fpBoxResizeMap) { ro.unobserve(innerBox); __fpBoxResizeMap.delete(innerBox); }
                });
                return;
            }
            attachBboxRefreshListeners();
            ensureFpFormStateAndBboxMap();
            const store = window.__bboxStore;
            const pdfDoc = store && store.docs && store.docs.text && store.docs.text.pdfDoc;
            const placeholders = Array.from(rootEl.querySelectorAll('.image-placeholder-container[data-fp-key]'));
            const BATCH = 3;
            let idx = 0;
            function processBatch() {
                for (let i = 0; i < BATCH && idx < placeholders.length; i++) {
                    const container = placeholders[idx++];
                    const key = container.getAttribute('data-fp-key');
                    const raw = resolveBboxForFinalPreviewKey(key);
                    const bboxRecord = normalizeBboxRecord(raw);
                    const innerBox = getPlaceholderInnerBox(container);
                    if (!innerBox) continue;
                    if (!isElementVisible(innerBox)) continue;
                    const valid = bboxRecord != null && isValidBboxRecord(bboxRecord);
                    if (window.__DEBUG_BBOX_PREVIEW) console.debug('bbox-preview', { key: key, normalized: bboxRecord, valid: valid, pdfLoaded: !!pdfDoc });
                    if (!pdfDoc || !valid) {
                        container.classList.remove('has-bbox-preview');
                        innerBox.querySelectorAll('.fp-bbox-canvas').forEach(function (el) { el.remove(); });
                        innerBox.innerHTML = (innerBox.__fpOriginalHtml != null ? innerBox.__fpOriginalHtml : __fpDefaultInnerHtml);
                        innerBox.style.height = '150px';
                        innerBox.style.display = 'flex';
                        var ro = getFpResizeObserver();
                        if (ro && __fpBoxResizeMap) { ro.unobserve(innerBox); __fpBoxResizeMap.delete(innerBox); }
                        continue;
                    }
                    container.classList.add('has-bbox-preview');
                    innerBox.querySelectorAll('.fp-bbox-canvas').forEach(function (el) { el.remove(); });
                    renderBboxCropIntoInnerBox(bboxRecord, innerBox);
                }
                if (idx >= placeholders.length) {
                    triggerAutoSizeRecalc();
                } else {
                    requestAnimationFrame(processBatch);
                }
            }
            if (placeholders.length > 0) requestAnimationFrame(processBatch);
        }

        // Apply bbox rendering to all live previews and final preview. No per-image work; uses existing batching.
        function applyBboxesEverywhere(opts) {
            opts = opts || {};
            var forceRetag = opts.forceRetag === true;
            ensureFpFormStateAndBboxMap();
            document.querySelectorAll('.live-preview').forEach(function (livePreview) {
                if (forceRetag) retagPreviewPlaceholdersUnder(livePreview);
                applyBboxesToPreviewRoot(livePreview);
            });
            var fpContent = document.getElementById('final-preview-content');
            if (fpContent) {
                if (forceRetag) retagPreviewPlaceholdersUnder(fpContent);
                applyBboxesToPreviewRoot(fpContent);
            }
            triggerAutoSizeRecalc();
        }

        // Debounced post-layout bbox refresh: 2 rAFs then apply to active panel only (or everywhere if no scope).
        var __bboxPostLayoutScheduled = false;
        function schedulePostLayoutBboxRefresh(scopeEl) {
            if (__bboxPostLayoutScheduled) return;
            __bboxPostLayoutScheduled = true;
            requestAnimationFrame(function () {
                requestAnimationFrame(function () {
                    __bboxPostLayoutScheduled = false;
                    var activeRoot = scopeEl || resolveActivePanelRoot();
                    if (activeRoot) {
                        activeRoot.querySelectorAll('.live-preview').forEach(function (preview) {
                            retagPreviewPlaceholdersUnder(preview);
                            applyBboxesToPreviewRoot(preview);
                        });
                        var fpContent = document.getElementById('final-preview-content');
                        if (fpContent && (activeRoot.id === 'final-preview-content' || activeRoot.contains(fpContent))) {
                            retagPreviewPlaceholdersUnder(fpContent);
                            applyBboxesToPreviewRoot(fpContent);
                        }
                    } else {
                        applyBboxesEverywhere({ forceRetag: false });
                    }
                    triggerAutoSizeRecalc();
                });
            });
        }

        // One-time tab-switch hook: after tab click, re-apply bboxes to the newly visible panel only (fixes truncation).
        function attachBboxTabSwitchHook() {
            if (window.__bboxTabSwitchHookAttached) return;
            window.__bboxTabSwitchHookAttached = true;
            document.addEventListener('click', function (e) {
                var tab = e.target && e.target.closest && e.target.closest('.tab');
                if (!tab) return;
                schedulePostLayoutBboxRefresh();
            });
        }

        // One-time global PDF-ready hook: when pdfDoc becomes available, apply bboxes everywhere (all tabs).
        function scheduleBboxApplyWhenPdfReady() {
            if (window.__bboxPdfReadyScheduled) return;
            window.__bboxPdfReadyScheduled = true;
            var tries = 0;
            var MAX_TRIES = 10;
            var interval = 300;
            var t = setInterval(function () {
                tries++;
                var store = window.__bboxStore;
                var pdfDoc = store && store.docs && store.docs.text && store.docs.text.pdfDoc;
                if (pdfDoc) {
                    clearInterval(t);
                    window.__bboxPdfReadyScheduled = false;
                    applyBboxesEverywhere({ forceRetag: false });
                } else if (tries >= MAX_TRIES) {
                    clearInterval(t);
                    window.__bboxPdfReadyScheduled = false;
                }
            }, interval);
        }

        // Debounced refresh of all bbox previews when bbox inputs or order change. Single pending flush. Retag first so keys match current order.
        var __bboxRefreshTimeout = null;
        function scheduleBboxRefresh() {
            if (__bboxRefreshTimeout) clearTimeout(__bboxRefreshTimeout);
            __bboxRefreshTimeout = setTimeout(function () {
                __bboxRefreshTimeout = null;
                ensureFpFormStateAndBboxMap();
                document.querySelectorAll('.live-preview').forEach(function (el) {
                    retagPreviewPlaceholdersUnder(el);
                    applyBboxesToPreviewRoot(el);
                });
                var fpContent = document.getElementById('final-preview-content');
                if (fpContent) {
                    retagPreviewPlaceholdersUnder(fpContent);
                    applyBboxesToPreviewRoot(fpContent);
                }
            }, 150);
        }

        // One-time: attach delegated listener and MutationObserver for bbox UI changes.
        function attachBboxRefreshListeners() {
            if (window.__bboxRefreshListenersAttached) return;
            window.__bboxRefreshListenersAttached = true;
            function insideBboxContainer(el) {
                return el && el.nodeType === 1 && el.closest && el.closest('.bbox-container') !== null;
            }
            function isBboxRowButton(el, texts) {
                if (!el || el.tagName !== 'BUTTON') return false;
                var t = (el.textContent || '').trim();
                for (var i = 0; i < texts.length; i++) if (t.indexOf(texts[i]) !== -1) return true;
                return false;
            }
            document.addEventListener('input', function (e) {
                if (insideBboxContainer(e.target)) scheduleBboxRefresh();
            });
            document.addEventListener('change', function (e) {
                if (insideBboxContainer(e.target)) scheduleBboxRefresh();
            });
            document.addEventListener('click', function (e) {
                var btn = e.target && e.target.closest ? e.target.closest('button') : null;
                if (!btn || !insideBboxContainer(btn)) return;
                if (btn.classList && (btn.classList.contains('reorder-btn') || btn.classList.contains('remove-btn') || btn.classList.contains('add-before') || btn.classList.contains('add-after'))) { scheduleBboxRefresh(); return; }
                if (isBboxRowButton(btn, ['Delete', 'Remove', '\u00D7', 'Before', 'After', 'Up', 'Down', 'Move'])) scheduleBboxRefresh();
            });
            var contentContainer = document.getElementById('content_sections_container');
            var questionsContainer = document.getElementById('questions_container');
            var observer = new MutationObserver(function (mutations) {
                for (var i = 0; i < mutations.length; i++) {
                    var m = mutations[i];
                    if (m.removedNodes && m.removedNodes.length > 0 && (m.target.classList && m.target.classList.contains('bbox-container') || (m.target.closest && m.target.closest('.bbox-container')))) { scheduleBboxRefresh(); return; }
                    var t = m.target;
                    if (t.classList && t.classList.contains('bbox-container')) { scheduleBboxRefresh(); return; }
                    if (t.closest && t.closest('.bbox-container')) { scheduleBboxRefresh(); return; }
                }
            });
            if (contentContainer) observer.observe(contentContainer, { childList: true, subtree: true });
            if (questionsContainer) observer.observe(questionsContainer, { childList: true, subtree: true });
            attachBboxTabSwitchHook();
        }

        // Generate Final Preview
        function generateFinalPreview() {
            const previewContainer = document.getElementById('final-preview-content');
            if (!previewContainer) return;
            
            let html = '';
            
            // First, render basic info
            const textbookPage = document.getElementById('textbook_page') ? document.getElementById('textbook_page').value || '' : '';
            const textbookPdfPage = document.getElementById('textbook_pdf_page') ? document.getElementById('textbook_pdf_page').value || '' : '';
            const guidebookStartPage = document.getElementById('guidebook_start_page') ? document.getElementById('guidebook_start_page').value || '' : '';
            const guidebookEndPage = document.getElementById('guidebook_end_page') ? document.getElementById('guidebook_end_page').value || '' : '';
            const pageType = document.getElementById('page_type') ? document.getElementById('page_type').value || '' : '';
            
            let hasBasicInfo = textbookPage || textbookPdfPage || guidebookStartPage || guidebookEndPage || pageType;
            if (hasBasicInfo) {
                html += '<div class="final-preview-section"><h3>Basic Info</h3>';
                html += '<div class="final-preview-section">';
                
                if (textbookPage) {
                    html += buildPreviewBox({
                        title: 'Textbook Page Number',
                        editTarget: "navigateToInput(document.getElementById('textbook_page'))",
                        bodyHTML: `<div style="padding: 8px; dir: ltr; text-align: left;">${textbookPage}</div>`
                    });
                }
                
                if (textbookPdfPage) {
                    html += buildPreviewBox({
                        title: 'PDF Page Number',
                        editTarget: "navigateToInput(document.getElementById('textbook_pdf_page'))",
                        bodyHTML: `<div style="padding: 8px; dir: ltr; text-align: left;">${textbookPdfPage}</div>`
                    });
                }
                
                if (guidebookStartPage || guidebookEndPage) {
                    const guidebookPages = guidebookStartPage && guidebookEndPage ? `${guidebookStartPage} - ${guidebookEndPage}` : (guidebookStartPage || guidebookEndPage);
                    html += buildPreviewBox({
                        title: 'Guidebook PDF Pages (Start - End)',
                        editTarget: "navigateToInput(document.getElementById('guidebook_start_page'))",
                        bodyHTML: `<div style="padding: 8px; dir: ltr; text-align: left;">${guidebookPages}</div>`
                    });
                }
                
                if (pageType) {
                    const pageTypeOptions = {
                        'content': 'Content',
                        'project': 'Project',
                        'vocabulary': 'Vocabulary',
                        'unit_table_of_content': 'Unit Table of Content',
                        'table_of_content': 'Table of Content',
                        'other': 'Other'
                    };
                    const pageTypeLabel = pageTypeOptions[pageType] || pageType;
                    html += buildPreviewBox({
                        title: 'Page Type',
                        editTarget: "navigateToInput(document.getElementById('page_type'))",
                        bodyHTML: `<div style="padding: 8px; dir: ltr; text-align: left;">${pageTypeLabel}</div>`
                    });
                }
                
                html += '</div></div>';
            }
            
            // Then, render lesson preamble
            const lessonId = document.getElementById('lesson_id') ? document.getElementById('lesson_id').value || '' : '';
            const lessonTitleInput = document.getElementById('lesson_title');
            const lessonTitle = lessonTitleInput ? lessonTitleInput.value || '' : '';
            const lessonStandardsContainer = document.getElementById('lesson_standards');
            const lessonStandards = lessonStandardsContainer ? Array.from(lessonStandardsContainer.querySelectorAll('.array-item textarea')).map(textarea => textarea.value.trim()).filter(v => v) : [];
            const terminologyContainer = document.getElementById('terminology');
            const terminologyItems = terminologyContainer ? Array.from(terminologyContainer.querySelectorAll('.array-item textarea')) : [];
            const lessonTextarea = document.getElementById('lesson_text');
            const lessonText = lessonTextarea ? lessonTextarea.value || '' : '';
            
            let hasLessonPreamble = lessonId || lessonTitle || lessonStandards.length > 0 || terminologyItems.length > 0 || lessonText;
            if (hasLessonPreamble) {
                html += '<div class="final-preview-section"><h3>Lesson Preamble</h3>';
                html += '<div class="final-preview-section">';
                
                if (lessonId) {
                    html += buildPreviewBox({
                        title: 'Lesson ID',
                        editTarget: "navigateToInput(document.getElementById('lesson_id'))",
                        bodyHTML: `<div style="padding: 8px; dir: ltr; text-align: left;">${lessonId}</div>`
                    });
                }
                
                if (lessonTitle && lessonTitleInput) {
                    // Find existing preview for lesson title
                    let titlePreview = null;
                    let sibling = lessonTitleInput.nextElementSibling;
                    while (sibling) {
                        if (sibling.classList && sibling.classList.contains('live-preview')) {
                            titlePreview = sibling;
                            break;
                        }
                        sibling = sibling.nextElementSibling;
                    }
                    
                    let titlePreviewHTML;
                    if (titlePreview && titlePreview.innerHTML) {
                        titlePreviewHTML = titlePreview.innerHTML;
                    } else {
                        const tempTitlePreview = document.createElement('div');
                        tempTitlePreview.className = 'live-preview';
                        tempTitlePreview.setAttribute('dir', 'rtl');
                        tempTitlePreview.style.textAlign = 'right';
                        renderLivePreviewToElement(lessonTitleInput, tempTitlePreview);
                        titlePreviewHTML = tempTitlePreview.innerHTML;
                    }
                    html += buildPreviewBox({
                        title: 'Lesson Title',
                        editTarget: "navigateToInput(document.getElementById('lesson_title'))",
                        bodyHTML: `<div class="live-preview" dir="rtl" style="text-align: right;">${titlePreviewHTML}</div>`
                    });
                }
                
                // Render Lesson Standards as grouped list
                if (lessonStandards.length > 0) {
                    const standardsTextareas = Array.from(lessonStandardsContainer.querySelectorAll('.array-item textarea'));
                    const standardsBodyHTML = renderPreviewArrayList({
                        title: 'Lesson Standards',
                        items: standardsTextareas,
                        getEditTargetForIndex: (index) => {
                            return `navigateToInput(document.getElementById('lesson_standards').querySelectorAll('.array-item textarea')[${index}])`;
                        }
                    });
                    html += buildPreviewBox({
                        title: 'Lesson Standards',
                        editTarget: null, // Group-level edit not applicable
                        bodyHTML: standardsBodyHTML
                    });
                }
                
                // Render Terminology as grouped list
                if (terminologyItems.length > 0) {
                    const terminologyBodyHTML = renderPreviewArrayList({
                        title: 'Terminology',
                        items: terminologyItems,
                        getEditTargetForIndex: (index) => {
                            return `navigateToInput(document.getElementById('terminology').querySelectorAll('.array-item textarea')[${index}])`;
                        }
                    });
                    html += buildPreviewBox({
                        title: 'Terminology',
                        editTarget: null, // Group-level edit not applicable
                        bodyHTML: terminologyBodyHTML
                    });
                }
                
                if (lessonText && lessonTextarea) {
                    // Find existing preview for lesson text
                    let textPreview = null;
                    let sibling = lessonTextarea.nextElementSibling;
                    while (sibling) {
                        if (sibling.classList && sibling.classList.contains('live-preview')) {
                            textPreview = sibling;
                            break;
                        }
                        sibling = sibling.nextElementSibling;
                    }
                    
                    let lessonTextPreviewHTML;
                    if (textPreview && textPreview.innerHTML) {
                        lessonTextPreviewHTML = textPreview.innerHTML;
                    } else {
                        const tempTextPreview = document.createElement('div');
                        tempTextPreview.className = 'live-preview';
                        tempTextPreview.setAttribute('dir', 'rtl');
                        tempTextPreview.style.textAlign = 'right';
                        renderLivePreviewToElement(lessonTextarea, tempTextPreview);
                        lessonTextPreviewHTML = tempTextPreview.innerHTML;
                    }
                    html += buildPreviewBox({
                        title: 'Lesson Text',
                        editTarget: "navigateToInput(document.getElementById('lesson_text'))",
                        bodyHTML: `<div class="live-preview" dir="rtl" style="text-align: right;">${lessonTextPreviewHTML}</div>`
                    });
                }
                
                html += '</div></div>';
            }
            
            // Then, render all content sections
            const contentSections = document.querySelectorAll('#content_sections_container > .array-item');
            if (contentSections.length > 0) {
                html += '<div class="final-preview-section"><h3>Content Sections</h3>';
                contentSections.forEach((sectionEl, index) => {
                    const titleInput = sectionEl.querySelector('input[placeholder="Section title"]');
                    const textarea = sectionEl.querySelector('.text-field-container textarea');
                    const title = titleInput ? titleInput.value || '' : '';
                    const text = textarea ? textarea.value || '' : '';
                    const sectionId = 'content-section-' + index;
                    sectionEl.setAttribute('data-preview-id', sectionId);
                    
                    html += `<div class="final-preview-section">`;
                    
                    // Section Title Preview (separate box)
                    if (title && titleInput) {
                        // Find existing preview for title
                        let titlePreview = null;
                        let sibling = titleInput.nextElementSibling;
                        while (sibling) {
                            if (sibling.classList && sibling.classList.contains('live-preview')) {
                                titlePreview = sibling;
                                break;
                            }
                            sibling = sibling.nextElementSibling;
                        }
                        
                        let titlePreviewHTML;
                        if (titlePreview && titlePreview.innerHTML) {
                            titlePreviewHTML = titlePreview.innerHTML;
                        } else {
                            const tempTitlePreview = document.createElement('div');
                            tempTitlePreview.className = 'live-preview';
                            tempTitlePreview.setAttribute('dir', 'rtl');
                            tempTitlePreview.style.textAlign = 'right';
                            renderLivePreviewToElement(titleInput, tempTitlePreview);
                            titlePreviewHTML = tempTitlePreview.innerHTML;
                        }
                        html += buildPreviewBox({
                            title: 'Section Title',
                            editTarget: `navigateToInput(document.querySelector('#content_sections_container > .array-item:nth-child(${index + 1}) input[placeholder=\\'Section title\\']'))`,
                            bodyHTML: `<div class="live-preview" dir="rtl" style="text-align: right;">${titlePreviewHTML}</div>`,
                            dataAttrs: { 'navigate-to': sectionId, 'target-element': 'title' }
                        });
                    }
                    
                    // Content Preview (separate box)
                    if (text && textarea) {
                        // Find existing preview for content
                        let contentPreview = null;
                        let sibling = textarea.nextElementSibling;
                        while (sibling) {
                            if (sibling.classList && sibling.classList.contains('live-preview')) {
                                contentPreview = sibling;
                                break;
                            }
                            sibling = sibling.nextElementSibling;
                        }
                        
                        let contentPreviewHTML;
                        if (contentPreview && contentPreview.innerHTML) {
                            contentPreviewHTML = contentPreview.innerHTML;
                        } else {
                            const tempContentPreview = document.createElement('div');
                            tempContentPreview.className = 'live-preview';
                            tempContentPreview.setAttribute('dir', 'rtl');
                            tempContentPreview.style.textAlign = 'right';
                            renderLivePreviewToElement(textarea, tempContentPreview);
                            contentPreviewHTML = tempContentPreview.innerHTML;
                        }
                        html += buildPreviewBox({
                            title: 'Content',
                            editTarget: `navigateToInput(document.querySelector('#content_sections_container > .array-item:nth-child(${index + 1}) .text-field-container textarea'))`,
                            bodyHTML: `<div class="live-preview" dir="rtl" style="text-align: right;">${contentPreviewHTML}</div>`,
                            dataAttrs: { 'navigate-to': sectionId, 'target-element': 'content' }
                        });
                    }
                    
                    // If neither title nor content exists
                    if (!title && !text) {
                        html += '<p style="color: #6c757d; font-style: italic;">(No content)</p>';
                    }
                    
                    html += `</div>`;
                });
                html += '</div>';
            }
            
            // Then, render all questions
            const questions = document.querySelectorAll('#questions_container > .array-item');
            if (questions.length > 0) {
                html += '<div class="final-preview-section"><h3>Questions</h3>';
                questions.forEach((questionEl, index) => {
                    html += renderQuestionPreview(questionEl, index);
                });
                html += '</div>';
            }
            
            // If no content, show message
            if (!hasBasicInfo && !hasLessonPreamble && contentSections.length === 0 && questions.length === 0) {
                html = '<div class="final-preview-section"><p style="color: #6c757d; font-style: italic;">No content sections or questions to preview. Add some content in the Input Form tab.</p></div>';
            }
            
            previewContainer.innerHTML = html;
            
            // Shared bbox rendering: placeholders already have data-fp-key from creation; apply in-place
            ensureFpFormStateAndBboxMap();
            applyBboxesToPreviewRoot(previewContainer);
            if (!(window.__bboxStore && window.__bboxStore.docs && window.__bboxStore.docs.text && window.__bboxStore.docs.text.pdfDoc)) {
                scheduleBboxApplyWhenPdfReady();
            }

            // Apply current font size and line height to all live-preview elements in final preview
            const savedFontSize = localStorage.getItem('fontSize') || '14';
            const savedLineHeight = localStorage.getItem('lineHeight') || '1.5';
            const fontSize = savedFontSize + 'px';
            const lineHeight = savedLineHeight;
            
            // Apply to all live-preview elements in the final preview container
            previewContainer.querySelectorAll('.live-preview').forEach(el => {
                el.style.fontSize = fontSize;
                el.style.lineHeight = lineHeight;
                
                // Check for trailing spaces in final preview
                // Find the associated textarea by looking for the data-navigate-to attribute
                const previewSection = el.closest('.preview-section');
                if (previewSection) {
                    const navigateTo = previewSection.getAttribute('data-navigate-to');
                    const targetElement = previewSection.getAttribute('data-target-element');
                    
                    if (navigateTo && targetElement) {
                        // Try to find the original textarea
                        let textarea = null;
                        if (navigateTo.startsWith('content-section-')) {
                            const index = parseInt(navigateTo.replace('content-section-', ''), 10);
                            const sectionEl = document.querySelectorAll('#content_sections_container > .array-item')[index];
                            if (sectionEl) {
                                if (targetElement === 'title') {
                                    textarea = sectionEl.querySelector('input[placeholder="Section title"]');
                                } else if (targetElement === 'content') {
                                    textarea = sectionEl.querySelector('.text-field-container textarea');
                                }
                            }
                        } else if (navigateTo.startsWith('question-')) {
                            const index = parseInt(navigateTo.replace('question-', ''), 10);
                            const questionEl = document.querySelectorAll('#questions_container > .array-item')[index];
                            if (questionEl) {
                                // Find textarea based on the preview section label or structure
                                const label = previewSection.querySelector('.preview-section-label');
                                if (label) {
                                    const labelText = label.textContent.trim();
                                    if (labelText === 'Setup Text') {
                                        textarea = questionEl.querySelector('textarea[placeholder*="setup"]');
                                    } else if (labelText === 'Question Text') {
                                        textarea = questionEl.querySelector('textarea[placeholder*="Enter question text"]');
                                    }
                                }
                            }
                        }
                        
                        if (textarea) {
                            updateTrailingSpacesIndicator(textarea, el);
                        }
                    }
                }
            });
            
            // Re-render any LaTeX or markdown in the preview
            previewContainer.querySelectorAll('.live-preview').forEach(preview => {
                // Math rendering will be handled by existing KaTeX setup
                if (window.renderMathInElement) {
                    safeRenderMathInElement(preview, {
                        delimiters: [
                            {left: '$$', right: '$$', display: true},
                            {left: '$', right: '$', display: false}
                        ]
                    });
                applyKatexBidi(preview);
                }
            });
        }

        // Apply consistent KaTeX bidi handling across all previews
    function applyKatexBidi(root) {
        if (!root) return;
        const katexElements = root.querySelectorAll('.katex');
        katexElements.forEach(el => {
            const katexHtml = el.querySelector('.katex-html');
            if (katexHtml) {
                katexHtml.style.direction = 'ltr';
                katexHtml.style.unicodeBidi = 'bidi-override';
            }
            // Set dir attribute on .mtext spans based on content
            el.querySelectorAll('.mtext').forEach(mtext => {
                const text = mtext.textContent || '';
                const hasArabic = /[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/.test(text);
                mtext.setAttribute('dir', hasArabic ? 'rtl' : 'ltr');
            });
        });
    }

        function escapeHtml(text) {
            return (text || '')
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
        }

        function protectAltMarkers(html) {
            const placeholders = [];
            const updated = html.replace(/alt="([^"]*)"/g, (match, value) => {
                const replaced = value.replace(/@@(?:LEADING|TRAILING|CONSECUTIVE)_SPACES_\d+@@/g, (marker) => {
                    const token = `@@ALT_SPACE_MARKER_${placeholders.push(marker) - 1}@@`;
                    return token;
                });
                return `alt="${replaced}"`;
            });
            return { html: updated, placeholders };
        }

        function restoreAltMarkers(html, placeholders) {
            return html.replace(/@@ALT_SPACE_MARKER_(\d+)@@/g, (match, idx) => {
                const index = parseInt(idx, 10);
                return placeholders[index] || '';
            });
        }

        function appendImageDescription(captionSpan, description) {
            if (!description) return;
            const parts = description.split(/@@INLINE_MATH_(\d+)@@/);
            parts.forEach((part, idx) => {
                if (idx % 2 === 0) {
                    if (!part) return;
                    const safeText = escapeHtml(part);
                    const processed = replaceTrailingSpaceMarkers(safeText);
                    const temp = document.createElement('span');
                    temp.innerHTML = processed;
                    while (temp.firstChild) {
                        captionSpan.appendChild(temp.firstChild);
                    }
                } else {
                    const span = document.createElement('span');
                    span.className = '__math_inline';
                    span.setAttribute('data-im', part);
                    captionSpan.appendChild(span);
                }
            });
        }

        // ========================================
        // REUSABLE PREVIEW ARRAY LIST RENDERER
        // ========================================
        // Renders array items (standards, terminology, etc.) as list rows with edit pens
        // Similar to choice rows but without markers/badges
        /**
         * Render an array of items as a preview list (reusable for standards, terminology, etc.)
         * @param {Object} config - Configuration object
         * @param {string} config.title - Group title (e.g., "Lesson Standards", "Terminology")
         * @param {Array<HTMLElement>} config.items - Array of textarea elements to render
         * @param {Function} config.getEditTargetForIndex - Function(index) that returns editTarget string for navigateToInput
         * @returns {string} HTML string for the preview box body
         */
        function renderPreviewArrayList(config) {
            const { title, items, getEditTargetForIndex } = config;
            
            if (!items || items.length === 0) {
                return '<div style="color: #6c757d; font-style: italic; padding: 8px;">(No items)</div>';
            }
            
            let html = `<div class="preview-array-list">`;
            
            items.forEach((textarea, domIndex) => {
                if (!textarea) return;
                
                const value = textarea.value || '';
                if (!value.trim()) return; // Skip empty items
                
                // Generate preview HTML for this item
                const tempPreview = document.createElement('div');
                tempPreview.className = 'live-preview';
                tempPreview.setAttribute('dir', 'rtl');
                tempPreview.style.textAlign = 'right';
                renderLivePreviewToElement(textarea, tempPreview);
                const previewHTML = tempPreview.innerHTML;
                
                // Get edit target for this DOM index (not filtered index)
                const editTarget = getEditTargetForIndex ? getEditTargetForIndex(domIndex) : '';
                const editPenHTML = editTarget 
                    ? `<div class="preview-choice-actions" onclick="${editTarget}" onmouseover="this.style.opacity='1'; this.style.background='var(--bg-tertiary)';" onmouseout="this.style.opacity='0.7'; this.style.background='transparent';" title="Click to edit"><i class="fas fa-edit"></i></div>`
                    : '';
                
                // Render as a list row (similar to choice rows but without marker)
                html += `<div class="preview-choice-row preview-array-item">`;
                html += `<div class="preview-choice-main">`;
                html += `<div class="live-preview" dir="rtl" style="text-align: right;">${previewHTML}</div>`;
                html += `</div>`;
                html += editPenHTML;
                html += `</div>`;
            });
            
            html += `</div>`;
            return html;
        }

        // ========================================
        // UNIVERSAL PREVIEW BOX BUILDER
        // ========================================
        // Single function for all final preview field boxes
        // Ensures consistent structure, styling, and edit-pen navigation
        function buildPreviewBox(options) {
            const {
                title,              // Box header label
                editTarget,         // onclick expression string for navigateToInput
                bodyHTML,           // Inner content HTML
                bodyClass = 'setup-text', // CSS class for body wrapper (default: setup-text)
                dataAttrs = {}      // Optional data-* attributes for the container
            } = options;
            
            // Build data attributes string
            let dataAttrsStr = '';
            for (const [key, value] of Object.entries(dataAttrs)) {
                dataAttrsStr += ` data-${key}="${value}"`;
            }
            
            // Edit pen HTML (consistent across all preview boxes); z-index so it sits above content and is fully clickable
            const editPenHTML = editTarget 
                ? `<div class="preview-edit-pen" style="position: absolute; top: 8px; right: 8px; z-index: 10; color: var(--accent); font-size: 0.85rem; opacity: 0.7; cursor: pointer; padding: 4px; border-radius: 4px; transition: all 0.2s ease;" onclick="${editTarget}" onmouseover="this.style.opacity='1'; this.style.background='var(--bg-tertiary)';" onmouseout="this.style.opacity='0.7'; this.style.background='transparent';" title="Click to edit"><i class="fas fa-edit"></i></div>`
                : '';
            
            return `<div class="preview-section" style="position: relative;"${dataAttrsStr}>${editPenHTML}<h5 class="preview-section-label">${title}</h5><div class="${bodyClass}">${bodyHTML}</div></div>`;
        }

        // Helper function to render markdown to an element (similar to renderLivePreview but for a target element)
        function renderLivePreviewToElement(textarea, targetElement) {
            if (!targetElement || !textarea) return;
            
            try {
                // Check if textarea already has a rendered preview - if so, use that
                let existingPreview = null;
                let sibling = textarea.nextElementSibling;
                while (sibling) {
                    if (sibling.classList && sibling.classList.contains('live-preview')) {
                        existingPreview = sibling;
                        break;
                    }
                    sibling = sibling.nextElementSibling;
                }
                
                // If preview exists and has content, copy it
                if (existingPreview && existingPreview.innerHTML) {
                    targetElement.innerHTML = existingPreview.innerHTML;
                    targetElement.setAttribute('dir', existingPreview.getAttribute('dir') || 'rtl');
                    targetElement.style.textAlign = existingPreview.style.textAlign || 'right';
                    return;
                }
                
                // Otherwise, trigger a render by calling renderLivePreview if the preview element exists
                // First, check if we can attach preview to the textarea temporarily
                // But we don't want to modify the DOM, so we'll do a simplified render
                
                // Use the same math extraction approach as renderLivePreview
                let md = (textarea.value || '').replace(/\r\n?/g, '\n');
                const isLTR = textarea.hasAttribute('data-ltr');
                const direction = isLTR ? 'ltr' : 'rtl';
                const textAlign = isLTR ? 'left' : 'right';
                
                targetElement.setAttribute('dir', direction);
                targetElement.style.textAlign = textAlign;
                
                // Extract math expressions BEFORE markdown parsing (same as renderLivePreview)
                const mathBlocks = [];
                const inlineMath = [];
                
                // Extract block math ($$\n...\n$$)
                md = md.replace(/\$\$\s*\\n([\s\S]*?)\\n\s*\$\$/g, (m, inner) => {
                    let fixed = inner.replace(/\\n/g, '\n').trim();
                    // Escape < and > symbols to prevent HTML interpretation issues
                    fixed = fixed.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                    const idx = mathBlocks.push(fixed) - 1;
                    return `@@MATH_BLOCK_${idx}@@`;
                });
                
                // Extract inline math ($...$) - increased limit to handle long expressions like arrays
                md = md.replace(/(^|[^$])\$\s*([^$\n]{1,5000}?)\s*\$(?!\$)/g, (m, pre, inner) => {
                    // Only process if we have a valid closing $ and reasonable content length
                    if (inner.trim().length === 0) return m; // Don't process empty math
                    // Escape < and > symbols to prevent HTML interpretation issues
                    const escapedInner = inner.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                    return `${pre}@@INLINE_MATH_${inlineMath.push(escapedInner)-1}@@`;
                });
                
                // Render markdown
                if (window.marked && typeof window.marked.parse === 'function') {
                    if (window.marked.setOptions) {
                        window.marked.setOptions({ gfm: true, breaks: true });
                    }
                    // Normalize list spacing and empty list items before markdown parsing
                    md = normalizeEmptyListItemsForPreview(md);
                    // Mark trailing spaces before markdown parsing
                    md = markTrailingSpaces(md);
                    let html = window.marked.parse(md);
                    // Replace trailing space markers with HTML (but protect alt attributes)
                    const altProtection = protectAltMarkers(html);
                    html = replaceTrailingSpaceMarkers(altProtection.html);
                    html = restoreAltMarkers(html, altProtection.placeholders);
                    
                    // Re-inject math placeholders as elements for KaTeX to render (block math first)
                    mathBlocks.forEach((content, i) => {
                        const token = `@@MATH_BLOCK_${i}@@`;
                        const holder = `<div class="__math_block" data-math-idx="${i}" style="text-align: center; margin: 1em auto; display: block; direction: ltr; unicode-bidi: isolate;"></div>`;
                        html = html.split(token).join(holder);
                    });
                    
                    // Unescape HTML entities that were escaped during math processing
                    html = html.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
                    
                    targetElement.innerHTML = html;
                    
                    // Replace inline math placeholders in text nodes
                    const walker = document.createTreeWalker(targetElement, NodeFilter.SHOW_TEXT, null);
                    const textNodes = [];
                    while (walker.nextNode()) textNodes.push(walker.currentNode);
                    const inlineRe = /@@INLINE_MATH_(\d+)@@/g;
                    textNodes.forEach(node => {
                        const text = node.nodeValue;
                        if (!inlineRe.test(text)) return;
                        inlineRe.lastIndex = 0;
                        const frag = document.createDocumentFragment();
                        let lastIndex = 0;
                        let match;
                        while ((match = inlineRe.exec(text)) !== null) {
                            const before = text.slice(lastIndex, match.index);
                            if (before) frag.appendChild(document.createTextNode(before));
                            const idx = parseInt(match[1], 10);
                            const span = document.createElement('span');
                            span.className = '__math_inline';
                            span.setAttribute('data-im', String(idx));
                            frag.appendChild(span);
                            lastIndex = match.index + match[0].length;
                        }
                        const after = text.slice(lastIndex);
                        if (after) frag.appendChild(document.createTextNode(after));
                        node.parentNode.replaceChild(frag, node);
                    });
                    
                    // Process images to match original rendering exactly
                    // Create a temporary container to hold all images before processing
                    const tempContainer = document.createElement('div');
                    // Remove image src attributes before setting innerHTML to prevent browser from trying to load them
                    let tempHtml = targetElement.innerHTML;
                    tempHtml = tempHtml.replace(/<img([^>]*?)\s+src=["']([^"']*)["']([^>]*?)>/gi, (match, before, src, after) => {
                        // Remove src attribute to prevent browser from trying to load relative paths
                        const cleaned = (before + ' ' + after).trim().replace(/\s+/g, ' ');
                        return `<img ${cleaned}>`;
                    });
                    tempContainer.innerHTML = tempHtml;
                    const imgs = tempContainer.querySelectorAll('img[alt]');
                    
                    imgs.forEach(img => {
                        const alt = img.getAttribute('alt') || '';
                        const src = img.getAttribute('src') || '';
                        let description = alt;
                        
                        // Description is in alt, index is in src (from markdown ![desc](index))
                        // Create container matching original format (class/data for bbox key)
                        const container = document.createElement('div');
                        container.className = 'image-placeholder-container';
                        container.setAttribute('data-image-index', String(src));
                        const fpPrefix = getBboxKeyPrefixForTextarea(textarea);
                        if (fpPrefix != null) container.setAttribute('data-fp-key', fpPrefix + '-' + src);
                        container.style.display = 'block';
                        container.style.textAlign = 'center';
                        container.style.margin = '12px auto';
                        
                        // Create placeholder matching original (class for responsive bbox CSS)
                        const placeholder = document.createElement('div');
                        placeholder.className = 'image-placeholder-box';
                        placeholder.style.width = '200px';
                        placeholder.style.height = '150px';
                        placeholder.style.backgroundColor = '#f0f0f0';
                        placeholder.style.border = '2px dashed #ccc';
                        placeholder.style.borderRadius = '4px';
                        placeholder.style.display = 'flex';
                        placeholder.style.alignItems = 'center';
                        placeholder.style.justifyContent = 'center';
                        placeholder.style.margin = '0 auto';
                        placeholder.innerHTML = '<span style="color: #999; font-size: 14px;"> Image</span>';
                        
                        // Create caption span
                        const captionSpan = document.createElement('span');
                        captionSpan.className = 'image-description-math';
                        captionSpan.style.display = 'block';
                        captionSpan.style.marginTop = '4px';
                        
                        // Add description if it exists
                        if (description) {
                            appendImageDescription(captionSpan, description);
                            container.appendChild(placeholder);
                            if (captionSpan.firstChild) {
                                container.appendChild(captionSpan);
                            }
                        } else {
                            container.appendChild(placeholder);
                        }
                        
                        // Replace img with container
                        img.parentElement.replaceChild(container, img);
                    });
                    
                    // Update targetElement with processed HTML
                    targetElement.innerHTML = tempContainer.innerHTML;
                    
                    // Render math with KaTeX directly (same approach as renderLivePreview)
                    if (window.katex) {
                        // Render block math
                        const blockNodes = targetElement.querySelectorAll('.__math_block');
                        blockNodes.forEach(node => {
                            const i = parseInt(node.getAttribute('data-math-idx'), 10);
                            const originalTex = mathBlocks[i] || '';
                            const isBold = !!(node.closest('strong, b'));
                            const isItalic = !!(node.closest('em, i'));
                            let texToRender = originalTex;
                            // Avoid wrapping environments like aligned/align in macros
                            if (texToRender && !/\\begin\{[\s\S]*?\}/.test(texToRender)) {
                                if (isBold && isItalic) texToRender = `\\boldsymbol{\\mathit{${texToRender}}}`;
                                else if (isBold) texToRender = `\\boldsymbol{${texToRender}}`;
                                else if (isItalic) texToRender = `\\mathit{${texToRender}}`;
                            }
                            try { 
                                // Unescape HTML entities back to original symbols for KaTeX
                                texToRender = texToRender.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
                                safeKatexRender(texToRender, node, { displayMode: true }); 
                                // Force centering after rendering
                                node.style.textAlign = 'center';
                                node.style.margin = '1em auto';
                            } catch (e) {
                                console.error('KaTeX block error:', e);
                            }
                        });
                        
                        // Render inline math
                        const inlineNodes = targetElement.querySelectorAll('.__math_inline');
                        inlineNodes.forEach(node => {
                            const i = parseInt(node.getAttribute('data-im'), 10);
                            const originalTex = inlineMath[i] || '';
                            const isBold = !!(node.closest('strong, b'));
                            const isItalic = !!(node.closest('em, i'));
                            let texToRender = originalTex;
                            if (texToRender) {
                                if (isBold && isItalic) texToRender = `\\boldsymbol{\\mathit{${texToRender}}}`;
                                else if (isBold) texToRender = `\\boldsymbol{${texToRender}}`;
                                else if (isItalic) texToRender = `\\mathit{${texToRender}}`;
                            }
                            try { 
                                // Unescape HTML entities back to original symbols for KaTeX
                                texToRender = texToRender.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
                                safeKatexRender(texToRender, node, { displayMode: false });
                            } catch (e) {
                                console.error('KaTeX inline error:', e);
                            }
                        });
                        applyKatexBidi(targetElement);
                    }
                } else {
                    // Fallback: plain text
                    targetElement.textContent = md;
                }
                
                // Update trailing spaces indicator
                updateTrailingSpacesIndicator(textarea, targetElement);
                
            } catch (e) {
                console.error('Error rendering preview:', e);
                // Fallback: simple text display
                targetElement.textContent = textarea ? textarea.value || '' : '';
                // Still check for trailing spaces even in fallback
                updateTrailingSpacesIndicator(textarea, targetElement);
            }
        }

        // Render a question preview based on its type
        function renderQuestionPreview(questionEl, index) {
            const questionIdInput = findFieldByLabel(questionEl, 'Question ID', 'input');
            const questionId = questionIdInput ? questionIdInput.value || `${index + 1}` : `${index + 1}`;
            
            const questionType = getQuestionType(questionEl);
            
            const setupTextarea = findFieldByLabel(questionEl, 'Set-up Text', 'textarea');
            const setupText = setupTextarea ? setupTextarea.value || '' : '';
            
            const questionTextarea = questionEl.querySelector('textarea[placeholder*="Enter question text"]');
            const questionText = questionTextarea ? questionTextarea.value || '' : '';
            
            const questionTypeLabels = {
                'free_form': 'Free Form',
                'multiple_choice': 'Multiple Choice',
                'checkbox': 'Checkbox',
                'fill_in_the_blanks': 'Fill in the Blanks',
                'matching': 'Matching',
                'annotate': 'Annotate',
                'create_table': 'Create Table'
            };
            
            let html = `<div class="final-preview-question">`;
            html += `<h4>Question ${questionId}</h4>`;
            html += `<span class="question-type-badge">${questionTypeLabels[questionType] || 'Question'}</span>`;
            
            const questionIndex = Array.from(document.querySelectorAll('#questions_container > .array-item')).indexOf(questionEl);
            
            // Per-question Guide PDF Page (REQUIRED - always show)
            const guidePdfPageInput = findFieldByLabel(questionEl, 'Guide PDF Page', 'input');
            const guidePdfPage = guidePdfPageInput ? guidePdfPageInput.value || '' : '';
            html += buildPreviewBox({
                title: 'Guide PDF Page',
                editTarget: `navigateToInput(document.querySelectorAll('#questions_container > .array-item')[${questionIndex}].querySelector('input[placeholder*=\\'e.g., 78\\']'))`,
                bodyHTML: `<div style="padding: 8px; dir: ltr; text-align: left;">${guidePdfPage || '<span style="color: var(--text-secondary); font-style: italic;">(not set)</span>'}</div>`
            });
            
            // Per-question Related Question (OPTIONAL - only show if non-empty)
            const relatedQuestionInput = findFieldByLabel(questionEl, 'Related Question', 'input');
            const relatedQuestion = relatedQuestionInput ? relatedQuestionInput.value || '' : '';
            if (relatedQuestion.trim()) {
                html += buildPreviewBox({
                    title: 'Related Question',
                    editTarget: `navigateToInput(document.querySelectorAll('#questions_container > .array-item')[${questionIndex}].querySelector('input[placeholder*=\\'Leave empty if no related\\']'))`,
                    bodyHTML: `<div style="padding: 8px; dir: ltr; text-align: left;">${escapeHtml(relatedQuestion)}</div>`
                });
            }
            
            // Setup text - show if not empty (check both value and trimmed value)
            if (setupTextarea && setupText && setupText.trim()) {
                const setupPreview = document.createElement('div');
                setupPreview.className = 'live-preview setup-text';
                setupPreview.setAttribute('dir', 'rtl');
                setupPreview.style.textAlign = 'right';
                renderLivePreviewToElement(setupTextarea, setupPreview);
                // Store the setup textarea reference for navigation
                const setupTextareaId = setupTextarea.id || `setup-textarea-${Date.now()}-${questionIndex}`;
                if (!setupTextarea.id) {
                    setupTextarea.id = setupTextareaId;
                }
                html += buildPreviewBox({
                    title: 'Setup Text',
                    editTarget: `navigateToInput(document.getElementById('${setupTextareaId}'))`,
                    bodyHTML: `<div class="live-preview" dir="rtl" style="text-align: right;">${setupPreview.innerHTML}</div>`
                });
            }
            
            // Question text - always RTL in final preview
            if (questionText) {
                const questionPreview = document.createElement('div');
                questionPreview.className = 'live-preview question-text';
                questionPreview.setAttribute('dir', 'rtl');
                questionPreview.style.textAlign = 'right';
                renderLivePreviewToElement(questionTextarea, questionPreview);
                html += buildPreviewBox({
                    title: 'Question Text',
                    editTarget: `navigateToInput(document.querySelectorAll('#questions_container > .array-item')[${questionIndex}].querySelector('textarea[placeholder*=\\'Enter question text\\']'))`,
                    bodyHTML: `<div class="live-preview" dir="rtl" style="text-align: right;">${questionPreview.innerHTML}</div>`,
                    bodyClass: 'question-text'
                });
            }
            
            // Render based on question type
            if (questionType === 'multiple_choice' || questionType === 'checkbox') {
                html += renderMultipleChoicePreview(questionEl, questionType);
                // Guide answer is already included in renderMultipleChoicePreview
            } else if (questionType === 'fill_in_the_blanks') {
                html += renderFillInBlanksPreview(questionEl);
                // Guide answer is already included in renderFillInBlanksPreview
            } else if (questionType === 'matching') {
                html += renderMatchingPreview(questionEl);
                // Guide answer is already included in renderMatchingPreview
            } else if (questionType === 'annotate' || questionType === 'create_table' || questionType === 'free_form') {
                html += renderGuideAnswerPreview(questionEl, questionType);
            }
            
            html += `</div>`;
            return html;
        }

        // ========================================
        // SHARED CHOICE ROW RENDERER
        // ========================================
        // Renders a single choice row for both MCQ and Checkbox questions
        // Ensures all choices have edit pens regardless of correctness
        function renderChoiceRowPreview(choiceEl, questionIndex, choiceIndex, isMCQ, isCorrect, correctUidMCQ, correctUidsCheckbox) {
            // Read user-entered Choice ID from the .choice-id input (NOT internal UID)
            const choiceIdInput = choiceEl.querySelector('input.choice-id');
            const choiceId = choiceIdInput ? choiceIdInput.value.trim() : '';
            const choiceUid = choiceEl.dataset.choiceUid || '';
            
            const choiceTextarea = choiceEl.querySelector('textarea');
            const choiceText = choiceTextarea ? choiceTextarea.value || '' : '';
            
            // Build choice item with distinct marker based on type
            const markerIcon = isMCQ 
                ? (isCorrect ? '<i class="fas fa-dot-circle" style="color: #28a745;"></i>' : '<i class="far fa-circle" style="color: var(--text-secondary);"></i>')
                : (isCorrect ? '<i class="fas fa-check-square" style="color: #28a745;"></i>' : '<i class="far fa-square" style="color: var(--text-secondary);"></i>');
            
            const correctBadge = isCorrect 
                ? `<span style="display: inline-block; background: #28a745; color: white; font-size: 0.7rem; padding: 2px 6px; border-radius: 3px; margin-left: 8px; font-weight: 600;">${isMCQ ? ' Correct Answer' : ' Correct'}</span>`
                : '';
            
            // Choice ID label (only if user provided one)
            const choiceIdLabel = choiceId ? `<span class="choice-id" style="font-weight: 600;">${escapeHtml(choiceId)}.</span> ` : '';
            
            // Build edit pen - ALWAYS present for all choices
            // Use a reliable selector: get question by index, then find choices list within it, then get choice by index
            const editTarget = `navigateToInput((function(){var q=document.querySelectorAll('#questions_container > .array-item')[${questionIndex}];if(!q)return null;var cl=q.querySelector('[id^=\\'choices-list-\\']');if(!cl)return null;var ci=cl.querySelectorAll('.choice-item')[${choiceIndex}];return ci?ci.querySelector('textarea'):null;})())`;
            const editPenHTML = `<div class="preview-choice-actions" onclick="${editTarget}" onmouseover="this.style.opacity='1'; this.style.background='var(--bg-tertiary)';" onmouseout="this.style.opacity='0.7'; this.style.background='transparent';" title="Click to edit"><i class="fas fa-edit"></i></div>`;
            
            // Use flex layout with dedicated actions column to prevent overlap
            let html = `<div class="preview-choice-row choice-item ${isCorrect ? 'correct' : ''}" style="${isCorrect ? 'background: rgba(40, 167, 69, 0.08); border-left: 3px solid #28a745; border-radius: 4px;' : ''}">`;
            
            // Marker icon
            html += `<span class="preview-choice-marker">${markerIcon}</span>`;
            
            // Choice content (with padding-right to prevent overlap with actions)
            html += `<div class="preview-choice-main">`;
            html += `${choiceIdLabel}${correctBadge}`;
            
            if (choiceText && choiceTextarea) {
                const choicePreview = document.createElement('div');
                choicePreview.className = 'live-preview';
                choicePreview.setAttribute('dir', 'rtl');
                choicePreview.style.textAlign = 'right';
                renderLivePreviewToElement(choiceTextarea, choicePreview);
                html += `<div class="live-preview" dir="rtl" style="text-align: right; margin-top: 4px;">${choicePreview.innerHTML}</div>`;
            } else {
                html += '<div style="color: #6c757d; font-style: italic; margin-top: 4px;">(No choice text)</div>';
            }
            
            html += `</div>`;
            
            // Actions column (edit pen)
            html += editPenHTML;
            
            html += `</div>`;
            return html;
        }

        // Render multiple choice or checkbox preview with distinct visual markers
        // MCQ: radio circle marker, single correct answer (UID-based)
        // Checkbox: checkbox square marker, multiple correct answers (UID-based)
        function renderMultipleChoicePreview(questionEl, questionType) {
            const choicesList = questionEl.querySelector('[id^="choices-list-"]');
            if (!choicesList) return '';
            
            const choices = choicesList.querySelectorAll('.choice-item');
            if (choices.length === 0) return '';
            
            const questionIndex = Array.from(document.querySelectorAll('#questions_container > .array-item')).indexOf(questionEl);
            const isMCQ = questionType === 'multiple_choice';
            const typeLabel = isMCQ ? 'Multiple Choice' : 'Checkbox (Multiple Answers)';
            
            // Get correct UIDs using canonical helpers
            const correctUidMCQ = isMCQ ? getCorrectChoiceUid(questionEl) : null;
            const correctUidsCheckbox = !isMCQ ? getCorrectChoiceUids(questionEl) : null;
            
            let html = `<div class="preview-section"><div class="choices-container"><h5 class="preview-section-label">Choices <span style="font-weight: normal; font-size: 0.8em; color: var(--text-secondary);">(${typeLabel})</span></h5>`;
            
            choices.forEach((choiceEl, index) => {
                const choiceUid = choiceEl.dataset.choiceUid || '';
                
                // Determine if this choice is correct using UID-based comparison
                let isCorrect = false;
                if (isMCQ) {
                    // MCQ: compare choice UID with the single correct UID
                    isCorrect = choiceUid && correctUidMCQ && choiceUid === correctUidMCQ;
                } else {
                    // Checkbox: check if choice UID is in the set of correct UIDs
                    isCorrect = choiceUid && correctUidsCheckbox && correctUidsCheckbox.has(choiceUid);
                }
                
                // Use shared helper to render choice row (ensures all choices have edit pens)
                html += renderChoiceRowPreview(choiceEl, questionIndex, index, isMCQ, isCorrect, correctUidMCQ, correctUidsCheckbox);
            });
            
            html += '</div></div>';
            
            // Guide answer section
            const choicesContainer = questionEl.querySelector('#choices-container');
            if (choicesContainer) {
                const guideAnswerTextarea = choicesContainer.querySelector('.guide-answer-notes');
                if (guideAnswerTextarea && guideAnswerTextarea.value && guideAnswerTextarea.value.trim()) {
                    const guidePreview = document.createElement('div');
                    guidePreview.className = 'live-preview';
                    guidePreview.setAttribute('dir', 'rtl');
                    guidePreview.style.textAlign = 'right';
                    renderLivePreviewToElement(guideAnswerTextarea, guidePreview);
                    html += buildPreviewBox({
                        title: 'Guide Answer',
                        editTarget: `navigateToInput(document.querySelectorAll('#questions_container > .array-item')[${questionIndex}].querySelector('#choices-container .guide-answer-notes'))`,
                        bodyHTML: `<div class="live-preview" dir="rtl" style="text-align: right;">${guidePreview.innerHTML}</div>`,
                        bodyClass: 'guide-answer'
                    });
                }
            }
            
            return html;
        }

        // Render fill in the blanks preview
        function renderFillInBlanksPreview(questionEl) {
            const blanksContainer = questionEl.querySelector('#blanks-container');
            if (!blanksContainer) return '';
            
            const blanksAnswersContainer = questionEl.querySelector('#blanks-answers-container');
            const questionTextarea = questionEl.querySelector('textarea[placeholder*="Enter question text"]');
            const questionText = questionTextarea ? questionTextarea.value || '' : '';
            
            const questionIndex = Array.from(document.querySelectorAll('#questions_container > .array-item')).indexOf(questionEl);
            let html = '';
            
            // Blank answers list (comes first)
            const blankAnswers = blanksContainer.querySelectorAll('.blank-answer-item');
            if (blankAnswers.length > 0) {
                html += '<div class="preview-section"><div class="blanks-container"><h5 class="preview-section-label">Answers</h5>';
                
                blankAnswers.forEach((blankEl, index) => {
                    const blankNumber = index + 1;
                    const blankTextarea = blankEl.querySelector('textarea');
                    const blankText = blankTextarea ? blankTextarea.value || '' : '';
                    
                    // Use same flex layout pattern as choice rows for consistency
                    const editTarget = `navigateToInput(document.querySelectorAll('#questions_container > .array-item')[${questionIndex}].querySelectorAll('#blanks-container .blank-answer-item')[${index}].querySelector('textarea'))`;
                    const editPenHTML = `<div class="preview-choice-actions" onclick="${editTarget}" onmouseover="this.style.opacity='1'; this.style.background='var(--bg-tertiary)';" onmouseout="this.style.opacity='0.7'; this.style.background='transparent';" title="Click to edit"><i class="fas fa-edit"></i></div>`;
                    
                    html += `<div class="preview-choice-row blank-answer">`;
                    html += `<div class="preview-choice-main">`;
                    html += `<span class="blank-number">Blank ${blankNumber}:</span> `;
                    
                    if (blankText) {
                        const blankPreview = document.createElement('div');
                        blankPreview.className = 'live-preview';
                        // Always RTL in final preview
                        blankPreview.setAttribute('dir', 'rtl');
                        blankPreview.style.textAlign = 'right';
                        renderLivePreviewToElement(blankTextarea, blankPreview);
                        html += `<div class="live-preview" dir="rtl" style="text-align: right; margin-top: 4px;">${blankPreview.innerHTML}</div>`;
                    } else {
                        html += '<span style="color: #6c757d; font-style: italic;">(No answer)</span>';
                    }
                    
                    html += `</div>`;
                    html += editPenHTML;
                    html += `</div>`;
                });
                
                html += '</div></div>';
            }
            
            // Add filled blanks preview (question text with answers inserted) - comes after Answers
            if (questionText && blanksAnswersContainer && typeof parseBlanksFromText === 'function') {
                const blankItems = blanksAnswersContainer.querySelectorAll('.blank-answer-item');
                const blankAnswersMap = {};
                
                blankItems.forEach(item => {
                    const blankNum = item.dataset.blankNumber;
                    const textarea = item.querySelector('.blank-answer-input');
                    if (textarea && blankNum) {
                        blankAnswersMap[blankNum] = textarea.value.trim();
                    }
                });
                
                const blanks = parseBlanksFromText(questionText);
                const allFilled = blanks.length > 0 && blanks.every(num => blankAnswersMap[num] && blankAnswersMap[num].trim());
                
                if (allFilled) {
                    // Replace blanks with answers
                    let filledText = questionText;
                    blanks.forEach(num => {
                        const answer = blankAnswersMap[num] || '';
                        const regex = new RegExp(`___${num}___`, 'g');
                        // Use the same styling as the input form preview
                        // Don't escape here - renderLivePreviewToElement will handle it properly
                        filledText = filledText.replace(regex, `<span style="display: inline-block; padding: 2px 6px; background: linear-gradient(135deg, #28a745 0%, #20c997 100%); color: white; border-radius: 3px; font-weight: 600; box-shadow: 0 1px 3px rgba(0,0,0,0.2);">${answer}</span>`);
                    });
                    
                    const filledPreview = document.createElement('div');
                    filledPreview.className = 'live-preview';
                    // Always RTL in final preview
                    filledPreview.setAttribute('dir', 'rtl');
                    filledPreview.style.textAlign = 'right';
                    
                    // Create temporary textarea to use renderLivePreviewToElement
                    const tempTextarea = document.createElement('textarea');
                    tempTextarea.value = filledText;
                    tempTextarea.setAttribute('dir', 'rtl');
                    renderLivePreviewToElement(tempTextarea, filledPreview);
                    
                    html += buildPreviewBox({
                        title: 'Preview with Answers',
                        editTarget: `navigateToInput(document.querySelectorAll('#questions_container > .array-item')[${questionIndex}].querySelector('textarea[placeholder*=\\'Enter question text\\']'))`,
                        bodyHTML: `<div class="live-preview" dir="rtl" style="text-align: right;">${filledPreview.innerHTML}</div>`
                    });
                }
            }
            
            // Guide answer - always RTL in final preview
            const guideAnswerTextarea = blanksContainer.querySelector('.guide-answer-notes');
            if (guideAnswerTextarea && guideAnswerTextarea.value && guideAnswerTextarea.value.trim()) {
                const guidePreview = document.createElement('div');
                guidePreview.className = 'live-preview';
                guidePreview.setAttribute('dir', 'rtl');
                guidePreview.style.textAlign = 'right';
                renderLivePreviewToElement(guideAnswerTextarea, guidePreview);
                html += buildPreviewBox({
                    title: 'Guide Answer',
                    editTarget: `navigateToInput(document.querySelectorAll('#questions_container > .array-item')[${questionIndex}].querySelector('#blanks-container .guide-answer-notes'))`,
                    bodyHTML: `<div class="live-preview" dir="rtl" style="text-align: right;">${guidePreview.innerHTML}</div>`,
                    bodyClass: 'guide-answer'
                });
            }
            
            return html;
        }

        // Helper: Render a single matching item as a preview box with rendered output
        // Reused for left items, right items, and relationship table cells
        function renderMatchingItemPreviewBox(questionIndex, side, itemIndex, itemText, textarea, options = {}) {
            const { compact = false, showTitle = true } = options;
            const label = side === 'left' ? `L${itemIndex + 1}` : `R${itemIndex + 1}`;
            const title = showTitle ? (side === 'left' ? `Left Item ${label}` : `Right Item ${label}`) : label;
            // List selector prefix (matching-left-list- or matching-right-list-)
            const listSelectorPrefix = side === 'left' ? 'matching-left-list-' : 'matching-right-list-';
            
            // Generate rendered preview of the item content
            let bodyHTML;
            if (textarea && itemText) {
                const previewEl = document.createElement('div');
                previewEl.className = 'live-preview';
                previewEl.setAttribute('dir', 'rtl');
                previewEl.style.textAlign = 'right';
                renderLivePreviewToElement(textarea, previewEl);
                bodyHTML = `<div class="live-preview" dir="rtl" style="text-align: right;">${previewEl.innerHTML}</div>`;
            } else {
                bodyHTML = '<div style="color: var(--text-secondary); font-style: italic;">(empty)</div>';
            }
            
            // Build editTarget: use escaped single quotes (\\') for attribute selectors
            // because the onclick attribute uses double quotes
            const editTarget = `navigateToInput(document.querySelectorAll('#questions_container > .array-item')[${questionIndex}].querySelector('[id^=\\'${listSelectorPrefix}\\'] .matching-item:nth-child(${itemIndex + 1}) textarea'))`;
            
            return buildPreviewBox({
                title: title,
                editTarget: editTarget,
                bodyHTML: bodyHTML,
                bodyClass: compact ? 'matching-item-compact' : 'setup-text'
            });
        }

        // Render matching preview - each item as its own preview box + relationships table with preview boxes
        function renderMatchingPreview(questionEl) {
            const matchingContainer = questionEl.querySelector('#matching-container');
            if (!matchingContainer) return '';
            
            const questionIndex = Array.from(document.querySelectorAll('#questions_container > .array-item')).indexOf(questionEl);
            
            // Step 1: Collect left and right items with UID-to-index mapping
            const leftList = matchingContainer.querySelector('[id^="matching-left-list-"]');
            const rightList = matchingContainer.querySelector('[id^="matching-right-list-"]');
            
            const leftItems = [];
            const rightItems = [];
            const leftUidToIdx = new Map();
            const rightUidToIdx = new Map();
            
            if (leftList) {
                leftList.querySelectorAll('.matching-item').forEach((el, i) => {
                    const ta = el.querySelector('textarea');
                    const uid = el.dataset.leftUid || '';
                    leftItems.push({ index: i, text: ta ? ta.value || '' : '', textarea: ta, uid });
                    if (uid) leftUidToIdx.set(uid, i);
                });
            }
            if (rightList) {
                rightList.querySelectorAll('.matching-item').forEach((el, i) => {
                    const ta = el.querySelector('textarea');
                    const uid = el.dataset.rightUid || '';
                    rightItems.push({ index: i, text: ta ? ta.value || '' : '', textarea: ta, uid });
                    if (uid) rightUidToIdx.set(uid, i);
                });
            }
            
            // Step 2: Extract relationships (UIDs from selects, map to indices)
            // Returns array of { leftIdx, rightIdx } pairs for many-to-many support
            const relationships = [];
            matchingContainer.querySelectorAll('.relationship-item').forEach(relEl => {
                const leftSelect = relEl.querySelector('.relationship-left');
                const rightSelect = relEl.querySelector('.relationship-right');
                if (!leftSelect || !rightSelect) return;
                
                const leftUid = leftSelect.value;
                const rightUid = rightSelect.value;
                if (!leftUid || !rightUid) return;
                
                const leftIdx = leftUidToIdx.get(leftUid);
                const rightIdx = rightUidToIdx.get(rightUid);
                
                if (leftIdx !== undefined) {
                    relationships.push({
                        leftIdx: leftIdx,
                        rightIdx: rightIdx !== undefined ? rightIdx : null,
                        isMissing: rightIdx === undefined
                    });
                }
            });
            
            let html = '';
            
            // Step 3: Render each LEFT item as its own preview box
            if (leftItems.length > 0) {
                html += '<div style="margin-bottom: 16px;">';
                html += '<h5 style="font-size: 0.9rem; margin: 0 0 8px 0; color: var(--text-secondary); text-transform: uppercase; font-weight: 600;">Left Items</h5>';
                leftItems.forEach((item, i) => {
                    html += renderMatchingItemPreviewBox(questionIndex, 'left', i, item.text, item.textarea);
                });
                html += '</div>';
            }
            
            // Step 4: Render each RIGHT item as its own preview box
            if (rightItems.length > 0) {
                html += '<div style="margin-bottom: 16px;">';
                html += '<h5 style="font-size: 0.9rem; margin: 0 0 8px 0; color: var(--text-secondary); text-transform: uppercase; font-weight: 600;">Right Items</h5>';
                rightItems.forEach((item, i) => {
                    html += renderMatchingItemPreviewBox(questionIndex, 'right', i, item.text, item.textarea);
                });
                html += '</div>';
            }
            
            // Step 5: Render Relationships table with preview boxes in each cell
            let relationshipsBodyHTML = '';
            if (relationships.length === 0) {
                relationshipsBodyHTML = '<p style="color: var(--text-secondary); font-style: italic;">No relationships defined yet.</p>';
            } else {
                relationshipsBodyHTML += '<table style="width: 100%; border-collapse: collapse; font-size: 0.9rem; border: 1px solid var(--border-color); border-radius: 4px;">';
                relationshipsBodyHTML += '<thead><tr style="background: var(--bg-tertiary);">';
                relationshipsBodyHTML += '<th style="padding: 8px 12px; text-align: left; border-bottom: 1px solid var(--border-color);">Left Item</th>';
                relationshipsBodyHTML += '<th style="padding: 8px 12px; text-align: center; border-bottom: 1px solid var(--border-color); width: 40px;"></th>';
                relationshipsBodyHTML += '<th style="padding: 8px 12px; text-align: left; border-bottom: 1px solid var(--border-color);">Right Item</th>';
                relationshipsBodyHTML += '</tr></thead><tbody>';
                
                relationships.forEach(rel => {
                    const leftItem = leftItems[rel.leftIdx];
                    relationshipsBodyHTML += '<tr style="background: var(--bg-secondary);">';
                    
                    // Left cell - embedded preview box (compact mode with just label as title)
                    if (leftItem) {
                        relationshipsBodyHTML += `<td style="padding: 4px; border-bottom: 1px solid var(--border-color);">`;
                        relationshipsBodyHTML += renderMatchingItemPreviewBox(questionIndex, 'left', rel.leftIdx, leftItem.text, leftItem.textarea, { compact: true, showTitle: false });
                        relationshipsBodyHTML += `</td>`;
                    } else {
                        relationshipsBodyHTML += '<td style="padding: 8px 12px; border-bottom: 1px solid var(--border-color); color: #dc3545; font-style: italic;">(missing item)</td>';
                    }
                    
                    // Arrow
                    relationshipsBodyHTML += `<td style="padding: 8px 12px; text-align: center; border-bottom: 1px solid var(--border-color); color: ${rel.isMissing ? 'var(--text-secondary)' : '#28a745'}; font-weight: bold;"></td>`;
                    
                    // Right cell - embedded preview box (compact mode)
                    if (rel.rightIdx !== null) {
                        const rightItem = rightItems[rel.rightIdx];
                        if (rightItem) {
                            relationshipsBodyHTML += `<td style="padding: 4px; border-bottom: 1px solid var(--border-color);">`;
                            relationshipsBodyHTML += renderMatchingItemPreviewBox(questionIndex, 'right', rel.rightIdx, rightItem.text, rightItem.textarea, { compact: true, showTitle: false });
                            relationshipsBodyHTML += `</td>`;
                        } else {
                            relationshipsBodyHTML += '<td style="padding: 8px 12px; border-bottom: 1px solid var(--border-color); color: #dc3545; font-style: italic;">(missing item)</td>';
                        }
                    } else {
                        relationshipsBodyHTML += '<td style="padding: 8px 12px; border-bottom: 1px solid var(--border-color); color: #dc3545; font-style: italic;">(missing item)</td>';
                    }
                    
                    relationshipsBodyHTML += '</tr>';
                });
                
                relationshipsBodyHTML += '</tbody></table>';
            }
            
            html += buildPreviewBox({
                title: 'Relationships',
                editTarget: null, // Table only - individual items have their own pen icons
                bodyHTML: relationshipsBodyHTML,
                bodyClass: 'matching-container'
            });
            
            // Guide answer section
            const guideAnswerTextarea = matchingContainer.querySelector('.guide-answer-notes');
            if (guideAnswerTextarea && guideAnswerTextarea.value && guideAnswerTextarea.value.trim()) {
                const guidePreview = document.createElement('div');
                guidePreview.className = 'live-preview';
                guidePreview.setAttribute('dir', 'rtl');
                guidePreview.style.textAlign = 'right';
                renderLivePreviewToElement(guideAnswerTextarea, guidePreview);
                html += buildPreviewBox({
                    title: 'Guide Answer',
                    editTarget: `navigateToInput(document.querySelectorAll('#questions_container > .array-item')[${questionIndex}].querySelector('#matching-container .guide-answer-notes'))`,
                    bodyHTML: `<div class="live-preview" dir="rtl" style="text-align: right;">${guidePreview.innerHTML}</div>`,
                    bodyClass: 'guide-answer'
                });
            }
            
            return html;
        }

        // Render guide answer preview (for free_form, annotate, create_table)
        function renderGuideAnswerPreview(questionEl, questionType) {
            // Check all possible locations for guide answer
            let guideAnswerTextarea = null;
            
            // First, check in #guide-answer-container (for multiple_choice, checkbox, free_form, annotate, create_table)
            const guideAnswerContainer = questionEl.querySelector('#guide-answer-container');
            if (guideAnswerContainer) {
                guideAnswerTextarea = guideAnswerContainer.querySelector('textarea');
            }
            
            // If not found, check in blanks container (for fill_in_the_blanks)
            if (!guideAnswerTextarea) {
                const blanksContainer = questionEl.querySelector('#blanks-container');
                if (blanksContainer) {
                    guideAnswerTextarea = blanksContainer.querySelector('.guide-answer-notes');
                }
            }
            
            // If not found, check in matching container (for matching)
            if (!guideAnswerTextarea) {
                const matchingContainer = questionEl.querySelector('#matching-container');
                if (matchingContainer) {
                    guideAnswerTextarea = matchingContainer.querySelector('.guide-answer-notes');
                }
            }
            
            if (!guideAnswerTextarea || !guideAnswerTextarea.value || !guideAnswerTextarea.value.trim()) {
                return '';
            }
            
            const guidePreview = document.createElement('div');
            guidePreview.className = 'live-preview';
            // Always RTL in final preview
            guidePreview.setAttribute('dir', 'rtl');
            guidePreview.style.textAlign = 'right';
            renderLivePreviewToElement(guideAnswerTextarea, guidePreview);
            
            // Find the selector for the guide answer textarea
            const questionIndex = Array.from(document.querySelectorAll('#questions_container > .array-item')).indexOf(questionEl);
            let guideSelector = '';
            if (questionEl.querySelector('#guide-answer-container textarea')) {
                guideSelector = '#guide-answer-container textarea';
            } else if (questionEl.querySelector('#blanks-container .guide-answer-notes')) {
                guideSelector = '#blanks-container .guide-answer-notes';
            } else if (questionEl.querySelector('#matching-container .guide-answer-notes')) {
                guideSelector = '#matching-container .guide-answer-notes';
            }
            
            return buildPreviewBox({
                title: 'Guide Answer',
                editTarget: `navigateToInput(document.querySelectorAll('#questions_container > .array-item')[${questionIndex}].querySelector('${guideSelector}'))`,
                bodyHTML: `<div class="live-preview" dir="rtl" style="text-align: right;">${guidePreview.innerHTML}</div>`,
                bodyClass: 'guide-answer'
            });
        }

        // Quick jump functionality
        function quickJumpTo(value) {
            if (!value) return;
            
            // Check if it's a main tab
            if (['basic', 'preamble', 'content', 'questions'].includes(value)) {
                // Switch to input form tab first
                showMainTab('input-form');
                setTimeout(() => {
                    showTab(value);
                }, 100);
            } else if (value.startsWith('content-') || value.startsWith('question-')) {
                // Jump to specific section using canonical section ID lookup
                const isContent = value.startsWith('content-');
                showMainTab('input-form');
                setTimeout(() => {
                    showTab(isContent ? 'content' : 'questions');
                    setTimeout(() => {
                        // Use canonical section marker lookup (strict - only sections with data-section-id)
                        const container = isContent 
                            ? document.getElementById('content_sections_container')
                            : document.getElementById('questions_container');
                        
                        if (!container) return; // Guard: container not found
                        
                        // Look up by data-section-id (canonical marker)
                        const element = container.querySelector(`[data-section-id="${value}"]`);
                        
                        // Verify it's a valid section (not a nested element)
                        if (element && isValidSection(element)) {
                            // Use universal scroll helper to scroll to top with sticky offset
                            scrollElementToTop(element);
                            // Highlight briefly
                            element.style.backgroundColor = '#fff3cd';
                            setTimeout(() => element.style.backgroundColor = '', 2000);
                        }
                        // If not found or invalid, do nothing (no console errors, no fallback)
                    }, 100);
                }, 100);
            }
            
            // Reset select
            const quickJumpSelect = document.getElementById('quickJumpSelect');
            if (quickJumpSelect) {
                quickJumpSelect.value = '';
            }
        }



        // Search/Filter functionality
        // Helper function to get context around a match
        function getContextPreview(text, searchTerm, maxLength = 100) {
            const lowerText = text.toLowerCase();
            const lowerTerm = searchTerm.toLowerCase();
            const index = lowerText.indexOf(lowerTerm);
            
            if (index === -1) {
                // If exact match not found, return first part of text
                return text.substring(0, maxLength) + (text.length > maxLength ? '...' : '');
            }
            
            // Get context around the match
            const start = Math.max(0, index - 30);
            const end = Math.min(text.length, index + searchTerm.length + 30);
            let preview = text.substring(start, end);
            
            // Highlight the match
            const matchIndex = preview.toLowerCase().indexOf(lowerTerm);
            if (matchIndex !== -1) {
                const before = preview.substring(0, matchIndex);
                const match = preview.substring(matchIndex, matchIndex + searchTerm.length);
                const after = preview.substring(matchIndex + searchTerm.length);
                preview = before + '<span class="highlight">' + escapeHtml(match) + '</span>' + after;
            }
            
            // Add ellipsis if needed
            if (start > 0) preview = '...' + preview;
            if (end < text.length) preview = preview + '...';
            
            return preview;
        }
        
        // Helper function to clear search highlights without clearing the input
        function clearSearchHighlights() {
            const contentSections = document.querySelectorAll('#content_sections_container .array-item');
            const questions = document.querySelectorAll('#questions_container .array-item');
            
            // Remove highlighting from content sections
            contentSections.forEach(section => {
                section.style.display = '';
                section.style.border = '';
                section.style.borderRadius = '';
                section.style.padding = '';
                section.style.marginBottom = '';
                section.style.backgroundColor = '';
            });
            
            // Remove highlighting from questions
            questions.forEach(question => {
                question.style.display = '';
                question.style.border = '';
                question.style.borderRadius = '';
                question.style.padding = '';
                question.style.marginBottom = '';
                question.style.backgroundColor = '';
            });
        }
        
        // Helper function to jump to an element
        function jumpToElement(element) {
            if (!element) return;
            
            // Determine which tab the element belongs to and switch if needed
            const contentContainer = document.getElementById('content_sections_container');
            const questionsContainer = document.getElementById('questions_container');
            
            if (contentContainer && contentContainer.contains(element)) {
                // Element is in content sections - switch to content tab
                showTab('content');
            } else if (questionsContainer && questionsContainer.contains(element)) {
                // Element is in questions - switch to questions tab
                showTab('questions');
            }
            
            // Remove any existing highlights (but keep search input)
            clearSearchHighlights();
            
            // Show the element if it's hidden
            element.style.display = '';
            
            // Wait a moment for tab switch to complete, then scroll
            setTimeout(() => {
                element.scrollIntoView({ behavior: 'smooth', block: 'center' });
                
                // Highlight briefly
                const originalBorder = element.style.border;
                const originalBg = element.style.backgroundColor;
                element.style.border = '3px solid var(--accent)';
                element.style.borderRadius = '8px';
                element.style.padding = '15px';
                element.style.backgroundColor = 'rgba(102, 126, 234, 0.1)';
                element.style.transition = 'all 0.3s';
                
                setTimeout(() => {
                    element.style.border = originalBorder;
                    element.style.borderRadius = '';
                    element.style.padding = '';
                    element.style.backgroundColor = originalBg;
                }, 2000);
            }, 100);
            
            // Close dropdown
            const dropdown = document.getElementById('searchResultsDropdown');
            if (dropdown) {
                dropdown.style.display = 'none';
            }
        }
        
        let searchDropdownSelectedIndex = -1;
        
        function performSearch(searchTerm) {
            const term = searchTerm.trim();
            const clearBtn = document.getElementById('clearSearchBtn');
            const dropdown = document.getElementById('searchResultsDropdown');
            const resultsCount = document.getElementById('searchResultsCount');
            
            // Show/hide clear button
            if (term.length > 0) {
                clearBtn.style.display = 'block';
            } else {
                clearBtn.style.display = 'none';
            }
            
            if (term.length === 0) {
                // Clear search - show all items
                clearSearch();
                if (dropdown) dropdown.style.display = 'none';
                if (resultsCount) resultsCount.style.display = 'none';
                return;
            }
            
            const results = [];
            const lowerTerm = term.toLowerCase();
            
            // Search content sections
            const contentSections = document.querySelectorAll('#content_sections_container .array-item');
            contentSections.forEach((section, index) => {
                const sectionTitle = section.querySelector('input[placeholder*="Section title"]')?.value || '';
                const sectionContent = section.querySelector('textarea[placeholder*="Enter content"]')?.value || '';
                
                const sectionNumber = index + 1;
                
                // Check section title separately
                if (sectionTitle.toLowerCase().includes(lowerTerm)) {
                    results.push({
                        type: 'Content Title',
                        title: `Content Section ${sectionNumber}`,
                        preview: getContextPreview(sectionTitle, term),
                        element: section,
                        index: sectionNumber
                    });
                }
                
                // Check section content separately
                if (sectionContent.toLowerCase().includes(lowerTerm)) {
                    results.push({
                        type: 'Content Text',
                        title: `Content Section ${sectionNumber}`,
                        preview: getContextPreview(sectionContent, term),
                        element: section,
                        index: sectionNumber
                    });
                }
            });
            
            // Search questions
            const questionsContainer = document.getElementById('questions_container');
            if (questionsContainer) {
                const questions = questionsContainer.querySelectorAll('.array-item');
                questions.forEach((question, index) => {
                    const questionIdInput = question.querySelector('input[placeholder*="e.g., 1"]');
                    const questionId = questionIdInput?.value || '';
                    const questionText = question.querySelector('textarea[placeholder*="Enter question text"]')?.value || '';
                    const setupText = question.querySelector('textarea[placeholder*="Text shared across"]')?.value || '';
                    const guideAnswer = question.querySelector('textarea[placeholder*="Enter guide answer"]')?.value || '';
                    const guideAnswerNotes = question.querySelector('.guide-answer-notes')?.value || '';
                    
                    const qType = getQuestionType(question) || '';
                    const typeLabel = qType === 'multiple_choice' ? 'MCQ' : qType === 'checkbox' ? 'Checkbox' : qType === 'fill_in_the_blanks' ? 'Fill-in-Blanks' : qType === 'matching' ? 'Matching' : 'Question';
                    
                    // Get question number - use ID if available, otherwise use index + 1
                    const questionNumber = questionId || String(index + 1);
                    const questionTitle = `Question ${questionNumber}`;
                    
                    // Check each field separately and create results for each match
                    // Priority order: Question ID, Question Text, Setup Text, Guide Answer, Choices
                    
                    if (questionId.toLowerCase().includes(lowerTerm)) {
                        results.push({
                            type: typeLabel,
                            title: questionTitle + ' (ID)',
                            preview: getContextPreview(questionId, term),
                            element: question,
                            index: index + 1
                        });
                    }
                    
                    if (questionText.toLowerCase().includes(lowerTerm)) {
                        results.push({
                            type: typeLabel,
                            title: questionTitle + ' (Question)',
                            preview: getContextPreview(questionText, term),
                            element: question,
                            index: index + 1
                        });
                    }
                    
                    if (setupText.toLowerCase().includes(lowerTerm)) {
                        results.push({
                            type: typeLabel,
                            title: questionTitle + ' (Setup)',
                            preview: getContextPreview(setupText, term),
                            element: question,
                            index: index + 1
                        });
                    }
                    
                    if (guideAnswer.toLowerCase().includes(lowerTerm)) {
                        results.push({
                            type: typeLabel,
                            title: questionTitle + ' (Answer)',
                            preview: getContextPreview(guideAnswer, term),
                            element: question,
                            index: index + 1
                        });
                    }
                    
                    if (guideAnswerNotes && guideAnswerNotes.toLowerCase().includes(lowerTerm)) {
                        results.push({
                            type: typeLabel,
                            title: questionTitle + ' (Answer Notes)',
                            preview: getContextPreview(guideAnswerNotes, term),
                            element: question,
                            index: index + 1
                        });
                    }
                    
                    // Check each choice individually - only for MCQ and Checkbox questions
                    if (qType === 'multiple_choice' || qType === 'checkbox') {
                        const choiceTextareas = question.querySelectorAll('.choice-text');
                        choiceTextareas.forEach((choiceTextarea, choiceIndex) => {
                            const choiceText = choiceTextarea.value || '';
                            if (choiceText.toLowerCase().includes(lowerTerm)) {
                                // Get choice ID if available
                                const choiceItem = choiceTextarea.closest('.choice-item');
                                const choiceIdInput = choiceItem?.querySelector('.choice-id');
                                const choiceId = choiceIdInput?.value || String.fromCharCode(65 + choiceIndex); // A, B, C, etc.
                                
                                results.push({
                                    type: typeLabel,
                                    title: questionTitle + ` (Choice ${choiceId})`,
                                    preview: getContextPreview(choiceText, term),
                                    element: question,
                                    index: index + 1
                                });
                            }
                        });
                    }
                    
                    // Check blank answers for fill-in-the-blanks questions
                    if (qType === 'fill_in_the_blanks') {
                        // Check guide answer (optional) for fill-in-the-blanks
                        const blanksContainer = question.querySelector('#blanks-container');
                        const blanksGuideAnswer = blanksContainer?.querySelector('.guide-answer-notes');
                        if (blanksGuideAnswer) {
                            const blanksGuideAnswerText = blanksGuideAnswer.value || '';
                            if (blanksGuideAnswerText.toLowerCase().includes(lowerTerm)) {
                                results.push({
                                    type: typeLabel,
                                    title: questionTitle + ' (Answer Notes)',
                                    preview: getContextPreview(blanksGuideAnswerText, term),
                                    element: question,
                                    index: index + 1
                                });
                            }
                        }
                        
                        // Check individual blank answers
                        const blankItems = question.querySelectorAll('.blank-answer-item');
                        blankItems.forEach((blankItem, blankIndex) => {
                            const blankInput = blankItem.querySelector('.blank-answer-input');
                            if (blankInput) {
                                const blankText = blankInput.value || '';
                                if (blankText.toLowerCase().includes(lowerTerm)) {
                                    results.push({
                                        type: typeLabel,
                                        title: questionTitle + ` (Blank ${blankIndex + 1})`,
                                        preview: getContextPreview(blankText, term),
                                        element: question,
                                        index: index + 1
                                    });
                                }
                            }
                        });
                    }
                    
                    // Check matching left and right items
                    if (qType === 'matching') {
                        // Check guide answer (optional) for matching questions
                        const matchingContainer = question.querySelector('#matching-container');
                        const matchingGuideAnswer = matchingContainer?.querySelector('.guide-answer-notes');
                        if (matchingGuideAnswer) {
                            const matchingGuideAnswerText = matchingGuideAnswer.value || '';
                            if (matchingGuideAnswerText.toLowerCase().includes(lowerTerm)) {
                                results.push({
                                    type: typeLabel,
                                    title: questionTitle + ' (Answer Notes)',
                                    preview: getContextPreview(matchingGuideAnswerText, term),
                                    element: question,
                                    index: index + 1
                                });
                            }
                        }
                        
                        const leftList = question.querySelector('[id^="matching-left-list-"]');
                        const rightList = question.querySelector('[id^="matching-right-list-"]');
                        
                        // Check left items
                        if (leftList) {
                            const leftItems = leftList.querySelectorAll('.matching-item');
                            leftItems.forEach((leftItem, leftIndex) => {
                                const leftTextarea = leftItem.querySelector('.matching-item-text');
                                if (leftTextarea) {
                                    const leftText = leftTextarea.value || '';
                                    if (leftText.toLowerCase().includes(lowerTerm)) {
                                        results.push({
                                            type: typeLabel,
                                            title: questionTitle + ` (Left ${leftIndex + 1})`,
                                            preview: getContextPreview(leftText, term),
                                            element: question,
                                            index: index + 1
                                        });
                                    }
                                }
                            });
                        }
                        
                        // Check right items
                        if (rightList) {
                            const rightItems = rightList.querySelectorAll('.matching-item');
                            rightItems.forEach((rightItem, rightIndex) => {
                                const rightTextarea = rightItem.querySelector('.matching-item-text');
                                if (rightTextarea) {
                                    const rightText = rightTextarea.value || '';
                                    if (rightText.toLowerCase().includes(lowerTerm)) {
                                        results.push({
                                            type: typeLabel,
                                            title: questionTitle + ` (Right ${rightIndex + 1})`,
                                            preview: getContextPreview(rightText, term),
                                            element: question,
                                            index: index + 1
                                        });
                                    }
                                }
                            });
                        }
                    }
                });
            }
            
            // Update results count
            if (resultsCount) {
                if (results.length > 0) {
                    resultsCount.textContent = `${results.length} result${results.length !== 1 ? 's' : ''}`;
                    resultsCount.style.display = 'block';
                } else {
                    resultsCount.style.display = 'none';
                    }
            }
            
            // Build dropdown HTML
            if (dropdown) {
                if (results.length === 0) {
                    dropdown.innerHTML = '<div class="search-result-empty">No results found</div>';
                    dropdown.style.display = 'block';
                } else {
                    dropdown.innerHTML = results.map((result, idx) => `
                        <div class="search-result-item" data-index="${idx}" onmousedown="event.preventDefault(); jumpToSearchResult(${idx})" onmouseenter="highlightSearchResult(${idx})">
                            <div class="search-result-header">
                                <span class="search-result-type">${escapeHtml(result.type)}</span>
                                <span>${escapeHtml(result.title)}</span>
                            </div>
                            <div class="search-result-preview">${result.preview}</div>
                        </div>
                    `).join('');
                    dropdown.style.display = 'block';
                    searchDropdownSelectedIndex = -1;
                }
            }
            
            // Store results globally for keyboard navigation
            window.searchResults = results;
        }
        
        function jumpToSearchResult(index) {
            if (window.searchResults && window.searchResults[index]) {
                const result = window.searchResults[index];
                jumpToElement(result.element);
                // Keep the search input focused, don't clear it, and keep dropdown open
                const searchInput = document.getElementById('searchFilter');
                const dropdown = document.getElementById('searchResultsDropdown');
                if (searchInput) {
                    // Use mousedown instead of click to prevent blur from firing first
                    setTimeout(() => {
                        searchInput.focus();
                        if (dropdown && searchInput.value.trim().length > 0) {
                            dropdown.style.display = 'block';
                        }
                    }, 100);
                }
            }
        }
        
        function highlightSearchResult(index) {
            const items = document.querySelectorAll('.search-result-item');
            items.forEach((item, idx) => {
                if (idx === index) {
                    item.classList.add('highlighted');
                } else {
                    item.classList.remove('highlighted');
                }
            });
            searchDropdownSelectedIndex = index;
        }
        
        function handleSearchFocus() {
            const searchInput = document.getElementById('searchFilter');
            const dropdown = document.getElementById('searchResultsDropdown');
            if (searchInput && searchInput.value.trim().length > 0 && dropdown) {
                dropdown.style.display = 'block';
            }
        }
        
        function handleSearchBlur() {
            // Delay hiding dropdown to allow clicks on results
            // Don't hide if clicking on a result item
            setTimeout(() => {
                const dropdown = document.getElementById('searchResultsDropdown');
                const searchInput = document.getElementById('searchFilter');
                if (dropdown && searchInput && document.activeElement !== searchInput) {
                    // Check if focus moved to a result item
                    const activeElement = document.activeElement;
                    if (!activeElement || !activeElement.closest('.search-results-dropdown')) {
                        dropdown.style.display = 'none';
                    }
                }
            }, 200);
        }
        
        function handleSearchKeydown(event) {
            const dropdown = document.getElementById('searchResultsDropdown');
            if (!dropdown || dropdown.style.display === 'none' || !window.searchResults) {
                return;
            }
            
            const items = document.querySelectorAll('.search-result-item');
            
            if (event.key === 'ArrowDown') {
                event.preventDefault();
                searchDropdownSelectedIndex = Math.min(searchDropdownSelectedIndex + 1, items.length - 1);
                highlightSearchResult(searchDropdownSelectedIndex);
                items[searchDropdownSelectedIndex]?.scrollIntoView({ block: 'nearest' });
            } else if (event.key === 'ArrowUp') {
                event.preventDefault();
                searchDropdownSelectedIndex = Math.max(searchDropdownSelectedIndex - 1, -1);
                if (searchDropdownSelectedIndex >= 0) {
                    highlightSearchResult(searchDropdownSelectedIndex);
                    items[searchDropdownSelectedIndex]?.scrollIntoView({ block: 'nearest' });
                } else {
                    items.forEach(item => item.classList.remove('highlighted'));
                }
            } else if (event.key === 'Enter' && searchDropdownSelectedIndex >= 0) {
                event.preventDefault();
                jumpToSearchResult(searchDropdownSelectedIndex);
            } else if (event.key === 'Escape') {
                dropdown.style.display = 'none';
                searchDropdownSelectedIndex = -1;
            }
        }

        function clearSearch() {
            const searchInput = document.getElementById('searchFilter');
            const clearBtn = document.getElementById('clearSearchBtn');
            const dropdown = document.getElementById('searchResultsDropdown');
            const resultsCount = document.getElementById('searchResultsCount');
            
            if (searchInput) {
                searchInput.value = '';
            }
            clearBtn.style.display = 'none';
            
            if (dropdown) {
                dropdown.style.display = 'none';
            }
            
            if (resultsCount) {
                resultsCount.style.display = 'none';
            }
            
            // Clear stored results
            window.searchResults = [];
            searchDropdownSelectedIndex = -1;
            
            // Remove highlighting and show all items
            const contentSections = document.querySelectorAll('#content_sections_container .array-item');
            contentSections.forEach(section => {
                section.style.display = '';
                section.style.border = '';
                section.style.borderRadius = '';
                section.style.padding = '';
                section.style.marginBottom = '';
                section.style.backgroundColor = '';
            });
            
            const questionsContainer = document.getElementById('questions_container');
            if (questionsContainer) {
                const questions = questionsContainer.querySelectorAll('.array-item');
                questions.forEach(question => {
                    question.style.display = '';
                    question.style.border = '';
                    question.style.borderRadius = '';
                    question.style.padding = '';
                    question.style.marginBottom = '';
                    question.style.backgroundColor = '';
                });
            }
        }
        
        // Scroll to top function
        function scrollToTop() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
            // Also scroll the left column (form section) to the top
            const leftColumn = document.querySelector('.form-section:not(.toggle-section)');
            if (leftColumn) {
                leftColumn.scrollTo({ top: 0, behavior: 'smooth' });
            }
        }

        // ========================================
        // CANONICAL SECTION REGISTRY
        // ========================================
        // Single source of truth for section navigation
        // Only true top-level sections are registered (not nested bbox/choice elements)
        
        /**
         * Check if an element is a true top-level section (not nested)
         * @param {HTMLElement} element - Element to check
         * @returns {boolean} True if element is a valid section
         */
        function isValidSection(element) {
            if (!element) return false;
            
            // Must have data-section-id marker (canonical section marker)
            if (!element.hasAttribute('data-section-id')) return false;
            
            // Must be a direct child of a section container (structural requirement)
            const isDirectChild = element.parentElement && (
                element.parentElement.id === 'content_sections_container' ||
                element.parentElement.id === 'questions_container'
            );
            if (!isDirectChild) return false;
            
            // Must be an .array-item (structural requirement)
            if (!element.classList.contains('array-item')) return false;
            
            // Hard guard: explicitly exclude if this element is itself a nested item
            // (e.g., a bbox row or choice item that somehow got a data-section-id)
            // Check if this element is inside a nested container (not a direct child of the main container)
            const parent = element.parentElement;
            if (parent && parent.id !== 'content_sections_container' && parent.id !== 'questions_container') {
                // If parent is not a main container, this is nested
                return false;
            }
            
            // Additional guard: ensure section ID format is correct
            const sectionId = element.getAttribute('data-section-id');
            if (!sectionId || (!sectionId.startsWith('content-') && !sectionId.startsWith('question-'))) {
                return false;
            }
            
            return true;
        }
        
        /**
         * Ensure all existing sections have data-section-id markers
         * Called when building the registry to mark any sections that were created before markers were added
         */
        function ensureSectionMarkers() {
            // Mark content sections
            const contentSections = document.querySelectorAll('#content_sections_container > .array-item');
            contentSections.forEach((section, index) => {
                if (!section.hasAttribute('data-section-id')) {
                    section.setAttribute('data-section-id', `content-${index + 1}`);
                }
            });
            
            // Mark questions
            const questions = document.querySelectorAll('#questions_container > .array-item');
            questions.forEach((question, index) => {
                if (!question.hasAttribute('data-section-id')) {
                    question.setAttribute('data-section-id', `question-${index + 1}`);
                }
            });
        }
        
        /**
         * Collect all valid sections for navigation (canonical registry builder)
         * @returns {Object} { contentSections: Array, questions: Array }
         */
        function collectValidSections() {
            // Ensure all sections have markers
            ensureSectionMarkers();
            
            // Collect content sections using canonical marker
            const contentSections = Array.from(document.querySelectorAll('#content_sections_container > [data-section-id]'))
                .filter(isValidSection);
            
            // Collect questions using canonical marker
            const questions = Array.from(document.querySelectorAll('#questions_container > [data-section-id]'))
                .filter(isValidSection);
            
            return { contentSections, questions };
        }
        
        // Update quick jump menu with dynamic content
        function updateQuickJumpMenu() {
            const contentGroup = document.getElementById('contentSectionsGroup');
            const questionsGroup = document.getElementById('questionsGroup');
            
            if (!contentGroup || !questionsGroup) return; // Guard: elements not found
            
            // Clear existing options
            contentGroup.innerHTML = '';
            questionsGroup.innerHTML = '';
            
            // Use canonical section collector
            const { contentSections, questions } = collectValidSections();
            
            // Add content sections
            contentSections.forEach((section) => {
                const sectionId = section.getAttribute('data-section-id');
                if (!sectionId) return; // Guard: missing ID
                
                const titleInput = section.querySelector('input[placeholder="Section title"]');
                const title = titleInput ? titleInput.value.trim() : '';
                const displayTitle = title || `Section ${sectionId.replace('content-', '')}`;
                
                const option = document.createElement('option');
                option.value = sectionId;
                option.textContent = `${displayTitle.substring(0, 30)}${displayTitle.length > 30 ? '...' : ''}`;
                contentGroup.appendChild(option);
            });
            
            // Add questions
            questions.forEach((question) => {
                const sectionId = question.getAttribute('data-section-id');
                if (!sectionId) return; // Guard: missing ID
                
                const questionIdInput = findFieldByLabel(question, 'Question ID', 'input');
                const title = questionIdInput ? questionIdInput.value.trim() : '';
                const displayTitle = title || `Question ${sectionId.replace('question-', '')}`;
                
                const option = document.createElement('option');
                option.value = sectionId;
                option.textContent = `${displayTitle.substring(0, 30)}${displayTitle.length > 30 ? '...' : ''}`;
                questionsGroup.appendChild(option);
            });
        }

        // Field validation system
        function validateField(field) {
            // Defensive guard: if field is null or removed from DOM, return safely
            if (!field || !field.parentNode) {
                return true;
            }
            
            const formGroup = field.closest('.form-group');
            // Defensive guard: if formGroup is null, field may not be in a form-group context
            if (!formGroup) {
                return true;
            }
            
            const value = field.value.trim();
            const isRequired = formGroup.classList.contains('required');
            
            // Remove existing validation classes
            formGroup.classList.remove('valid', 'invalid');
            
            // Remove existing validation messages
            const existingMessage = formGroup.querySelector('.validation-message');
            if (existingMessage) {
                existingMessage.remove();
            }
            
            let isValid = true;
            let message = '';
            
            // Check if required field is empty
            if (isRequired && !value) {
                isValid = false;
                message = 'This field is required';
            }
            
            // Specific validation rules
            if (value) {
                // Number validation
                if (field.type === 'number' && isNaN(field.value)) {
                    isValid = false;
                    message = 'Please enter a valid number';
                }
                
                // Email validation (if applicable)
                if (field.type === 'email' && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value)) {
                    isValid = false;
                    message = 'Please enter a valid email address';
                }
            }
            
            // Apply validation state (green checkmark removed per user request)
            if (isValid && value) {
                // formGroup.classList.add('valid'); // Removed - no green checkmark
            } else if (!isValid) {
                formGroup.classList.add('invalid');
                
                // Add validation message
                const messageDiv = document.createElement('div');
                messageDiv.className = 'validation-message error';
                messageDiv.textContent = message;
                formGroup.appendChild(messageDiv);
            }
            
            return isValid;
        }


        // Initialize field validation
        function initializeFieldValidation() {
            // Mark required fields
            const requiredFields = [
                '#textbook_page',
                '#textbook_pdf_page',
                '#guidebook_start_page',
                '#guidebook_end_page',
                '#page_type'
            ];
            
            requiredFields.forEach(selector => {
                const field = document.querySelector(selector);
                if (field) {
                    const formGroup = field.closest('.form-group');
                    if (formGroup) {
                    formGroup.classList.add('required');
                    }
                }
            });
            
            // Attach validation listeners
            document.querySelectorAll('input, textarea, select').forEach(field => {
                // Skip search input - it shouldn't trigger validation or auto-save
                if (field.id === 'searchFilter') return;
                
                field.addEventListener('blur', () => validateField(field));
                field.addEventListener('input', () => {
                    // Debounced validation for better performance
                    clearTimeout(field.validationTimeout);
                    field.validationTimeout = setTimeout(() => validateField(field), 500);
                });
            });
        }

        // Validate integer input and prevent invalid characters
        function validateInteger(input) {
            const value = input.value;
            
            // Remove any non-digit characters (except for empty string)
            if (value && !/^\d+$/.test(value)) {
                input.value = value.replace(/[^\d]/g, '');
            }
            
            // Add visual feedback (validation-success removed per user request)
            if (value && /^\d+$/.test(value)) {
                input.classList.remove('validation-error');
                // Green checkmark removed - no longer adding validation-success class
            } else if (value) {
                input.classList.add('validation-error');
            } else {
                input.classList.remove('validation-error');
            }
        }

        // Normalize and validate bbox coordinates to ensure top-right to bottom-left format
        // Format: [[x0, y0], [x1, y1]] where [x0, y0] is top-right and [x1, y1] is bottom-left
        // This means: x0 > x1 (right > left) and y0 < y1 (top < bottom)
        function normalizeBboxCoordinates(x0, y0, x1, y1) {
            // Parse as integers
            const x0Val = parseInt(x0);
            const y0Val = parseInt(y0);
            const x1Val = parseInt(x1);
            const y1Val = parseInt(y1);
            
            // Check if all values are valid numbers
            if (isNaN(x0Val) || isNaN(y0Val) || isNaN(x1Val) || isNaN(y1Val)) {
                return null; // Invalid input
            }
            
            // Determine the actual top, bottom, left, right values
            const top = Math.min(y0Val, y1Val);
            const bottom = Math.max(y0Val, y1Val);
            const left = Math.min(x0Val, x1Val);
            const right = Math.max(x0Val, x1Val);
            
            // Return in the correct format: [top-right, bottom-left]
            return {
                x0: right,  // top-right X (larger X)
                y0: top,    // top-right Y (smaller Y)
                x1: left,   // bottom-left X (smaller X)
                y1: bottom  // bottom-left Y (larger Y)
            };
        }

        // Validate and normalize bbox inputs when user finishes entering data
        function validateAndNormalizeBbox(bboxInputsContainer) {
            const inputs = bboxInputsContainer.querySelectorAll('.bbox-inputs input');
            if (inputs.length < 5) return;
            
            const page = inputs[0].value;
            const x0 = inputs[1].value;
            const y0 = inputs[2].value;
            const x1 = inputs[3].value;
            const y1 = inputs[4].value;
            
            // Only validate if all coordinate fields have values (page can be empty for some cases)
            if (!x0 || !y0 || !x1 || !y1) return;
            
            const normalized = normalizeBboxCoordinates(x0, y0, x1, y1);
            if (!normalized) return;
            
            // Check if normalization changed the values
            const changed = (
                parseInt(x0) !== normalized.x0 ||
                parseInt(y0) !== normalized.y0 ||
                parseInt(x1) !== normalized.x1 ||
                parseInt(y1) !== normalized.y1
            );
            
            if (changed) {
                // Update the input values with normalized coordinates
                inputs[1].value = normalized.x0;
                inputs[2].value = normalized.y0;
                inputs[3].value = normalized.x1;
                inputs[4].value = normalized.y1;
                
                // Provide visual feedback
                inputs[1].style.background = '#fff3cd';
                inputs[2].style.background = '#fff3cd';
                inputs[3].style.background = '#fff3cd';
                inputs[4].style.background = '#fff3cd';
                
                // Clear the highlight after 1 second
                setTimeout(() => {
                    inputs[1].style.background = '';
                    inputs[2].style.background = '';
                    inputs[3].style.background = '';
                    inputs[4].style.background = '';
                }, 1000);
                
            }
        }

        function addQuestion() {
            addOrInsertSection({
                containerId: 'questions_container',
                builderFn: (count) => buildQuestionItem(count, { setDataset: true }),
                position: 'end',
                setupFn: setupQuestionDirections,
                captureSnapshot: true,
                snapshotFn: serializeQuestionState
            });
        }

        function toggleQuestionType(selectElement) {
            const questionEl = selectElement.closest('.array-item');
            if (!questionEl) return;
            
            // Update dataset (canonical source of truth)
            const currentType = selectElement.value || 'free_form';
            questionEl.dataset.questionType = currentType;
            
            const guideAnswerContainer = questionEl.querySelector('#guide-answer-container');
            const choicesContainer = questionEl.querySelector('#choices-container');
            
            // Save current guide answer value before switching
            let currentGuideAnswer = '';
            // Check main guide answer container (free_form, annotate, create_table)
            const guideAnswerTextareaMain = guideAnswerContainer?.querySelector('textarea');
            if (guideAnswerTextareaMain && guideAnswerTextareaMain.value) {
                currentGuideAnswer = guideAnswerTextareaMain.value;
            }
            // Check blanks container
            if (!currentGuideAnswer) {
                const blanksContainer = questionEl.querySelector('#blanks-container');
                const blanksGuideAnswer = blanksContainer?.querySelector('.guide-answer-notes');
                if (blanksGuideAnswer && blanksGuideAnswer.value) {
                    currentGuideAnswer = blanksGuideAnswer.value;
                }
            }
            // Check matching container
            if (!currentGuideAnswer) {
                const matchingContainer = questionEl.querySelector('#matching-container');
                const matchingGuideAnswer = matchingContainer?.querySelector('.guide-answer-notes');
                if (matchingGuideAnswer && matchingGuideAnswer.value) {
                    currentGuideAnswer = matchingGuideAnswer.value;
                }
            }
            // Check choices container
            if (!currentGuideAnswer) {
                const choicesGuideAnswer = choicesContainer?.querySelector('.guide-answer-notes');
                if (choicesGuideAnswer && choicesGuideAnswer.value) {
                    currentGuideAnswer = choicesGuideAnswer.value;
                }
            }
            
            // Find fields by label text
            const setupContainer = Array.from(questionEl.querySelectorAll('.form-group')).find(el => 
                el.querySelector('label')?.textContent.includes('Set-up Text'));
            const questionTextContainer = Array.from(questionEl.querySelectorAll('.form-group')).find(el => 
                el.querySelector('label')?.textContent.includes('Question Text'));
            const questionImagesContainer = Array.from(questionEl.querySelectorAll('.form-group')).find(el => 
                el.querySelector('label')?.textContent.includes('Question Images'));
            const answerImagesContainer = Array.from(questionEl.querySelectorAll('.form-group')).find(el => 
                el.querySelector('label')?.textContent.includes('Answer Images'));
            const guidePdfPageContainer = Array.from(questionEl.querySelectorAll('.form-group')).find(el => 
                el.querySelector('label')?.textContent.includes('Guide PDF Page'));
            const relatedQuestionContainer = Array.from(questionEl.querySelectorAll('.form-group')).find(el => 
                el.querySelector('label')?.textContent.includes('Related Question'));
            
            // Get special containers
            const blanksContainer = questionEl.querySelector('#blanks-container');
            const matchingContainer = questionEl.querySelector('#matching-container');
            
            // Hide/show fields based on question type (use currentType, not questionType)
            if (currentType === 'fill_in_the_blanks') {
                // fill_in_the_blanks: Show question text, blanks, images, guide PDF, related question
                if (setupContainer) setupContainer.style.display = 'block';
                if (questionTextContainer) questionTextContainer.style.display = 'block';
                if (guideAnswerContainer) guideAnswerContainer.style.display = 'none';
                if (choicesContainer) choicesContainer.style.display = 'none';
                if (blanksContainer) blanksContainer.style.display = 'block';
                if (matchingContainer) matchingContainer.style.display = 'none';
                if (questionImagesContainer) questionImagesContainer.style.display = 'block';
                if (answerImagesContainer) answerImagesContainer.style.display = 'block';
                if (guidePdfPageContainer) guidePdfPageContainer.style.display = 'block';
                if (relatedQuestionContainer) relatedQuestionContainer.style.display = 'block';
                
                // Add listener to question text to update blanks UI
                const questionTextarea = questionEl.querySelector('textarea[placeholder*="Enter question text"]');
                if (questionTextarea && !questionTextarea.dataset.blanksListenerAttached) {
                    questionTextarea.addEventListener('input', () => {
                        updateBlankAnswersUI(questionEl);
                    });
                    questionTextarea.dataset.blanksListenerAttached = 'true';
                    // Initial update
                    updateBlankAnswersUI(questionEl);
                }
            } else if (currentType === 'matching') {
                // matching: Show question text, matching section, images, guide PDF, related question
                if (setupContainer) setupContainer.style.display = 'block';
                if (questionTextContainer) questionTextContainer.style.display = 'block';
                if (guideAnswerContainer) guideAnswerContainer.style.display = 'none';
                if (choicesContainer) choicesContainer.style.display = 'none';
                if (blanksContainer) blanksContainer.style.display = 'none';
                if (matchingContainer) matchingContainer.style.display = 'block';
                if (questionImagesContainer) questionImagesContainer.style.display = 'block';
                if (answerImagesContainer) answerImagesContainer.style.display = 'block';
                if (guidePdfPageContainer) guidePdfPageContainer.style.display = 'block';
                if (relatedQuestionContainer) relatedQuestionContainer.style.display = 'block';
                
                // Initialize with at least one item on each side if empty
                const leftList = questionEl.querySelector('[id^="matching-left-list-"]');
                const rightList = questionEl.querySelector('[id^="matching-right-list-"]');
                if (leftList && leftList.querySelectorAll('.matching-item').length === 0) {
                    const addLeftBtn = questionEl.querySelector('button[onclick*="addMatchingItem"][onclick*="left"]');
                    if (addLeftBtn) addMatchingItem(addLeftBtn, 'left');
                }
                if (rightList && rightList.querySelectorAll('.matching-item').length === 0) {
                    const addRightBtn = questionEl.querySelector('button[onclick*="addMatchingItem"][onclick*="right"]');
                    if (addRightBtn) addMatchingItem(addRightBtn, 'right');
                }
            } else {
                // Show all common fields for standard types (free_form, multiple_choice, checkbox, annotate, create_table)
                if (setupContainer) setupContainer.style.display = 'block';
                if (questionTextContainer) questionTextContainer.style.display = 'block';
                if (questionImagesContainer) questionImagesContainer.style.display = 'block';
                if (answerImagesContainer) answerImagesContainer.style.display = 'block';
                if (guidePdfPageContainer) guidePdfPageContainer.style.display = 'block';
                if (relatedQuestionContainer) relatedQuestionContainer.style.display = 'block';
                // Hide special containers
                if (blanksContainer) blanksContainer.style.display = 'none';
                if (matchingContainer) matchingContainer.style.display = 'none';
                
                // Hide "Insert Blank" button for non-fill_in_the_blanks types
                const blankBtn = questionTextContainer?.querySelector('.blank-btn');
                if (blankBtn) blankBtn.style.display = 'none';
                
                // Handle choices vs guide answer
                if (currentType === 'multiple_choice' || currentType === 'checkbox') {
                    if (guideAnswerContainer) guideAnswerContainer.style.display = 'none';
                    if (choicesContainer) {
                        choicesContainer.style.display = 'block';
                        // Update label based on type
                        const label = choicesContainer.querySelector('label');
                        if (label) {
                            label.textContent = currentType === 'checkbox' ? 'Checkbox Choices' : 'Multiple Choice Options';
                        }
                        
                        // Show/hide the radio button selector for multiple choice
                        const correctAnswerSelector = choicesContainer.querySelector('#correct-answer-selector');
                        if (correctAnswerSelector) {
                            correctAnswerSelector.style.display = currentType === 'multiple_choice' ? 'block' : 'none';
                        }
                        
                        // Show/hide the checkbox summary for checkbox
                        const checkboxSummary = choicesContainer.querySelector('#checkbox-summary');
                        if (checkboxSummary) {
                            checkboxSummary.style.display = currentType === 'checkbox' ? 'block' : 'none';
                        }
                        
                        // Update existing choices to add/remove correct checkbox field based on type
                        const choicesList = choicesContainer.querySelector('[id^="choices-list-"]');
                        if (choicesList) {
                            const existingChoices = choicesList.querySelectorAll('.choice-item');
                            existingChoices.forEach(choiceItem => {
                                const existingCorrectField = choiceItem.querySelector('.choice-correct');
                                const existingCorrectContainer = existingCorrectField?.closest('.form-group');
                                
                                if (currentType === 'checkbox' && !existingCorrectField) {
                                    // Add correct answer checkbox field for checkbox type
                                    const checkedFieldHTML = `
                                        <div class="form-group checkbox-group" style="align-items: center; margin-top: 10px;">
                                            <label for="choice-correct-${Date.now()}-${Math.random()}" style="font-weight: 600; color: #28a745;"> Correct Answer</label>
                                            <input type="checkbox" class="choice-correct" id="choice-correct-${Date.now()}-${Math.random()}" title="Mark this choice as a correct answer">
                                        </div>
                                    `;
                                    choiceItem.insertAdjacentHTML('beforeend', checkedFieldHTML);
                                    
                                    // Add change listener for real-time summary update (UID-based)
                                    const newCheckbox = choiceItem.querySelector('.choice-correct');
                                    if (newCheckbox) {
                                        ensureChoiceUids(questionEl);
                                        const choiceUid = choiceItem.dataset.choiceUid;
                                        newCheckbox.addEventListener('change', () => {
                                            const correctUids = getCorrectChoiceUids(questionEl);
                                            if (newCheckbox.checked) {
                                                correctUids.add(choiceUid);
                                            } else {
                                                correctUids.delete(choiceUid);
                                            }
                                            setCorrectChoiceUids(questionEl, correctUids);
                                            updateCheckboxSummary(questionEl);
                                            markFormAsChanged();
                                            triggerAutoSave();
                                        });
                                    }
                                } else if (currentType === 'multiple_choice' && existingCorrectField) {
                                    // Remove correct field for multiple_choice type
                                    if (existingCorrectContainer) {
                                        existingCorrectContainer.remove();
                                    }
                                }
                            });
                            
                            // Initialize with at least one choice if empty
                            if (choicesList.children.length === 0) {
                                addChoice(choicesContainer.querySelector('.add-btn'), 'end', currentType);
                            }
                        }
                    }
                    // Update the correct answer UI after a small delay to ensure DOM is ready
                        setTimeout(() => {
                        syncChoiceUI(questionEl);
                        }, 50);
                } else {
                    if (guideAnswerContainer) guideAnswerContainer.style.display = 'block';
                    if (choicesContainer) choicesContainer.style.display = 'none';
                }
            }
            
            // Restore guide answer value to the appropriate field for the new question type
            if (currentGuideAnswer) {
                if (currentType === 'free_form' || currentType === 'annotate' || currentType === 'create_table') {
                    // Use the main guide answer container
                    const guideAnswerTextarea = guideAnswerContainer?.querySelector('textarea');
                    if (guideAnswerTextarea) {
                        guideAnswerTextarea.value = currentGuideAnswer;
                    }
                } else if (currentType === 'fill_in_the_blanks') {
                    // Use the blanks container guide answer
                    const blanksContainer = questionEl.querySelector('#blanks-container');
                    const guideAnswerNotes = blanksContainer?.querySelector('.guide-answer-notes');
                    if (guideAnswerNotes) {
                        guideAnswerNotes.value = currentGuideAnswer;
                    }
                } else if (currentType === 'matching') {
                    // Use the matching container guide answer
                    const matchingContainer = questionEl.querySelector('#matching-container');
                    const guideAnswerNotes = matchingContainer?.querySelector('.guide-answer-notes');
                    if (guideAnswerNotes) {
                        guideAnswerNotes.value = currentGuideAnswer;
                    }
                } else if (currentType === 'multiple_choice' || currentType === 'checkbox') {
                    // Use the choices container guide answer
                    const choicesGuideAnswer = choicesContainer?.querySelector('.guide-answer-notes');
                    if (choicesGuideAnswer) {
                        choicesGuideAnswer.value = currentGuideAnswer;
                    }
                }
            }
            
            
            // Reinitialize previews for all textareas in this question after type change
            // This ensures newly shown fields get previews and direction is properly set
            attachPreviews(questionEl);
            if (typeof PreviewBox !== 'undefined' && PreviewBox.ensureRendered) {
                PreviewBox.ensureRendered(questionEl);
            }
            
            // Track question type change
        }

        function addChoice(button, position = 'end', questionType = null) {
            const choicesContainer = button.closest('#choices-container');
            const choicesList = choicesContainer.querySelector('[id^="choices-list-"]');
            
            // Determine question type if not provided
            if (!questionType) {
                const questionEl = button.closest('.array-item[data-type="question"]') || button.closest('.array-item');
                questionType = questionEl ? getQuestionType(questionEl) : 'multiple_choice';
            }
            
            
            // Add correct checkbox field for checkbox type
            const checkedField = questionType === 'checkbox' ? `
                <div class="form-group checkbox-group" style="align-items: center; margin-top: 10px;">
                    <label for="choice-correct-${Date.now()}" style="font-weight: 600; color: #28a745;"> Correct Answer</label>
                    <input type="checkbox" class="choice-correct" id="choice-correct-${Date.now()}" title="Mark this choice as a correct answer">
                </div>
            ` : '';
            
            const choiceItem = document.createElement('div');
            choiceItem.className = 'array-item choice-item';
            choiceItem.setAttribute('data-item-type', 'choice');
            choiceItem.innerHTML = getChoiceRowHTML({ questionType, choiceId: '', choiceText: '' });
            
            // Add choice at the specified position
            if (position === 'end') {
                choicesList.appendChild(choiceItem);
            } else if (position.before) {
                choicesList.insertBefore(choiceItem, position.before);
            } else if (position.after) {
                if (position.after.nextElementSibling) {
                    choicesList.insertBefore(choiceItem, position.after.nextElementSibling);
                } else {
                    choicesList.appendChild(choiceItem);
                }
            }
            
            // Record action for undo/redo (after adding to DOM so we have the actual element)
            const nextSibling = choiceItem.nextSibling;
            recordFormAction({
                type: ACTION_TYPES.ADD_ITEM,
                element: choiceItem,
                parent: choicesList,
                nextSibling: nextSibling,
                containerId: null, // Choices don't have a container ID
                updateNumbers: false
            });
            
            // Set RTL direction for choice text input
            const textarea = choiceItem.querySelector('textarea');
            if (textarea && !textarea.hasAttribute('dir')) {
                textarea.setAttribute('dir', 'rtl');
            }
            // Use canonical finalizer for previews, fonts, and autosize
            finalizeElement(choiceItem, { previews: true, fonts: true, bbox: false, refresh: true, autoSize: true });
            
            // Update correct answer UI (radio buttons or checkbox summary)
            const questionEl = choicesContainer.closest('.array-item');
            // Use centralized hook for UI updates
            afterQuestionTypeListMutation(questionEl);
            
            // Add real-time listeners for UI updates
            if (questionType === 'checkbox') {
                const correctCheckbox = choiceItem.querySelector('.choice-correct');
                if (correctCheckbox) {
                    ensureChoiceUids(questionEl);
                    const choiceUid = choiceItem.dataset.choiceUid;
                    correctCheckbox.addEventListener('change', () => {
                        const correctUids = getCorrectChoiceUids(questionEl);
                        if (correctCheckbox.checked) {
                            correctUids.add(choiceUid);
                        } else {
                            correctUids.delete(choiceUid);
                        }
                        setCorrectChoiceUids(questionEl, correctUids);
                        updateCheckboxSummary(questionEl);
                        markFormAsChanged();
                        triggerAutoSave();
                    });
                }
            } else if (questionType === 'multiple_choice') {
                // Add listener to choice text for real-time radio button updates
                const choiceTextArea = choiceItem.querySelector('.choice-text');
                if (choiceTextArea) {
                    choiceTextArea.addEventListener('input', () => {
                        // Ensure the live preview is rendered first
                        if (choiceTextArea.__livePreviewHandler) {
                            choiceTextArea.__livePreviewHandler();
                        } else {
                            renderLivePreview(choiceTextArea);
                        }
                        syncChoiceUI(questionEl);
                    });
                }
                // Add listener to choice ID for real-time radio button updates
                const choiceIdInput = choiceItem.querySelector('.choice-id');
                if (choiceIdInput) {
                    choiceIdInput.addEventListener('input', () => {
                        rebuildCorrectAnswerUI(questionEl);
                    });
                }
            }
        }

        function addChoiceBefore(button) {
            const choiceItem = button.closest('.choice-item');
            const choicesContainer = choiceItem.closest('#choices-container');
            // Get the question container (parent of choices container, not the choice item itself)
            const questionEl = choicesContainer.closest('.array-item');
            
            // Get question type using unified helper
            const questionType = getQuestionType(questionEl);
            
            
            const addBtn = choicesContainer.querySelector('.add-btn');
            addChoice(addBtn, { before: choiceItem }, questionType);
        }

        function addChoiceAfter(button) {
            const choiceItem = button.closest('.choice-item');
            const choicesContainer = choiceItem.closest('#choices-container');
            // Get the question container (parent of choices container, not the choice item itself)
            const questionEl = choicesContainer.closest('.array-item');
            
            // Get question type using unified helper
            const questionType = getQuestionType(questionEl);
            
            
            const addBtn = choicesContainer.querySelector('.add-btn');
            addChoice(addBtn, { after: choiceItem }, questionType);
        }

        function updateChoiceHeader(inputElement) {
            const choiceItem = inputElement.closest('.choice-item');
            const header = choiceItem.querySelector('h5');
            const choiceId = inputElement.value.trim();
            if (header) {
                header.textContent = choiceId ? `Choice ${choiceId}` : 'Choice';
            }
            // Update correct answer UI when ID changes
            const questionEl = choiceItem.parentElement?.closest('.array-item');
            if (questionEl) {
                syncChoiceUI(questionEl);
            }
        }

        // Reusable confirmation helper for removing nested list items
        function confirmRemoveListItem(kind) {
            const labels = {
                'choice': 'Are you sure you want to remove this choice?',
                'matching-left': 'Are you sure you want to remove this left matching item?',
                'matching-right': 'Are you sure you want to remove this right matching item?',
                'matching': 'Are you sure you want to remove this matching item?',
                'relationship': 'Are you sure you want to remove this relationship?'
            };
            const message = labels[kind] || `Are you sure you want to remove this ${kind}?`;
            return confirm(message);
        }

        function removeChoice(button) {
            const choiceItem = button.closest('.choice-item');
            if (!choiceItem) return;
            
            const context = getListContext(choiceItem);
            if (!context) return;
            
            if (!confirmRemoveListItem('choice')) return;
            
            // Record action for undo/redo BEFORE removing
            // Preserve the actual DOM node (not a clone) for proper restoration
            recordFormAction({
                type: ACTION_TYPES.REMOVE_ITEM,
                element: choiceItem, // Preserve actual DOM node
                parent: choiceItem.parentNode,
                nextSibling: choiceItem.nextSibling,
                containerId: context.containerId,
                updateNumbers: true,
                isChoice: true,
                questionEl: context.questionEl
            });
            
            // Remove from DOM
            choiceItem.remove();
            
            // Update UI using centralized hook
            afterQuestionTypeListMutation(context.questionEl);
            if (context.updateNumbersFn) {
                context.updateNumbersFn();
            }
            
            markFormAsChanged();
            triggerAutoSave();
        }

        function updateCorrectAnswerOptions(selectElement) {
            // This function is kept for backward compatibility but now delegates to rebuildCorrectAnswerUI
            const questionEl = selectElement ? selectElement.closest('.array-item') : null;
            if (questionEl) {
                rebuildCorrectAnswerUI(questionEl);
            }
        }
        
        // Legacy alias for backward compatibility
        function updateCorrectAnswerRadios(questionEl) {
            rebuildCorrectAnswerUI(questionEl);
        }
        
        // Single canonical UI sync helper for choices (multiple choice + checkbox)
        // Ensures UIDs exist, syncs UI with dataset state, and updates summaries
        function syncChoiceUI(questionEl) {
            if (!questionEl) return;
            
            const questionType = getQuestionType(questionEl);
            if (questionType !== 'multiple_choice' && questionType !== 'checkbox') return;
            
            ensureChoiceUids(questionEl);
            
            if (questionType === 'multiple_choice') {
                // Sync multiple choice: rebuild radio UI from dataset.correctChoiceUid
                rebuildCorrectAnswerUI(questionEl);
            } else if (questionType === 'checkbox') {
                // Sync checkbox: update checkboxes from dataset.correctChoiceUids
                const choicesList = questionEl.querySelector('[id^="choices-list-"]');
                if (!choicesList) return;
                
                const choices = choicesList.querySelectorAll('.choice-item');
                const correctUids = getCorrectChoiceUids(questionEl);
                
                choices.forEach(choiceItem => {
                    const choiceUid = choiceItem.dataset.choiceUid;
                    if (!choiceUid) return;
                    
                    const checkbox = choiceItem.querySelector('.choice-correct');
                    if (checkbox) {
                        const isCorrect = correctUids.has(choiceUid);
                        checkbox.checked = isCorrect;
                        choiceItem.dataset.isCorrect = isCorrect ? 'true' : 'false';
                    }
                });
                
                // Update checkbox summary
                updateCheckboxSummary(questionEl);
            }
        }

        // Rebuild correct answer UI for multiple choice questions (UID-based)
        function rebuildCorrectAnswerUI(questionEl) {
            const choicesList = questionEl.querySelector('[id^="choices-list-"]');
            const radiosContainer = questionEl.querySelector('[id^="correct-answer-radios-"]');
            const questionType = getQuestionType(questionEl);
            
            if (!radiosContainer || questionType !== 'multiple_choice') return;
            
            // Ensure all choices have UIDs
            ensureChoiceUids(questionEl);
            
            // Get currently selected UID (canonical truth)
            const correctChoiceUid = getCorrectChoiceUid(questionEl);
            
            // Get or create direction state for this radios container
            const containerId = radiosContainer.id;
            if (!radiosContainer.dataset.direction) {
                radiosContainer.dataset.direction = 'rtl'; // Default to RTL
            }
            const currentDirection = radiosContainer.dataset.direction;
            
            // Clear existing radio buttons
            radiosContainer.innerHTML = '';
            
            // Add LTR/RTL toggle button at the top
            const dirToggleBtn = document.createElement('button');
            dirToggleBtn.type = 'button';
            dirToggleBtn.className = 'dir-btn';
            dirToggleBtn.textContent = currentDirection === 'rtl' ? 'LTR' : 'RTL';
            dirToggleBtn.title = 'Toggle direction RTL/LTR for all previews';
            dirToggleBtn.style.cssText = 'margin-bottom: 10px; width: fit-content; display: inline-flex;';
            dirToggleBtn.onclick = () => {
                const newDirection = radiosContainer.dataset.direction === 'rtl' ? 'ltr' : 'rtl';
                radiosContainer.dataset.direction = newDirection;
                rebuildCorrectAnswerUI(questionEl); // Refresh to apply new direction
            };
            radiosContainer.appendChild(dirToggleBtn);
            
            if (choicesList) {
                const choices = choicesList.querySelectorAll('.choice-item');
                choices.forEach((choice, index) => {
                    const choiceUid = choice.dataset.choiceUid;
                    if (!choiceUid) return; // Skip if no UID
                    
                    const choiceTextArea = choice.querySelector('.choice-text');
                    const choiceIdInput = choice.querySelector('.choice-id');
                    const choiceText = choiceTextArea ? choiceTextArea.value.trim() : '';
                    const choiceId = choiceIdInput ? choiceIdInput.value.trim() : '';
                    
                    // Display position (1-indexed) but use UID as value
                    const position = index + 1;
                    const radioId = `correct-radio-${questionEl.querySelector('[id^="choices-list-"]').id}-${choiceUid}`;
                    
                    const radioWrapper = document.createElement('div');
                    radioWrapper.className = 'radio-choice-wrapper';
                    radioWrapper.style.cssText = 'display: flex; align-items: flex-start; gap: 10px; padding: 10px; border-radius: 6px; border: 1px solid var(--border-color); background: var(--bg-secondary); transition: all 0.2s ease;';
                    
                    // Add hover effect
                    radioWrapper.addEventListener('mouseenter', () => {
                        radioWrapper.style.background = 'var(--bg-tertiary)';
                        radioWrapper.style.borderColor = 'var(--accent)';
                    });
                    radioWrapper.addEventListener('mouseleave', () => {
                        radioWrapper.style.background = 'var(--bg-secondary)';
                        radioWrapper.style.borderColor = 'var(--border-color)';
                    });
                    
                    const radioInput = document.createElement('input');
                    radioInput.type = 'radio';
                    radioInput.name = `correct-answer-${questionEl.querySelector('[id^="choices-list-"]').id}`;
                    radioInput.value = choiceUid; // Use UID as value, not position
                    radioInput.id = radioId;
                    radioInput.className = 'choice-correct-radio';
                    radioInput.title = `Select this choice as the correct answer (Position ${position})`;
                    radioInput.style.cssText = 'cursor: pointer; width: 18px; height: 18px; accent-color: var(--accent); margin-top: 4px; flex-shrink: 0;';
                    if (correctChoiceUid === choiceUid) {
                        radioInput.checked = true;
                    }
                    
                    // Add change listener to store UID and trigger auto-save
                    radioInput.addEventListener('change', () => {
                        if (radioInput.checked) {
                            setCorrectChoiceUid(questionEl, choiceUid);
                            markFormAsChanged();
                            triggerAutoSave();
                        }
                    });
                    
                    const radioLabel = document.createElement('label');
                    radioLabel.htmlFor = radioId;
                    radioLabel.style.cssText = 'cursor: pointer; flex: 1; margin: 0; color: var(--text-primary); display: flex; flex-direction: column; gap: 5px;';
                    
                    // Header with position and ID
                    const headerDiv = document.createElement('div');
                    headerDiv.style.cssText = 'display: flex; align-items: center; gap: 8px;';
                    
                    const positionBadge = document.createElement('strong');
                    positionBadge.textContent = `(${position})`;
                    positionBadge.style.cssText = 'color: var(--accent); margin-right: 0;';
                    
                    const idBadge = choiceId ? document.createElement('span') : null;
                    if (idBadge) {
                        idBadge.textContent = `[${choiceId}]`;
                        idBadge.style.cssText = 'color: var(--text-secondary); margin-right: 0; font-weight: 600;';
                    }
                    
                    headerDiv.appendChild(positionBadge);
                    if (idBadge) headerDiv.appendChild(idBadge);
                    
                    // Rendered preview (same pipeline as choice previews)
                    const previewDiv = document.createElement('div');
                    previewDiv.className = 'live-preview';
                    // Match the same behavior as the main choice preview: use dir + textAlign based on direction
                    const isRTL = currentDirection === 'rtl';
                    previewDiv.setAttribute('dir', isRTL ? 'rtl' : 'ltr');
                    previewDiv.style.textAlign = isRTL ? 'right' : 'left';
                    
                    if (choiceText && choiceTextArea) {
                        // Use the same renderer function as choice preview boxes
                        renderLivePreview(choiceTextArea, previewDiv);
                        previewDiv.setAttribute('dir', isRTL ? 'rtl' : 'ltr');
                        previewDiv.style.textAlign = isRTL ? 'right' : 'left';
                    } else {
                        previewDiv.textContent = '(empty)';
                        previewDiv.style.opacity = '0.5';
                        previewDiv.style.fontStyle = 'italic';
                    }
                    
                    radioLabel.appendChild(headerDiv);
                    radioLabel.appendChild(previewDiv);
                    
                    radioWrapper.appendChild(radioInput);
                    radioWrapper.appendChild(radioLabel);
                    
                    radiosContainer.appendChild(radioWrapper);
                });
            }
            // Apply universal font settings to this subtree so Correct Answer labels/previews match other output (same pipeline)
            if (typeof applyFontSettings === 'function') {
                applyFontSettings(questionEl);
            }
        }

        function updateCheckboxSummary(questionEl) {
            const summaryContainer = questionEl.querySelector('#checkbox-summary-text');
            const choicesList = questionEl.querySelector('[id^="choices-list-"]');
            
            if (!summaryContainer || !choicesList) return;
            
            const choices = choicesList.querySelectorAll('.choice-item');
            const correctChoices = [];
            
            choices.forEach((choice, index) => {
                const correctCheckbox = choice.querySelector('.choice-correct');
                if (correctCheckbox && correctCheckbox.checked) {
                    const choiceIdInput = choice.querySelector('.choice-id');
                    const choiceId = choiceIdInput ? choiceIdInput.value.trim() : '';
                    correctChoices.push(choiceId || `Choice ${index + 1}`);
                }
            });
            
            if (correctChoices.length === 0) {
                summaryContainer.innerHTML = '<span style="opacity: 0.7; color: var(--text-secondary);">Check the " Correct Answer" boxes above to mark correct choices</span>';
            } else {
                summaryContainer.innerHTML = `<strong style="color: #28a745;">${correctChoices.length} of ${choices.length} marked correct:</strong> <span style="color: var(--text-primary);">${correctChoices.join(', ')}</span>`;
                            }
        }

        function attachChoiceListeners(questionEl) {
            const questionType = getQuestionType(questionEl);
            const choicesList = questionEl.querySelector('[id^="choices-list-"]');
            
            if (!choicesList) return;
            
            const choiceItems = choicesList.querySelectorAll('.choice-item');
            choiceItems.forEach((choiceItem) => {
                if (questionType === 'multiple_choice') {
                    // Add listeners for multiple choice
                    const choiceTextArea = choiceItem.querySelector('.choice-text');
                    const choiceIdInput = choiceItem.querySelector('.choice-id');
                    
                    if (choiceTextArea && !choiceTextArea.dataset.listenerAttached) {
                        choiceTextArea.addEventListener('input', () => {
                            // Ensure the live preview is rendered first
                            if (choiceTextArea.__livePreviewHandler) {
                                choiceTextArea.__livePreviewHandler();
                            } else {
                                renderLivePreview(choiceTextArea);
                            }
                            syncChoiceUI(questionEl);
                        });
                        choiceTextArea.dataset.listenerAttached = 'true';
                    }
                    
                    if (choiceIdInput && !choiceIdInput.dataset.listenerAttached) {
                        choiceIdInput.addEventListener('input', () => {
                            syncChoiceUI(questionEl);
                        });
                        choiceIdInput.dataset.listenerAttached = 'true';
                    }
                } else if (questionType === 'checkbox') {
                    // Add listeners for checkbox (UID-based)
                    const correctCheckbox = choiceItem.querySelector('.choice-correct');
                    if (correctCheckbox && !correctCheckbox.dataset.listenerAttached) {
                        ensureChoiceUids(questionEl);
                        const choiceUid = choiceItem.dataset.choiceUid;
                        if (choiceUid) {
                            correctCheckbox.addEventListener('change', () => {
                                const correctUids = getCorrectChoiceUids(questionEl);
                                if (correctCheckbox.checked) {
                                    correctUids.add(choiceUid);
                                } else {
                                    correctUids.delete(choiceUid);
                                }
                                setCorrectChoiceUids(questionEl, correctUids);
                                updateCheckboxSummary(questionEl);
                                markFormAsChanged();
                                triggerAutoSave();
                            });
                            correctCheckbox.dataset.listenerAttached = 'true';
                        }
                    }
                }
            });
        }

        /**
         * Unified helper for moving items up or down in a list.
         * Handles the common pattern of DOM manipulation, action recording, and UI updates.
         * 
         * @param {Object} options
         * @param {HTMLElement} options.item - The item to move
         * @param {string} options.direction - 'up' or 'down'
         * @param {HTMLElement} options.container - The container element (for insertBefore)
         * @param {string|null} options.containerId - Container ID for numbering updates
         * @param {Object} [options.actionExtras={}] - Extra properties to add to the recorded action
         * @param {Function} [options.postMoveHook=null] - Function to call after move
         * @returns {boolean} Whether the move was performed
         */
        function performItemMove(options) {
            const {
                item,
                direction,
                container,
                containerId,
                actionExtras = {},
                postMoveHook = null
            } = options;
            
            if (!item || !container) return false;
            
            // Find the sibling to swap with
            const sibling = direction === 'up' 
                ? item.previousElementSibling 
                : item.nextElementSibling;
            
            if (!sibling) return false;
            
            // Save old position before move
            const oldParent = item.parentNode;
            const oldNextSibling = item.nextSibling;
            
            // Perform the move: for 'up', insert item before sibling; for 'down', insert sibling before item
            if (direction === 'up') {
                container.insertBefore(item, sibling);
            } else {
                container.insertBefore(sibling, item);
            }
            
            // Record action for undo/redo
            recordFormAction({
                type: ACTION_TYPES.MOVE_ITEM,
                element: item,
                oldParent: oldParent,
                oldNextSibling: oldNextSibling,
                newParent: item.parentNode,
                newNextSibling: item.nextSibling,
                containerId: containerId,
                updateNumbers: true,
                ...actionExtras
            });
            
            // Run post-move hook if provided
            if (postMoveHook) {
                postMoveHook();
            }
            
            markFormAsChanged();
            triggerAutoSave();
            
            return true;
        }

        function moveChoiceUp(button) {
            const choiceItem = button.closest('.choice-item');
            if (!choiceItem) return;
            
            const context = getListContext(choiceItem);
            if (!context) return;
            
            performItemMove({
                item: choiceItem,
                direction: 'up',
                container: context.containerEl,
                containerId: context.containerId,
                actionExtras: { isChoice: true, questionEl: context.questionEl },
                postMoveHook: context.updateNumbersFn
            });
        }

        function moveChoiceDown(button) {
            const choiceItem = button.closest('.choice-item');
            if (!choiceItem) return;
            
            const context = getListContext(choiceItem);
            if (!context) return;
            
            performItemMove({
                item: choiceItem,
                direction: 'down',
                container: context.containerEl,
                containerId: context.containerId,
                actionExtras: { isChoice: true, questionEl: context.questionEl },
                postMoveHook: context.updateNumbersFn
            });
        }

        function removeArrayItem(button) {
            // Single source of truth: the row being removed is the nearest .array-item to the button.
            const row = button.closest('.array-item');
            if (!row) {
                const listItem = button.closest('.bbox-item, .choice-item');
                if (listItem && confirm('Are you sure you want to remove this item?\n\nThis action cannot be undone.')) {
                    let containerId = button.closest('#questions_container') ? 'questions_container' : (button.closest('#content_sections_container') ? 'content_sections_container' : null);
                    recordFormAction({ type: ACTION_TYPES.REMOVE_ITEM, element: listItem.cloneNode(true), parent: listItem.parentNode, nextSibling: listItem.nextSibling, containerId: containerId, updateNumbers: false });
                    listItem.remove();
                    afterListMutation(containerId);
                    markFormAsChanged();
                }
                return;
            }

            // Type from this row only (data-item-type on the row being removed)
            const rawType = (row.getAttribute('data-item-type') || '').trim().toLowerCase();
            const labelMap = { 'content-section': 'content section', 'question': 'question', 'image': 'image', 'terminology': 'terminology', 'standard': 'standard', 'choice': 'choice' };
            let itemTypeLabel = labelMap[rawType] || (rawType || '');

            // Fallback: if row has no data-item-type, classify by where this row lives (not ancestors)
            if (!itemTypeLabel) {
                if (row.parentElement && row.parentElement.id === 'content_sections_container') {
                    itemTypeLabel = 'content section';
                } else if (row.parentElement && row.parentElement.id === 'questions_container') {
                    itemTypeLabel = 'question';
                } else if (row.closest('.bbox-container') !== null) {
                    itemTypeLabel = 'image';
                } else if (row.closest('#lesson_standards')) {
                    itemTypeLabel = 'standard';
                } else if (row.closest('#terminology')) {
                    itemTypeLabel = 'terminology';
                } else if (row.closest('[id^="choices-list-"]')) {
                    itemTypeLabel = 'choice';
                } else {
                    itemTypeLabel = 'item';
                }
            }

            const isMainSection = (itemTypeLabel === 'content section' || itemTypeLabel === 'question');

            if (isMainSection) {
                const isQuestion = (itemTypeLabel === 'question');
                const itemTitle = row.querySelector('h4')?.textContent || itemTypeLabel;
                if (confirm(`Are you sure you want to remove this ${itemTypeLabel}?\n\n"${itemTitle}"`)) {
                    const container = isQuestion ? document.getElementById('questions_container') : document.getElementById('content_sections_container');
                    const action = {
                        type: ACTION_TYPES.REMOVE_ITEM,
                        element: row.cloneNode(true),
                        parent: row.parentNode,
                        nextSibling: row.nextSibling,
                        containerId: isQuestion ? 'questions_container' : 'content_sections_container',
                        updateNumbers: true
                    };
                    if (isQuestion) {
                        const scopedSelect = row.querySelector('select.question-type-select, select[onchange*="toggleQuestionType"]');
                        if (scopedSelect) row.dataset.questionType = scopedSelect.value || 'free_form';
                        action.snapshotState = serializeQuestionState(row);
                        const qContainer = document.getElementById('questions_container');
                        action.questionIndex = qContainer ? Array.from(qContainer.children).indexOf(row) : null;
                    }
                    recordFormAction(action);
                    row.remove();
                    if (isQuestion) updateQuestionNumbers(); else updateContentSectionNumbers();
                    markFormAsChanged();
                }
            } else {
                let itemPreview = '';
                if (itemTypeLabel === 'standard' || itemTypeLabel === 'terminology') {
                    const input = row.querySelector('input[type="text"], textarea');
                    itemPreview = input?.value || '';
                } else if (itemTypeLabel === 'image') {
                    const page = row.querySelector('.bbox-page')?.value || '';
                    const x0 = row.querySelector('.bbox-x0')?.value || '';
                    const y0 = row.querySelector('.bbox-y0')?.value || '';
                    if (page || x0 || y0) itemPreview = `Page ${page}, Position (${x0}, ${y0})`;
                } else if (itemTypeLabel === 'choice') {
                    const choiceId = row.querySelector('.choice-id')?.value || '';
                    const choiceText = row.querySelector('.choice-text')?.value || '';
                    if (choiceId || choiceText) itemPreview = `${choiceId}: ${choiceText.substring(0, 30)}${choiceText.length > 30 ? '...' : ''}`;
                }
                const confirmMessage = itemPreview
                    ? `Are you sure you want to remove this ${itemTypeLabel}?\n\n"${itemPreview}"\n\nThis action cannot be undone.`
                    : `Are you sure you want to remove this ${itemTypeLabel}?\n\nThis action cannot be undone.`;
                if (confirm(confirmMessage)) {
                    let containerId = button.closest('#questions_container') ? 'questions_container' : (button.closest('#content_sections_container') ? 'content_sections_container' : null);
                    recordFormAction({ type: ACTION_TYPES.REMOVE_ITEM, element: row.cloneNode(true), parent: row.parentNode, nextSibling: row.nextSibling, containerId: containerId, updateNumbers: false });
                    row.remove();
                    afterListMutation(containerId);
                    markFormAsChanged();
                }
            }
        }

        // Toggle section collapse/expand
        function toggleSectionCollapse(button) {
            const section = button.closest('.array-item');
            if (section) {
                section.classList.toggle('collapsed');
            }
        }

        // Move item up in the list
        function moveItemUp(button) {
            const item = button.closest('.array-item');
            if (!item || !item.previousElementSibling) return;
            
                const container = item.closest('#questions_container') || item.closest('#content_sections_container');
                const containerId = container ? container.id : null;
                
            performItemMove({
                item: item,
                direction: 'up',
                container: item.parentNode,
                    containerId: containerId,
                postMoveHook: () => afterListMutation(containerId)
            });
        }

        // Move item down in the list
        function moveItemDown(button) {
            const item = button.closest('.array-item');
            if (!item || !item.nextElementSibling) return;
            
                const container = item.closest('#questions_container') || item.closest('#content_sections_container');
                const containerId = container ? container.id : null;
                
            performItemMove({
                item: item,
                direction: 'down',
                container: item.parentNode,
                    containerId: containerId,
                postMoveHook: () => afterListMutation(containerId)
            });
        }

        // Update question numbers after reordering
        function updateQuestionNumbers() {
            const container = document.getElementById('questions_container');
            if (!container) {
                console.warn('Questions container not found');
                return;
            }
            
            // Get all direct children that are array-items (questions)
            // Use querySelectorAll with direct child selector to avoid nested items
            const questions = container.querySelectorAll(':scope > .array-item');
            
            questions.forEach((question, index) => {
                // Look for h4 in the array-item-header
                const header = question.querySelector('.array-item-header > h4');
                if (header) {
                    header.textContent = `Question ${index + 1}`;
                }
                
                // Update canonical section ID marker (for navigation)
                question.setAttribute('data-section-id', `question-${index + 1}`);
                
                // Don't auto-update question ID input anymore - let user set their own IDs
            });
            
            // Update quick jump menu after renumbering
            updateQuickJumpMenu();
        }

        // Update content section numbers after reordering
        function updateContentSectionNumbers() {
            const container = document.getElementById('content_sections_container');
            if (!container) return;
            
            // Get all direct children that are array-items (content sections)
            // Use querySelectorAll with direct child selector to avoid nested items
            const sections = container.querySelectorAll(':scope > .array-item');
            
            sections.forEach((section, index) => {
                // Look for h4 in the array-item-header
                const header = section.querySelector('.array-item-header > h4');
                if (header) {
                    header.textContent = `Content Section ${index + 1}`;
                }
                
                // Update canonical section ID marker (for navigation)
                section.setAttribute('data-section-id', `content-${index + 1}`);
            });
            
            // Update quick jump menu after renumbering
            updateQuickJumpMenu();
        }

        // Copy entire section (content section or question) as JSON
        function copySection(button) {
            try {
                const sectionEl = button.closest('.array-item');
                if (!sectionEl) {
                    alert('Could not find section to copy');
                    return;
                }
                
                // Use canonical serializer
                const sectionData = serializeSection(sectionEl);
                
                // Copy to clipboard
                const jsonText = JSON.stringify(sectionData, null, 2);
                const textarea = document.createElement('textarea');
                textarea.value = jsonText;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                
                // Visual feedback
                const copyBtn = button;
                const originalIcon = copyBtn.innerHTML;
                copyBtn.innerHTML = '<i class="fas fa-check"></i>';
                copyBtn.style.background = '#28a745';
                setTimeout(() => {
                    copyBtn.innerHTML = originalIcon;
                    copyBtn.style.background = '';
                }, 1200);
                
                
            } catch (e) {
                console.error('Failed to copy section:', e);
                alert('Failed to copy section: ' + e.message);
            }
        }

        // Duplicate entire section (copy and paste below immediately)
        function duplicateSection(button) {
            try {
                const sectionEl = button.closest('.array-item');
                if (!sectionEl) {
                    alert('Could not find section to duplicate');
                    return;
                }
                
                // Use canonical serializer
                const sectionData = serializeSection(sectionEl);
                
                // Determine container and insertion point
                const isQuestion = sectionData.type === 'question';
                const container = isQuestion 
                    ? document.getElementById('questions_container')
                    : document.getElementById('content_sections_container');
                
                if (!container) {
                    alert(`Could not find ${isQuestion ? 'questions' : 'content sections'} container`);
                    return;
                }
                
                // Use canonical deserializer to create duplicate
                const newSection = deserializeSection(sectionData, {
                    container: container,
                    insertBefore: sectionEl.nextSibling,
                    isReplacement: false,
                    targetEl: null
                });
                
                // Record action for undo/redo
                recordFormAction({
                    type: ACTION_TYPES.DUPLICATE_ITEM,
                    originalElement: sectionEl,
                    duplicatedElement: newSection,
                    parent: container,
                    nextSibling: newSection.nextSibling,
                    containerId: isQuestion ? 'questions_container' : 'content_sections_container',
                    updateNumbers: true,
                    isQuestion: isQuestion,
                    snapshotState: isQuestion ? serializeQuestionState(newSection) : collectContentData(newSection)
                });
                
                // Initialize the new section using canonical finalizer
                finalizeElement(newSection, { containerId: isQuestion ? 'questions_container' : 'content_sections_container' });
                
                // Visual feedback
                const duplicateBtn = button;
                const originalIcon = duplicateBtn.innerHTML;
                duplicateBtn.innerHTML = '<i class="fas fa-check"></i>';
                duplicateBtn.style.background = '#28a745';
                setTimeout(() => {
                    duplicateBtn.innerHTML = originalIcon;
                    duplicateBtn.style.background = '';
                }, 1200);
                
                // Mark form as changed and trigger auto-save
                markFormAsChanged();
                triggerAutoSave();
                
            } catch (e) {
                console.error('Failed to duplicate section:', e);
                alert('Failed to duplicate section: ' + e.message);
            }
        }
        

        // Paste and replace current section content
        function pasteIntoSection(button) {
            try {
                const sectionEl = button.closest('.array-item');
                if (!sectionEl) {
                    alert('Could not find section to paste into');
                    return;
                }
                
                const text = prompt('Paste section JSON here to replace current content:');
                if (!text || !text.trim()) return;
                
                let sectionData;
                try {
                    sectionData = JSON.parse(text);
                } catch (e) {
                    alert('Pasted content is not valid JSON.');
                    return;
                }
                
                if (!sectionData.type || !sectionData.data) {
                    alert('Invalid section JSON format. Please copy from a section copy button.');
                    return;
                }
                
                // Determine current section type
                const isQuestion = !!sectionEl.closest('#questions_container');
                
                // Verify type matches
                if (isQuestion && sectionData.type !== 'question') {
                    alert('Cannot paste a content section into a question. Types must match.');
                    return;
                }
                if (!isQuestion && sectionData.type !== 'content') {
                    alert('Cannot paste a question into a content section. Types must match.');
                    return;
                }
                
                // Confirm replacement
                if (!confirm('This will replace all content in this section. Continue?')) {
                    return;
                }
                
                // Save old section state for undo
                const oldSectionState = sectionEl.cloneNode(true);
                const container = sectionEl.parentNode;
                const nextSibling = sectionEl.nextSibling;
                const containerId = isQuestion ? 'questions_container' : 'content_sections_container';
                
                // Use canonical deserializer to replace content
                deserializeSection(sectionData, {
                    container: container,
                    insertBefore: null,
                    isReplacement: true,
                    targetEl: sectionEl
                });
                
                // Spawn finalization: force-fit textareas/previews with current content (values already set by deserialize)
                if (typeof AutoSizeManager !== 'undefined' && AutoSizeManager.finalizeSpawn) {
                    AutoSizeManager.finalizeSpawn(sectionEl);
                }
                
                // Record action for undo/redo (after section is replaced)
                const pastedState = sectionEl.cloneNode(true);
                recordFormAction({
                    type: ACTION_TYPES.PASTE,
                    pastedElement: sectionEl,
                    pastedState: pastedState, // Save the pasted content state for redo
                    oldElement: oldSectionState, // Save the old content state for undo
                    parent: container,
                    nextSibling: nextSibling,
                    containerId: containerId,
                    updateNumbers: false
                });
                
                markFormAsChanged();
                triggerAutoSave();
                
                // Visual feedback
                const pasteBtn = button;
                const originalIcon = pasteBtn.innerHTML;
                pasteBtn.innerHTML = '<i class="fas fa-check"></i>';
                pasteBtn.classList.remove('paste-replace-btn');
                pasteBtn.style.background = '#28a745';
                setTimeout(() => {
                    pasteBtn.innerHTML = originalIcon;
                    pasteBtn.classList.add('paste-replace-btn');
                    pasteBtn.style.background = '';
                }, 1200);
                
            } catch (e) {
                console.error('Failed to paste into section:', e);
                alert('Failed to paste into section: ' + e.message);
            }
        }
        

        // Paste section at the end of the list
        function pasteSectionAtEnd(expectedType) {
            try {
                const text = prompt('Paste section JSON here:');
                if (!text || !text.trim()) return;
                
                let sectionData;
                try {
                    sectionData = JSON.parse(text);
                } catch (e) {
                    alert('Pasted content is not valid JSON.');
                    return;
                }
                
                if (!sectionData.type || !sectionData.data) {
                    alert('Invalid section JSON format. Please copy from a section copy button.');
                    return;
                }
                
                // Verify we're pasting to the right place
                if (expectedType === 'content' && sectionData.type !== 'content') {
                    alert('This appears to be a question. Please paste it in the Questions tab.');
                    return;
                }
                if (expectedType === 'question' && sectionData.type !== 'question') {
                    alert('This appears to be a content section. Please paste it in the Content tab.');
                    return;
                }
                
                // Determine container
                const container = sectionData.type === 'question'
                    ? document.getElementById('questions_container')
                    : document.getElementById('content_sections_container');
                
                if (!container) {
                    alert(`Could not find ${sectionData.type === 'question' ? 'questions' : 'content sections'} container`);
                    return;
                }
                
                // Use canonical deserializer to create new section
                const newSection = deserializeSection(sectionData, {
                    container: container,
                    insertBefore: null,
                    isReplacement: false,
                    targetEl: null
                });
                
                // Spawn finalization: force-fit textareas/previews with current content (values already set by deserialize)
                if (typeof AutoSizeManager !== 'undefined' && AutoSizeManager.finalizeSpawn) {
                    AutoSizeManager.finalizeSpawn(newSection);
                }
                
                // Record action for undo/redo
                recordFormAction({
                    type: sectionData.type === 'question' ? ACTION_TYPES.PASTE_QUESTION : ACTION_TYPES.PASTE_SECTION,
                    pastedElement: newSection,
                    parent: container,
                    nextSibling: null,
                    containerId: sectionData.type === 'question' ? 'questions_container' : 'content_sections_container',
                    updateNumbers: true
                });
                
                markFormAsChanged();
                triggerAutoSave();
                
            } catch (e) {
                console.error('Failed to paste section:', e);
                alert('Failed to paste section: ' + e.message);
            }
        }

        // Helper: Generate markdown button bar HTML (reusable across all markdown-enabled fields)
        // Options: { includeImage: false, includeTable: false, fieldType: 'textarea' | 'input' }
        function getMarkdownButtonBarHTML(options = {}) {
            const { includeImage = false, includeTable = false, fieldType = 'textarea' } = options;
            const fieldSelector = fieldType === 'input' ? 'input' : 'textarea';
            return `
                    <button type="button" class="markdown-btn" onclick="insertBold(this.parentElement.querySelector('${fieldSelector}'))" title="Make selected text bold (**text**)">
                        <i class="fas fa-bold"></i>
                    </button>
                    <button type="button" class="markdown-btn" onclick="insertItalic(this.parentElement.querySelector('${fieldSelector}'))" title="Make selected text italic (*text*)">
                        <i class="fas fa-italic"></i>
                    </button>
                    <button type="button" class="markdown-btn" onclick="insertBulletList(this.parentElement.querySelector('${fieldSelector}'))" title="Convert line(s) to bullet list (- item)">
                        <i class="fas fa-list-ul"></i>
                    </button>
                    <button type="button" class="markdown-btn" onclick="insertNumberedList(this.parentElement.querySelector('${fieldSelector}'))" title="Convert line(s) to numbered list (1. item)">
                        <i class="fas fa-list-ol"></i>
                    </button>
                    <button type="button" class="markdown-btn" onclick="insertBlockquote(this.parentElement.querySelector('${fieldSelector}'))" title="Convert line(s) to blockquote (> text)">
                        <i class="fas fa-quote-right"></i>
                    </button>
                    <button type="button" class="markdown-btn" onclick="insertInlineLatex(this.parentElement.querySelector('${fieldSelector}'))" title="Wrap selection with $ or insert $$">
                        <i class="fas fa-dollar-sign"></i>
                    </button>
                    <button type="button" class="markdown-btn" onclick="insertBlockLatex(this.parentElement.querySelector('${fieldSelector}'))" title="Wrap selection with block LaTeX ($$\\n...\\n$$) or insert $$\\n\\n$$">
                        <i class="fas fa-square-root-alt"></i>
                    </button>
                    <button type="button" class="markdown-btn" onclick="removeMarkdownFormatting(this)" title="Undo last markdown formatting operation">
                        <i class="fas fa-undo"></i>
                    </button>
                    <button type="button" class="markdown-btn" onclick="redoMarkdownFormatting(this)" title="Redo last undone markdown formatting operation">
                        <i class="fas fa-redo"></i>
                    </button>
                    ${includeTable ? `<button type="button" class="table-btn" onclick="insertTable(this.parentElement.querySelector('${fieldSelector}'))" title="Insert a markdown table template">
                        <i class="fas fa-table"></i> Insert Table
                    </button>` : ''}
                    ${includeImage ? `<button type="button" class="image-btn" onclick="insertImage(this.parentElement.querySelector('${fieldSelector}'))" title="Insert an image placeholder">
                        <i class="fas fa-image"></i> Insert Image
                    </button>` : ''}
                    <button type="button" class="dir-btn" onclick="toggleDirection(this.parentElement.querySelector('${fieldSelector}'))" title="Toggle text direction (LTR/RTL)">LTR</button>
            `;
        }
        
        // Helper: Generate title toolbar HTML (single-line safe buttons only)
        // For title fields: Bold, Italic, Inline LaTeX, Undo, Redo, Direction toggle
        // Excludes: Bullet list, Numbered list, Blockquote, Block LaTeX, Image, Table
        function getTitleMarkdownButtonBarHTML(fieldType = 'input') {
            const fieldSelector = fieldType === 'textarea' ? 'textarea' : 'input';
            return `
                    <button type="button" class="markdown-btn" onclick="insertBold(this.parentElement.querySelector('${fieldSelector}'))" title="Make selected text bold (**text**)">
                        <i class="fas fa-bold"></i>
                    </button>
                    <button type="button" class="markdown-btn" onclick="insertItalic(this.parentElement.querySelector('${fieldSelector}'))" title="Make selected text italic (*text*)">
                        <i class="fas fa-italic"></i>
                    </button>
                    <button type="button" class="markdown-btn" onclick="insertInlineLatex(this.parentElement.querySelector('${fieldSelector}'))" title="Wrap selection with $ or insert $$">
                        <i class="fas fa-dollar-sign"></i>
                    </button>
                    <button type="button" class="markdown-btn" onclick="removeMarkdownFormatting(this)" title="Undo last markdown formatting operation">
                        <i class="fas fa-undo"></i>
                    </button>
                    <button type="button" class="markdown-btn" onclick="redoMarkdownFormatting(this)" title="Redo last undone markdown formatting operation">
                        <i class="fas fa-redo"></i>
                    </button>
                    <button type="button" class="dir-btn" onclick="toggleDirection(this.parentElement.querySelector('${fieldSelector}'))" title="Toggle text direction (LTR/RTL)">LTR</button>
            `;
        }
        
        // Hydrate static markdown toolbars in initial HTML items
        function hydrateStaticMarkdownToolbars() {
            const toolbars = document.querySelectorAll('.js-markdown-toolbar');
            toolbars.forEach(toolbar => {
                const includeImage = toolbar.dataset.includeImage === 'true';
                const includeTable = toolbar.dataset.includeTable === 'true';
                const buttonHTML = getMarkdownButtonBarHTML({ includeImage, includeTable });
                
                // Insert buttons directly into text-field-container (buttons must be direct children)
                const container = toolbar.parentElement; // text-field-container
                if (container && container.classList.contains('text-field-container')) {
                    // Create a temporary div to parse the HTML
                    const temp = document.createElement('div');
                    temp.innerHTML = buttonHTML.trim();
                    
                    // Insert buttons before the placeholder
                    while (temp.firstChild) {
                        container.insertBefore(temp.firstChild, toolbar);
                    }
                    
                    // Remove the placeholder
                    toolbar.remove();
                }
            });
        }
        
        // Helper: Build complete lesson standard array-item with textarea and markdown buttons
        // Note: attachPreviews() and applyFontSettings() must be called AFTER DOM insertion
        function buildLessonStandardArrayItem() {
            const newItem = document.createElement('div');
            newItem.className = 'array-item';
            newItem.setAttribute('data-item-type', 'standard');
            
            // Build standards-specific button config (LIST_ITEM style with before/after)
            const standardConfig = {
                ...ACTION_BUTTON_CONFIGS.LIST_ITEM,
                handlers: {
                    before: 'addLessonStandardBefore',
                    after: 'addLessonStandardAfter',
                    moveUp: 'moveItemUp',
                    moveDown: 'moveItemDown',
                    remove: 'removeArrayItem'
                },
                containerClass: 'row-actions'
            };
            
            newItem.innerHTML = `
                <div class="text-field-container">
                    <span class="input-label">Input Markdown</span>
                    <textarea placeholder="e.g., CCSS.MATH.CONTENT.8.G.A.1" title="Educational standard code (e.g., Common Core State Standards)"></textarea>
                    ${getMarkdownButtonBarHTML()}
                </div>
                ${buildActionButtonsHTML(standardConfig, { itemLabel: 'Standard' })}
            `;
            
            // Ensure the new lesson standard field starts with RTL (default direction)
            const textarea = newItem.querySelector('textarea');
            if (textarea) {
                textarea.setAttribute('dir', 'rtl');
            }
            
            return newItem;
        }
        
        function addLessonStandard() {
            const container = document.getElementById('lesson_standards');
            const newItem = buildLessonStandardArrayItem();
            
            container.appendChild(newItem);
            
            // Record action for undo/redo (after adding to DOM so we have the actual element)
            recordFormAction({
                type: ACTION_TYPES.ADD_ITEM,
                element: newItem,
                parent: container,
                nextSibling: null,
                containerId: 'lesson_standards',
                updateNumbers: false
            });
            
            // Use universal finalizer (includes previews, fonts, autosize)
            finalizeElement(newItem, { containerId: 'lesson_standards' });
        }

        // Helper: Build complete terminology array-item with textarea and markdown buttons
        // Note: attachPreviews() and applyFontSettings() must be called AFTER DOM insertion
        function buildTerminologyArrayItem() {
            const newItem = document.createElement('div');
            newItem.className = 'array-item';
            newItem.setAttribute('data-item-type', 'terminology');
            
            // Build terminology-specific button config (LIST_ITEM style with before/after)
            const terminologyConfig = {
                ...ACTION_BUTTON_CONFIGS.LIST_ITEM,
                handlers: {
                    before: 'addTerminologyBefore',
                    after: 'addTerminologyAfter',
                    moveUp: 'moveItemUp',
                    moveDown: 'moveItemDown',
                    remove: 'removeArrayItem'
                },
                containerClass: 'row-actions'
            };
            
            newItem.innerHTML = `
                <div class="text-field-container">
                <span class="input-label">Input Markdown</span>
                    <textarea placeholder="e.g., Parallel Lines" title="Terminology term with definition (supports markdown formatting)"></textarea>
                    ${getMarkdownButtonBarHTML()}
                </div>
                ${buildActionButtonsHTML(terminologyConfig, { itemLabel: 'Term' })}
            `;
            
            // Ensure the new terminology field starts with RTL (default direction)
            const textarea = newItem.querySelector('textarea');
            if (textarea) {
                textarea.setAttribute('dir', 'rtl');
            }
            
            return newItem;
        }
        
        function addTerminology() {
            const container = document.getElementById('terminology');
            const newItem = buildTerminologyArrayItem();
            
            container.appendChild(newItem);
            
            // Record action for undo/redo (after adding to DOM so we have the actual element)
            recordFormAction({
                type: ACTION_TYPES.ADD_ITEM,
                element: newItem,
                parent: container,
                nextSibling: null,
                containerId: 'terminology',
                updateNumbers: false
            });
            
            // Use universal finalizer (includes previews, fonts, autosize)
            finalizeElement(newItem, { containerId: 'terminology' });
        }

        // Functions to add lesson standards before/after current item
        function addLessonStandardBefore(button) {
            insertArrayItemBefore(
                button,
                buildLessonStandardArrayItem,
                { containerId: 'lesson_standards', updateNumbers: false }
            );
        }

        function addLessonStandardAfter(button) {
            insertArrayItemAfter(
                button,
                buildLessonStandardArrayItem,
                { containerId: 'lesson_standards', updateNumbers: false }
            );
        }

        // Functions to add terminology before/after current item
        function addTerminologyBefore(button) {
            insertArrayItemBefore(
                button,
                buildTerminologyArrayItem,
                { containerId: 'terminology', updateNumbers: false }
            );
        }

        function addTerminologyAfter(button) {
            insertArrayItemAfter(
                button,
                buildTerminologyArrayItem,
                { containerId: 'terminology', updateNumbers: false }
            );
        }


        // Flag to prevent redundant updates during bulk operations
        let isBulkOperation = false;

        /**
         * Unified helper for adding/inserting content sections and questions.
         * Single source of truth for the add/insert pattern.
         * 
         * @param {Object} options
         * @param {string} options.containerId - ID of the parent container
         * @param {Function} options.builderFn - Function that takes count and returns new element
         * @param {string} [options.position='end'] - 'end', 'before', or 'after'
         * @param {HTMLElement} [options.referenceElement=null] - Required for 'before'/'after'
         * @param {Function} [options.setupFn=null] - Optional function to run after element creation but before finalization
         * @param {boolean} [options.captureSnapshot=false] - Whether to capture snapshotState for undo/redo
         * @param {Function} [options.snapshotFn=null] - Function to generate snapshot state
         * @returns {HTMLElement|null} The newly created element, or null if failed
         */
        function addOrInsertSection(options) {
            const {
                containerId,
                builderFn,
                position = 'end',
                referenceElement = null,
                setupFn = null,
                captureSnapshot = false,
                snapshotFn = null
            } = options;
            
            const container = document.getElementById(containerId);
            if (!container) return null;
            
            // For 'before'/'after', we need a reference element
            if ((position === 'before' || position === 'after') && !referenceElement) {
                return null;
            }
            
            const itemCount = container.querySelectorAll(':scope > .array-item').length + 1;
            const newElement = builderFn(itemCount);
            
            // Insert at the appropriate position
            if (position === 'end') {
                container.appendChild(newElement);
            } else if (position === 'before') {
                container.insertBefore(newElement, referenceElement);
            } else if (position === 'after') {
                container.insertBefore(newElement, referenceElement.nextSibling);
            }
            
            // Run optional setup function (e.g., direction attributes for questions)
            if (setupFn) {
                setupFn(newElement);
            }
            
            // Record action for undo/redo
            const action = {
                type: ACTION_TYPES.ADD_ITEM,
                element: newElement,
                parent: container,
                nextSibling: position === 'end' ? null : newElement.nextSibling,
                containerId: containerId,
                updateNumbers: true
            };
            if (captureSnapshot && snapshotFn) {
                action.snapshotState = snapshotFn(newElement);
            }
            recordFormAction(action);
            
            // Finalize: skipBulkCheck only for non-end positions (before/after always update immediately)
            const skipBulk = position !== 'end';
            finalizeElement(newElement, { containerId: containerId, skipBulkCheck: skipBulk });
            
            return newElement;
        }

        function addContentSection() {
            addOrInsertSection({
                containerId: 'content_sections_container',
                builderFn: buildContentSectionItem,
                position: 'end'
            });
        }

        // Unified helper for appending BBox items to container
        function appendBBoxItem(button, beforeHandler, afterHandler) {
            const container = button.previousElementSibling;
            const newItem = buildBBoxRow({
                beforeHandler,
                afterHandler,
                buttonOrder: 'reorderFirst'
            });
            
            container.appendChild(newItem);
            
            recordFormAction({
                type: ACTION_TYPES.ADD_ITEM,
                element: newItem,
                parent: container,
                nextSibling: null,
                containerId: null,
                updateNumbers: false
            });
            
            finalizeBBoxRow(newItem);
        }

        function addContentImage(button) {
            appendBBoxItem(button, 'addContentImageBefore', 'addContentImageAfter');
        }

        function addQuestionImage(button) {
            appendBBoxItem(button, 'addQuestionImageBefore', 'addQuestionImageAfter');
        }

        function addAnswerImage(button) {
            appendBBoxItem(button, 'addAnswerImageBefore', 'addAnswerImageAfter');
        }

        // Functions to add sections before/after current section
        function addContentSectionBefore(button) {
            const currentSection = button.closest('.array-item');
            if (!currentSection) return;
            
            addOrInsertSection({
                containerId: 'content_sections_container',
                builderFn: buildContentSectionItem,
                position: 'before',
                referenceElement: currentSection
            });
        }

        function addContentSectionAfter(button) {
            const currentSection = button.closest('.array-item');
            if (!currentSection) return;
            
            addOrInsertSection({
                containerId: 'content_sections_container',
                builderFn: buildContentSectionItem,
                position: 'after',
                referenceElement: currentSection
            });
        }

        function addQuestionBefore(button) {
            const currentQuestion = button.closest('.array-item');
            if (!currentQuestion) return;
            
            // Note: addQuestionBefore does NOT set dataset.questionType (preserving original behavior)
            addOrInsertSection({
                containerId: 'questions_container',
                builderFn: buildQuestionItem,
                position: 'before',
                referenceElement: currentQuestion,
                captureSnapshot: true,
                snapshotFn: serializeQuestionState
            });
        }

        function addQuestionAfter(button) {
            const currentQuestion = button.closest('.array-item');
            if (!currentQuestion) return;
            
            addOrInsertSection({
                containerId: 'questions_container',
                builderFn: (count) => buildQuestionItem(count, { setDataset: true }),
                position: 'after',
                referenceElement: currentQuestion,
                captureSnapshot: true,
                snapshotFn: serializeQuestionState
            });
        }

        /**
         * Helper: Build a new question DOM element.
         * Returns the DOM element (not inserted into DOM).
         * Note: attachPreviews() and applyFontSettings() must be called AFTER DOM insertion.
         * 
         * @param {number} questionCount - The question number (1-based)
         * @param {Object} [options={}] - Build options
         * @param {boolean} [options.setDataset=false] - Whether to set dataset.questionType = 'free_form'
         * @returns {HTMLElement} The new question element
         */
        function buildQuestionItem(questionCount, options = {}) {
            const { setDataset = false } = options;
            
            const newQuestion = document.createElement('div');
            newQuestion.className = 'array-item';
            newQuestion.setAttribute('data-item-type', 'question');
            // Mark as a true section for navigation (canonical section marker)
            newQuestion.setAttribute('data-section-id', `question-${questionCount}`);
            newQuestion.innerHTML = getQuestionHTML(questionCount);
            
            if (setDataset) {
            // CRITICAL: Set dataset for new questions (defaults to free_form)
            newQuestion.dataset.questionType = 'free_form';
            }
            
            return newQuestion;
        }
        
        /**
         * Setup direction attributes for a new question element.
         * Used by addQuestion() to set RTL for textareas and LTR for ID fields.
         * 
         * @param {HTMLElement} questionEl - The question element
         */
        function setupQuestionDirections(questionEl) {
            // Ensure all textareas in the new question start with RTL (content is RTL)
            questionEl.querySelectorAll('textarea').forEach(ta => {
                ta.setAttribute('dir', 'rtl');
            });
            // Ensure ID fields start with LTR (English text)
            const idInput = questionEl.querySelector('input[placeholder*="e.g.,"]');
            if (idInput) {
                idInput.setAttribute('dir', 'ltr');
            }
            const relatedInput = questionEl.querySelector('input[placeholder*="9a (for grouped questions)"]');
            if (relatedInput) {
                relatedInput.setAttribute('dir', 'ltr');
            }
            // Ensure direction buttons show "LTR" since content is RTL by default
            questionEl.querySelectorAll('.dir-btn').forEach(btn => {
                btn.textContent = 'LTR';
            });
        }

        // Helper: Build complete content section DOM element
        // Returns the DOM element (not inserted into DOM)
        // Note: attachPreviews() and applyFontSettings() must be called AFTER DOM insertion
        function buildContentSectionItem(sectionCount) {
            const newSection = document.createElement('div');
            newSection.className = 'array-item';
            newSection.setAttribute('data-item-type', 'content-section');
            // Mark as a true section for navigation (canonical section marker)
            newSection.setAttribute('data-section-id', `content-${sectionCount}`);
            newSection.innerHTML = getContentSectionHTML(sectionCount);
            
            // Ensure the new section textarea starts with RTL (content is RTL)
            const newTextarea = newSection.querySelector('textarea');
            if (newTextarea) {
                newTextarea.setAttribute('dir', 'rtl');
            }
            
            // Ensure the section title starts with RTL (Arabic content)
            const newTitleInput = newSection.querySelector('input[placeholder="Section title"]');
            if (newTitleInput) {
                newTitleInput.setAttribute('dir', 'rtl');
            }
            
            // Ensure the direction button shows "LTR" since content is RTL by default
            const dirBtn = newSection.querySelector('.dir-btn');
            if (dirBtn) {
                dirBtn.textContent = 'LTR';
            }
            
            return newSection;
        }
        
        // Helper: Generate bbox inputs HTML (5 inputs: page, x0, y0, x1, y1)
        // values: { page, x0, y0, x1, y1 } (optional, defaults to empty)
        function getBBoxInputsHTML(values = {}) {
            const { page = '', x0 = '', y0 = '', x1 = '', y1 = '' } = values;
            return `
                <div class="bbox-inputs">
                    <input type="number" placeholder="Page" class="bbox-page" min="1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57" value="${page}">
                    <input type="number" placeholder="X0" class="bbox-x0" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57" value="${x0}">
                    <input type="number" placeholder="Y0" class="bbox-y0" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57" value="${y0}">
                    <input type="number" placeholder="X1" class="bbox-x1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57" value="${x1}">
                    <input type="number" placeholder="Y1" class="bbox-y1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57" value="${y1}">
                </div>
            `;
        }
        
        // Helper: Generate bbox row-actions buttons HTML
        // options: { beforeHandler, afterHandler, buttonOrder }
        // buttonOrder: 'beforeFirst' (Before/After first) or 'reorderFirst' (reorder buttons first) or 'none' (no Before/After)
        function getBBoxRowActionsHTML(options = {}) {
            const { beforeHandler = null, afterHandler = null, buttonOrder = 'beforeFirst' } = options;
            
            // Build bbox-specific button config
            // Button order must match question template: moveUp, moveDown, before, after, draw, paste, copy, duplicate, remove
            const bboxConfig = {
                ...ACTION_BUTTON_CONFIGS.BBOX,
                handlers: {
                    moveUp: 'moveItemUp',
                    moveDown: 'moveItemDown',
                    before: beforeHandler,
                    after: afterHandler,
                    draw: 'openBboxDrawer',
                    paste: 'pasteBboxJson',
                    copy: 'copyBboxJson',
                    duplicate: 'duplicateBbox',
                    remove: 'removeArrayItem'
                },
                buttons: beforeHandler && afterHandler 
                    ? (buttonOrder === 'beforeFirst' 
                        ? ['before', 'after', 'moveUp', 'moveDown', 'draw', 'paste', 'copy', 'duplicate', 'remove']
                        : ['moveUp', 'moveDown', 'before', 'after', 'draw', 'paste', 'copy', 'duplicate', 'remove'])
                    : ['moveUp', 'moveDown', 'draw', 'paste', 'copy', 'duplicate', 'remove']
            };
            
            return `<div class="row-actions">${buildActionButtonsHTML(bboxConfig)}</div>`;
        }
        
        // Helper: Build complete bbox row DOM element
        // options: { values, beforeHandler, afterHandler, buttonOrder }
        // Returns DOM element (not inserted into DOM)
        function buildBBoxRow(options = {}) {
            const { values = {}, beforeHandler = null, afterHandler = null, buttonOrder = 'beforeFirst' } = options;
            
            const newItem = document.createElement('div');
            newItem.className = 'array-item';
            newItem.setAttribute('data-item-type', 'image');
            newItem.innerHTML = getBBoxInputsHTML(values) + getBBoxRowActionsHTML({ beforeHandler, afterHandler, buttonOrder });
            
            return newItem;
        }
        
        // Helper: Attach bbox validation to a single item
        function attachBboxValidationToItem(item) {
            const coordinateInputs = item.querySelectorAll('.bbox-x0, .bbox-y0, .bbox-x1, .bbox-y1');
            coordinateInputs.forEach(input => {
                // Remove existing listener if any
                if (input.__bboxValidationHandler) {
                    input.removeEventListener('blur', input.__bboxValidationHandler);
                }
                
                // Add new listener
                const handler = function() {
                    validateAndNormalizeBbox(item);
                };
                input.addEventListener('blur', handler);
                input.__bboxValidationHandler = handler;
            });
        }
        
        // Helper: Attach bbox validation to all bbox items in a container
        function attachBboxValidation(container) {
            const bboxItems = container.querySelectorAll('.bbox-container .array-item, .array-item .bbox-inputs');
            // Find parent array-items that contain bbox-inputs
            const items = Array.from(container.querySelectorAll('.array-item')).filter(item => 
                item.querySelector('.bbox-inputs')
            );
            items.forEach(item => {
                attachBboxValidationToItem(item);
            });
        }
        
        // Helper: Finalize a bbox row (apply validation and font settings)
        function finalizeBBoxRow(item) {
            attachBboxValidationToItem(item);
            applyFontSettings(item);
        }
        
        /**
         * Finalize a pasted section by applying font settings to all bbox inputs
         * This ensures bbox inputs match current font settings after paste operations
         * @param {HTMLElement} sectionEl - The section element to finalize
         * @param {Object} options - Options object
         * @param {string} options.type - 'content' or 'question'
         */
        /**
         * Finalize a pasted section (after paste operation).
         * Specialization of finalizeElement for pasted content.
         */
        function finalizePastedSection(sectionEl, options = {}) {
            if (!sectionEl) return;
            
            // Use canonical finalizer for fonts, refresh, and autosize
            // Note: previews should already be attached by caller before this is called
            finalizeElement(sectionEl, { 
                previews: false,  // Caller should have attached previews already
                fonts: true, 
                bbox: false,  // We handle bbox finalization separately below
                refresh: true, 
                autoSize: true 
            });
            
            // Also explicitly finalize all bbox rows in the section
            // This ensures any bbox rows created by fillBboxGroup get proper font settings
            const allBboxItems = sectionEl.querySelectorAll('.bbox-container .array-item');
            allBboxItems.forEach(item => {
                finalizeBBoxRow(item);
            });
        }
        
        /* ============================================================================
         * CANONICAL HELPERS - Single Source of Truth
         * ============================================================================
         * Element finalization:     finalizeElement(el, options)
         * Final preview box:        buildPreviewBox(options)
         * Edit-pen navigation:      navigateToInput(element)
         * Section/Question insert:  addOrInsertSection(options)
         * Textarea autosize:        AutoSizeManager.finalizeSpawn(el) after spawn / markDirty(el) on input
         * Undo/redo restore:        postUndoRedoRestore(element)
         * Choice UIDs:              ensureChoiceUids(), getCorrectChoiceUid(), getCorrectChoiceUids()
         * Matching UIDs:            ensureMatchingUids()
         * ============================================================================ */

        /**
         * Unified finalization helper for newly created/restored elements.
         * Single source of truth for the post-insertion initialization sequence.
         * 
         * @param {HTMLElement} el - The element to finalize
         * @param {Object} options - Finalization options
         * @param {boolean} [options.previews=true] - Attach preview boxes
         * @param {boolean} [options.fonts=true] - Apply font settings
         * @param {boolean} [options.bbox=true] - Attach bbox validation
         * @param {boolean} [options.refresh=true] - Force render all previews
         * @param {boolean} [options.autoSize=true] - Trigger autosize pipeline
         * @param {string|null} [options.containerId=null] - Container ID for afterListMutation
         * @param {boolean} [options.skipBulkCheck=false] - Skip isBulkOperation check for containerId
         */
        function finalizeElement(el, options = {}) {
            if (!el) return;
            
            const {
                previews = true,
                fonts = true,
                bbox = true,
                refresh = true,
                autoSize = true,
                containerId = null,
                skipBulkCheck = false
            } = options;
            
            // Order matters: previews before fonts (so previews inherit font settings)
            if (previews) {
                attachPreviews(el);
            }
            
            if (fonts) {
                applyFontSettings(el);
            }
            
            if (bbox) {
                attachBboxValidation(el);
            }
            
            // Update list numbering if container specified
            if (containerId && (skipBulkCheck || !isBulkOperation)) {
                afterListMutation(containerId);
            }
            
            // Force render previews after all setup is complete
            if (refresh && typeof PreviewBox !== 'undefined' && PreviewBox.ensureRendered) {
                PreviewBox.ensureRendered(el);
            }
            
            // Spawn finalization: register and force-fit with current content (after values/previews are set)
            if (autoSize && typeof AutoSizeManager !== 'undefined' && AutoSizeManager.finalizeSpawn) {
                AutoSizeManager.finalizeSpawn(el);
            }
        }
        
        // Unified helper: Insert array item before current item
        // builderFn: function that returns a new DOM element
        // recordOptions: { containerId: string|null, updateNumbers: bool, snapshotState: any|null }
        function insertArrayItemBefore(button, builderFn, recordOptions = {}) {
            const currentItem = button.closest('.array-item');
            const container = currentItem ? currentItem.parentElement : null;
            if (!currentItem || !container) return;
            
            const newItem = builderFn();
            container.insertBefore(newItem, currentItem);
            
            // Use canonical finalizer (builders already set RTL on textareas)
            finalizeElement(newItem, { 
                previews: true, 
                fonts: true, 
                bbox: false, 
                refresh: true, 
                autoSize: true,
                containerId: recordOptions.containerId || null
            });
            
            recordFormAction({
                type: ACTION_TYPES.ADD_ITEM,
                element: newItem,
                parent: container,
                nextSibling: newItem.nextSibling,
                containerId: recordOptions.containerId || null,
                updateNumbers: recordOptions.updateNumbers || false,
                snapshotState: recordOptions.snapshotState || null
            });
        }
        
        // Unified helper: Insert array item after current item
        function insertArrayItemAfter(button, builderFn, recordOptions = {}) {
            const currentItem = button.closest('.array-item');
            const container = currentItem ? currentItem.parentElement : null;
            if (!currentItem || !container) return;
            
            const newItem = builderFn();
            container.insertBefore(newItem, currentItem.nextSibling);
            
            // Use canonical finalizer (builders already set RTL on textareas)
            finalizeElement(newItem, { 
                previews: true, 
                fonts: true, 
                bbox: false, 
                refresh: true, 
                autoSize: true,
                containerId: recordOptions.containerId || null
            });
            
            recordFormAction({
                type: ACTION_TYPES.ADD_ITEM,
                element: newItem,
                parent: container,
                nextSibling: newItem.nextSibling,
                containerId: recordOptions.containerId || null,
                updateNumbers: recordOptions.updateNumbers || false,
                snapshotState: recordOptions.snapshotState || null
            });
        }

        // Helper function to get HTML for content section (extracted from addContentSection)
        function getContentSectionHTML(sectionCount) {
            // Build content section-specific button config
            const contentConfig = {
                ...ACTION_BUTTON_CONFIGS.SECTION,
                handlers: {
                    before: 'addContentSectionBefore',
                    after: 'addContentSectionAfter',
                    copy: 'copySection',
                    paste: 'pasteIntoSection',
                    duplicate: 'duplicateSection',
                    moveUp: 'moveItemUp',
                    moveDown: 'moveItemDown',
                    collapse: 'toggleSectionCollapse',
                    remove: 'removeArrayItem'
                }
            };
            
            return `
                <div class="array-item-header">
                    <h4>Content Section ${sectionCount}</h4>
                    ${buildActionButtonsHTML(contentConfig, { sectionLabel: 'Section' })}
                </div>
                
                <div class="section-content">
                <div class="form-group">
                    <label>Section Title</label>
                    <span class="input-label">Input Markdown</span>
                    <div class="text-field-container">
                        <input type="text" placeholder="Section title" title="Optional title for this content section (supports markdown formatting)">
                        ${getTitleMarkdownButtonBarHTML('input')}
                    </div>
                </div>
                
                <div class="form-group required-field required">
                    <label>Content (Markdown + LaTeX)</label>
                    <div class="text-field-container">
                        <span class="input-label">Input Markdown</span>
                        <textarea placeholder="Enter content with markdown formatting and LaTeX..." title="Main content text supporting markdown and LaTeX math expressions"></textarea>
                        ${getMarkdownButtonBarHTML({ includeImage: true, includeTable: true })}
                    </div>
                </div>
                
                <div class="form-group">
                    <label>Section Images</label>
                    <div class="bbox-container">
                        <div class="array-item" data-item-type="image">
                            ${getBBoxInputsHTML() + getBBoxRowActionsHTML({ beforeHandler: 'addContentImageBefore', afterHandler: 'addContentImageAfter', buttonOrder: 'reorderFirst' })}
                        </div>
                    </div>
                    ${getActionButtonHTML({ label: 'Add Image', onClick: 'addContentImage(this)', iconClass: 'fa-plus', title: 'Add a new image bounding box for this content section' })}
                </div>
                </div>
            `;
        }

        // Helper: Generate question header fields HTML
        // Returns HTML string for: question_id, question_type, guide_pdf_page, related_question
        function getQuestionHeaderFieldsHTML() {
            return `
                <div class="form-group required-field required">
                    <label>Question ID</label>
                    <input type="text" placeholder="e.g., 1" data-ltr="true" title="Unique identifier for this question (e.g., 1, 2, 3)">
                </div>
                
                <div class="form-group">
                    <label>Question Type</label>
                    <select class="question-type-select" onchange="toggleQuestionType(this)" title="Select the type of question (affects available fields and validation)">
                        <option value="free_form" selected>Free Form</option>
                        <option value="multiple_choice">Multiple Choice</option>
                        <option value="checkbox">Checkbox</option>
                        <option value="fill_in_the_blanks">Fill in the Blanks</option>
                        <option value="matching">Matching</option>
                        <option value="annotate">Annotate</option>
                        <option value="create_table">Create Table</option>
                    </select>
                </div>
                
                <div class="form-group required-field required">
                    <label>Guide PDF Page</label>
                    <input type="number" placeholder="e.g., 78" min="1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57" title="Page number in the guidebook PDF where the answer appears (must be within the guidebook page range)">
                </div>
                
                <div class="form-group">
                    <label>Related Question</label>
                    <input type="text" placeholder="Leave empty if no related questions" data-ltr="true" title="Optional reference to related questions (e.g., 3)">
                </div>
            `;
        }

        // Helper: Generate markdown-enabled textarea block HTML for setup_text and question_text
        // Returns HTML string for a textarea with markdown toolbar
        function getQuestionMarkdownTextareaBlockHTML(options = {}) {
            const { label, placeholder, title, required = false, includeBlankButton = false } = options;
            const requiredClass = required ? 'required-field required' : '';
            const blankButtonHTML = includeBlankButton ? `
                        <button type="button" class="blank-btn" onclick="insertBlankAtCursor(this.parentElement.querySelector('textarea'))" style="display: none;" title="Insert a fill-in-the-blank placeholder">
                            <i class="fas fa-square"></i> Insert Blank
                        </button>` : '';
            
            return `
                <div class="form-group ${requiredClass}">
                    <label>${label}</label>
                    <div class="text-field-container">
                        <span class="input-label">Input Markdown</span>
                        <textarea placeholder="${placeholder}" title="${title}"></textarea>
                        ${getMarkdownButtonBarHTML({ includeImage: true, includeTable: true })}
                        ${blankButtonHTML}
                    </div>
                </div>
            `;
        }

        // Helper: Generate choice row HTML (for MCQ and Checkbox)
        // Returns HTML string for a complete choice item
        function getChoiceRowHTML(options = {}) {
            const { questionType = 'multiple_choice', choiceId = '', choiceText = '' } = options;
            const isCheckbox = questionType === 'checkbox';
            const checkedField = isCheckbox ? `
                <div class="form-group checkbox-group" style="align-items: center; margin-top: 10px;">
                    <label for="choice-correct-${Date.now()}" style="font-weight: 600; color: #28a745;"> Correct Answer</label>
                    <input type="checkbox" class="choice-correct" id="choice-correct-${Date.now()}" title="Mark this choice as a correct answer">
                </div>
            ` : '';
            
            // Build choice-specific button config
            const choiceConfig = {
                ...ACTION_BUTTON_CONFIGS.LIST_ITEM,
                handlers: {
                    before: 'addChoiceBefore',
                    after: 'addChoiceAfter',
                    moveUp: 'moveChoiceUp',
                    moveDown: 'moveChoiceDown',
                    remove: 'removeChoice'
                }
            };
            
            return `
                <div class="array-item-header">
                    <h5>Choice</h5>
                    ${buildActionButtonsHTML(choiceConfig, { itemLabel: 'Choice' })}
                </div>
                <div class="form-group">
                    <label>Choice ID <span style="opacity: 0.6; font-size: 0.85em;">(Optional)</span></label>
                    <input type="text" class="choice-id" value="${choiceId}" data-ltr="true" placeholder="Optional: A, B, C..." oninput="updateChoiceHeader(this)" title="Optional identifier for this choice (e.g., A, B, C, D)">
                </div>
                <div class="form-group required-field required">
                    <label>Choice Text</label>
                    <div class="text-field-container">
                        <span class="input-label">Input Markdown</span>
                        <textarea class="choice-text" placeholder="Enter choice text..." title="The text for this answer choice (supports markdown and LaTeX)">${choiceText}</textarea>
                        ${getMarkdownButtonBarHTML({ includeImage: true, includeTable: true })}
                    </div>
                </div>
                ${checkedField}
            `;
        }

        // Helper: Generate blank answer item HTML
        // Returns HTML string for a blank answer input field
        function getBlankAnswerItemHTML(blankNum, value = '') {
            return `
                <div class="form-group blank-answer-item" style="margin-bottom: 15px;" data-blank-number="${blankNum}">
                    <label style="font-weight: 600; color: var(--text-primary);">
                        <span style="color: var(--accent); font-size: 1.1em;">___${blankNum}___</span> Answer
                    </label>
                    <div class="text-field-container">
                        <span class="input-label">Input Markdown</span>
                        <textarea class="blank-answer-input" placeholder="Enter answer for blank ${blankNum}..." style="min-height: 60px;" title="Answer text for blank ___${blankNum}___ (supports markdown and LaTeX)">${value}</textarea>
                        ${getTitleMarkdownButtonBarHTML('textarea')}
                    </div>
                </div>
            `;
        }

        // Helper: Generate matching item HTML (for left/right items)
        // Returns HTML string for a matching item
        function getMatchingItemHTML(side, itemCount) {
            // Build matching item-specific button config with custom styles
            const matchingConfig = {
                ...ACTION_BUTTON_CONFIGS.LIST_ITEM,
                handlers: {
                    before: 'addMatchingItemBefore',
                    after: 'addMatchingItemAfter',
                    moveUp: 'moveMatchingItemUp',
                    moveDown: 'moveMatchingItemDown',
                    remove: 'removeMatchingItem'
                },
                customStyles: {
                    before: 'padding: 2px 6px; font-size: 0.8em;',
                    after: 'padding: 2px 6px; font-size: 0.8em;',
                    moveUp: 'padding: 2px 6px; font-size: 0.8em;',
                    moveDown: 'padding: 2px 6px; font-size: 0.8em;',
                    remove: 'padding: 2px 8px; font-size: 0.9em;'
                },
                containerClass: null // Inline in flex container
            };
            
            const sideLabel = side === 'left' ? 'Left' : 'Right';
            return `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <strong style="color: var(--accent); font-size: 1.1em;">${side === 'left' ? 'L' : 'R'}${itemCount}</strong>
                    <div style="display: flex; gap: 5px;">
                        ${buildActionButtonsHTML(matchingConfig, { itemLabel: `${sideLabel} Item` })}
                    </div>
                </div>
                <div class="text-field-container">
                    <span class="input-label">Input Markdown</span>
                    <textarea class="matching-item-text" placeholder="Enter ${side} item text..." style="min-height: 60px;" title="Text for this ${side} matching item (supports markdown and LaTeX)"></textarea>
                    ${getMarkdownButtonBarHTML({ includeImage: true, includeTable: true })}
                </div>
            `;
        }

        // Helper: Generate guide answer block HTML (supports required and optional formats)
        // Returns HTML string for guide_answer field
        function getGuideAnswerHTML(options = {}) {
            const { required = false, containerId = null, containerClasses = '' } = options;
            
            if (required) {
                // Format A: Required guide answer (for free_form, annotate, create_table)
                return `
                    <div class="form-group required-field required free-form-answer" ${containerId ? `id="${containerId}"` : ''}>
                    <label>Guide Answer</label>
                    <div class="text-field-container">
                        <span class="input-label">Input Markdown</span>
                        <textarea placeholder="Enter guide answer..." title="Step-by-step solution or answer key for teachers (supports markdown and LaTeX)"></textarea>
                            ${getMarkdownButtonBarHTML({ includeImage: true, includeTable: true })}
                        </div>
                    </div>
                `;
            } else {
                // Format B: Optional guide answer (for multiple_choice, checkbox, fill_in_the_blanks, matching)
                return `
                    <div class="form-group" style="margin-top: 15px;" ${containerClasses ? `class="${containerClasses}"` : ''}>
                        <label>Guide Answer <span style="opacity: 0.6; font-size: 0.85em;">(Optional)</span></label>
                        <div class="text-field-container">
                            <span class="input-label">Input Markdown</span>
                            <textarea class="guide-answer-notes" placeholder="Optional: Enter guide answer..." title="Optional guide answer or notes for teachers (supports markdown and LaTeX)"></textarea>
                            ${getMarkdownButtonBarHTML({ includeImage: true, includeTable: true })}
                        </div>
                    </div>
                `;
            }
        }

        // Helper function to get HTML for question (extracted from addQuestion)
        function getQuestionHTML(questionCount) {
            // Build question-specific button config
            const questionConfig = {
                ...ACTION_BUTTON_CONFIGS.SECTION,
                handlers: {
                    before: 'addQuestionBefore',
                    after: 'addQuestionAfter',
                    copy: 'copySection',
                    paste: 'pasteIntoSection',
                    duplicate: 'duplicateSection',
                    moveUp: 'moveItemUp',
                    moveDown: 'moveItemDown',
                    collapse: 'toggleSectionCollapse',
                    remove: 'removeArrayItem'
                }
            };
            
            return `
                <div class="array-item-header">
                    <h4>Question ${questionCount}</h4>
                    ${buildActionButtonsHTML(questionConfig, { sectionLabel: 'Question' })}
                </div>
                
                <div class="section-content">
                ${getQuestionHeaderFieldsHTML()}
                
                ${getQuestionMarkdownTextareaBlockHTML({
                    label: 'Set-up Text (Shared across questions)',
                    placeholder: 'Text shared across multiple questions or required to answer...',
                    title: 'Context or information shared across multiple questions (supports markdown and LaTeX)',
                    required: false
                })}
                
                ${getQuestionMarkdownTextareaBlockHTML({
                    label: 'Question Text',
                    placeholder: 'Enter question text...',
                    title: 'The main question text that students need to answer (supports markdown and LaTeX)',
                    required: true,
                    includeBlankButton: true
                })}
                
                ${getGuideAnswerHTML({ required: true, containerId: 'guide-answer-container' })}
                
                <div class="form-group mcq-choices" id="choices-container" style="display: none;">
                    <label>Multiple Choice Options</label>
                    <div id="choices-list-${questionCount}">
                        <!-- Choices will be added here -->
                </div>
                    ${getActionButtonHTML({ label: 'Add Choice', onClick: 'addChoice(this)', iconClass: 'fa-plus', title: 'Add a new answer choice' })}
                    <div class="form-group" id="correct-answer-selector" style="margin-top: 15px; display: none;">
                        <label style="font-weight: 600;">Correct Answer Position</label>
                        <div id="correct-answer-radios-${questionCount}" style="display: flex; flex-direction: column; gap: 8px; margin-top: 8px;">
                            <!-- Radio buttons will be generated dynamically based on choices -->
                        </div>
                    </div>
                    <div class="form-group" style="margin-top: 15px; display: none;" id="checkbox-summary">
                        <label style="font-weight: 600; color: #28a745;">Correct Answers Summary</label>
                        <div id="checkbox-summary-text" style="padding: 10px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 6px; font-size: 0.9em;">
                            <span style="opacity: 0.7; color: var(--text-secondary);">Check the " Correct Answer" boxes above to mark correct choices</span>
                        </div>
                    </div>
                    ${getGuideAnswerHTML({ required: false })}
                </div>
                
                <!-- Fill in the Blanks Section -->
                <div class="form-group" id="blanks-container" style="display: none;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <label style="font-weight: 600; margin: 0;">Blank Answers</label>
                        ${getActionButtonHTML({ label: 'Insert Next Blank', onClick: "insertBlankAtCursor(this.closest('.array-item').querySelector('textarea[placeholder*=\\'Enter question text\\']'))", iconClass: 'fa-plus', title: 'Insert the next numbered blank placeholder in the question text', style: 'padding: 4px 10px; font-size: 0.85em;' })}
                    </div>
                    <div id="blanks-validation-errors" style="display: none; margin-bottom: 10px;"></div>
                    <div id="blanks-answers-container" style="padding: 15px; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 8px;">
                        <p style="color: var(--text-secondary); font-style: italic;">No blanks detected. Use ___1___, ___2___, etc. in your question text.</p>
                    </div>
                    
                    <!-- Preview of Question with Filled Blanks -->
                    <div class="form-group" style="margin-top: 15px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <label style="font-weight: 600; margin: 0;">Preview with Answers</label>
                        <button type="button" class="dir-btn" onclick="toggleFilledBlanksDirection(this)" style="margin: 0;" title="Toggle text direction (LTR/RTL)">LTR</button>
                        </div>
                        <div id="filled-blanks-preview" class="live-preview" style="min-height: 80px; max-height: 400px;" dir="rtl" title="Preview of the question with blank answers filled in">
                            <p style="color: var(--text-secondary); font-style: italic;">Preview will appear here when blanks are filled</p>
                        </div>
                    </div>
                    
                    ${getGuideAnswerHTML({ required: false })}
                </div>
                
                <!-- Matching Section -->
                <div class="form-group" id="matching-container" style="display: none;">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                        <!-- Left Column -->
                        <div>
                            <label style="font-weight: 600; margin: 0 0 10px 0; display: block;">Left Items</label>
                            <div id="matching-left-list-${questionCount}" class="matching-list" style="display: flex; flex-direction: column; gap: 10px; margin-bottom: 10px;">
                                <!-- Left items will be added here -->
                            </div>
                            ${getActionButtonHTML({ label: 'Add Left Item', onClick: "addMatchingItem(this, 'left')", iconClass: 'fa-plus', title: 'Add a new item to the left column' })}
                        </div>
                        
                        <!-- Right Column -->
                        <div>
                            <label style="font-weight: 600; margin: 0 0 10px 0; display: block;">Right Items</label>
                            <div id="matching-right-list-${questionCount}" class="matching-list" style="display: flex; flex-direction: column; gap: 10px; margin-bottom: 10px;">
                                <!-- Right items will be added here -->
                            </div>
                            ${getActionButtonHTML({ label: 'Add Right Item', onClick: "addMatchingItem(this, 'right')", iconClass: 'fa-plus', title: 'Add a new item to the right column' })}
                        </div>
                    </div>
                    
                    <!-- Relationships Section -->
                    <div style="margin-top: 20px; padding: 15px; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 8px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                            <label style="font-weight: 600; margin: 0;">Relationships</label>
                            ${getActionButtonHTML({ label: 'Add Relationship', onClick: 'addRelationship(this)', iconClass: 'fa-link', title: 'Add a new relationship connecting a left item to a right item' })}
                        </div>
                        <div id="relationships-list-${questionCount}" style="display: flex; flex-direction: column; gap: 8px;">
                            <p style="color: var(--text-secondary); font-style: italic; margin: 0;">No relationships added yet. Click "Add Relationship" to connect items.</p>
                        </div>
                    </div>
                    
                    ${getGuideAnswerHTML({ required: false })}
                </div>
                
                <div class="form-group">
                    <label>Question Images</label>
                    <div class="bbox-container">
                        <div class="array-item" data-item-type="image">
                            <div class="bbox-inputs">
                                <input type="number" placeholder="Page" class="bbox-page" min="1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57" title="PDF page number where this image appears">
                                <input type="number" placeholder="X0" class="bbox-x0" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57" title="Right X coordinate (top-right corner)">
                                <input type="number" placeholder="Y0" class="bbox-y0" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57" title="Top Y coordinate (top-right corner)">
                                <input type="number" placeholder="X1" class="bbox-x1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57" title="Left X coordinate (bottom-left corner)">
                                <input type="number" placeholder="Y1" class="bbox-y1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57" title="Bottom Y coordinate (bottom-left corner)">
                            </div>
                            <div class="row-actions">
                                <button class="reorder-btn" onclick="moveItemUp(this)" title="Move Up"><i class="fas fa-arrow-up"></i></button>
                                <button class="reorder-btn" onclick="moveItemDown(this)" title="Move Down"><i class="fas fa-arrow-down"></i></button>
                                <button class="add-bbox-btn" onclick="addQuestionImageBefore(this)" title="Add Image Before">
                                    <i class="fas fa-plus"></i> Before
                                </button>
                                <button class="add-bbox-btn" onclick="addQuestionImageAfter(this)" title="Add Image After">
                                    <i class="fas fa-plus"></i> After
                                </button>
                                <button class="add-btn" onclick="openBboxDrawer(this)" title="Open PDF viewer to draw bounding box"><i class="fas fa-pen-square"></i> Draw</button>
                                <button class="add-btn" onclick="pasteBboxJson(this)" title="Paste bounding box coordinates from clipboard"><i class="fas fa-paste"></i> Paste</button>
                                <button class="add-btn" onclick="copyBboxJson(this)" title="Copy bounding box coordinates to clipboard"><i class="fas fa-copy"></i> Copy</button>
                                <button class="duplicate-btn" onclick="duplicateBbox(this)" title="Duplicate Image"><i class="fas fa-clone"></i></button>
                                <button class="remove-btn" onclick="removeArrayItem(this)"></button>
                            </div>
                        </div>
                    </div>
                    ${getActionButtonHTML({ label: 'Add Image', onClick: 'addQuestionImage(this)', iconClass: 'fa-plus', title: 'Add a new image bounding box for question images' })}
                </div>
                
                <div class="form-group">
                    <label>Answer Images</label>
                    <div class="bbox-container">
                        <div class="array-item" data-item-type="image">
                            <div class="bbox-inputs">
                                <input type="number" placeholder="Page" class="bbox-page" min="1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57" title="PDF page number where this image appears">
                                <input type="number" placeholder="X0" class="bbox-x0" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57" title="Right X coordinate (top-right corner)">
                                <input type="number" placeholder="Y0" class="bbox-y0" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57" title="Top Y coordinate (top-right corner)">
                                <input type="number" placeholder="X1" class="bbox-x1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57" title="Left X coordinate (bottom-left corner)">
                                <input type="number" placeholder="Y1" class="bbox-y1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57" title="Bottom Y coordinate (bottom-left corner)">
                            </div>
                            <div class="row-actions">
                                <button class="reorder-btn" onclick="moveItemUp(this)" title="Move Up"><i class="fas fa-arrow-up"></i></button>
                                <button class="reorder-btn" onclick="moveItemDown(this)" title="Move Down"><i class="fas fa-arrow-down"></i></button>
                                <button class="add-bbox-btn" onclick="addAnswerImageBefore(this)" title="Add Image Before">
                                    <i class="fas fa-plus"></i> Before
                                </button>
                                <button class="add-bbox-btn" onclick="addAnswerImageAfter(this)" title="Add Image After">
                                    <i class="fas fa-plus"></i> After
                                </button>
                                <button class="add-btn" onclick="openBboxDrawer(this)" title="Open PDF viewer to draw bounding box"><i class="fas fa-pen-square"></i> Draw</button>
                                <button class="add-btn" onclick="pasteBboxJson(this)" title="Paste bounding box coordinates from clipboard"><i class="fas fa-paste"></i> Paste</button>
                                <button class="add-btn" onclick="copyBboxJson(this)" title="Copy bounding box coordinates to clipboard"><i class="fas fa-copy"></i> Copy</button>
                                <button class="duplicate-btn" onclick="duplicateBbox(this)" title="Duplicate Image"><i class="fas fa-clone"></i></button>
                                <button class="remove-btn" onclick="removeArrayItem(this)"></button>
                            </div>
                        </div>
                    </div>
                    ${getActionButtonHTML({ label: 'Add Image', onClick: 'addAnswerImage(this)', iconClass: 'fa-plus', title: 'Add a new image bounding box for answer images' })}
                </div>
                </div>
            `;
        }

        // Functions to add bboxes/images before/after current item
        // Unified helper for BBox before/after operations
        function insertBBoxItemBefore(button, beforeHandler, afterHandler) {
            const currentItem = button.closest('.array-item');
            const container = currentItem ? currentItem.parentElement : null;
            if (!currentItem || !container) return;
            
            const newItem = buildBBoxRow({
                beforeHandler,
                afterHandler,
                buttonOrder: 'reorderFirst'
            });
            
            container.insertBefore(newItem, currentItem);
            
            recordFormAction({
                type: ACTION_TYPES.ADD_ITEM,
                element: newItem,
                parent: container,
                nextSibling: newItem.nextSibling,
                containerId: null,
                updateNumbers: false
            });
            
            finalizeBBoxRow(newItem);
        }

        function insertBBoxItemAfter(button, beforeHandler, afterHandler) {
            const currentItem = button.closest('.array-item');
            const container = currentItem ? currentItem.parentElement : null;
            if (!currentItem || !container) return;
            
            const newItem = buildBBoxRow({
                beforeHandler,
                afterHandler,
                buttonOrder: 'reorderFirst'
            });
            
            container.insertBefore(newItem, currentItem.nextSibling);
            
            recordFormAction({
                type: ACTION_TYPES.ADD_ITEM,
                element: newItem,
                parent: container,
                nextSibling: newItem.nextSibling,
                containerId: null,
                updateNumbers: false
            });
            
            finalizeBBoxRow(newItem);
        }

        function addContentBboxBefore(button) {
            insertBBoxItemBefore(button, 'addContentImageBefore', 'addContentImageAfter');
        }

        function addContentBboxAfter(button) {
            insertBBoxItemAfter(button, 'addContentImageBefore', 'addContentImageAfter');
        }

        function addContentImageBefore(button) {
            insertBBoxItemBefore(button, 'addContentImageBefore', 'addContentImageAfter');
        }

        function addContentImageAfter(button) {
            insertBBoxItemAfter(button, 'addContentImageBefore', 'addContentImageAfter');
        }

        function addQuestionImageBefore(button) {
            insertBBoxItemBefore(button, 'addQuestionImageBefore', 'addQuestionImageAfter');
        }

        function addQuestionImageAfter(button) {
            insertBBoxItemAfter(button, 'addQuestionImageBefore', 'addQuestionImageAfter');
        }

        function addAnswerImageBefore(button) {
            insertBBoxItemBefore(button, 'addAnswerImageBefore', 'addAnswerImageAfter');
        }

        function addAnswerImageAfter(button) {
            insertBBoxItemAfter(button, 'addAnswerImageBefore', 'addAnswerImageAfter');
        }

        // Helper function to attach bbox validation to a single item
        // Render Markdown + LaTeX into preview container
        function renderLivePreview(textarea, previewOverride = null) {
            // Find preview box by walking through siblings (skip buttons, error divs, and labels)
            let preview = previewOverride;
            if (!preview) {
                let nextSibling = textarea.nextElementSibling;
                
                // Skip over buttons, error divs, and labels to find preview label or preview
                while (nextSibling) {
                    if (nextSibling.tagName === 'BUTTON') {
                        // Skip buttons
                        nextSibling = nextSibling.nextElementSibling;
                    } else if (nextSibling.classList && (
                        nextSibling.classList.contains('preview-label') ||
                        nextSibling.classList.contains('table-validation-errors') ||
                        nextSibling.classList.contains('list-validation-errors') ||
                        nextSibling.classList.contains('blockquote-validation-errors') ||
                        nextSibling.classList.contains('latex-validation-errors') ||
                        nextSibling.classList.contains('image-validation-errors') ||
                        nextSibling.classList.contains('quote-validation-errors') ||
                        nextSibling.classList.contains('br-validation-errors')
                    )) {
                        // Skip labels and error validation divs, continue to preview
                        nextSibling = nextSibling.nextElementSibling;
                    } else if (nextSibling.classList && nextSibling.classList.contains('live-preview')) {
                        // Found preview!
                        preview = nextSibling;
                        break;
                    } else {
                        // Unknown element, stop looking
                        break;
                    }
                }
            }
            
            if (!preview) return;
            
            // Always sync preview direction with textarea direction
            const isLTR = textarea.hasAttribute('data-ltr');
            const direction = isLTR ? 'ltr' : 'rtl';
            const textAlign = isLTR ? 'left' : 'right';
            preview.setAttribute('dir', direction);
            preview.style.textAlign = textAlign;
            
            // Update trailing spaces indicator
            updateTrailingSpacesIndicator(textarea, preview);
            
            try {
                // Normalize CRLF
                let md = (textarea.value || '').replace(/\r\n?/g, '\n');
                // Extract $$\n...\n$$ or $$ \n...\n $$ blocks to protect content from Markdown munging
                const mathBlocks = [];
                const mathBlockErrors = [];
                const imageDescriptionErrors = [];
                const quoteValidationErrors = [];
                const brTagErrors = [];
                
                // Validate quotes and dollar signs before processing markdown
                const rawValue = textarea.value || '';
                const quoteErrors = validateQuotes(rawValue);
                if (quoteErrors.length > 0) {
                    quoteValidationErrors.push(...quoteErrors);
                }
                
                const dollarErrors = validateDollarSigns(rawValue);
                if (dollarErrors.length > 0) {
                    quoteValidationErrors.push(...dollarErrors);
                }
                
                // Validate <br> tags
                const brErrors = validateBrTags(rawValue);
                if (brErrors.length > 0) {
                    brTagErrors.push(...brErrors);
                }
                
                // Protect LaTeX math expressions inside image descriptions before validation
                // This prevents false positives when descriptions contain LaTeX like $...$ or $\sqrt[3]{3}$
                const latexPlaceholders = [];
                let placeholderIndex = 0;
                
                // First, protect ALL inline math $...$ in the entire text
                // This must happen BEFORE we try to match image patterns, because LaTeX can contain brackets
                // that would confuse the image pattern matching (e.g., $\sqrt[3]{16}$)
                md = md.replace(/\$([^$\n]{1,200}?)\$/g, (mathMatch, mathContent) => {
                    // Only protect if it looks like actual math (has some content and isn't just $$)
                    if (mathContent.trim().length > 0) {
                        const placeholder = `@@LATEX_INLINE_IMG_${placeholderIndex}@@`;
                        latexPlaceholders[placeholderIndex] = mathMatch;
                        placeholderIndex++;
                        return placeholder;
                    }
                    return mathMatch; // Don't protect if it's malformed
                });
                
                // Check for malformed image syntax patterns before markdown parsing
                const malformedPatterns = [
                    { regex: /!\[([^\]]*?)\]\s+\(\d+\)/g, message: 'Space between ] and (' },
                    { regex: /!\s+\[([^\]]*?)\]\(\d+\)/g, message: 'Space between ! and [' },
                    { regex: /!\[([^\]]*?)\]\[\d+\]/g, message: 'Square brackets used instead of parentheses for index' },
                    { regex: /!\(([^)]*?)\)\(\d+\)/g, message: 'Parentheses used instead of square brackets for description' },
                    { regex: /!\{([^}]*?)\}\(\d+\)/g, message: 'Curly braces used for description' },
                    { regex: /!\[([^\]]*?)\]\{\d+\}/g, message: 'Curly braces used for index' },
                    { regex: /!\[([^\]]*?)\]\(\s+\d+\)/g, message: 'Space after opening ( in image index' },
                    { regex: /!\[([^\]]*?)\]\(\d+\s+\)/g, message: 'Space before closing ) in image index' },
                    // Removed: { regex: /!\[([^\]\n]{1,100})\(\d+\)/g, message: 'Missing closing ] bracket' },
                    // This pattern caused false positives when descriptions contained patterns like "f(0)" or "g(1)"
                    { regex: /!([a-zA-Z][^\[\]\n]{0,100})\]\(\d+\)/g, message: 'Missing opening [ bracket' },
                    { regex: /!\[([^\]]*?)\]\d+\)/g, message: 'Missing opening ( parenthesis' },
                    { regex: /!\[([^\]]*?)\]\(\d+[^\)\s]/g, message: 'Missing closing ) or extra characters' },
                    { regex: /!\[([^\]]*?)\]\(\d+$/gm, message: 'Missing closing ) parenthesis' },
                    { regex: /(?<![!\w])\[([^\]]{1,100})\]\(\d+\)/g, message: 'Missing ! at the beginning' }
                ];
                
                malformedPatterns.forEach(pattern => {
                    md = md.replace(pattern.regex, (match) => {
                        const errorIdx = imageDescriptionErrors.push({
                            type: 'malformed_syntax',
                            message: pattern.message,
                            match: match
                        }) - 1;
                        return `@@IMAGE_DESCRIPTION_ERROR_${errorIdx}@@`;
                    });
                });
                
                // Restore LaTeX math expressions after validation
                latexPlaceholders.forEach((latex, idx) => {
                    md = md.replace(`@@LATEX_INLINE_IMG_${idx}@@`, latex);
                });
                
                // Check for newlines in image descriptions before markdown parsing
                // Use the protected version to check for newlines (LaTeX is already protected)
                md = md.replace(/!\[([\s\S]*?)\]\((\d+)\)/g, (m, desc, idx) => {
                    // Restore LaTeX in description to check for actual newlines
                    let descToCheck = desc;
                    latexPlaceholders.forEach((latex, idx) => {
                        descToCheck = descToCheck.replace(`@@LATEX_INLINE_IMG_${idx}@@`, latex);
                    });
                    
                    // Check for block LaTeX ($$\n...\n$$) in image description - not allowed
                    if (descToCheck.includes('$$')) {
                        const errorIdx = imageDescriptionErrors.push({
                            type: 'block_latex_in_description',
                            message: 'Block LaTeX ($$\\n...\\n$$) is not allowed in image descriptions. Use inline LaTeX ($...$) instead',
                            description: descToCheck,
                            index: idx
                        }) - 1;
                        // Replace with placeholder that will show error
                        return `@@IMAGE_DESCRIPTION_ERROR_${errorIdx}@@`;
                    }
                    
                    // Remove all LaTeX expressions (inline and block) before checking for newlines
                    // This ensures LaTeX commands like \neq or \right( don't trigger false positives
                    const descWithoutMath = removeMathExpressions(descToCheck);
                    // Check if description contains newlines (both literal \n and actual newlines)
                    // Only check the parts outside of LaTeX expressions
                    if (descWithoutMath.includes('\n') || descWithoutMath.includes('\r') || descWithoutMath.includes('\\n') || descWithoutMath.includes('\\r')) {
                        const errorIdx = imageDescriptionErrors.push({
                            type: 'newline_in_description',
                            message: 'Image description cannot contain newline characters',
                            description: descToCheck,
                            index: idx
                        }) - 1;
                        // Replace with placeholder that will show error
                        return `@@IMAGE_DESCRIPTION_ERROR_${errorIdx}@@`;
                    }
                    return m;
                });
                
                // First, check for old format $$...$$ (without newlines) and show error
                md = md.replace(/\$\$([\s\S]*?)\$\$/g, (m, inner) => {
                    // Skip if this is already a valid newline format
                    if (m.match(/^\$\$\s*\\n[\s\S]*?\\n\s*\$\$$/)) {
                        return m; // Let the main regex handle it
                    }
                    // This is the old format without newlines - show error
                    const errorIdx = mathBlockErrors.push({
                        type: 'incorrect_delimiters',
                        message: 'Block latex must use newline delimiters: $$\\n...\\n$$ or $$ \\n...\\n $$',
                        content: inner
                    }) - 1;
                    return `@@MATH_BLOCK_ERROR_${errorIdx}@@`;
                });
                
                md = md.replace(/\$\$\s*\\n([\s\S]*?)\\n\s*\$\$/g, (m, inner) => {
                    // Check for extra newlines inside the block latex content (both literal \n and actual newlines)
                    if (inner.includes('\\n') || inner.includes('\n')) {
                        const errorIdx = mathBlockErrors.push({
                            type: 'extra_newlines',
                            message: 'Block latex cannot contain extra newline characters inside the content',
                            content: inner
                        }) - 1;
                        return `@@MATH_BLOCK_ERROR_${errorIdx}@@`;
                    }
                    // Check for empty content
                    if (inner.trim().length === 0) {
                        const errorIdx = mathBlockErrors.push({
                            type: 'empty_content',
                            message: 'Block latex cannot be empty',
                            content: inner
                        }) - 1;
                        return `@@MATH_BLOCK_ERROR_${errorIdx}@@`;
                    }
                    let fixed = inner.replace(/\\n/g, '\n').trim();
                    // Escape < and > symbols to prevent HTML interpretation issues
                    fixed = fixed.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                    const idx = mathBlocks.push(fixed) - 1;
                    return `@@MATH_BLOCK_${idx}@@`;
                });
                if (window.marked?.setOptions) {
                    window.marked.setOptions({ gfm: true, breaks: true });
                }
                // Protect inline math $...$ before markdown parsing to avoid backslash escapes like \, turning into commas
                // Increased limit to handle long expressions like arrays (was 200, now 5000)
                const inlineMath = [];
                md = md.replace(/(^|[^$])\$\s*([^$\n]{1,5000}?)\s*\$(?!\$)/g, (m, pre, inner) => {
                    // Only process if we have a valid closing $ and reasonable content length
                    if (inner.trim().length === 0) return m; // Don't process empty math
                    // Escape < and > symbols to prevent HTML interpretation issues
                    const escapedInner = inner.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                    return `${pre}@@INLINE_MATH_${inlineMath.push(escapedInner)-1}@@`;
                });
                
                // Fix blockquotes: join consecutive lines unless separated by blank ">"
                // Special handling for tables inside blockquotes - preserve newlines for table rows
                // Process blockquotes line by line
                const lines = md.split('\n');
                let processedLines = [];
                let inBlockquotePre = false;
                let blockquoteBuffer = [];
                
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    const isBlockquoteLine = /^>($| )/.test(line);
                    const isBlankBlockquote = line.trim() === '>';
                    const isBlankLine = line.trim() === '';
                    const nextLine = i < lines.length - 1 ? lines[i + 1] : '';
                    const nextIsBlockquote = /^>($| )/.test(nextLine);
                    
                    // Check if this blockquote line is part of a table
                    // Strip blockquote prefix and check if it starts with |
                    const strippedLine = isBlockquoteLine ? stripBlockquotePrefix(line) : '';
                    const isTableRowInBlockquote = isBlockquoteLine && strippedLine.trim().startsWith('|');
                    
                    if (isBlockquoteLine) {
                        if (!inBlockquotePre) {
                            // Start of blockquote section
                            inBlockquotePre = true;
                            blockquoteBuffer = [];
                        }
                        
                        if (isBlankBlockquote) {
                            // Blank ">" creates a paragraph break
                            // Flush current buffer
                            if (blockquoteBuffer.length > 0) {
                                processedLines.push('> ' + blockquoteBuffer.join(' '));
                                blockquoteBuffer = [];
                            }
                            // Add blank line in blockquote
                            processedLines.push('> ');
                        } else if (isTableRowInBlockquote) {
                            // This is a table row inside a blockquote
                            // Flush any non-table content first (regular blockquote text)
                            if (blockquoteBuffer.length > 0) {
                                processedLines.push('> ' + blockquoteBuffer.join(' '));
                                blockquoteBuffer = [];
                            }
                            
                            // Add the table row as-is (preserving the blockquote prefix and newline structure)
                            // This preserves the table structure instead of joining with spaces
                            processedLines.push(line);
                        } else {
                            // Regular blockquote line (not a table) - extract text after "> "
                            const text = line.substring(1).trim();
                            if (text) {
                                blockquoteBuffer.push(text);
                            }
                            
                            // If next line is not a blockquote or is blank ">", flush buffer
                            if (!nextIsBlockquote || nextLine.trim() === '>') {
                                if (blockquoteBuffer.length > 0) {
                                    processedLines.push('> ' + blockquoteBuffer.join(' '));
                                    blockquoteBuffer = [];
                                }
                            }
                        }
                    } else if (isBlankLine) {
                        // Blank line ends blockquote - flush buffer
                        if (blockquoteBuffer.length > 0) {
                            processedLines.push('> ' + blockquoteBuffer.join(' '));
                            blockquoteBuffer = [];
                        }
                        inBlockquotePre = false;
                        processedLines.push(line);
                    } else {
                        // Non-blockquote line - flush buffer and add line
                        if (blockquoteBuffer.length > 0) {
                            processedLines.push('> ' + blockquoteBuffer.join(' '));
                            blockquoteBuffer = [];
                        }
                        inBlockquotePre = false;
                        processedLines.push(line);
                    }
                }
                
                // Flush any remaining buffer
                if (blockquoteBuffer.length > 0) {
                    processedLines.push('> ' + blockquoteBuffer.join(' '));
                }
                
                md = processedLines.join('\n');
                
                // Fix horizontal rules: only allow them if they have blank lines before AND after
                // Escape horizontal rules that don't meet this requirement
                const hrLines = md.split('\n');
                const hrProcessed = [];
                for (let i = 0; i < hrLines.length; i++) {
                    const line = hrLines[i];
                    const trimmed = line.trim();
                    const isHorizontalRule = /^[-*_]{3,}$/.test(trimmed);
                    
                    if (isHorizontalRule) {
                        const prevLine = i > 0 ? hrLines[i - 1] : '';
                        const nextLine = i < hrLines.length - 1 ? hrLines[i + 1] : '';
                        const prevIsBlank = prevLine.trim() === '';
                        const nextIsBlank = nextLine.trim() === '';
                        
                        // Only allow horizontal rule if both prev and next lines are blank
                        if (prevIsBlank && nextIsBlank) {
                            hrProcessed.push(line);
                        } else {
                            // Escape it by adding a backslash or converting to text
                            hrProcessed.push('\\' + line);
                        }
                    } else {
                        hrProcessed.push(line);
                    }
                }
                
                md = hrProcessed.join('\n');
                
                // Merge multi-line table rows before markdown processing
                // This allows cells to contain newlines while still being valid markdown tables
                const mdLinesForTableMerge = md.split('\n');
                const mergedTableLines = [];
                let currentTableRow = null;
                let inTable = false; // Track if we're currently inside a table
                
                for (let i = 0; i < mdLinesForTableMerge.length; i++) {
                    const line = mdLinesForTableMerge[i];
                    const trimmed = line.trim();
                    
                    // Check if this line is part of a blockquote
                    const isBlockquoteLine = /^\s*>/.test(line);
                    // Strip blockquote prefix for table processing
                    const lineForTableCheck = isBlockquoteLine ? stripBlockquotePrefix(trimmed) : trimmed;
                    
                    // Remove math expressions for detection
                    let lineWithoutMath = removeMathExpressions(lineForTableCheck);
                    
                    // Check if line is a table row (using stripped content for blockquote tables)
                    const startsWithPipe = lineWithoutMath.startsWith('|');
                    const hasPipes = lineWithoutMath.includes('|') && lineWithoutMath.split('|').length >= 3;
                    const endsWithPipe = lineWithoutMath.endsWith('|');
                    const isSeparator = /^[\s|:-]+$/.test(lineWithoutMath) && lineWithoutMath.includes('-');
                    
                    // Check if original line (before removing math and blockquote) starts with pipe
                    // This is used for continuation detection - a line starting with LaTeX should still be a continuation
                    const originalStartsWithPipe = lineForTableCheck.startsWith('|');
                    
                    // If we have an incomplete row and this line doesn't start with pipe in original,
                    // it's a continuation even if it has pipes after removing math
                    // Can only be a continuation if currentTableRow exists and doesn't end with |
                    // Also check if both current and previous lines are blockquote lines (same blockquote context)
                    const currentRowIsBlockquote = currentTableRow !== null && /^\s*>/.test(currentTableRow);
                    const isContinuation = currentTableRow !== null && 
                        !originalStartsWithPipe && 
                        currentTableRow.trim() !== '' && 
                        !currentTableRow.trim().endsWith('|') &&
                        (isBlockquoteLine === currentRowIsBlockquote); // Must be in same context (both blockquote or both not)
                    
                    // Empty lines always end tables (check original line, not stripped)
                    const isEmptyLine = lineForTableCheck.length === 0;
                    
                    // Determine if this line is part of a table
                    // If it's a continuation, treat it as part of the table
                    // Empty lines are NEVER table lines
                    const isTableLine = !isEmptyLine && ((hasPipes || (startsWithPipe && inTable)) && !isContinuation);
                    
                    if ((isTableLine || isSeparator || isContinuation) && !isEmptyLine) {
                        // We're in a table
                        inTable = true;
                        
                        if (isSeparator) {
                            // Separator row - finish any incomplete row first
                            if (currentTableRow !== null) {
                                mergedTableLines.push(currentTableRow);
                                currentTableRow = null;
                            }
                            mergedTableLines.push(line);
                        } else if (isContinuation) {
                            // Continuation of incomplete row (doesn't start with pipe, even if it has pipes)
                            currentTableRow = currentTableRow + '\n' + line;
                        } else if (startsWithPipe) {
                            // Table row starting with pipe
                            if (endsWithPipe) {
                                // Complete row
                                if (currentTableRow !== null) {
                                    // Finish previous incomplete row
                                    mergedTableLines.push(currentTableRow);
                                    currentTableRow = null;
                                }
                                mergedTableLines.push(line);
                            } else {
                                // Incomplete row - start or continue
                                if (currentTableRow === null) {
                                    currentTableRow = line;
                                } else {
                                    // Continue previous row
                                    currentTableRow = currentTableRow + '\n' + line;
                                }
                            }
                        } else {
                            // Shouldn't happen, but handle it
                            mergedTableLines.push(line);
                        }
                    } else {
                        // Not a table line - always end table mode
                        if (currentTableRow !== null) {
                            // Finish incomplete row
                            mergedTableLines.push(currentTableRow);
                            currentTableRow = null;
                        }
                        // Always exit table mode when we encounter non-table content
                        inTable = false;
                        mergedTableLines.push(line);
                    }
                }
                
                // Finish any remaining incomplete row
                if (currentTableRow !== null) {
                    mergedTableLines.push(currentTableRow);
                }
                
                // Convert newlines within merged table rows to <br> tags
                // This preserves line breaks within cells for proper rendering
                // We need to be careful: only convert newlines that are within cells, not between rows
                for (let i = 0; i < mergedTableLines.length; i++) {
                    let line = mergedTableLines[i];
                    // Check if this line contains newlines (from merging multi-line cells)
                    if (line.includes('\n')) {
                        // This is a merged table row with newlines - convert them to <br>
                        // The newlines are within the row content (cell content), so convert them
                        // This will create: | Cell 1<br>continued | Cell 2 |
                        line = line.replace(/\n/g, '<br>');
                        mergedTableLines[i] = line;
                    }
                }
                
                md = mergedTableLines.join('\n');
                
                // Normalize list spacing and empty list items to avoid list truncation
                md = normalizeEmptyListItemsForPreview(md);
                
                // Preserve multiple consecutive newlines by converting them to <br> tags
                // BUT preserve markdown block syntax boundaries (blockquotes, horizontal rules, headers, lists, code blocks)
                // Find all markdown block sections and mark their boundaries
                const mdLines = md.split('\n');
                let markedMd = [];
                let inBlockquote = false;
                let inCodeBlock = false;
                
                // Helper function to check if a line is a markdown block element
                const isMarkdownBlockElement = (line) => {
                    const trimmed = line.trim();
                    return (
                        /^#{1,6}\s/.test(trimmed) ||  // Headers: # ## ### etc
                        /^[-*_]{3,}$/.test(trimmed) ||  // Horizontal rules: --- *** ___
                        /^[*+-]\s/.test(trimmed) ||  // Unordered lists: - * +
                        /^\d+\.\s/.test(trimmed) ||  // Ordered lists: 1. 2.
                        /^```/.test(trimmed) ||  // Code blocks: ```
                        /^>($| )/.test(line) ||  // Blockquotes: > or > text
                        /^\|.*\|/.test(trimmed)  // Tables: | cell | cell |
                    );
                };
                
                for (let i = 0; i < mdLines.length; i++) {
                    const line = mdLines[i];
                    const trimmed = line.trim();
                    const isBlockquoteLine = /^>($| )/.test(line);
                    const isBlankLine = trimmed === '';
                    const isCodeBlockDelimiter = /^```/.test(trimmed);
                    const nextLine = i < mdLines.length - 1 ? mdLines[i + 1] : '';
                    const nextIsBlockquote = /^>($| )/.test(nextLine);
                    const nextIsBlank = nextLine.trim() === '';
                    const nextIsMarkdownBlock = isMarkdownBlockElement(nextLine);
                    const prevLine = i > 0 ? mdLines[i - 1] : '';
                    const prevIsBlank = prevLine.trim() === '';
                    const prevIsMarkdownBlock = isMarkdownBlockElement(prevLine);
                    
                    // Track code block state
                    if (isCodeBlockDelimiter) {
                        inCodeBlock = !inCodeBlock;
                        markedMd.push(line);
                        continue;
                    }
                    
                    // Don't process anything inside code blocks
                    if (inCodeBlock) {
                        markedMd.push(line);
                        continue;
                    }
                    
                    if (isBlockquoteLine) {
                        inBlockquote = true;
                        markedMd.push(line);
                    } else if (isBlankLine) {
                        // Check if this blank line is adjacent to any markdown block element
                        if (nextIsMarkdownBlock && !inBlockquote) {
                            // Blank line before markdown block - mark it to preserve
                            markedMd.push('@@MARKDOWN_BOUNDARY@@');
                        } else if (prevIsMarkdownBlock) {
                            // Blank line after markdown block - mark it to preserve
                            markedMd.push('@@MARKDOWN_BOUNDARY@@');
                            if (inBlockquote && !nextIsBlockquote) {
                                inBlockquote = false;
                            }
                        } else if (inBlockquote) {
                            // Blank line inside or after blockquote
                            if (!nextIsBlank && !nextIsBlockquote) {
                                markedMd.push('@@MARKDOWN_BOUNDARY@@');
                                inBlockquote = false;
                            } else if (nextIsBlank) {
                                markedMd.push('@@MARKDOWN_BOUNDARY@@');
                                inBlockquote = false;
                            } else {
                                markedMd.push(line);
                            }
                        } else {
                            // Regular blank line not near markdown blocks
                            markedMd.push(line);
                        }
                    } else {
                        if (inBlockquote && !isBlockquoteLine) {
                            inBlockquote = false;
                        }
                        markedMd.push(line);
                    }
                }
                
                md = markedMd.join('\n');
                
                // Mark trailing spaces BEFORE converting newlines (so we can detect empty lines correctly)
                md = markTrailingSpaces(md);
                
                // Convert empty line markers to HTML divs before newline conversion to preserve them
                // This ensures all empty lines are preserved even when multiple newlines are converted
                md = md.replace(/@@LEADING_EMPTY_LINE@@/g, '<div class="trailing-empty-line"></div>');
                md = md.replace(/@@TRAILING_EMPTY_LINE@@/g, '<div class="trailing-empty-line"></div>');
                md = md.replace(/@@CONSECUTIVE_EMPTY_LINE@@/g, '<div class="trailing-empty-line"></div>');
                
                // Now convert 2+ newlines to <br> tags, but skip markdown boundary markers
                md = md.replace(/\n{2,}/g, (match) => {
                    const count = match.length;
                    return '<br>'.repeat(count);
                });
                
                // Restore markdown boundary markers as \n\n for proper markdown parsing
                md = md.replace(/@@MARKDOWN_BOUNDARY@@/g, '\n\n');
                
                // Preserve multiple consecutive spaces (2 or more) by converting to &nbsp;
                md = md.replace(/ {2,}/g, (match) => {
                    // Don't convert space markers (they're already marked)
                    // This regex only matches spaces, not the markers themselves
                    return '&nbsp;'.repeat(match.length);
                });

                // Protect fill-in-the-blank placeholders from markdown processing
                const blankPlaceholders = [];
                md = md.replace(/___(\d+)___/g, (match, num) => {
                    const idx = blankPlaceholders.push(num) - 1;
                    return `@@BLANK_PLACEHOLDER_${idx}@@`;
                });

                let html = window.marked?.parse ? window.marked.parse(md) : md;
                
                // Replace trailing space markers with HTML (but protect alt attributes)
                const altProtection = protectAltMarkers(html);
                html = replaceTrailingSpaceMarkers(altProtection.html);
                html = restoreAltMarkers(html, altProtection.placeholders);
                // Re-inject math placeholders as elements for KaTeX to render (block math first via string replace)
                mathBlocks.forEach((content, i) => {
                    const token = `@@MATH_BLOCK_${i}@@`;
                    const holder = `<div class="__math_block" data-math-idx="${i}" style="text-align: center; margin: 1em auto; display: block; direction: ltr; unicode-bidi: isolate;"></div>`;
                    html = html.split(token).join(holder);
                });
                
                // Remove math block error tokens (errors now shown below preview)
                mathBlockErrors.forEach((error, i) => {
                    const token = `@@MATH_BLOCK_ERROR_${i}@@`;
                    html = html.split(token).join('');
                });
                
                // Unescape HTML entities that were escaped during math processing
                html = html.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
                
                // Fix blockquotes to end properly at blank lines
                // Check original text to determine where blockquotes should actually end
                const originalText = textarea.value || '';
                const originalLines = originalText.replace(/\r\n?/g, '\n').split('\n');
                
                // Find where blockquotes should end (at blank lines followed by non-blockquote text)
                let blockquoteShouldEndAt = [];
                let inBlockquoteCheck = false;
                
                for (let i = 0; i < originalLines.length; i++) {
                    const line = originalLines[i];
                    const isBlockquoteLine = /^>($| )/.test(line);
                    const isBlankLine = line.trim() === '';
                    const nextLine = i < originalLines.length - 1 ? originalLines[i + 1] : '';
                    const nextIsBlockquote = /^>($| )/.test(nextLine);
                    const nextIsBlank = nextLine.trim() === '';
                    
                    if (isBlockquoteLine) {
                        inBlockquoteCheck = true;
                    } else if (isBlankLine && inBlockquoteCheck && !nextIsBlank && !nextIsBlockquote) {
                        // Blank line after blockquote, followed by regular text - blockquote should end here
                        blockquoteShouldEndAt.push(i);
                        inBlockquoteCheck = false;
                    } else if (!isBlankLine && !isBlockquoteLine && inBlockquoteCheck) {
                        // Regular text immediately after blockquote (no blank line) - mark previous line as end
                        if (i > 0) {
                            blockquoteShouldEndAt.push(i - 1);
                        }
                        inBlockquoteCheck = false;
                    }
                }
                
                // Fix blockquote HTML by splitting at positions where blockquotes should end
                // Match blockquote tags and split them at the correct positions
                let blockquoteIndex = 0;
                html = html.replace(/<blockquote>([\s\S]*?)<\/blockquote>/g, (match, content) => {
                    // Check if this blockquote should be split based on original text structure
                    // Look for double <br> tags (representing blank lines) followed by content
                    // Split the blockquote at those points
                    const doubleBrRegex = /(<br\s*\/?>\s*){2,}/;
                    if (doubleBrRegex.test(content)) {
                        // Split at double <br> (blank lines)
                        const parts = content.split(doubleBrRegex);
                        if (parts.length > 1) {
                            // First part is blockquote content, rest should be outside
                            const blockquotePart = parts[0];
                            const outsidePart = parts.slice(1).filter(p => p.trim()).join('');
                            if (outsidePart.trim()) {
                                return '<blockquote>' + blockquotePart + '</blockquote><p>' + outsidePart + '</p>';
                            }
                        }
                    }
                    return match;
                });
                
                // Remove image description error tokens (errors now shown below preview)
                imageDescriptionErrors.forEach((error, i) => {
                    const token = `@@IMAGE_DESCRIPTION_ERROR_${i}@@`;
                    html = html.split(token).join('');
                });
                
                // Quote, dollar sign, and <br> tag errors are now shown below preview (not in preview HTML)
                
                // Restore fill-in-the-blank placeholders with styled HTML
                html = html.replace(/@@BLANK_PLACEHOLDER_(\d+)@@/g, (match, idx) => {
                    const blankNum = blankPlaceholders[parseInt(idx)];
                    return `<span style="display: inline-block; padding: 2px 8px; margin: 0 2px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border-radius: 4px; font-weight: 600; font-size: 0.9em; box-shadow: 0 2px 4px rgba(0,0,0,0.2);">Blank #${blankNum}</span>`;
                });
                
                // Don't add label here - it's already outside the preview box
                // Remove image src attributes before setting innerHTML to prevent browser from trying to load them
                html = html.replace(/<img([^>]*?)\s+src=["']([^"']*)["']([^>]*?)>/gi, (match, before, src, after) => {
                    // Remove src attribute to prevent browser from trying to load relative paths
                    const cleaned = (before + ' ' + after).trim().replace(/\s+/g, ' ');
                    return `<img ${cleaned}>`;
                });
                preview.innerHTML = html;
                // Handle all images - replace with styled placeholder and show description
                const imgs = preview.querySelectorAll('img[alt]');
                imgs.forEach((img, imgIdx) => {
                    const alt = img.getAttribute('alt') || '';
                    let description = alt;
                    
                    // Create a container div to wrap the image and description (class/data for bbox key)
                    const container = document.createElement('div');
                    container.className = 'image-placeholder-container';
                    container.setAttribute('data-image-index', String(imgIdx));
                    const fpPrefix = getBboxKeyPrefixForTextarea(textarea);
                    if (fpPrefix != null) container.setAttribute('data-fp-key', fpPrefix + '-' + imgIdx);
                    container.style.display = 'block';
                    container.style.textAlign = 'center';
                    container.style.margin = '0 auto';
                    
                    // Create a span to hold the image description (caption)
                    const captionSpan = document.createElement('span');
                    captionSpan.className = 'image-description-math';
                    captionSpan.style.display = 'block';
                    captionSpan.style.marginTop = '4px';
                    captionSpan.style.direction = 'ltr';
                    
                    // Replace the broken image with a styled placeholder div (class for responsive bbox CSS)
                    const placeholder = document.createElement('div');
                    placeholder.className = 'image-placeholder-box';
                    placeholder.style.width = '200px';
                    placeholder.style.height = '150px';
                    placeholder.style.backgroundColor = '#f0f0f0';
                    placeholder.style.border = '2px dashed #ccc';
                    placeholder.style.borderRadius = '4px';
                    placeholder.style.display = 'flex';
                    placeholder.style.alignItems = 'center';
                    placeholder.style.justifyContent = 'center';
                    placeholder.style.margin = '0 auto';
                    placeholder.innerHTML = '<span style="color: #999; font-size: 14px;"> Image</span>';
                    
                    // Process the alt text
                    if (description) {
                        appendImageDescription(captionSpan, description);
                    }
                    
                    // Wrap in the container
                    img.parentElement.replaceChild(container, img);
                    container.appendChild(placeholder);
                    if (captionSpan.firstChild) {
                        container.appendChild(captionSpan);
                    }
                });
                // Replace inline math placeholders only in text nodes (avoid attributes)
                const walker = document.createTreeWalker(preview, NodeFilter.SHOW_TEXT, null);
                const textNodes = [];
                while (walker.nextNode()) textNodes.push(walker.currentNode);
                const inlineRe = /@@INLINE_MATH_(\d+)@@/g;
                textNodes.forEach(node => {
                    const text = node.nodeValue;
                    if (!inlineRe.test(text)) return;
                    inlineRe.lastIndex = 0;
                    const frag = document.createDocumentFragment();
                    let lastIndex = 0;
                    let match;
                    while ((match = inlineRe.exec(text)) !== null) {
                        const before = text.slice(lastIndex, match.index);
                        if (before) frag.appendChild(document.createTextNode(before));
                        const idx = parseInt(match[1], 10);
                        const span = document.createElement('span');
                        span.className = '__math_inline';
                        span.setAttribute('data-im', String(idx));
                        span.style.unicodeBidi = 'plaintext';
                        span.style.direction = 'auto';
                        frag.appendChild(span);
                        lastIndex = match.index + match[0].length;
                    }
                    const after = text.slice(lastIndex);
                    if (after) frag.appendChild(document.createTextNode(after));
                    node.parentNode.replaceChild(frag, node);
                });
                
                // Also unescape any remaining HTML entities in text nodes that weren't part of math
                textNodes.forEach(node => {
                    if (node.parentNode && node.parentNode.classList.contains('__math_inline')) {
                        // Skip math nodes as they'll be handled by KaTeX
                        return;
                    }
                    const text = node.nodeValue;
                    if (text.includes('&lt;') || text.includes('&gt;')) {
                        const unescaped = text.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
                        if (unescaped !== text) {
                            node.nodeValue = unescaped;
                        }
                    }
                });
                // Render block math explicitly with KaTeX (displayMode)
                if (window.katex) {
                    const nodes = preview.querySelectorAll('.__math_block');
                    nodes.forEach(node => {
                        const i = parseInt(node.getAttribute('data-math-idx'), 10);
                        const originalTex = mathBlocks[i] || '';
                        const isBold = !!(node.closest('strong, b'));
                        const isItalic = !!(node.closest('em, i'));
                        let texToRender = originalTex;
                        // Avoid wrapping environments like aligned/align in macros
                        if (texToRender && !/\\begin\{[\s\S]*?\}/.test(texToRender)) {
                            if (isBold && isItalic) texToRender = `\\boldsymbol{\\mathit{${texToRender}}}`;
                            else if (isBold) texToRender = `\\boldsymbol{${texToRender}}`;
                            else if (isItalic) texToRender = `\\mathit{${texToRender}}`;
                        }
                        try { 
                            // Unescape HTML entities back to original symbols for KaTeX
                            texToRender = texToRender.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
                            safeKatexRender(texToRender, node, { displayMode: true }); 
                            // Force centering after rendering
                            node.style.textAlign = 'center';
                            node.style.margin = '1em auto';
                        } catch {}
                    });
                    const inlines = preview.querySelectorAll('.__math_inline');
                    inlines.forEach(node => {
                        const i = parseInt(node.getAttribute('data-im'), 10);
                        const originalTex = inlineMath[i] || '';
                        const isBold = !!(node.closest('strong, b'));
                        const isItalic = !!(node.closest('em, i'));
                        let texToRender = originalTex;
                        if (texToRender) {
                            if (isBold && isItalic) texToRender = `\\boldsymbol{\\mathit{${texToRender}}}`;
                            else if (isBold) texToRender = `\\boldsymbol{${texToRender}}`;
                            else if (isItalic) texToRender = `\\mathit{${texToRender}}`;
                        }
                        try { 
                            // Unescape HTML entities back to original symbols for KaTeX
                            texToRender = texToRender.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
                            safeKatexRender(texToRender, node, { displayMode: false }); 
                        } catch {}
                    });
                    applyKatexBidi(preview);
                }
                // Skip auto-render for $...$ since we handled it; still support \( ... \) and \[ ... ]
                if (window.renderMathInElement) {
                    safeRenderMathInElement(preview, {
                        delimiters: [
                            { left: '\\(', right: '\\)', display: false },
                            { left: '\\[', right: '\\]', display: true }
                        ]
                    });
                    applyKatexBidi(preview);
                }
                applyBboxesToPreviewRoot(preview);
            } catch (e) {
                // fail silent to avoid blocking typing
            }
        }

        // Attach preview under each textarea and bind listeners
        // Legacy attachPreviews function - now delegates to universal PreviewBox component
        // Maintained for backward compatibility during migration
        function attachPreviews(root=document) {
            PreviewBox.attachPreviews(root);
        }

        // ============================================================================
        // UNIVERSAL PREVIEW BOX COMPONENT
        // ============================================================================
        // Single source of truth for all preview box functionality
        // Replaces: attachPreviews(), renderLivePreview(), renderLivePreviewToElement(),
        //           and all special-case preview handling
        //
        // INVENTORY OF EXISTING PREVIEW IMPLEMENTATIONS:
        // ============================================================================
        // 1. Main preview system (attachPreviews + renderLivePreview):
        //    - DOM: <label class="preview-label">Output Preview</label>
        //            <div class="live-preview" dir="rtl|ltr">...</div>
        //    - Selectors: .text-field-container textarea, #lesson_text, #lesson_title,
        //                 .form-group input[placeholder="Section title"], #terminology textarea,
        //                 #lesson_standards textarea
        //    - Features: Markdown rendering, LaTeX (block/inline), image handling,
        //                trailing spaces indicator, validation errors, RTL/LTR direction,
        //                auto-resize, font settings propagation
        //
        // 2. Choice previews:
        //    - Uses the same preview renderer as main previews
        //
        // 3. Fill-in-the-blanks preview (updateFilledBlanksPreview):
        //    - DOM: <div id="filled-blanks-preview">...</div>
        //    - Features: Replaces ___num___ with answers, then renders markdown/LaTeX
        //
        // 4. Final preview (renderQuestionPreview, renderContentSectionPreview):
        //    - Uses renderLivePreviewToElement() to render to temporary divs
        //    - Features: Same rendering pipeline but for final preview tab
        //
        // CALL SITES (37+ locations):
        // - Content sections: addContentSectionBefore/After, duplicateContentSection,
        //   pasteContentSection, loadJSON, undo/redo restore
        // - Questions: addQuestionBefore/After, duplicateQuestion, pasteQuestion,
        //   loadJSON, undo/redo restore, postUndoRedoRestore
        // - Choices: addChoice, duplicateChoice, pasteChoice, loadJSON
        // - Matching items: finalizeMatchingListItem, pasteMatchingItem, loadJSON
        // - Relationship items: finalizeRelationshipItem, pasteRelationshipItem
        // - Bbox rows: (if any previews exist)
        // - Global: attachPreviews(document) on page load, after JSON load
        // ============================================================================

        const PreviewBox = (function() {
            'use strict';
            
            // WeakMap to track initialized previews and prevent double-binding
            const initializedPreviews = new WeakMap();
            
            /**
             * Universal PreviewBox component
             * @param {Object} config - Configuration object
             * @param {HTMLElement} config.sourceEl - Source textarea/input element
             * @param {HTMLElement} [config.targetEl] - Target preview element (if exists)
             * @param {HTMLElement} [config.rootEl] - Root element to search within (default: document)
             * @param {Object} [config.options] - Additional options
             * @param {string} [config.options.mode='live'] - 'live' or 'static'
             * @param {string} [config.options.className='live-preview'] - CSS class for preview
             * @param {boolean} [config.options.showLabel=true] - Show preview label
             * @param {boolean} [config.options.autoResize=true] - Enable auto-resize
             * @param {boolean} [config.options.createDirBtn=true] - Create direction toggle button
             * @returns {Object} - PreviewBox instance with methods
             */
            function createPreviewBox(config) {
                const { sourceEl, targetEl, rootEl = document, options = {} } = config;
                if (!sourceEl) return null;
                
                const {
                    mode = 'live',
                    className = 'live-preview',
                    showLabel = true,
                    autoResize = true,
                    createDirBtn = true
                } = options;
                
                // Check if already initialized
                if (initializedPreviews.has(sourceEl)) {
                    const existing = initializedPreviews.get(sourceEl);
                    // Update target if changed
                    if (targetEl && existing.targetEl !== targetEl) {
                        existing.targetEl = targetEl;
                        existing.previewEl = targetEl;
                    }
                    return existing;
                }
                
                // Find or create preview element
                let previewEl = targetEl;
                let previewLabel = null;
                
                if (!previewEl) {
                    // Find existing preview by walking siblings
                    let sibling = sourceEl.nextElementSibling;
                while (sibling) {
                    if (sibling.classList && sibling.classList.contains('preview-label')) {
                        previewLabel = sibling;
                        } else if (sibling.classList && sibling.classList.contains(className)) {
                            previewEl = sibling;
                            break;
                    }
                    sibling = sibling.nextElementSibling;
                    }
                }
                
                // Create preview if it doesn't exist
                if (!previewEl) {
                    const isLTR = sourceEl.hasAttribute('data-ltr');
                    const direction = isLTR ? 'ltr' : 'rtl';
                    const textAlign = isLTR ? 'left' : 'right';
                    
                    // Create direction toggle button if needed
                    if (createDirBtn && !sourceEl.parentElement.querySelector('.dir-btn')) {
                        const dirBtn = document.createElement('button');
                        dirBtn.type = 'button';
                        dirBtn.className = 'dir-btn';
                        dirBtn.textContent = isLTR ? 'RTL' : 'LTR';
                        dirBtn.title = 'Toggle direction RTL/LTR';
                        dirBtn.onclick = () => toggleDirection(sourceEl);
                        dirBtn.style.marginTop = '8px';
                        dirBtn.style.marginBottom = '8px';
                        sourceEl.parentElement.insertBefore(dirBtn, sourceEl.nextSibling);
                    }
                    
                    // Create preview label if needed
                    if (showLabel) {
                    previewLabel = document.createElement('label');
                    previewLabel.className = 'preview-label';
                    previewLabel.textContent = 'Output Preview';
                    }
                    
                    // Create preview element
                    previewEl = document.createElement('div');
                    previewEl.className = className;
                    previewEl.setAttribute('dir', direction);
                    previewEl.style.textAlign = textAlign;
                    
                    // Find insertion point after buttons
                    let insertPoint = sourceEl.nextSibling;
                    while (insertPoint && (insertPoint.nodeType === 3 || (insertPoint.tagName && insertPoint.tagName === 'BUTTON'))) {
                        insertPoint = insertPoint.nextSibling;
                    }
                    
                    // Insert elements
                    if (previewLabel) {
                        sourceEl.parentElement.insertBefore(previewLabel, insertPoint);
                        sourceEl.parentElement.insertBefore(previewEl, previewLabel.nextSibling);
                } else {
                        sourceEl.parentElement.insertBefore(previewEl, insertPoint);
                    }
                } else {
                    // Update existing preview properties
                    const isLTR = sourceEl.hasAttribute('data-ltr');
                    const direction = isLTR ? 'ltr' : 'rtl';
                    const textAlign = isLTR ? 'left' : 'right';
                    previewEl.setAttribute('dir', direction);
                    previewEl.style.textAlign = textAlign;
                    
                    // Ensure preview label exists
                    if (showLabel && !previewLabel) {
                        previewLabel = document.createElement('label');
                        previewLabel.className = 'preview-label';
                        previewLabel.textContent = 'Output Preview';
                        previewEl.parentElement.insertBefore(previewLabel, previewEl);
                    }
                }
                
                // Ensure source element direction matches data-ltr attribute
                const isLTR = sourceEl.hasAttribute('data-ltr');
                const direction = isLTR ? 'ltr' : 'rtl';
                sourceEl.setAttribute('dir', direction);
                
                // Create instance
                const instance = {
                    sourceEl,
                    targetEl: previewEl,
                    previewEl,
                    previewLabel,
                    mode,
                    className,
                    render: function() {
                        if (mode === 'live') {
                            renderLivePreview(sourceEl);
                        } else {
                            renderLivePreviewToElement(sourceEl, previewEl);
                        }
                        updateTrailingSpacesIndicator(sourceEl, previewEl);
                        // NOTE: Sizing is handled by AutoSizeManager (no sizing logic here)
                    },
                    update: function() {
                        this.render();
                        if (autoResize && autoResizeEnabled && typeof AutoSizeManager !== 'undefined') {
                            AutoSizeManager.fitHeightToContent(previewEl);
                        }
                        // Show validation errors
                        showTableValidationErrors(sourceEl);
                        showListValidationErrors(sourceEl);
                        showBlockquoteValidationErrors(sourceEl);
                        showLatexValidationErrors(sourceEl);
                        showImageValidationErrors(sourceEl);
                        showQuoteValidationErrors(sourceEl);
                        showBrTagValidationErrors(sourceEl);
                    },
                    destroy: function() {
                        if (sourceEl.__livePreviewHandler) {
                            sourceEl.removeEventListener('input', sourceEl.__livePreviewHandler);
                            delete sourceEl.__livePreviewHandler;
                        }
                        initializedPreviews.delete(sourceEl);
                    }
                };
                
                // Initial render
                instance.render();
                
                // Bind input handler for live mode
                if (mode === 'live') {
                    sourceEl.removeEventListener('input', sourceEl.__livePreviewHandler || (()=>{}));
                const handler = () => {
                        instance.update();
                    };
                    sourceEl.addEventListener('input', handler);
                    sourceEl.__livePreviewHandler = handler;
                }
                
                // NOTE: Auto-resize for textareas is now handled by AutoSizeManager
                
                // Show validation errors on initial load
                if (mode === 'live') {
                    showTableValidationErrors(sourceEl);
                    showListValidationErrors(sourceEl);
                    showBlockquoteValidationErrors(sourceEl);
                    showLatexValidationErrors(sourceEl);
                    showImageValidationErrors(sourceEl);
                    showQuoteValidationErrors(sourceEl);
                    showBrTagValidationErrors(sourceEl);
                }
                
                // Store instance
                initializedPreviews.set(sourceEl, instance);
                
                return instance;
            }
            
            /**
             * Initialize previews for all matching elements in a root
             * @param {HTMLElement} rootEl - Root element to search within
             * @param {Object} options - Options passed to createPreviewBox
             */
            function initPreviewBoxes(rootEl = document, options = {}) {
                const selectors = [
                    '.text-field-container textarea',
                    '#lesson_text',
                    '#lesson_title',
                    '.form-group input[placeholder="Section title"]',
                    '#terminology textarea',
                    '#lesson_standards textarea'
                ];
                
                const nodes = [];
                selectors.forEach(selector => {
                    nodes.push(...rootEl.querySelectorAll(selector));
                });
                
                nodes.forEach(node => {
                    if (!initializedPreviews.has(node)) {
                        createPreviewBox({ sourceEl: node, rootEl, options });
                    }
                });
            }
            
            /**
             * Force render all previews in a container (canonical refresh pathway)
             * @param {HTMLElement} rootEl - Root element to refresh previews within
             */
            function refreshAll(rootEl = document) {
                const selectors = [
                    '.text-field-container textarea',
                    '#lesson_text',
                    '#lesson_title',
                    '.form-group input[placeholder="Section title"]',
                    '#terminology textarea',
                    '#lesson_standards textarea'
                ];
                
                const nodes = [];
                selectors.forEach(selector => {
                    nodes.push(...rootEl.querySelectorAll(selector));
                });
                
                nodes.forEach(node => {
                    // If already initialized, force update (render + validations)
                    if (initializedPreviews.has(node)) {
                        const instance = initializedPreviews.get(node);
                        if (instance && typeof instance.update === 'function') {
                            instance.update();
                        } else if (instance && typeof instance.render === 'function') {
                            instance.render();
                        }
                    } else {
                        // If not initialized, create it (which will render)
                        createPreviewBox({ sourceEl: node, rootEl });
                    }
                });
            }

            /**
             * Ensure previews are initialized and rendered for existing content only.
             * Avoids re-rendering already rendered previews.
             * @param {HTMLElement} rootEl - Root element to scan within
             */
            function ensureRendered(rootEl = document) {
                const selectors = [
                    '.text-field-container textarea',
                    '#lesson_text',
                    '#lesson_title',
                    '.form-group input[placeholder="Section title"]',
                    '#terminology textarea',
                    '#lesson_standards textarea'
                ];
                
                const nodes = [];
                selectors.forEach(selector => {
                    nodes.push(...rootEl.querySelectorAll(selector));
                });
                
                nodes.forEach(node => {
                    if (!initializedPreviews.has(node)) {
                        createPreviewBox({ sourceEl: node, rootEl });
                        return;
                    }
                    const instance = initializedPreviews.get(node);
                    const previewEl = instance?.previewEl;
                    const value = (node.value || '').trim();
                    if (value && previewEl && !previewEl.innerHTML.trim()) {
                        if (typeof instance.update === 'function') {
                            instance.update();
                        } else if (typeof instance.render === 'function') {
                            instance.render();
                        }
                    }
                });
            }
            
            // NOTE: Sizing logic has been moved to AutoSizeManager
            // PreviewBox only handles preview DOM creation and rendering
            
            return {
                create: createPreviewBox,
                init: initPreviewBoxes,
                refreshAll: refreshAll,
                ensureRendered: ensureRendered,
                // Expose WeakMap for external access
                getInitializedPreviews: () => initializedPreviews,
                // Expose for backward compatibility during migration
                attachPreviews: function(root = document) {
                    initPreviewBoxes(root);
                }
            };
        })();

        // Global state for auto-resize feature
        let autoResizeEnabled = true; // Default to enabled
        
        // NOTE: Sizing logic is in AutoSizeManager.FUDGE_PX and AutoSizeManager.fitHeightToContent
        // These wrappers exist for backward compatibility with input handlers
        
        // Auto-resize textarea to fit content (binds input handler)
        function autoResizeTextarea(textarea) {
            if (!textarea || textarea.tagName !== 'TEXTAREA') return;
            
            // Skip JSON input textarea (used for loading JSON)
            if (textarea.id === 'json_input') return;
            
            // If auto-resize is disabled, remove handlers if they exist and return
            if (!autoResizeEnabled) {
                if (textarea.__autoResizeHandler) {
                    textarea.removeEventListener('input', textarea.__autoResizeHandler);
                    textarea.removeEventListener('focus', textarea.__autoResizeHandler);
                    textarea.__autoResizeHandler = null;
                }
                // Set a fixed minimum height but allow manual resizing
                if (!textarea.style.height || textarea.style.height === 'auto') {
                    textarea.style.height = '80px'; // Default min-height
                }
                return;
            }
            
            // Initial height based on content - delegate to AutoSizeManager
            if (typeof AutoSizeManager !== 'undefined') {
                AutoSizeManager.fitHeightToContent(textarea);
            }
        }
        
        // Auto-resize all textareas in a container (binds handlers, used by toggle)
        function autoResizeAllTextareas(container = document) {
            const textareas = container.querySelectorAll('textarea');
            textareas.forEach(ta => {
                autoResizeTextarea(ta);
            });
        }
        
        function attachAutoResizeInputHandler() {
            if (document.__autoResizeInputBound) return;
            document.__autoResizeInputBound = true;
            document.addEventListener('input', (e) => {
                const target = e.target;
                if (!autoResizeEnabled || !target || target.tagName !== 'TEXTAREA') return;
                if (target.id === 'json_input') return;
                if (typeof AutoSizeManager !== 'undefined' && AutoSizeManager.markDirty) {
                    AutoSizeManager.markDirty(target);
                }
            });
        }
        
        // Toggle auto-resize feature
        function toggleAutoResize() {
            autoResizeEnabled = !autoResizeEnabled;
            const toggle = document.getElementById('autoResizeToggle');
            const icon = toggle.querySelector('i');
            
            // Keep original icon, just change background color
            if (autoResizeEnabled) {
                // ON state: Green background
                toggle.title = 'Auto-Resize: ON (Click to disable)';
                toggle.style.background = 'rgba(40, 167, 69, 0.8)'; // Green background
                toggle.style.borderColor = 'rgba(255, 255, 255, 0.9)';
            } else {
                // OFF state: Red background
                toggle.title = 'Auto-Resize: OFF (Click to enable)';
                toggle.style.background = 'rgba(220, 53, 69, 0.8)'; // Red background
                toggle.style.borderColor = 'rgba(255, 255, 255, 0.9)';
            }
            
            // Save preference to localStorage
            localStorage.setItem('autoResizeEnabled', autoResizeEnabled ? 'true' : 'false');
            
            // When turning auto-resize ON: ensure previews and spawn-finalize active panel (force-fit with current content)
            if (autoResizeEnabled) {
                refreshActivePanel(resolveActivePanelRoot());
                if (typeof AutoSizeManager !== 'undefined' && AutoSizeManager.finalizeSpawn) {
                    AutoSizeManager.finalizeSpawn(resolveActivePanelRoot());
                }
            } else {
                autoResizeAllTextareas();
            }
        }
        
        // Initialize auto-resize state from localStorage
        function initializeAutoResize() {
            const saved = localStorage.getItem('autoResizeEnabled');
            if (saved !== null) {
                autoResizeEnabled = saved === 'true';
            } else {
                autoResizeEnabled = true; // Default to enabled
            }
            
            const toggle = document.getElementById('autoResizeToggle');
            if (toggle) {
                const icon = toggle.querySelector('i');
                // Keep original icon, just change background color
                if (autoResizeEnabled) {
                    // ON state: Green background
                    toggle.title = 'Auto-Resize: ON (Click to disable)';
                    toggle.style.background = 'rgba(40, 167, 69, 0.8)'; // Green background
                    toggle.style.borderColor = 'rgba(255, 255, 255, 0.9)';
                } else {
                    // OFF state: Red background
                    toggle.title = 'Auto-Resize: OFF (Click to enable)';
                    toggle.style.background = 'rgba(220, 53, 69, 0.8)'; // Red background
                    toggle.style.borderColor = 'rgba(255, 255, 255, 0.9)';
                }
            }
        }

        function toggleDirection(textarea) {
            // Toggle the data-ltr attribute to switch between RTL and LTR
            const isLTR = textarea.hasAttribute('data-ltr');
            if (isLTR) {
                // Currently LTR, switch to RTL
                textarea.removeAttribute('data-ltr');
                textarea.setAttribute('dir', 'rtl');
            } else {
                // Currently RTL, switch to LTR
                textarea.setAttribute('data-ltr', 'true');
                textarea.setAttribute('dir', 'ltr');
            }
            
            // Find preview box by walking through siblings (skip buttons, labels, and error divs)
            let nextSibling = textarea.nextElementSibling;
            let preview = null;
            
            // Skip over buttons, error divs, and labels to find preview
            while (nextSibling) {
                if (nextSibling.tagName === 'BUTTON') {
                    // Skip buttons
                    nextSibling = nextSibling.nextElementSibling;
                } else if (nextSibling.classList && (
                    nextSibling.classList.contains('table-validation-errors') ||
                    nextSibling.classList.contains('list-validation-errors') ||
                    nextSibling.classList.contains('blockquote-validation-errors') ||
                    nextSibling.classList.contains('latex-validation-errors') ||
                    nextSibling.classList.contains('image-validation-errors') ||
                    nextSibling.classList.contains('quote-validation-errors') ||
                    nextSibling.classList.contains('br-validation-errors')
                )) {
                    // Skip validation error divs
                    nextSibling = nextSibling.nextElementSibling;
                } else if (nextSibling.classList && nextSibling.classList.contains('preview-label')) {
                    // Skip label, continue to preview
                    nextSibling = nextSibling.nextElementSibling;
                } else if (nextSibling.classList && nextSibling.classList.contains('live-preview')) {
                    // Found preview!
                    preview = nextSibling;
                    break;
                } else {
                    // Unknown element, stop looking
                    break;
                }
            }
            
            if (preview) {
                const newDir = textarea.hasAttribute('data-ltr') ? 'ltr' : 'rtl';
                preview.setAttribute('dir', newDir);
                preview.style.textAlign = newDir === 'rtl' ? 'right' : 'left';
                // Re-render preview to ensure direction is applied to content
                renderLivePreview(textarea);
            }
            
            // Update button label: find the dir button in this container
            const container = textarea.closest('.text-field-container') || textarea.parentElement;
            const btn = container ? container.querySelector('.dir-btn') : null;
            if (btn) {
                // Button shows what clicking it will do
                btn.textContent = textarea.hasAttribute('data-ltr') ? 'RTL' : 'LTR';
            }
        }

        // Font Settings Functions
        // Apply font settings to specific elements or all elements
        function applyFontSettings(container) {
            const savedFontSize = localStorage.getItem('fontSize') || '14';
            const savedLineHeight = localStorage.getItem('lineHeight') || '1.5';
            const fontSize = savedFontSize + 'px';
            const lineHeight = savedLineHeight;
            
            // Get elements from container or entire document
            const scope = container || document;
            
            // Apply to all form controls in scope, but exclude search bar and JSON input
            // Match CSS rule: .form-group input, .form-group textarea, .form-group select
            scope.querySelectorAll('.form-group input, .form-group textarea, .form-group select').forEach(el => {
                // Exclude search bar and JSON input from font settings
                if (el.id === 'searchFilter' || el.id === 'json_input') {
                    return; // Skip these elements
                }
                el.style.fontSize = fontSize;
                el.style.lineHeight = lineHeight;
            });
            
            // If a container is passed, also apply to inputs/selects directly in that container
            // (for cases like array-item inputs that aren't in form-group, including bbox inputs)
            if (container && container !== document) {
                container.querySelectorAll('input, textarea, select').forEach(el => {
                    // Exclude search bar and JSON input from font settings
                    if (el.id === 'searchFilter' || el.id === 'json_input') {
                        return; // Skip these elements
                    }
                    // Only apply if not already handled by form-group selector above
                    if (!el.closest('.form-group')) {
                        el.style.fontSize = fontSize;
                        el.style.lineHeight = lineHeight;
                    }
                });
            }
            
            // Apply to all preview boxes in scope
            scope.querySelectorAll('.live-preview').forEach(el => {
                el.style.fontSize = fontSize;
                el.style.lineHeight = lineHeight;
            });
            
            // Correct Answer / checkbox output: container + labels so dynamically rebuilt content inherits or gets font
            scope.querySelectorAll('#correct-answer-selector, #checkbox-summary, #checkbox-summary-text, [id^="correct-answer-radios-"], [id^="correct-answer-radios-"] label').forEach(el => {
                el.style.fontSize = fontSize;
                el.style.lineHeight = lineHeight;
            });
        }
        
        function changeFontSize(size) {
            // Ensure size is a string
            const sizeStr = String(size);
            const fontSize = sizeStr + 'px';
            
            // Apply to all form controls, but exclude search bar and JSON input
            // Match CSS rule: .form-group input, .form-group textarea, .form-group select
            document.querySelectorAll('.form-group input, .form-group textarea, .form-group select').forEach(el => {
                // Exclude search bar and JSON input from font size changes
                if (el.id === 'searchFilter' || el.id === 'json_input') {
                    return; // Skip these elements
                }
                el.style.fontSize = fontSize;
            });
            // Also apply to bbox inputs (not in .form-group)
            document.querySelectorAll('.bbox-inputs input').forEach(el => {
                if (el.id === 'searchFilter' || el.id === 'json_input') {
                    return; // Skip these elements
                }
                el.style.fontSize = fontSize;
            });
            // Correct Answer / checkbox output: container + labels (same as applyFontSettings)
            document.querySelectorAll('#correct-answer-selector, #checkbox-summary, #checkbox-summary-text, [id^="correct-answer-radios-"], [id^="correct-answer-radios-"] label').forEach(el => {
                el.style.fontSize = fontSize;
            });
            // Apply to all preview boxes
            document.querySelectorAll('.live-preview').forEach(el => {
                el.style.fontSize = fontSize;
            });
            
            // If final preview tab is active, regenerate it to apply font size
            const finalPreviewTab = document.getElementById('final-preview');
            if (finalPreviewTab && finalPreviewTab.classList.contains('active')) {
                generateFinalPreview();
            }
            
            // Save to localStorage (save as string)
            localStorage.setItem('fontSize', sizeStr);
            
            // Re-fit only registered targets in active panel (font size affects scrollHeight). No tab scan.
            if (typeof AutoSizeManager !== 'undefined' && AutoSizeManager.refreshStyleChange) {
                AutoSizeManager.refreshStyleChange(resolveActivePanelRoot());
            }
        }
        
        function changeLineHeight(height) {
            // Ensure height is a string
            const heightStr = String(height);
            const lineHeight = heightStr;
            
            // Apply to all form controls, but exclude search bar and JSON input
            // Match CSS rule: .form-group input, .form-group textarea, .form-group select
            document.querySelectorAll('.form-group input, .form-group textarea, .form-group select').forEach(el => {
                // Exclude search bar and JSON input from line height changes
                if (el.id === 'searchFilter' || el.id === 'json_input') {
                    return; // Skip these elements
                }
                el.style.lineHeight = lineHeight;
            });
            // Also apply to bbox inputs (not in .form-group)
            document.querySelectorAll('.bbox-inputs input').forEach(el => {
                if (el.id === 'searchFilter' || el.id === 'json_input') {
                    return; // Skip these elements
                }
                el.style.lineHeight = lineHeight;
            });
            // Correct Answer / checkbox output: container + labels (same as applyFontSettings)
            document.querySelectorAll('#correct-answer-selector, #checkbox-summary, #checkbox-summary-text, [id^="correct-answer-radios-"], [id^="correct-answer-radios-"] label').forEach(el => {
                el.style.lineHeight = lineHeight;
            });
            // Apply to all preview boxes
            document.querySelectorAll('.live-preview').forEach(el => {
                el.style.lineHeight = lineHeight;
            });
            
            // If final preview tab is active, regenerate it to apply line height
            const finalPreviewTab = document.getElementById('final-preview');
            if (finalPreviewTab && finalPreviewTab.classList.contains('active')) {
                generateFinalPreview();
            }
            
            // Save to localStorage (save as string)
            localStorage.setItem('lineHeight', heightStr);
            
            // Re-fit only registered targets in active panel (line height affects scrollHeight). No tab scan.
            if (typeof AutoSizeManager !== 'undefined' && AutoSizeManager.refreshStyleChange) {
                AutoSizeManager.refreshStyleChange(resolveActivePanelRoot());
            }
        }
        
        // Initialize font settings from localStorage
        function initializeFontSettings() {
            const savedFontSize = localStorage.getItem('fontSize');
            const savedLineHeight = localStorage.getItem('lineHeight');
            
            // Set and apply font size (use saved value or default)
            const fontSizeToApply = savedFontSize || '14'; // Default to 14px if not saved
                const fontSizeSelect = document.getElementById('fontSizeSelect');
                if (fontSizeSelect) {
                fontSizeSelect.value = fontSizeToApply;
                // Use setTimeout to ensure all elements are loaded
                setTimeout(() => {
                    changeFontSize(fontSizeToApply);
                }, 0);
            }
            
            // Set and apply line height (use saved value or default)
            const lineHeightToApply = savedLineHeight || '1.5'; // Default to 1.5 if not saved
                const lineHeightSelect = document.getElementById('lineHeightSelect');
                if (lineHeightSelect) {
                lineHeightSelect.value = lineHeightToApply;
                // Use setTimeout to ensure all elements are loaded
                setTimeout(() => {
                    changeLineHeight(lineHeightToApply);
                }, 0);
            }
        }

        function toggleDarkMode() {
            const body = document.body;
            const toggle = document.getElementById('darkModeToggle');
            const icon = toggle.querySelector('i');
            
            // Toggle the data-theme attribute
            const isDark = body.getAttribute('data-theme') !== 'dark';
            if (body.getAttribute('data-theme') === 'dark') {
                body.removeAttribute('data-theme');
                icon.className = 'fas fa-moon';
                localStorage.setItem('darkMode', 'light');
            } else {
                body.setAttribute('data-theme', 'dark');
                icon.className = 'fas fa-sun';
                localStorage.setItem('darkMode', 'dark');
            }
        }

        // Initialize dark mode from localStorage
        function initializeDarkMode() {
            const savedTheme = localStorage.getItem('darkMode');
            const body = document.body;
            const toggle = document.getElementById('darkModeToggle');
            const icon = toggle.querySelector('i');
            
            if (savedTheme === 'dark') {
                body.setAttribute('data-theme', 'dark');
                icon.className = 'fas fa-sun';
            } else {
                body.removeAttribute('data-theme');
                icon.className = 'fas fa-moon';
            }
        }

        // Check if a textarea has trailing spaces or empty lines
        function hasTrailingSpaces(textarea) {
            if (!textarea || !textarea.value) return false;
            const text = textarea.value;
            const lines = text.split('\n');
            
            // Check for trailing spaces on lines
            const hasTrailingSpacesOnLines = lines.some(line => {
                if (line.trim().length === 0) return false; // Skip empty lines
                return line.trimEnd() !== line; // Line has trailing spaces
            });
            
            // Check for leading spaces on lines
            const hasLeadingSpacesOnLines = lines.some(line => {
                if (line.trim().length === 0) return false; // Skip empty lines
                return line.trimStart() !== line; // Line has leading spaces
            });
            
            // Check for multiple consecutive spaces within text (2+ consecutive spaces)
            const hasMultipleConsecutiveSpaces = lines.some(line => {
                if (line.trim().length === 0) return false; // Skip empty lines
                // Check for 2+ consecutive spaces that are not at the beginning or end
                const trimmedStart = line.trimStart();
                const trimmedEnd = trimmedStart.trimEnd();
                // Check if the trimmed content (without leading/trailing spaces) has 2+ consecutive spaces
                return / {2,}/.test(trimmedEnd);
            });
            
            // Check for trailing empty lines (all consecutive empty lines at the end)
            let trailingEmptyLineCount = 0;
            for (let i = lines.length - 1; i >= 0; i--) {
                if (lines[i].trim().length === 0) {
                    trailingEmptyLineCount++;
                } else {
                    break; // Stop when we hit a non-empty line
                }
            }
            const hasTrailingEmptyLines = trailingEmptyLineCount > 0 && text.trim().length > 0;
            
            // Check for leading empty lines (all consecutive empty lines at the beginning)
            let leadingEmptyLineCount = 0;
            for (let i = 0; i < lines.length; i++) {
                if (lines[i].trim().length === 0) {
                    leadingEmptyLineCount++;
                } else {
                    break; // Stop when we hit a non-empty line
                }
            }
            const hasLeadingEmptyLines = leadingEmptyLineCount > 0 && text.trim().length > 0;
            
            // Check for consecutive empty lines in the middle (2+ consecutive empty lines)
            let hasConsecutiveEmptyLines = false;
            let consecutiveEmptyCount = 0;
            for (let i = 0; i < lines.length; i++) {
                if (lines[i].trim().length === 0) {
                    consecutiveEmptyCount++;
                    if (consecutiveEmptyCount >= 2) {
                        // Check if this is not part of leading or trailing empty lines
                        const isLeading = i < leadingEmptyLineCount;
                        const isTrailing = i >= lines.length - trailingEmptyLineCount;
                        if (!isLeading && !isTrailing) {
                            hasConsecutiveEmptyLines = true;
                            break;
                        }
                    }
                } else {
                    consecutiveEmptyCount = 0;
                }
            }
            
            return hasTrailingSpacesOnLines || hasLeadingSpacesOnLines || hasMultipleConsecutiveSpaces || hasTrailingEmptyLines || hasLeadingEmptyLines || hasConsecutiveEmptyLines;
        }
        
        // Mark trailing spaces in markdown text before rendering
        function markTrailingSpaces(md) {
            const isEnabled = localStorage.getItem('trailingSpacesIndicator') === 'true';
            if (!isEnabled || !md) return md;
            
            // Split into lines and process each line
            const lines = md.split('\n');
            
            // Find trailing empty lines count
            let trailingEmptyLineCount = 0;
            for (let i = lines.length - 1; i >= 0; i--) {
                if (lines[i].trim().length === 0) {
                    trailingEmptyLineCount++;
                } else {
                    break;
                }
            }
            
            // Find leading empty lines count
            let leadingEmptyLineCount = 0;
            for (let i = 0; i < lines.length; i++) {
                if (lines[i].trim().length === 0) {
                    leadingEmptyLineCount++;
                } else {
                    break;
                }
            }
            
            // Identify consecutive empty lines in the middle (2+ consecutive empty lines)
            const consecutiveEmptyLineIndices = new Set();
            let consecutiveStartIndex = -1;
            let consecutiveEmptyCount = 0;
            for (let i = 0; i < lines.length; i++) {
                if (lines[i].trim().length === 0) {
                    if (consecutiveStartIndex === -1) {
                        consecutiveStartIndex = i;
                    }
                    consecutiveEmptyCount++;
                } else {
                    // End of consecutive empty lines group
                    if (consecutiveEmptyCount >= 2) {
                        // Check if this group is not part of leading or trailing empty lines
                        const isLeading = consecutiveStartIndex < leadingEmptyLineCount;
                        const isTrailing = consecutiveStartIndex >= lines.length - trailingEmptyLineCount;
                        if (!isLeading && !isTrailing) {
                            // Mark all consecutive empty lines in this group
                            for (let j = consecutiveStartIndex; j < consecutiveStartIndex + consecutiveEmptyCount; j++) {
                                consecutiveEmptyLineIndices.add(j);
                            }
                        }
                    }
                    consecutiveStartIndex = -1;
                    consecutiveEmptyCount = 0;
                }
            }
            // Handle case where consecutive empty lines are at the end (but not trailing)
            if (consecutiveEmptyCount >= 2 && consecutiveStartIndex !== -1) {
                const isLeading = consecutiveStartIndex < leadingEmptyLineCount;
                const isTrailing = consecutiveStartIndex >= lines.length - trailingEmptyLineCount;
                if (!isLeading && !isTrailing) {
                    // Mark all consecutive empty lines in this group
                    for (let j = consecutiveStartIndex; j < consecutiveStartIndex + consecutiveEmptyCount; j++) {
                        consecutiveEmptyLineIndices.add(j);
                    }
                }
            }
            
            // Process lines for trailing and leading spaces (only process non-empty lines and non-leading/trailing empty lines)
            const processedLines = lines.map((line, index) => {
                // Check if line has spaces (leading or trailing, but not if it's an empty line)
                if (line.trim().length > 0) {
                    let result = '';
                    
                    // Check for leading spaces
                    const trimmedStart = line.trimStart();
                    const leadingSpacesCount = line.length - trimmedStart.length;
                    if (leadingSpacesCount > 0) {
                        result += '@@LEADING_SPACES_' + leadingSpacesCount + '@@';
                    }
                    
                    // Check for trailing spaces on the trimmed line (after removing leading spaces)
                    const trimmedEnd = trimmedStart.trimEnd();
                    const trailingSpacesCount = trimmedStart.length - trimmedEnd.length;
                    
                    // Process the content (without leading and trailing spaces) to mark multiple consecutive spaces
                    // Replace 2+ consecutive spaces with a marker
                    const processedContent = trimmedEnd.replace(/ {2,}/g, (match) => {
                        return '@@CONSECUTIVE_SPACES_' + match.length + '@@';
                    });
                    
                    // Add the processed content
                    result += processedContent;
                    
                    // Add trailing spaces marker if present
                    if (trailingSpacesCount > 0) {
                        result += '@@TRAILING_SPACES_' + trailingSpacesCount + '@@';
                    }
                    
                    return result;
                }
                // For empty lines, check if they're leading, trailing, or consecutive in the middle
                if (line.trim().length === 0) {
                    // Check leading first (most specific)
                    if (index < leadingEmptyLineCount) {
                        // Leading empty line - replace with marker
                        return '@@LEADING_EMPTY_LINE@@';
                    }
                    // Check trailing next
                    if (index >= lines.length - trailingEmptyLineCount && trailingEmptyLineCount > 0) {
                        // Trailing empty line - replace with marker
                        return '@@TRAILING_EMPTY_LINE@@';
                    }
                    // Check consecutive in the middle
                    if (consecutiveEmptyLineIndices.has(index)) {
                        // Consecutive empty line in the middle - replace with marker
                        return '@@CONSECUTIVE_EMPTY_LINE@@';
                    }
                }
                return line;
            });
            
            return processedLines.join('\n');
        }
        
        // Replace trailing space markers in HTML with styled spans
        function replaceTrailingSpaceMarkers(html) {
            const isEnabled = localStorage.getItem('trailingSpacesIndicator') === 'true';
            if (!isEnabled || !html) return html;
            
            // Replace leading space markers with styled spans
            html = html.replace(/@@LEADING_SPACES_(\d+)@@/g, (match, count) => {
                const numSpaces = parseInt(count, 10);
                const spaces = '&nbsp;'.repeat(numSpaces);
                return `<span class="leading-space">${spaces}</span>`;
            });
            
            // Replace trailing space markers with styled spans
            html = html.replace(/@@TRAILING_SPACES_(\d+)@@/g, (match, count) => {
                const numSpaces = parseInt(count, 10);
                const spaces = '&nbsp;'.repeat(numSpaces);
                return `<span class="trailing-space">${spaces}</span>`;
            });
            
            // Replace consecutive space markers (within text) with styled spans
            html = html.replace(/@@CONSECUTIVE_SPACES_(\d+)@@/g, (match, count) => {
                const numSpaces = parseInt(count, 10);
                const spaces = '&nbsp;'.repeat(numSpaces);
                return `<span class="consecutive-space">${spaces}</span>`;
            });
            
            // Replace trailing empty line markers
            html = html.replace(/@@TRAILING_EMPTY_LINE@@/g, '<div class="trailing-empty-line"></div>');
            
            // Replace leading empty line markers
            html = html.replace(/@@LEADING_EMPTY_LINE@@/g, '<div class="trailing-empty-line"></div>');
            
            // Replace consecutive empty line markers (in the middle)
            html = html.replace(/@@CONSECUTIVE_EMPTY_LINE@@/g, '<div class="trailing-empty-line"></div>');
            
            return html;
        }
        
        // Update trailing spaces indicator for a preview box
        function updateTrailingSpacesIndicator(textarea, preview) {
            if (!preview) return;
            const isEnabled = localStorage.getItem('trailingSpacesIndicator') === 'true';
            if (isEnabled && hasTrailingSpaces(textarea)) {
                preview.classList.add('has-trailing-spaces');
            } else {
                preview.classList.remove('has-trailing-spaces');
            }
        }
        
        // Toggle trailing spaces indicator
        function toggleTrailingSpacesIndicator() {
            const toggle = document.getElementById('trailingSpacesToggle');
            const icon = toggle.querySelector('i');
            const isEnabled = localStorage.getItem('trailingSpacesIndicator') === 'true';
            
            // Keep original icon, just change background color
            if (isEnabled) {
                localStorage.setItem('trailingSpacesIndicator', 'false');
                // OFF state: Red background
                toggle.title = 'Trailing Spaces Indicator: OFF (Click to enable)';
                toggle.style.background = 'rgba(220, 53, 69, 0.8)'; // Red background
                toggle.style.borderColor = 'rgba(255, 255, 255, 0.9)';
                // Remove indicators from all previews and re-render them to remove marker HTML
                document.querySelectorAll('textarea, input[type="text"]').forEach(textarea => {
                    // Skip search bar and JSON input
                    if (textarea.id === 'searchFilter' || textarea.id === 'json_input') return;
                    // Re-render the preview to remove markers
                    renderLivePreview(textarea);
                });
                // Also remove the class from all previews
                document.querySelectorAll('.live-preview').forEach(preview => {
                    preview.classList.remove('has-trailing-spaces');
                });
                // Regenerate final preview if it's active
                const finalPreviewTab = document.getElementById('final-preview');
                if (finalPreviewTab && finalPreviewTab.classList.contains('active')) {
                    generateFinalPreview();
                }
            } else {
                localStorage.setItem('trailingSpacesIndicator', 'true');
                // ON state: Green background
                toggle.title = 'Trailing Spaces Indicator: ON (Click to disable)';
                toggle.style.background = 'rgba(40, 167, 69, 0.8)'; // Green background
                toggle.style.borderColor = 'rgba(255, 255, 255, 0.9)';
                // Re-render all previews to add markers
                document.querySelectorAll('textarea, input[type="text"]').forEach(textarea => {
                    // Skip search bar and JSON input
                    if (textarea.id === 'searchFilter' || textarea.id === 'json_input') return;
                    // Re-render the preview to add markers
                    renderLivePreview(textarea);
                });
                // Update all previews to show indicators (add class)
                updateAllTrailingSpacesIndicators();
                // Regenerate final preview if it's active
                const finalPreviewTab = document.getElementById('final-preview');
                if (finalPreviewTab && finalPreviewTab.classList.contains('active')) {
                    generateFinalPreview();
                }
            }
        }
        
        // Update trailing spaces indicators for all previews
        function updateAllTrailingSpacesIndicators() {
            const isEnabled = localStorage.getItem('trailingSpacesIndicator') === 'true';
            if (!isEnabled) return;
            
            // Find all textareas and their associated previews
            document.querySelectorAll('textarea, input[type="text"]').forEach(textarea => {
                // Skip search bar and JSON input
                if (textarea.id === 'searchFilter' || textarea.id === 'json_input') return;
                
                // Find the associated preview
                let preview = null;
                let nextSibling = textarea.nextElementSibling;
                
                // Walk through siblings to find preview
                while (nextSibling) {
                    if (nextSibling.classList && nextSibling.classList.contains('live-preview')) {
                        preview = nextSibling;
                        break;
                    }
                    // Skip buttons, labels, and error divs
                    if (nextSibling.tagName === 'BUTTON' || 
                        nextSibling.classList.contains('preview-label') ||
                        nextSibling.classList.contains('table-validation-errors') ||
                        nextSibling.classList.contains('list-validation-errors') ||
                        nextSibling.classList.contains('blockquote-validation-errors') ||
                        nextSibling.classList.contains('latex-validation-errors') ||
                        nextSibling.classList.contains('image-validation-errors') ||
                        nextSibling.classList.contains('quote-validation-errors') ||
                        nextSibling.classList.contains('br-validation-errors')) {
                        nextSibling = nextSibling.nextElementSibling;
                    } else {
                        break;
                    }
                }
                
                if (preview) {
                    updateTrailingSpacesIndicator(textarea, preview);
                }
            });
        }
        
        // Initialize trailing spaces indicator from localStorage
        function initializeTrailingSpacesIndicator() {
            const isEnabled = localStorage.getItem('trailingSpacesIndicator') === 'true';
            const toggle = document.getElementById('trailingSpacesToggle');
            if (toggle) {
                const icon = toggle.querySelector('i');
                // Keep original icon, just change background color
                if (isEnabled) {
                    // ON state: Green background
                    toggle.title = 'Trailing Spaces Indicator: ON (Click to disable)';
                    toggle.style.background = 'rgba(40, 167, 69, 0.8)'; // Green background
                    toggle.style.borderColor = 'rgba(255, 255, 255, 0.9)';
                } else {
                    // OFF state: Red background
                    toggle.title = 'Trailing Spaces Indicator: OFF (Click to enable)';
                    toggle.style.background = 'rgba(220, 53, 69, 0.8)'; // Red background
                    toggle.style.borderColor = 'rgba(255, 255, 255, 0.9)';
                }
            }
            if (isEnabled) {
                // Update all previews after a short delay to ensure DOM is ready
                setTimeout(() => {
                    updateAllTrailingSpacesIndicators();
                }, 100);
            }
        }

        // Ensure preview updates after helper insertions
        function refreshPreviewFor(textarea) {
            if (textarea) renderLivePreview(textarea);
        }

        // Paste a bbox/image JSON snippet copied from the bbox tool (no permission dialog)
        function pasteBboxJson(button) {
            try {
                const text = prompt('Paste bbox/image JSON here:\n{"page": 1, "position": [[xRight, yTop], [xLeft, yBottom]]}');
                if (!text) { return; }
                let obj;
                try {
                    obj = JSON.parse(text);
                } catch (e) {
                    alert('Pasted content is not valid JSON.');
                    return;
                }
                if (typeof obj !== 'object' || !obj.position || !Array.isArray(obj.position) || obj.position.length !== 2) {
                    alert('JSON must be of the form {"page": N, "position": [[xRight, yTop], [xLeft, yBottom]]}.');
                    return;
                }
                const pageVal = parseInt(obj.page ?? obj.Page ?? obj.page_index ?? 0, 10);
                let [[xRight, yTop], [xLeft, yBottom]] = obj.position;
                
                // Normalize coordinates to ensure correct format (top-right to bottom-left)
                const normalized = normalizeBboxCoordinates(xRight, yTop, xLeft, yBottom);
                if (normalized) {
                    xRight = normalized.x0;
                    yTop = normalized.y0;
                    xLeft = normalized.x1;
                    yBottom = normalized.y1;
                }
                
                // Determine target container relative to where the Paste button is
                let arrContainer = null;
                const parentArrayItem = button.closest('.array-item');
                if (parentArrayItem && parentArrayItem.parentElement && parentArrayItem.parentElement.classList.contains('bbox-container')) {
                    // Row-level paste: use this row's container
                    arrContainer = parentArrayItem.parentElement;
                } else {
                    // Group-level paste: use the previous sibling container
                    arrContainer = button.previousElementSibling;
                }
                if (!arrContainer || !arrContainer.classList.contains('bbox-container')) {
                    alert('Could not find target container to paste into.');
                    return;
                }
                // Target row logic: overwrite current row if invoked from row; otherwise use first row or create one
                let targetRow = (parentArrayItem && parentArrayItem.parentElement === arrContainer) ? parentArrayItem : null;
                let wasNewRow = false;
                if (!targetRow) {
                    targetRow = arrContainer.querySelector('.array-item');
                    if (!targetRow) {
                        wasNewRow = true;
                        // Create generic bbox row (no Before/After buttons for paste context)
                        targetRow = buildBBoxRow({
                            buttonOrder: 'none'
                        });
                        arrContainer.appendChild(targetRow);
                        // Finalize the bbox row (validation + font settings)
                        finalizeBBoxRow(targetRow);
                    }
                }
                
                // Save old state before pasting (for undo)
                const oldState = {
                    page: targetRow.querySelector('.bbox-page')?.value || '',
                    x0: targetRow.querySelector('.bbox-x0')?.value || '',
                    y0: targetRow.querySelector('.bbox-y0')?.value || '',
                    x1: targetRow.querySelector('.bbox-x1')?.value || '',
                    y1: targetRow.querySelector('.bbox-y1')?.value || ''
                };
                
                const inputs = targetRow.querySelectorAll('input');
                if (inputs.length >= 5) {
                    inputs[0].value = Number.isFinite(pageVal) ? pageVal : '';
                    inputs[1].value = Math.round(xRight) || 0; // X0 (top-right x)
                    inputs[2].value = Math.round(yTop) || 0;   // Y0 (top-right y)
                    inputs[3].value = Math.round(xLeft) || 0;  // X1 (bottom-left x)
                    inputs[4].value = Math.round(yBottom) || 0;// Y1 (bottom-left y)
                }
                
                // Save pasted state (for redo)
                const pastedState = {
                    page: inputs[0].value,
                    x0: inputs[1].value,
                    y0: inputs[2].value,
                    x1: inputs[3].value,
                    y1: inputs[4].value
                };
                
                // Record action for undo/redo
                recordFormAction({
                    type: ACTION_TYPES.PASTE_BBOX,
                    targetRow: targetRow,
                    oldState: oldState,
                    pastedState: pastedState,
                    wasNewRow: wasNewRow
                });
                
                // Mark form as changed and trigger auto-save after pasting coordinates
                markFormAsChanged();
                triggerAutoSave();
            } catch (err) {
                console.error(err);
                alert('Failed to paste.');
            }
        }

        // Copy the current row's bbox/image as JSON for the Paste button format
        function copyBboxJson(button) {
            try {
                const parentArrayItem = button.closest('.array-item');
                const inputs = parentArrayItem ? parentArrayItem.querySelectorAll('.bbox-inputs input') : null;
                if (!inputs || inputs.length < 5) { alert('Could not locate bbox inputs'); return; }
                const page = parseInt(inputs[0].value, 10);
                const x0 = parseInt(inputs[1].value, 10);
                const y0 = parseInt(inputs[2].value, 10);
                const x1 = parseInt(inputs[3].value, 10);
                const y1 = parseInt(inputs[4].value, 10);
                if (![page, x0, y0, x1, y1].every(Number.isFinite)) {
                    alert('Please fill Page, X0, Y0, X1, Y1 with integers before copying.');
                    return;
                }
                const obj = { page: page, position: [[x0, y0], [x1, y1]] };
                const text = JSON.stringify(obj);
                const ta = document.createElement('textarea');
                ta.value = text;
                document.body.appendChild(ta);
                ta.select();
                try { document.execCommand('copy'); } catch {}
                document.body.removeChild(ta);
                const copyBtn = button;
                const original = copyBtn.innerHTML;
                copyBtn.innerHTML = '<i class="fas fa-check"></i> Copied!';
                copyBtn.style.background = '#28a745';
                setTimeout(() => { copyBtn.innerHTML = original; copyBtn.style.background = ''; }, 1200);
            } catch (e) {
                alert('Failed to copy.');
            }
        }

        // Duplicate the current bbox/image row (create a copy right below)
        function duplicateBbox(button) {
            try {
                const parentArrayItem = button.closest('.array-item');
                if (!parentArrayItem) {
                    alert('Could not find bbox item to duplicate');
                    return;
                }
                
                const inputs = parentArrayItem.querySelectorAll('.bbox-inputs input');
                if (!inputs || inputs.length < 5) {
                    alert('Could not locate bbox inputs');
                    return;
                }
                
                const page = inputs[0].value || '';
                const x0 = inputs[1].value || '';
                const y0 = inputs[2].value || '';
                const x1 = inputs[3].value || '';
                const y1 = inputs[4].value || '';
                
                // Find the parent container
                const container = parentArrayItem.parentElement;
                if (!container) {
                    alert('Could not find container');
                    return;
                }
                
                // Determine the type of image based on the label of parent form-group
                const formGroup = container.closest('.form-group');
                const label = formGroup ? formGroup.querySelector('label') : null;
                const labelText = label ? label.textContent : '';
                
                let beforeFunc = 'addContentImageBefore';
                let afterFunc = 'addContentImageAfter';
                let buttonOrder = 'reorderFirst';
                
                if (labelText.includes('Question Images')) {
                    beforeFunc = 'addQuestionImageBefore';
                    afterFunc = 'addQuestionImageAfter';
                } else if (labelText.includes('Answer Images')) {
                    beforeFunc = 'addAnswerImageBefore';
                    afterFunc = 'addAnswerImageAfter';
                } else if (labelText.includes('Section Images')) {
                    beforeFunc = 'addContentImageBefore';
                    afterFunc = 'addContentImageAfter';
                }
                
                // Create new item below current one
                const newItem = buildBBoxRow({
                    values: { page, x0, y0, x1, y1 },
                    beforeHandler: beforeFunc,
                    afterHandler: afterFunc,
                    buttonOrder: buttonOrder
                });
                
                // Insert after current item
                container.insertBefore(newItem, parentArrayItem.nextSibling);
                
                // Record action for undo/redo (after adding to DOM so we have the actual element)
                // Save snapshotState and metadata for deterministic redo
                recordFormAction({
                    type: ACTION_TYPES.DUPLICATE_ITEM,
                    originalElement: parentArrayItem,
                    duplicatedElement: newItem,
                    parent: container,
                    nextSibling: newItem.nextSibling,
                    containerId: null,
                    updateNumbers: false,
                    isBbox: true,
                    snapshotState: { page, x0, y0, x1, y1 },
                    bboxHandlers: { beforeFunc, afterFunc, buttonOrder }
                });
                
                // Finalize the bbox row (validation + font settings)
                finalizeBBoxRow(newItem);
                
                // Visual feedback
                const duplicateBtn = button;
                const originalIcon = duplicateBtn.innerHTML;
                duplicateBtn.innerHTML = '<i class="fas fa-check"></i>';
                duplicateBtn.style.background = '#28a745';
                setTimeout(() => {
                    duplicateBtn.innerHTML = originalIcon;
                    duplicateBtn.style.background = '';
                }, 1200);
                
                // Mark form as changed and trigger auto-save
                markFormAsChanged();
                triggerAutoSave();
                
            } catch (e) {
                console.error('Failed to duplicate bbox:', e);
                alert('Failed to duplicate: ' + e.message);
            }
        }

        // Open bbox drawer in picker mode and fill the current row on selection
        function openBboxDrawer(button) {
            // Identify the row to fill
            const parentArrayItem = button.closest('.array-item');
            const inputs = parentArrayItem ? parentArrayItem.querySelectorAll('.bbox-inputs input') : null;
            if (!inputs || inputs.length < 5) { alert('Could not locate bbox inputs'); return; }
            // Decide which PDF to use based on section type (answers vs non-answers)
            const group = button.closest('.form-group');
            const isGuide = !!(group && /Answer\s+Images/i.test(group.querySelector('label')?.textContent||''));
            // Pass current page as hint (prefer row page; else fallback to textbook or guidebook start page)
            let hintPage = inputs[0].value && String(inputs[0].value).trim()
                ? String(inputs[0].value).trim()
                : '';
            if (!hintPage) {
                if (isGuide) {
                    const gStart = document.getElementById('guidebook_start_page');
                    hintPage = (gStart && gStart.value) ? String(gStart.value).trim() : '';
                } else {
                    const tPdf = document.getElementById('textbook_pdf_page');
                    hintPage = (tPdf && tPdf.value) ? String(tPdf.value).trim() : '';
                }
            }
            // Save active target
            window.__embeddedBboxTarget = { inputs, isGuide: isGuide };
            // Open embedded modal and init viewer
            openEmbeddedBboxModal(hintPage);
        }

        // Helper functions for PDF persistence in IndexedDB
        async function savePdfToStorage(key, arrayBuffer) {
            try {
                return new Promise((resolve) => {
                    const request = indexedDB.open('bboxPdfStorage', 1);
                    
                    request.onerror = () => resolve(false);
                    
                    request.onsuccess = () => {
                        const db = request.result;
                        const transaction = db.transaction(['pdfs'], 'readwrite');
                        const store = transaction.objectStore('pdfs');
                        const putRequest = store.put(arrayBuffer, key);
                        
                        putRequest.onsuccess = () => resolve(true);
                        putRequest.onerror = () => resolve(false);
                    };
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains('pdfs')) {
                            db.createObjectStore('pdfs');
                        }
                    };
                });
            } catch (error) {
                return false;
            }
        }

        async function loadPdfFromStorage(key) {
            try {
                return new Promise((resolve) => {
                    const request = indexedDB.open('bboxPdfStorage', 1);
                    
                    request.onerror = () => resolve(null);
                    
                    request.onsuccess = () => {
                        const db = request.result;
                        if (!db.objectStoreNames.contains('pdfs')) {
                            resolve(null);
                            return;
                        }
                        
                        const transaction = db.transaction(['pdfs'], 'readonly');
                        const store = transaction.objectStore('pdfs');
                        const getRequest = store.get(key);
                        
                        getRequest.onsuccess = () => resolve(getRequest.result || null);
                        getRequest.onerror = () => resolve(null);
                    };
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains('pdfs')) {
                            db.createObjectStore('pdfs');
                        }
                    };
                });
            } catch (error) {
                return null;
            }
        }

        // Auto-load PDFs from IndexedDB on page load (for both bbox modal and main PDF viewer)
        async function initializePdfStore() {
            try {
                // Initialize the store if it doesn't exist
                const store = (window.__bboxStore = window.__bboxStore || {});
                // Preserve existing docs if they exist, otherwise initialize with defaults
                if (!store.docs) {
                    store.docs = { 
                        text: { 
                            pdfDoc: null, currentPage: 1, totalPages: 0, scale: 1.2, 
                            scrollLeft: 0, scrollTop: 0, 
                            mainViewerScale: 1.0, mainViewerScrollLeft: 0, mainViewerScrollTop: 0 
                        }, 
                        guide: { 
                            pdfDoc: null, currentPage: 1, totalPages: 0, scale: 1.2, 
                            scrollLeft: 0, scrollTop: 0,
                            mainViewerScale: 1.0, mainViewerScrollLeft: 0, mainViewerScrollTop: 0 
                        } 
                    };
                } else {
                    // Ensure both text and guide objects exist, but preserve existing data
                    if (!store.docs.text) {
                        store.docs.text = { 
                            pdfDoc: null, currentPage: 1, totalPages: 0, scale: 1.2, 
                            scrollLeft: 0, scrollTop: 0, 
                            mainViewerScale: 1.0, mainViewerScrollLeft: 0, mainViewerScrollTop: 0 
                        };
                    }
                    if (!store.docs.guide) {
                        store.docs.guide = { 
                            pdfDoc: null, currentPage: 1, totalPages: 0, scale: 1.2, 
                            scrollLeft: 0, scrollTop: 0,
                            mainViewerScale: 1.0, mainViewerScrollLeft: 0, mainViewerScrollTop: 0 
                        };
                    }
                }

                // Suppress PDF.js warnings (fake worker, cross-origin) - expected when using file:// protocol
                const originalWarn = console.warn;
                const originalError = console.error;
                console.warn = function(...args) {
                    const message = args.join(' ');
                    // Suppress PDF.js warnings
                    if (!message.includes('Setting up fake worker') && !message.includes('cross-origin')) {
                        originalWarn.apply(console, args);
                    }
                };
                console.error = function(...args) {
                    const message = args.join(' ');
                    // Suppress PDF.js cross-origin errors
                    if (!message.includes('cross-origin') && !message.includes('Refused to')) {
                        originalError.apply(console, args);
                    }
                };
                
                const pdfjs = await import('https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.4.168/pdf.min.mjs');
                // Set worker source - PDF.js will automatically fall back to fake worker
                // if cross-origin restrictions prevent loading (e.g., file:// protocol)
                pdfjs.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.4.168/pdf.worker.min.mjs';
                
                // Restore original console methods after a short delay to allow PDF.js to initialize
                setTimeout(() => {
                    console.warn = originalWarn;
                    console.error = originalError;
                }, 500);
                
                // Load both text and guide PDFs from IndexedDB (load them in parallel for better performance)
                const loadPromises = ['text', 'guide'].map(async (key) => {
                    try {
                        const pdfData = await loadPdfFromStorage(key);
                        if (pdfData && pdfData.byteLength > 0) {
                            const doc = await pdfjs.getDocument({ data: pdfData }).promise;
                            store.docs[key].pdfDoc = doc;
                            store.docs[key].totalPages = doc.numPages;
                            
                            // Restore saved page/scale if available, otherwise use defaults
                            if (!store.docs[key].currentPage || store.docs[key].currentPage > doc.numPages) {
                                store.docs[key].currentPage = 1;
                            }
                            if (!store.docs[key].scale) {
                                store.docs[key].scale = 1.2;
                            }
                            return { key, success: true };
                        }
                        return { key, success: false, reason: 'No PDF data found' };
                    } catch (error) {
                        // Fail silently - just don't load this PDF
                        return { key, success: false, reason: error.message };
                    }
                });
                
                // Wait for both PDFs to finish loading (use allSettled to ensure both attempts complete)
                await Promise.allSettled(loadPromises);
            } catch (error) {
                // Fail silently
            }
        }

        // Embedded BBox Drawer implementation
        async function openEmbeddedBboxModal(hintPage) {
            const modal = document.getElementById('bboxModal');
            if (!modal) return;
            modal.classList.add('show');
            
            // Set flag to prevent auto-navigation from switching sources when modal is open from Draw button
            const isMainFormUpload = (window.__embeddedBboxTarget && window.__embeddedBboxTarget.isMainFormUpload) || false;
            if (!isMainFormUpload) {
                window.__bboxModalOpen = true;
            }

            const pdfCanvas = document.getElementById('em-pdf');
            const drawCanvas = document.getElementById('em-draw');
            const canvasWrap = document.getElementById('em-canvas-wrap');
            const pdfCtx = pdfCanvas.getContext('2d', { alpha: false });
            const drawCtx = drawCanvas.getContext('2d');

            const textFileInput = document.getElementById('em-text-pdf-file');
            const guideFileInput = document.getElementById('em-guide-pdf-file');
            const docLabel = document.getElementById('em-doc-label');
            const prevBtn = document.getElementById('em-prev');
            const nextBtn = document.getElementById('em-next');
            const pageNumEl = document.getElementById('em-page-num');
            const pageCountEl = document.getElementById('em-page-count');
            const zoomInBtn = document.getElementById('em-zoom-in');
            const zoomOutBtn = document.getElementById('em-zoom-out');
            const zoomResetBtn = document.getElementById('em-zoom-reset');
            const zoomDisplay = document.getElementById('em-zoom-display');
            const gotoInput = document.getElementById('em-goto');
            const gotoBtn = document.getElementById('em-goto-btn');
            const clearBtn = document.getElementById('em-clear');
            const undoBtn = document.getElementById('em-undo');
            const coordsDisplay = document.getElementById('em-coords');
            const listEl = document.getElementById('em-list');
            const confirmBtn = document.getElementById('em-confirm');
            const cancelBtn = document.getElementById('em-cancel');

            // Save main PDF viewer scroll position before opening bbox modal
            const mainPdfContainer = document.getElementById('pdf-canvas-container');
            if (mainPdfContainer && !window.__mainPdfScrollSaved) {
                window.__mainPdfScroll = {
                    scrollLeft: mainPdfContainer.scrollLeft,
                    scrollTop: mainPdfContainer.scrollTop
                };
                window.__mainPdfScrollSaved = true;
            }
            
            // Persist two PDFs and view states between openings
            const store = (window.__bboxStore = window.__bboxStore || {});
            // Initialize docs object if it doesn't exist
            if (!store.docs) {
                store.docs = {};
            }
            // Initialize each PDF's state separately, preserving existing values
            if (!store.docs.text) {
                store.docs.text = { 
                    pdfDoc: null, currentPage: 1, totalPages: 0, scale: 1.2, 
                    scrollLeft: 0, scrollTop: 0, scrollLeftPercent: 0, scrollTopPercent: 0,
                    mainViewerScale: 1.0, mainViewerScrollLeft: 0, mainViewerScrollTop: 0 
                };
            }
            if (!store.docs.guide) {
                store.docs.guide = { 
                    pdfDoc: null, currentPage: 1, totalPages: 0, scale: 1.2, 
                    scrollLeft: 0, scrollTop: 0, scrollLeftPercent: 0, scrollTopPercent: 0,
                    mainViewerScale: 1.0, mainViewerScrollLeft: 0, mainViewerScrollTop: 0 
                };
            }
            const wantGuide = !!(window.__embeddedBboxTarget && window.__embeddedBboxTarget.isGuide);
            // Set activeKey based on which button was clicked - this determines which PDF's state to load
            // IMPORTANT: This is the LOCKED key for this modal session - all state saves go here
            const MODAL_SESSION_KEY = wantGuide ? 'guide' : 'text';
            // activeKey tracks which PDF is currently displayed (can change on upload)
            let activeKey = MODAL_SESSION_KEY;
            if (docLabel) docLabel.textContent = activeKey === 'guide' ? 'Answers' : 'Textbook';
            
            // Save main viewer's state before opening modal (only if not a main form upload)
            // isMainFormUpload was already declared above
            let savedMainViewerState = null;
            if (!isMainFormUpload) {
                const mainState = window.__mainPdfViewer;
                if (mainState) {
                    const mainKey = mainState.source === 'textbook' ? 'text' : 'guide';
                    // First, save current main viewer state to store (if visible)
                    if (mainState.visible && mainState.pdfDoc) {
                        updatePdfStore();
                    }
                    // Save the main viewer's current state before modal opens
                    // This includes source, page, scale, and scroll position
                    savedMainViewerState = {
                        source: mainState.source || 'textbook',
                        key: mainKey,
                        currentPage: mainState.currentPage || (store.docs[mainKey] ? store.docs[mainKey].currentPage : 1),
                        scale: mainState.scale || (store.docs[mainKey] ? store.docs[mainKey].mainViewerScale : 1.0),
                        scrollLeft: store.docs[mainKey] ? store.docs[mainKey].mainViewerScrollLeft : 0,
                        scrollTop: store.docs[mainKey] ? store.docs[mainKey].mainViewerScrollTop : 0,
                        // Also save the store values for both keys to restore them later
                        textCurrentPage: store.docs.text ? store.docs.text.currentPage : 1,
                        textScale: store.docs.text ? store.docs.text.mainViewerScale : 1.0,
                        textScrollLeft: store.docs.text ? store.docs.text.mainViewerScrollLeft : 0,
                        textScrollTop: store.docs.text ? store.docs.text.mainViewerScrollTop : 0,
                        guideCurrentPage: store.docs.guide ? store.docs.guide.currentPage : 1,
                        guideScale: store.docs.guide ? store.docs.guide.mainViewerScale : 1.0,
                        guideScrollLeft: store.docs.guide ? store.docs.guide.mainViewerScrollLeft : 0,
                        guideScrollTop: store.docs.guide ? store.docs.guide.mainViewerScrollTop : 0
                    };
                }
            }
            
            // Load PDF and state for the MODAL_SESSION_KEY (the PDF that was requested to open)
            let pdfDoc = store.docs[MODAL_SESSION_KEY].pdfDoc;
            let totalPages = store.docs[MODAL_SESSION_KEY].totalPages || 0;
            // ALWAYS load saved state from the store for MODAL_SESSION_KEY
            let currentPage = store.docs[MODAL_SESSION_KEY].currentPage || 1;
            let scale = store.docs[MODAL_SESSION_KEY].scale || 1.2;
            let isDrawing = true;
            let dragStart = null;
            let currentViewportScale = 1;
            // Store CSS-space dimensions for clearRect operations (accounting for devicePixelRatio scaling)
            let canvasCssWidth = 0;
            let canvasCssHeight = 0;
            // Edit state for moving/resizing an existing bbox
            let isEditing = false;      // true while dragging an existing rect
            let editMode = null;        // 'move' or one of 'nw','ne','se','sw','n','s','e','w'
            let editStart = null;       // {x,y} in canvas coords
            let editStartBBox = null;   // snapshot of lastDrawn at drag start
            // Always start fresh when Draw is pressed (clear old bbox)
            const activeInputs = (window.__embeddedBboxTarget && window.__embeddedBboxTarget.inputs) || null;
            let lastDrawn = null;
            let collected = [];
            
            // If this is opened from main form for PDF upload, don't show drawing tools
            if (isMainFormUpload) {
                // Hide drawing-related buttons
                const drawButtons = document.querySelectorAll('#em-add, #em-clear, #em-undo');
                drawButtons.forEach(btn => btn.style.display = 'none');
                
                // Hide the sidebar since it's not needed for PDF upload
                const sidebar = document.querySelector('.bbox-sidebar');
                if (sidebar) {
                    sidebar.style.display = 'none';
                }
                
                // Adjust the grid layout to use full width when sidebar is hidden
                const content = document.querySelector('.bbox-content');
                if (content) {
                    content.style.gridTemplateColumns = '1fr';
                }
                
                // Change modal title to indicate PDF upload mode
                const docLabel = document.getElementById('em-doc-label');
                if (docLabel) {
                    docLabel.textContent = activeKey === 'guide' ? 'Answers' : 'Textbook';
                }
                
                // Change confirm button text
                if (confirmBtn) {
                    confirmBtn.textContent = 'Close';
                }
            }
            
            // If the current row already has values, seed the preview/page to them
            if (activeInputs) {
                const p = parseInt(activeInputs[0].value, 10);
                const xr = parseInt(activeInputs[1].value, 10);
                const yt = parseInt(activeInputs[2].value, 10);
                const xl = parseInt(activeInputs[3].value, 10);
                const yb = parseInt(activeInputs[4].value, 10);
                if ([p, xr, yt, xl, yb].every(v => Number.isFinite(v))) {
                    lastDrawn = { page: p, position: [[xr, yt], [xl, yb]] };
                    currentPage = p;
                }
            }
            // Clear any previous temp preview immediately (from prior open)
            try { (() => { const dims = getCanvasCssDimensions(); drawCtx.clearRect(0, 0, dims.width, dims.height); })(); listEl.innerHTML = ''; } catch {}
            collected = [];

            async function loadPdfFromFile(file, key){
                const buf = await file.arrayBuffer();
                // Save PDF to IndexedDB for persistence (await to ensure it completes)
                await savePdfToStorage(key, buf);
                
                // Suppress PDF.js warnings (fake worker, cross-origin) - expected when using file:// protocol
                const originalWarn = console.warn;
                const originalError = console.error;
                console.warn = function(...args) {
                    const message = args.join(' ');
                    // Suppress PDF.js warnings
                    if (!message.includes('Setting up fake worker') && !message.includes('cross-origin')) {
                        originalWarn.apply(console, args);
                    }
                };
                console.error = function(...args) {
                    const message = args.join(' ');
                    // Suppress PDF.js cross-origin errors
                    if (!message.includes('cross-origin') && !message.includes('Refused to')) {
                        originalError.apply(console, args);
                    }
                };
                
                const pdfjs = await import('https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.4.168/pdf.min.mjs');
                // Set worker source - PDF.js will automatically fall back to fake worker
                // if cross-origin restrictions prevent loading (e.g., file:// protocol)
                pdfjs.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.4.168/pdf.worker.min.mjs';
                const doc = await pdfjs.getDocument({ data: buf }).promise;
                
                // Restore original console methods after a short delay to allow PDF.js to initialize
                setTimeout(() => {
                    console.warn = originalWarn;
                    console.error = originalError;
                }, 500);
                store.docs[key].pdfDoc = doc;
                store.docs[key].totalPages = doc.numPages;
                // Preserve saved state if it exists and is valid, otherwise use hint or default
                if (!store.docs[key].currentPage || store.docs[key].currentPage < 1 || store.docs[key].currentPage > doc.numPages) {
                    store.docs[key].currentPage = Math.min(Math.max((lastDrawn?.page) || (parseInt(hintPage,10)||1),1), doc.numPages);
                }
                // Preserve saved scale if it exists and is valid, otherwise use default
                if (!store.docs[key].scale || store.docs[key].scale <= 0) {
                    store.docs[key].scale = 1.2;
                }
                // Preserve saved scroll positions if they exist
                // (scroll positions are preserved automatically since we don't overwrite them here)
                
                // Update main viewer if it exists (regardless of visibility or source)
                const state = window.__mainPdfViewer;
                if (state) {
                    const sourceKey = key === 'text' ? 'textbook' : 'guide';
                    
                    // If this is a main form upload (from PDF viewer buttons), ensure we update
                    const isMainFormUpload = (window.__embeddedBboxTarget && window.__embeddedBboxTarget.isMainFormUpload) || false;
                    
                    // Only update the main viewer if this is a main form upload
                    // When opened from Draw button, don't affect the main viewer at all
                    if (isMainFormUpload) {
                        // If source doesn't match but it's a main form upload, switch source
                        if (isMainFormUpload && state.source !== sourceKey) {
                            state.source = sourceKey;
                            state.lastSyncedPage = null;
                            state.lastSyncedSource = null;
                            
                            // Update toggle button states
                            if (state.elements && state.elements.sourceToggle) {
                                if (state.elements.sourceToggle.textbook) {
                                    state.elements.sourceToggle.textbook.classList.toggle('active', sourceKey === 'textbook');
                                }
                                if (state.elements.sourceToggle.guide) {
                                    state.elements.sourceToggle.guide.classList.toggle('active', sourceKey === 'guide');
                                }
                            }
                        }
                        
                        state.pdfDoc = doc;
                        state.totalPages = doc.numPages;
                        state.currentPage = store.docs[key].currentPage || 1;
                        state.scale = scale || 1.0;
                        // Clear last rendered state when PDF document changes to force render
                        state._lastRenderedState = null;
                        
                        // Always try to render if viewer is visible
                        if (state.visible) {
                            if (state.canvas && state.context) {
                                updatePdfControls();
                                renderMainPdfPage();
                            } else {
                                // Canvas not ready yet, wait a bit
                                setTimeout(() => {
                                    if (state.canvas && state.context) {
                                        updatePdfControls();
                                        renderMainPdfPage();
                                    }
                                }, 200);
                            }
                        }
                    }
                }
                
                return doc;
            }
            textFileInput.onchange = async (e) => { 
                const f=e.target.files&&e.target.files[0]; 
                if(!f) return; 
                
                if ((collected.length > 0 || lastDrawn) && !confirm('You have unsaved bounding boxes. Loading a new PDF will clear them. Are you sure?')) {
                    e.target.value = ''; // Reset file input
                    return;
                }
                
                // NOTE: We don't save state here - the scroll listener and persistView handle all saves
                // State is always saved to MODAL_SESSION_KEY, not the uploaded PDF
                
                // Clear any existing work
                if (collected.length > 0 || lastDrawn) {
                    collected = [];
                    lastDrawn = null;
                    (() => { const dims = getCanvasCssDimensions(); drawCtx.clearRect(0, 0, dims.width, dims.height); })();
                    listEl.innerHTML = '';
                }
                
                const uploadedDoc = await loadPdfFromFile(f,'text'); 
                // Update activeKey to 'text' when text PDF is loaded
                activeKey = 'text';
                if (docLabel) docLabel.textContent = 'Textbook';
                pdfDoc=store.docs.text.pdfDoc; 
                totalPages=store.docs.text.totalPages; 
                // Always use the saved values from the store for the target PDF
                currentPage=store.docs.text.currentPage || 1; 
                scale=store.docs.text.scale || 1.2; 
                if (zoomDisplay) zoomDisplay.textContent = `${Math.round(scale * 100)}%`;
                await renderPage();
                
                // If this is a main form upload, ensure main viewer refreshes
                if (uploadedDoc && isMainFormUpload) {
                    setTimeout(() => {
                        const state = window.__mainPdfViewer;
                        if (state && state.visible) {
                            loadPdfFromStore();
                        }
                    }, 100);
                }
            };
            guideFileInput.onchange = async (e) => { 
                const f=e.target.files&&e.target.files[0]; 
                if(!f) return; 
                
                if ((collected.length > 0 || lastDrawn) && !confirm('You have unsaved bounding boxes. Loading a new PDF will clear them. Are you sure?')) {
                    e.target.value = ''; // Reset file input
                    return;
                }
                
                // NOTE: We don't save state here - the scroll listener and persistView handle all saves
                // State is always saved to MODAL_SESSION_KEY, not the uploaded PDF
                
                // Clear any existing work
                if (collected.length > 0 || lastDrawn) {
                    collected = [];
                    lastDrawn = null;
                    (() => { const dims = getCanvasCssDimensions(); drawCtx.clearRect(0, 0, dims.width, dims.height); })();
                    listEl.innerHTML = '';
                }
                
                const uploadedDoc = await loadPdfFromFile(f,'guide'); 
                // Update activeKey to 'guide' when guide PDF is loaded
                activeKey = 'guide';
                if (docLabel) docLabel.textContent = 'Answers';
                pdfDoc=store.docs.guide.pdfDoc; 
                totalPages=store.docs.guide.totalPages; 
                // Always use the saved values from the store for the target PDF
                currentPage=store.docs.guide.currentPage || 1; 
                scale=store.docs.guide.scale || 1.2; 
                updateZoomDisplay();
                await renderPage();
                
                // If this is a main form upload, ensure main viewer refreshes
                if (uploadedDoc && isMainFormUpload) {
                    setTimeout(() => {
                        const state = window.__mainPdfViewer;
                        if (state && state.visible) {
                            loadPdfFromStore();
                        }
                    }, 100);
                }
            };

            function getCanvasPoint(evt) {
                const rect = drawCanvas.getBoundingClientRect();
                // Get device pixel ratio (must match the one used in renderPage)
                const dpr = window.devicePixelRatio || 1;
                // Canvas internal dimensions are multiplied by dpr, but we want CSS-space coordinates
                // since the context is scaled by dpr
                const scaleX = (drawCanvas.width / dpr) / rect.width;
                const scaleY = (drawCanvas.height / dpr) / rect.height;
                // account for scroll inside container
                const wrapRect = canvasWrap.getBoundingClientRect();
                const offsetX = rect.left - wrapRect.left;
                const offsetY = rect.top - wrapRect.top;
                const x = (evt.clientX - rect.left) * scaleX;
                const y = (evt.clientY - rect.top) * scaleY;
                return { x, y };
            }

            function getCanvasCssDimensions() {
                // Return stored CSS dimensions if available, otherwise calculate from canvas
                if (canvasCssWidth > 0 && canvasCssHeight > 0) {
                    return { width: canvasCssWidth, height: canvasCssHeight };
                }
                // Fallback: calculate from canvas dimensions and devicePixelRatio
                const dpr = window.devicePixelRatio || 1;
                return {
                    width: drawCanvas.width / dpr,
                    height: drawCanvas.height / dpr
                };
            }

            async function renderPage() {
                    const page = await pdfDoc.getPage(currentPage);
                    const viewport = page.getViewport({ scale });
                const width = Math.floor(viewport.width);
                const height = Math.floor(viewport.height);
                
                // Get device pixel ratio for high-DPI rendering (ensures 100% quality at all zoom levels)
                const dpr = window.devicePixelRatio || 1;
                
                // Set canvas internal dimensions with devicePixelRatio for crisp rendering
                pdfCanvas.width = width * dpr;
                pdfCanvas.height = height * dpr;
                drawCanvas.width = width * dpr;
                drawCanvas.height = height * dpr;
                
                // Reset transform and scale the context to account for devicePixelRatio
                pdfCtx.setTransform(1, 0, 0, 1, 0, 0);
                pdfCtx.scale(dpr, dpr);
                drawCtx.setTransform(1, 0, 0, 1, 0, 0);
                drawCtx.scale(dpr, dpr);
                
                    drawCanvas.style.left = '0px';
                    drawCanvas.style.top = '0px';
                // Set CSS size so the wrapper can scroll (use actual display dimensions, not multiplied)
                pdfCanvas.style.width = width + 'px';
                pdfCanvas.style.height = height + 'px';
                drawCanvas.style.width = width + 'px';
                drawCanvas.style.height = height + 'px';
                    currentViewportScale = viewport.scale || scale;
                    
                // Store CSS-space dimensions for use in clearRect operations
                canvasCssWidth = width;
                canvasCssHeight = height;
                
                // Create scaled viewport for rendering (viewport is already at the correct scale)
                const renderContext = { canvasContext: pdfCtx, viewport };
                await page.render(renderContext).promise;
                    pageNumEl.textContent = String(currentPage);
                    pageCountEl.textContent = String(totalPages);
                    gotoInput.value = String(currentPage);
                    if (zoomDisplay) zoomDisplay.textContent = `${Math.round(scale * 100)}%`;
                // Clear using CSS-space dimensions since context is scaled by dpr
                drawCtx.clearRect(0, 0, canvasCssWidth, canvasCssHeight);
                    listEl.innerHTML = '';
                    if (lastDrawn) paintTemp(lastDrawn);
                    // Re-list any collected boxes for this page
                    (collected || []).filter(b=>b.page===currentPage).forEach(b=> appendListItem(b));
                
                // Restore scroll position after rendering
                // Use percentage-based restoration to work correctly across different zoom levels
                // CRITICAL: Restore from MODAL_SESSION_KEY, not activeKey
                // Use double requestAnimationFrame to ensure layout is complete
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        if (canvasWrap && store.docs[MODAL_SESSION_KEY]) {
                            // Priority 1: If there's an existing bbox to jump to, scroll to it (overrides saved state)
                            if (store.docs[MODAL_SESSION_KEY]._jumpToBbox) {
                                const bbox = store.docs[MODAL_SESSION_KEY]._jumpToBbox;
                                // Bbox coordinates are in PDF space: x0,y0 is top-right, x1,y1 is bottom-left
                                // Convert to canvas coordinates using currentViewportScale
                                const x0Canvas = bbox.x0 * currentViewportScale;
                                const y0Canvas = bbox.y0 * currentViewportScale;
                                const x1Canvas = bbox.x1 * currentViewportScale;
                                const y1Canvas = bbox.y1 * currentViewportScale;
                                
                                // Calculate center of bbox in canvas coordinates
                                const centerX = (x0Canvas + x1Canvas) / 2;
                                const centerY = (y0Canvas + y1Canvas) / 2;
                                
                                // Calculate scroll position to center the bbox in viewport
                                const viewportWidth = canvasWrap.clientWidth;
                                const viewportHeight = canvasWrap.clientHeight;
                                const scrollLeft = Math.max(0, centerX - viewportWidth / 2);
                                const scrollTop = Math.max(0, centerY - viewportHeight / 2);
                                
                                canvasWrap.scrollLeft = scrollLeft;
                                canvasWrap.scrollTop = scrollTop;
                                
                                // Update saved scroll position to match the bbox location
                                const scrollWidth = canvasWrap.scrollWidth - canvasWrap.clientWidth;
                                const scrollHeight = canvasWrap.scrollHeight - canvasWrap.clientHeight;
                                if (scrollWidth > 0) {
                                    store.docs[MODAL_SESSION_KEY].scrollLeftPercent = scrollLeft / scrollWidth;
                                }
                                if (scrollHeight > 0) {
                                    store.docs[MODAL_SESSION_KEY].scrollTopPercent = scrollTop / scrollHeight;
                                }
                                store.docs[MODAL_SESSION_KEY].scrollLeft = scrollLeft;
                                store.docs[MODAL_SESSION_KEY].scrollTop = scrollTop;
                                
                                // Clear the jump flag
                                delete store.docs[MODAL_SESSION_KEY]._jumpToBbox;
                            } else {
                                // Priority 2: Try to restore using percentage first (zoom-independent)
                                if (store.docs[MODAL_SESSION_KEY].scrollLeftPercent !== undefined || store.docs[MODAL_SESSION_KEY].scrollTopPercent !== undefined) {
                                    const scrollWidth = canvasWrap.scrollWidth - canvasWrap.clientWidth;
                                    const scrollHeight = canvasWrap.scrollHeight - canvasWrap.clientHeight;
                                    if (scrollWidth > 0 && store.docs[MODAL_SESSION_KEY].scrollLeftPercent !== undefined) {
                                        canvasWrap.scrollLeft = store.docs[MODAL_SESSION_KEY].scrollLeftPercent * scrollWidth;
                                    }
                                    if (scrollHeight > 0 && store.docs[MODAL_SESSION_KEY].scrollTopPercent !== undefined) {
                                        canvasWrap.scrollTop = store.docs[MODAL_SESSION_KEY].scrollTopPercent * scrollHeight;
                                    }
                                } else if (store.docs[MODAL_SESSION_KEY].scrollLeft !== undefined || store.docs[MODAL_SESSION_KEY].scrollTop !== undefined) {
                                    // Fallback to absolute values if percentages not available
                                    canvasWrap.scrollLeft = store.docs[MODAL_SESSION_KEY].scrollLeft || 0;
                                    canvasWrap.scrollTop = store.docs[MODAL_SESSION_KEY].scrollTop || 0;
                                }
                            }
                        }
                    });
                });
            }

            function normalizeToTRBL(x1,y1,x2,y2){
                const top=Math.min(y1,y2); const bottom=Math.max(y1,y2);
                const right=Math.max(x1,x2); const left=Math.min(x1,x2);
                return { top:Math.round(top), bottom:Math.round(bottom), right:Math.round(right), left:Math.round(left) };
            }

            function getCanvasRectFromLastDrawn(){
                if (!lastDrawn) return null;
                const [[xRight,yTop],[xLeft,yBottom]] = lastDrawn.position;
                const sx = currentViewportScale;
                const left = xLeft*sx, right = xRight*sx, top = yTop*sx, bottom = yBottom*sx;
                return normalizeToTRBL(right, top, left, bottom);
            }

            function hitTestHandles(cx, cy){
                const r = getCanvasRectFromLastDrawn();
                if (!r) return null;
                const size = 10, half = size/2;
                const handles = [
                    {name:'nw', x:r.left, y:r.top},
                    {name:'ne', x:r.right, y:r.top},
                    {name:'se', x:r.right, y:r.bottom},
                    {name:'sw', x:r.left, y:r.bottom}
                ];
                for (const h of handles) {
                    if (Math.abs(cx-h.x)<=half && Math.abs(cy-h.y)<=half) return h.name;
                }
                const tol=6;
                if (Math.abs(cy-r.top)<=tol && cx>=r.left && cx<=r.right) return 'n';
                if (Math.abs(cx-r.right)<=tol && cy>=r.top && cy<=r.bottom) return 'e';
                if (Math.abs(cy-r.bottom)<=tol && cx>=r.left && cx<=r.right) return 's';
                if (Math.abs(cx-r.left)<=tol && cy>=r.top && cy<=r.bottom) return 'w';
                return null;
            }

            function pointInBody(cx, cy){
                const r = getCanvasRectFromLastDrawn();
                if (!r) return false;
                return cx>=r.left && cx<=r.right && cy>=r.top && cy<=r.bottom;
            }

            function updateCursor(e){
                const {x,y}=getCanvasPoint(e);
                let cursor = 'crosshair';
                if (lastDrawn){
                    const h = hitTestHandles(x,y);
                    if (h){
                        const map={nw:'nwse-resize', se:'nwse-resize', ne:'nesw-resize', sw:'nesw-resize', n:'ns-resize', s:'ns-resize', e:'ew-resize', w:'ew-resize'};
                        cursor = map[h] || cursor;
                    } else if (pointInBody(x,y)) {
                        cursor = 'move';
                    }
                }
                drawCanvas.style.cursor = cursor;
            }

            function startDrawing(e){
                // Begin edit if clicking on existing rect
                if (lastDrawn){
                    const {x,y}=getCanvasPoint(e);
                    const h = hitTestHandles(x,y);
                    if (h){ isEditing=true; editMode=h; editStart={x,y}; editStartBBox=JSON.parse(JSON.stringify(lastDrawn)); return; }
                    if (pointInBody(x,y)){ isEditing=true; editMode='move'; editStart={x,y}; editStartBBox=JSON.parse(JSON.stringify(lastDrawn)); return; }
                }
                if (!isDrawing) return; const {x,y}=getCanvasPoint(e); dragStart={x,y};
            }
            function drawMove(e){
                updateCursor(e);
                if (isEditing && lastDrawn && editStart && editMode){
                    const {x,y}=getCanvasPoint(e);
                    const dx=(x-editStart.x)/currentViewportScale;
                    const dy=(y-editStart.y)/currentViewportScale;
                    const src=editStartBBox;
                    let [xr, yt] = src.position[0];
                    let [xl, yb] = src.position[1];
                    const minSize=10; // Minimum bbox size in PDF units
                    
                    if (editMode==='move'){
                        xr=Math.round(xr+dx); xl=Math.round(xl+dx);
                        yt=Math.round(yt+dy); yb=Math.round(yb+dy);
                    } else {
                        // Apply deltas based on which handle is being dragged
                        if (editMode.includes('n')) yt=Math.round(yt+dy);
                        if (editMode.includes('s')) yb=Math.round(yb+dy);
                        if (editMode.includes('e')) xr=Math.round(xr+dx);
                        if (editMode.includes('w')) xl=Math.round(xl+dx);
                        
                        // Prevent horizontal inversion: ensure xr (right) > xl (left) with minimum size
                        if (xr <= xl + minSize) {
                            if (editMode.includes('e')) {
                                xr = xl + minSize; // Don't let right edge go past left + minSize
                            } else if (editMode.includes('w')) {
                                xl = xr - minSize; // Don't let left edge go past right - minSize
                            }
                        }
                        
                        // Prevent vertical inversion: ensure yb (bottom) > yt (top) with minimum size
                        if (yb <= yt + minSize) {
                            if (editMode.includes('s')) {
                                yb = yt + minSize; // Don't let bottom edge go above top + minSize
                            } else if (editMode.includes('n')) {
                                yt = yb - minSize; // Don't let top edge go below bottom - minSize
                            }
                        }
                        
                        // Additional safety: normalize coordinates to ensure correct format
                        // This catches any edge cases where corners might still cross
                        const normalized = normalizeBboxCoordinates(xr, yt, xl, yb);
                        if (normalized) {
                            xr = normalized.x0;
                            yt = normalized.y0;
                            xl = normalized.x1;
                            yb = normalized.y1;
                        }
                    }
                    lastDrawn = { page: currentPage, position: [[xr, yt], [xl, yb]] };
                    paintTemp(lastDrawn);
                    return;
                }
                if (!isDrawing || !dragStart) return; const {x,y}=getCanvasPoint(e); const dims = getCanvasCssDimensions(); drawCtx.clearRect(0,0,dims.width, dims.height); const n=normalizeToTRBL(dragStart.x,dragStart.y,x,y); const left=n.left, top=n.top, right=n.right, bottom=n.bottom; drawCtx.setLineDash([6,4]); drawCtx.strokeStyle='#a78bfa'; drawCtx.lineWidth=2; drawCtx.strokeRect(left,top,right-left,bottom-top); drawCtx.setLineDash([]);
            }
            function endDrawing(e){ 
                if (isEditing){ 
                    isEditing=false; 
                    editMode=null; 
                    editStart=null; 
                    editStartBBox=null; 
                    return; 
                } 
                if (!isDrawing || !dragStart) return; 
                const {x,y}=getCanvasPoint(e); 
                const n=normalizeToTRBL(dragStart.x,dragStart.y,x,y); 
                dragStart=null; 
                
                // Enforce minimum bbox size (10 pixels in canvas space)
                const minCanvasSize = 10;
                if ((n.right-n.left)<minCanvasSize || (n.bottom-n.top)<minCanvasSize) {
                    return;
                }
                
                const inv=1/currentViewportScale; 
                const xr = Math.round(n.right*inv);
                const yt = Math.round(n.top*inv);
                const xl = Math.round(n.left*inv);
                const yb = Math.round(n.bottom*inv);
                
                // Ensure minimum size in PDF units (at least 10 units)
                const minPdfSize = 10;
                if ((xr - xl) < minPdfSize || (yb - yt) < minPdfSize) {
                    return;
                }
                
                lastDrawn = { page: currentPage, position: [[xr, yt], [xl, yb]] }; 
                paintTemp(lastDrawn);
            }

            function paintTemp(bbox){
                const dims = getCanvasCssDimensions();
                drawCtx.clearRect(0, 0, dims.width, dims.height);
                const sx = currentViewportScale;
                const left = Math.round(bbox.position[1][0] * sx);
                const top = Math.round(bbox.position[0][1] * sx);
                const right = Math.round(bbox.position[0][0] * sx);
                const bottom = Math.round(bbox.position[1][1] * sx);
                // Main rect
                drawCtx.strokeStyle = '#22c55e';
                drawCtx.lineWidth = 2;
                drawCtx.strokeRect(left, top, right-left, bottom-top);
                drawCtx.fillStyle = '#22c55e33';
                drawCtx.fillRect(left, top, right-left, bottom-top);
                // Corner handles
                const size=10, half=size/2;
                drawCtx.fillStyle = '#22c55e';
                const corners=[{x:left,y:top},{x:right,y:top},{x:right,y:bottom},{x:left,y:bottom}];
                corners.forEach(c=> drawCtx.fillRect(c.x-half, c.y-half, size, size));
                // list
                listEl.innerHTML = '';
                const item = document.createElement('div');
                item.className = 'bbox-item';
                const code = document.createElement('code');
                code.textContent = JSON.stringify(bbox);
                item.appendChild(code);
                listEl.appendChild(item);
            }

            function setCoords(xBase,yBase){ if (!Number.isFinite(xBase)||!Number.isFinite(yBase)) { coordsDisplay.textContent=''; return; } coordsDisplay.textContent = `(${Math.round(xBase)}, ${Math.round(yBase)})`; }

            // Rebind handlers fresh each time (avoid duplicates across openings)
            drawCanvas.onmousedown = startDrawing;
            drawCanvas.onmousemove = (e)=>{ drawMove(e); const {x,y}=getCanvasPoint(e); const inv=1/currentViewportScale; setCoords(x*inv, y*inv); };
            if (window.__bboxMouseUp) window.removeEventListener('mouseup', window.__bboxMouseUp);
            window.__bboxMouseUp = endDrawing;
            window.addEventListener('mouseup', window.__bboxMouseUp);
            drawCanvas.onmouseleave = ()=> setCoords();
            pdfCanvas.onmousemove = (e)=>{ const rect=pdfCanvas.getBoundingClientRect(); const dpr = window.devicePixelRatio || 1; const scaleX=(pdfCanvas.width/dpr)/rect.width; const scaleY=(pdfCanvas.height/dpr)/rect.height; const cx=(e.clientX-rect.left)*scaleX; const cy=(e.clientY-rect.top)*scaleY; const inv=1/currentViewportScale; setCoords(cx*inv, cy*inv); };
            pdfCanvas.onmouseleave = ()=> setCoords();

            function persistView(){ 
                // CRITICAL: Save to MODAL_SESSION_KEY, not activeKey
                // When opened from Draw button (not main form upload), we need to preserve the main viewer's state
                // So we save the modal's state but don't overwrite the main viewer's saved state
                if (!isMainFormUpload && savedMainViewerState) {
                    // Save modal state to a temporary location, not the main store
                    // We'll restore the main viewer's state when closing
                    if (!store.docs[MODAL_SESSION_KEY]._modalState) {
                        store.docs[MODAL_SESSION_KEY]._modalState = {};
                    }
                    store.docs[MODAL_SESSION_KEY]._modalState.currentPage = currentPage;
                    store.docs[MODAL_SESSION_KEY]._modalState.scale = scale;
                    if (canvasWrap) {
                        const scrollWidth = canvasWrap.scrollWidth - canvasWrap.clientWidth;
                        const scrollHeight = canvasWrap.scrollHeight - canvasWrap.clientHeight;
                        if (scrollWidth > 0) {
                            store.docs[MODAL_SESSION_KEY]._modalState.scrollLeftPercent = canvasWrap.scrollLeft / scrollWidth;
                        }
                        if (scrollHeight > 0) {
                            store.docs[MODAL_SESSION_KEY]._modalState.scrollTopPercent = canvasWrap.scrollTop / scrollHeight;
                        }
                        store.docs[MODAL_SESSION_KEY]._modalState.scrollLeft = canvasWrap.scrollLeft;
                        store.docs[MODAL_SESSION_KEY]._modalState.scrollTop = canvasWrap.scrollTop;
                    }
                } else {
                    // Normal save for main form uploads - save directly to store
                    store.docs[MODAL_SESSION_KEY].currentPage=currentPage; 
                    store.docs[MODAL_SESSION_KEY].scale=scale; 
                    // Save scroll position as percentage for zoom-independent restoration
                    if (canvasWrap) {
                        const scrollWidth = canvasWrap.scrollWidth - canvasWrap.clientWidth;
                        const scrollHeight = canvasWrap.scrollHeight - canvasWrap.clientHeight;
                        if (scrollWidth > 0) {
                            store.docs[MODAL_SESSION_KEY].scrollLeftPercent = canvasWrap.scrollLeft / scrollWidth;
                        }
                        if (scrollHeight > 0) {
                            store.docs[MODAL_SESSION_KEY].scrollTopPercent = canvasWrap.scrollTop / scrollHeight;
                        }
                        // Also save absolute values as backup
                        store.docs[MODAL_SESSION_KEY].scrollLeft = canvasWrap.scrollLeft;
                        store.docs[MODAL_SESSION_KEY].scrollTop = canvasWrap.scrollTop;
                    }
                }
            }
            prevBtn.onclick = async ()=>{ 
                if(!pdfDoc) return; 
                if(currentPage>1){ 
                    if (lastDrawn && !confirm('You have an unsaved bounding box. Are you sure you want to navigate away and lose it?')) {
                        return;
                    }
                    lastDrawn=null; 
                    try{ const dims = getCanvasCssDimensions(); drawCtx.clearRect(0,0,dims.width,dims.height); listEl.innerHTML=''; }catch{} 
                    currentPage--; 
                    persistView(); 
                    await renderPage(); 
                } 
            };
            nextBtn.onclick = async ()=>{ 
                if(!pdfDoc) return; 
                if(currentPage<totalPages){ 
                    if (lastDrawn && !confirm('You have an unsaved bounding box. Are you sure you want to navigate away and lose it?')) {
                        return;
                    }
                    lastDrawn=null; 
                    try{ const dims = getCanvasCssDimensions(); drawCtx.clearRect(0,0,dims.width,dims.height); listEl.innerHTML=''; }catch{} 
                    currentPage++; 
                    persistView(); 
                    await renderPage(); 
                } 
            };
            const updateZoomDisplay = () => {
                if (zoomDisplay) zoomDisplay.textContent = `${Math.round(scale * 100)}%`;
            };
            zoomInBtn.onclick = async ()=>{ if(!pdfDoc) return; scale = Math.min(scale*1.1, 8); persistView(); updateZoomDisplay(); await renderPage(); };
            zoomOutBtn.onclick = async ()=>{ if(!pdfDoc) return; scale = Math.max(scale/1.1, 0.2); persistView(); updateZoomDisplay(); await renderPage(); };
            zoomResetBtn.onclick = async ()=>{ 
                if(!pdfDoc) return; 
                if (lastDrawn && !confirm('You have an unsaved bounding box. Resetting zoom will clear it. Are you sure?')) {
                    return;
                }
                if (lastDrawn) {
                    lastDrawn = null;
                    (() => { const dims = getCanvasCssDimensions(); drawCtx.clearRect(0, 0, dims.width, dims.height); })();
                    listEl.innerHTML = '';
                }
                scale = 1.2;
                persistView(); 
                updateZoomDisplay();
                await renderPage(); 
            };
            function appendListItem(bbox){ const item=document.createElement('div'); item.className='bbox-item'; const code=document.createElement('code'); code.textContent=JSON.stringify(bbox); item.appendChild(code); listEl.appendChild(item); }
            clearBtn.onclick = ()=>{ 
                lastDrawn = null; 
                (() => { const dims = getCanvasCssDimensions(); drawCtx.clearRect(0, 0, dims.width, dims.height); })(); 
                listEl.innerHTML = ''; 
                collected = collected.filter(b=>b.page!==currentPage); 
            };
            undoBtn.onclick = ()=>{ 
                if (confirm('Are you sure you want to undo the last drawing? This will clear the current bounding box.')) {
                    lastDrawn = null; 
                    (() => { const dims = getCanvasCssDimensions(); drawCtx.clearRect(0, 0, dims.width, dims.height); })(); 
                    listEl.innerHTML = ''; 
                    collected = collected.filter(b=>b.page!==currentPage); 
                }
            };
            document.getElementById('em-add').onclick = ()=>{ 
                if(!lastDrawn) return; 
                collected.push(JSON.parse(JSON.stringify(lastDrawn))); 
                appendListItem(lastDrawn); 
                lastDrawn = null; 
                (() => { const dims = getCanvasCssDimensions(); drawCtx.clearRect(0, 0, dims.width, dims.height); })(); 
            };
            gotoBtn.onclick = async ()=>{ 
                if(!pdfDoc) return; 
                const n=parseInt(gotoInput.value,10); 
                if(!Number.isInteger(n)) return; 
                const target=Math.min(Math.max(n,1), totalPages); 
                if(target!==currentPage){ 
                    if (lastDrawn && !confirm('You have an unsaved bounding box. Are you sure you want to navigate away and lose it?')) {
                        return;
                    }
                    lastDrawn=null; 
                    try{ const dims = getCanvasCssDimensions(); drawCtx.clearRect(0,0,dims.width,dims.height); listEl.innerHTML=''; }catch{} 
                    currentPage=target; 
                    store.currentPage=currentPage; 
                    await renderPage(); 
                } 
            };
            gotoInput.addEventListener('keypress', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); gotoBtn.click(); } });
            
            // Add scroll listener to save bbox modal scroll position automatically
            // Save as percentage to work correctly across different zoom levels
            // CRITICAL: Always save to MODAL_SESSION_KEY, not activeKey (which can change)
            let scrollSaveTimeout;
            const scrollHandler = () => {
                clearTimeout(scrollSaveTimeout);
                scrollSaveTimeout = setTimeout(() => {
                    if (store.docs[MODAL_SESSION_KEY] && canvasWrap) {
                        const scrollWidth = canvasWrap.scrollWidth - canvasWrap.clientWidth;
                        const scrollHeight = canvasWrap.scrollHeight - canvasWrap.clientHeight;
                        
                        // Save as percentage of total scrollable area
                        if (scrollWidth > 0) {
                            store.docs[MODAL_SESSION_KEY].scrollLeftPercent = canvasWrap.scrollLeft / scrollWidth;
                        }
                        if (scrollHeight > 0) {
                            store.docs[MODAL_SESSION_KEY].scrollTopPercent = canvasWrap.scrollTop / scrollHeight;
                        }
                        // Also save absolute values as backup
                        store.docs[MODAL_SESSION_KEY].scrollLeft = canvasWrap.scrollLeft;
                        store.docs[MODAL_SESSION_KEY].scrollTop = canvasWrap.scrollTop;
                    }
                }, 100);
            };
            
            canvasWrap.addEventListener('scroll', scrollHandler);
            
            // Store reference for cleanup
            modal._scrollHandler = scrollHandler;
            modal._canvasWrap = canvasWrap;

            const closeModal = () => {
                // CRITICAL: Save current state to MODAL_SESSION_KEY (not activeKey which may have changed)
                // This ensures state is saved to the original PDF that opened this modal
                // When opened from Draw button, save to temporary location to avoid affecting main viewer
                if (pdfDoc && MODAL_SESSION_KEY) {
                    if (!isMainFormUpload && savedMainViewerState) {
                        // Save modal state to temporary location
                        if (!store.docs[MODAL_SESSION_KEY]._modalState) {
                            store.docs[MODAL_SESSION_KEY]._modalState = {};
                        }
                        store.docs[MODAL_SESSION_KEY]._modalState.currentPage = currentPage;
                        store.docs[MODAL_SESSION_KEY]._modalState.scale = scale;
                        if (canvasWrap) {
                            const scrollWidth = canvasWrap.scrollWidth - canvasWrap.clientWidth;
                            const scrollHeight = canvasWrap.scrollHeight - canvasWrap.clientHeight;
                            if (scrollWidth > 0) {
                                store.docs[MODAL_SESSION_KEY]._modalState.scrollLeftPercent = canvasWrap.scrollLeft / scrollWidth;
                            }
                            if (scrollHeight > 0) {
                                store.docs[MODAL_SESSION_KEY]._modalState.scrollTopPercent = canvasWrap.scrollTop / scrollHeight;
                            }
                            store.docs[MODAL_SESSION_KEY]._modalState.scrollLeft = canvasWrap.scrollLeft;
                            store.docs[MODAL_SESSION_KEY]._modalState.scrollTop = canvasWrap.scrollTop;
                        }
                    } else {
                        // Normal save for main form uploads
                        store.docs[MODAL_SESSION_KEY].currentPage = currentPage;
                        store.docs[MODAL_SESSION_KEY].scale = scale;
                        if (canvasWrap) {
                            // Save as percentage for zoom-independent restoration
                            const scrollWidth = canvasWrap.scrollWidth - canvasWrap.clientWidth;
                            const scrollHeight = canvasWrap.scrollHeight - canvasWrap.clientHeight;
                            if (scrollWidth > 0) {
                                store.docs[MODAL_SESSION_KEY].scrollLeftPercent = canvasWrap.scrollLeft / scrollWidth;
                            }
                            if (scrollHeight > 0) {
                                store.docs[MODAL_SESSION_KEY].scrollTopPercent = canvasWrap.scrollTop / scrollHeight;
                            }
                            // Also save absolute values as backup
                            store.docs[MODAL_SESSION_KEY].scrollLeft = canvasWrap.scrollLeft;
                            store.docs[MODAL_SESSION_KEY].scrollTop = canvasWrap.scrollTop;
                        }
                    }
                }
                
                // Restore main viewer's state if it was saved (only for Draw button, not main form upload)
                if (savedMainViewerState && !isMainFormUpload) {
                    const mainState = window.__mainPdfViewer;
                    if (mainState) {
                        // First, restore the store values for both textbook and guidebook to prevent cross-contamination
                        // This must be done BEFORE any source switching or loading
                        if (store.docs.text) {
                            store.docs.text.currentPage = savedMainViewerState.textCurrentPage;
                            store.docs.text.mainViewerScale = savedMainViewerState.textScale;
                            store.docs.text.mainViewerScrollLeft = savedMainViewerState.textScrollLeft;
                            store.docs.text.mainViewerScrollTop = savedMainViewerState.textScrollTop;
                        }
                        if (store.docs.guide) {
                            store.docs.guide.currentPage = savedMainViewerState.guideCurrentPage;
                            store.docs.guide.mainViewerScale = savedMainViewerState.guideScale;
                            store.docs.guide.mainViewerScrollLeft = savedMainViewerState.guideScrollLeft;
                            store.docs.guide.mainViewerScrollTop = savedMainViewerState.guideScrollTop;
                        }
                        
                        // Restore the main viewer's source if it was changed
                        // Do this after restoring store values, but use a direct approach to avoid overwriting
                        if (mainState.source !== savedMainViewerState.source) {
                            
                            // Directly set the source without using switchPdfSource to avoid saving current state
                            const oldSource = mainState.source;
                            mainState.source = savedMainViewerState.source;
                            mainState.lastSyncedPage = null;
                            mainState.lastSyncedSource = null;
                            
                            // Update toggle button states
                            if (mainState.elements && mainState.elements.sourceToggle) {
                                if (mainState.elements.sourceToggle.textbook) {
                                    mainState.elements.sourceToggle.textbook.classList.toggle('active', savedMainViewerState.source === 'textbook');
                                }
                                if (mainState.elements.sourceToggle.guide) {
                                    mainState.elements.sourceToggle.guide.classList.toggle('active', savedMainViewerState.source === 'guide');
                                }
                            }
                            
                            // Load PDF from store for the restored source (this will use our restored values)
                            if (typeof loadPdfFromStore === 'function') {
                                loadPdfFromStore();
                            }
                        }
                        
                        // Update main viewer state to match saved values
                        // Do this after a short delay to ensure loadPdfFromStore has completed
                        setTimeout(() => {
                            if (mainState.visible) {
                                const restoredKey = savedMainViewerState.key;
                                if (mainState.source === (restoredKey === 'text' ? 'textbook' : 'guide')) {
                                    // Only update and render if values actually changed
                                    const pageChanged = mainState.currentPage !== savedMainViewerState.currentPage;
                                    const scaleChanged = mainState.scale !== savedMainViewerState.scale;
                                    
                                    if (pageChanged || scaleChanged) {
                                        mainState.currentPage = savedMainViewerState.currentPage;
                                        mainState.scale = savedMainViewerState.scale;
                                        // Render the page to reflect the restored state
                                        if (mainState.canvas && mainState.context) {
                                            renderMainPdfPage();
                                            updatePdfControls();
                                        }
                                    }
                                }
                            }
                        }, 100);
                    }
                }
                
                restoreBboxModalLayout();
                window.__embeddedBboxTarget = null;
                // Clear flag to allow auto-navigation to work again
                window.__bboxModalOpen = false;
                modal.classList.remove('show');
                
                // Restore main PDF viewer scroll position
                if (window.__mainPdfScroll) {
                    const mainPdfContainer = document.getElementById('pdf-canvas-container');
                    if (mainPdfContainer) {
                        requestAnimationFrame(() => {
                            mainPdfContainer.scrollLeft = window.__mainPdfScroll.scrollLeft || 0;
                            mainPdfContainer.scrollTop = window.__mainPdfScroll.scrollTop || 0;
                        });
                    }
                    window.__mainPdfScrollSaved = false;
                }
                
                // Remove Escape and Enter key listeners when modal closes
                if (modal._escapeHandler) {
                    document.removeEventListener('keydown', modal._escapeHandler);
                    delete modal._escapeHandler;
                }
                if (modal._enterHandler) {
                    document.removeEventListener('keydown', modal._enterHandler);
                    delete modal._enterHandler;
                }
                
                // Remove scroll listener when modal closes
                if (modal._scrollHandler && modal._canvasWrap) {
                    modal._canvasWrap.removeEventListener('scroll', modal._scrollHandler);
                    delete modal._scrollHandler;
                    delete modal._canvasWrap;
                }
            };
            
            document.getElementById('em-close').onclick = closeModal;
            
            // Add Escape key handler to close modal
            const handleEscape = (e) => {
                if (e.key === 'Escape' && modal.classList.contains('show')) {
                    e.preventDefault();
                    e.stopPropagation();
                    closeModal();
                }
            };
            
            // Add Enter key handler to trigger "Use Selected" button
            const handleEnter = (e) => {
                if (e.key === 'Enter' && modal.classList.contains('show')) {
                    // Don't trigger if user is typing in an input field or textarea
                    const activeElement = document.activeElement;
                    if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA')) {
                        // Let the input handle Enter naturally
                        return;
                    }
                    // If not in an input field, trigger the confirm button
                    e.preventDefault();
                    e.stopPropagation();
                    confirmBtn.click();
                }
            };
            
            // Add event listeners when modal opens, remove when it closes
            document.addEventListener('keydown', handleEscape);
            document.addEventListener('keydown', handleEnter);
            
            // Store handler references for cleanup (will be removed when modal closes)
            modal._escapeHandler = handleEscape;
            modal._enterHandler = handleEnter;
            confirmBtn.onclick = ()=>{
                if (!window.__embeddedBboxTarget) { 
                    closeModal();
                    return; 
                }
                const target = window.__embeddedBboxTarget;
                
                // If this is opened from main form for PDF upload, refresh the main viewer and close
                if (target.isMainFormUpload) {
                    restoreBboxModalLayout();
                    window.__embeddedBboxTarget = null;
                    modal.classList.remove('show');
                    
                    // Clean up escape and enter handlers
                    if (modal._escapeHandler) {
                        document.removeEventListener('keydown', modal._escapeHandler);
                        delete modal._escapeHandler;
                    }
                    if (modal._enterHandler) {
                        document.removeEventListener('keydown', modal._enterHandler);
                        delete modal._enterHandler;
                    }
                    
                    // Refresh the main PDF viewer after upload
                    setTimeout(() => {
                        const state = window.__mainPdfViewer;
                        if (state) {
                            // Always try to load from store, even if not visible
                            const loaded = loadPdfFromStore();
                            
                            // If viewer is visible, ensure it renders
                            if (state.visible && loaded && state.canvas && state.context) {
                                renderMainPdfPage();
                            } else if (state.visible && loaded) {
                                // Wait a bit more for canvas
                                setTimeout(() => {
                                    if (state.canvas && state.context) {
                                        renderMainPdfPage();
                                    }
                                }, 300);
                            }
                        }
                    }, 300);
                    
                    return;
                }
                
                const targetRow = target.inputs && target.inputs[0] ? target.inputs[0].closest('.array-item') : null;
                const parentContainer = targetRow ? targetRow.parentElement : null;
                
                // Determine the type of bbox group to use appropriate before/after functions
                let beforeFunc = 'addContentBboxBefore';
                let afterFunc = 'addContentBboxAfter';
                let beforeTitle = 'Add BBox Before';
                let afterTitle = 'Add BBox After';
                
                // Check the form group label to determine bbox type (similar to fillBboxGroup)
                const formGroup = targetRow ? targetRow.closest('.form-group') : null;
                const labelEl = formGroup ? formGroup.querySelector('label') : null;
                const labelText = labelEl ? labelEl.textContent : '';
                
                if (labelText.includes('Question Images')) {
                    beforeFunc = 'addQuestionImageBefore';
                    afterFunc = 'addQuestionImageAfter';
                    beforeTitle = 'Add Image Before';
                    afterTitle = 'Add Image After';
                } else if (labelText.includes('Answer Images')) {
                    beforeFunc = 'addAnswerImageBefore';
                    afterFunc = 'addAnswerImageAfter';
                    beforeTitle = 'Add Image Before';
                    afterTitle = 'Add Image After';
                } else if (labelText.includes('Section Images')) {
                    beforeFunc = 'addContentImageBefore';
                    afterFunc = 'addContentImageAfter';
                    beforeTitle = 'Add Image Before';
                    afterTitle = 'Add Image After';
                }
                
                const boxes = [...(collected||[])];
                if (lastDrawn) boxes.push(lastDrawn);
                if (boxes.length === 0) { 
                    closeModal();
                    return; 
                }
                // Fill first into current row
                const first = boxes.shift();
                let [[fxr,fyt],[fxl,fyb]] = first.position;
                
                // Normalize coordinates before filling
                const normalized = normalizeBboxCoordinates(fxr, fyt, fxl, fyb);
                if (normalized) {
                    fxr = normalized.x0;
                    fyt = normalized.y0;
                    fxl = normalized.x1;
                    fyb = normalized.y1;
                }
                
                target.inputs[0].value = first.page || '';
                target.inputs[1].value = fxr; target.inputs[2].value = fyt; target.inputs[3].value = fxl; target.inputs[4].value = fyb;
                // For remaining, create new rows in same group and fill
                if (parentContainer) {
                    boxes.forEach(b => {
                        let [[xr,yt],[xl,yb]] = b.position;
                        
                        // Normalize coordinates before filling
                        const bNormalized = normalizeBboxCoordinates(xr, yt, xl, yb);
                        if (bNormalized) {
                            xr = bNormalized.x0;
                            yt = bNormalized.y0;
                            xl = bNormalized.x1;
                            yb = bNormalized.y1;
                        }
                        
                        const newItem = buildBBoxRow({
                            values: {
                                page: b.page || '',
                                x0: xr,
                                y0: yt,
                                x1: xl,
                                y1: yb
                            },
                            beforeHandler: beforeFunc,
                            afterHandler: afterFunc,
                            buttonOrder: 'reorderFirst'
                        });
                        
                        parentContainer.appendChild(newItem);
                        
                        // Finalize the bbox row (validation + font settings)
                        finalizeBBoxRow(newItem);
                    });
                }
                
                // Mark form as changed and trigger auto-save after coordinates are filled
                markFormAsChanged();
                triggerAutoSave();
                
                closeModal();
                // Use Selected updates bbox inputs programmatically, so input/change and MutationObserver
                // never fire; trigger preview refresh so live + final preview show the new crop.
                if (typeof scheduleBboxRefresh === 'function') scheduleBboxRefresh();
            };
            cancelBtn.onclick = ()=>{
                if (collected.length > 0 || lastDrawn) {
                    if (confirm('You have unsaved bounding boxes. Are you sure you want to cancel and lose your work?')) {
                        closeModal();
                    }
                } else {
                    closeModal();
                }
            };

            // PDFs should already be loaded from IndexedDB on page initialization
            // If a PDF is already loaded, render immediately (respect hint page if provided)
            if (!pdfDoc) { 
                // Use the PDF that matches MODAL_SESSION_KEY (the PDF that opened this modal)
                if (store.docs[MODAL_SESSION_KEY].pdfDoc) {
                    // Use the PDF that matches the requested MODAL_SESSION_KEY
                    pdfDoc = store.docs[MODAL_SESSION_KEY].pdfDoc; 
                    totalPages = store.docs[MODAL_SESSION_KEY].totalPages; 
                } else if (store.docs.text.pdfDoc && MODAL_SESSION_KEY === 'text') {
                    // Fallback: if text was requested but not found, use text if available
                    pdfDoc = store.docs.text.pdfDoc; 
                    totalPages = store.docs.text.totalPages; 
                } else if (store.docs.guide.pdfDoc && MODAL_SESSION_KEY === 'guide') {
                    // Fallback: if guide was requested but not found, use guide if available
                    pdfDoc = store.docs.guide.pdfDoc; 
                    totalPages = store.docs.guide.totalPages; 
                }
            }
            
            if (pdfDoc) {
                // Check if there are existing bbox values in the inputs - if so, jump to them
                let hasExistingBbox = false;
                let bboxPage = null;
                let bboxCoords = null;
                
                if (activeInputs && activeInputs.length >= 5) {
                    const pageVal = activeInputs[0].value ? parseInt(activeInputs[0].value, 10) : null;
                    const x0Val = activeInputs[1].value ? parseFloat(activeInputs[1].value) : null;
                    const y0Val = activeInputs[2].value ? parseFloat(activeInputs[2].value) : null;
                    const x1Val = activeInputs[3].value ? parseFloat(activeInputs[3].value) : null;
                    const y1Val = activeInputs[4].value ? parseFloat(activeInputs[4].value) : null;
                    
                    // Check if all bbox values are present and valid
                    if (Number.isFinite(pageVal) && pageVal > 0 && 
                        Number.isFinite(x0Val) && Number.isFinite(y0Val) && 
                        Number.isFinite(x1Val) && Number.isFinite(y1Val)) {
                        hasExistingBbox = true;
                        bboxPage = pageVal;
                        bboxCoords = { x0: x0Val, y0: y0Val, x1: x1Val, y1: y1Val };
                    }
                }
                
                if (hasExistingBbox && bboxPage && pdfDoc) {
                    // Override saved state with bbox values
                    currentPage = Math.min(Math.max(bboxPage, 1), totalPages || bboxPage);
                    store.docs[MODAL_SESSION_KEY].currentPage = currentPage;
                    
                    // Calculate optimal zoom to fit bbox in viewport
                    try {
                        const page = await pdfDoc.getPage(currentPage);
                        const defaultViewport = page.getViewport({ scale: 1.0 });
                        
                        // Bbox coordinates: x0,y0 is top-right, x1,y1 is bottom-left
                        // Calculate bbox dimensions in PDF space
                        const bboxWidth = Math.abs(bboxCoords.x0 - bboxCoords.x1);
                        const bboxHeight = Math.abs(bboxCoords.y0 - bboxCoords.y1);
                        
                        // Get viewport dimensions - use modal dimensions or reasonable defaults
                        // The modal is visible at this point, so we can get its dimensions
                        let viewportWidth = canvasWrap.clientWidth;
                        let viewportHeight = canvasWrap.clientHeight;
                        
                        // If dimensions aren't available yet, use modal container or defaults
                        if (!viewportWidth || !viewportHeight) {
                            const modalContent = document.querySelector('.bbox-content');
                            if (modalContent) {
                                viewportWidth = modalContent.clientWidth - 360; // Account for sidebar (340px + gap)
                                viewportHeight = window.innerHeight * 0.7; // Use 70% of viewport height
                            } else {
                                // Fallback to reasonable defaults
                                viewportWidth = 800;
                                viewportHeight = 600;
                            }
                        }
                        
                        const padding = 40; // Padding around bbox
                        const availableWidth = Math.max(viewportWidth - (padding * 2), 200);
                        const availableHeight = Math.max(viewportHeight - (padding * 2), 200);
                        
                        // Calculate optimal scale to fit bbox with padding
                        const scaleX = availableWidth / bboxWidth;
                        const scaleY = availableHeight / bboxHeight;
                        // Use the smaller scale to ensure bbox fits entirely
                        const optimalScale = Math.min(scaleX, scaleY, 8.0); // Cap at 8x zoom
                        // Ensure minimum zoom level
                        scale = Math.max(optimalScale, 0.5);
                        
                        // Store bbox coords for centering calculation after render
                        store.docs[MODAL_SESSION_KEY]._jumpToBbox = bboxCoords;
                        // Update scale in store
                        store.docs[MODAL_SESSION_KEY].scale = scale;
                    } catch (error) {
                        console.error('Error calculating optimal zoom:', error);
                        // Fallback to saved scale if calculation fails
                        scale = store.docs[MODAL_SESSION_KEY].scale || 1.2;
                        store.docs[MODAL_SESSION_KEY]._jumpToBbox = bboxCoords;
                    }
                    
                    // Render page with optimal zoom, then center bbox
                    await renderPage();
                    // Centering will be handled in renderPage after canvas is rendered
                } else {
                    // ALWAYS load saved state from the store for MODAL_SESSION_KEY
                    // This ensures we get the correct zoom/scroll for the PDF that opened this modal
                    currentPage = store.docs[MODAL_SESSION_KEY].currentPage || 1;
                    scale = store.docs[MODAL_SESSION_KEY].scale || 1.2;
                    
                    // Only override saved page if we have a hint or lastDrawn (for navigation purposes)
                    const desiredOpen = (lastDrawn?.page) || (hintPage ? parseInt(hintPage,10) : null);
                    if (Number.isFinite(desiredOpen)) {
                        const bounded = Math.min(Math.max(desiredOpen||1,1), totalPages||desiredOpen||1);
                        currentPage = bounded;
                        // Update store with the new page, but keep the saved scale/scroll
                        store.docs[MODAL_SESSION_KEY].currentPage = currentPage;
                    }
                    // Render with the loaded state (saved zoom/scroll will be restored in renderPage)
                    renderPage();
                }
            }
        }

        // Helper function to find duplicate values in an array
        function findDuplicates(arr) {
            const duplicates = [];
            const seen = new Set();
            
            arr.forEach(item => {
                if (seen.has(item)) {
                    if (!duplicates.includes(item)) {
                        duplicates.push(item);
                    }
                } else {
                    seen.add(item);
                }
            });
            
            return duplicates;
        }

        // Validate that tables have matching image bbox entries
        function validateTableImageReferences(jsonData) {
            const errors = [];
            
            // Check for tables in content sections
            if (jsonData.instructional_content) {
                jsonData.instructional_content.forEach((content, index) => {
                    
                    if (content.text && content.text.includes('|')) {
                        const tableImageIndices = extractTableImageIndices(content.text);
                        
                        const contentImageIndices = new Set();
                        
                        // Get image indices from this content section's image bboxes
                        if (content.images && content.images.length > 0) {
                            content.images.forEach(bbox => {
                                contentImageIndices.add(bbox.page.toString());
                            });
                        }
                        
                        
                        // Check if table images match content section images (by array index)
                        tableImageIndices.forEach(imgIndex => {
                            const arrayIndex = parseInt(imgIndex);
                            
                            if (arrayIndex < 0 || arrayIndex >= content.images.length) {
                                // Check if there are any image bboxes in this section
                                if (content.images.length === 0) {
                                    errors.push(ErrorMessages.missingTableImageContent(index, imgIndex));
                                } else {
                                    errors.push(ErrorMessages.outOfRangeContent(index, imgIndex, content.images.length - 1));
                                }
                            }
                        });
                    }
                });
            }
            
            // Check for tables in questions
            if (jsonData.practice_questions) {
                jsonData.practice_questions.forEach((question, qIndex) => {
                    const questionText = question.question_text || '';
                    const guideAnswer = question.guide_answer || '';
                    const setupText = question.set_up_text || '';
                    const questionType = question.question_type || 'free_form';
                    const choices = question.choices || [];
                    
                                            // Check for duplicate indices within each image array separately
                        
                        // Setup text and question text share question_images array
                        const sharedQuestionIndices = [];
                        if (questionText.includes('|')) {
                            sharedQuestionIndices.push(...extractTableImageIndices(questionText));
                        }
                        if (setupText.includes('|')) {
                            sharedQuestionIndices.push(...extractTableImageIndices(setupText));
                        }
                        
                        // NOTE: Duplicate checking removed - handled by validateImageConsistency()
                        
                    // For MCQ: Check choices for table image references (choices share question_images)
                    // For free_form: Check guide answer for table image references
                    if ((questionType === 'multiple_choice' || questionType === 'checkbox') && choices.length > 0) {
                        // Choices share question_images with setup and question text
                        // Collect choice table indices and combine with setup/question indices
                        const allChoiceTableIndices = [];
                        choices.forEach((choice, choiceIndex) => {
                            const choiceText = choice.text || '';
                            if (choiceText.includes('|')) {
                                const choiceTableIndices = extractTableImageIndices(choiceText);
                                allChoiceTableIndices.push(...choiceTableIndices);
                            }
                        });
                        
                        // Combine with setup and question text indices
                        const combinedQuestionIndices = [...sharedQuestionIndices, ...allChoiceTableIndices];
                        
                        // NOTE: Duplicate checking removed - handled by validateImageConsistency()
                        
                        // Validate choice table indices against question_images array
                        allChoiceTableIndices.forEach(imgIndex => {
                            const arrayIndex = parseInt(imgIndex);
                            if (arrayIndex < 0 || arrayIndex >= question.question_images.length) {
                                if (question.question_images.length === 0) {
                                    errors.push(ErrorMessages.missingImageChoice(qIndex, imgIndex));
                                } else {
                                    errors.push(ErrorMessages.outOfRangeQuestion(qIndex, imgIndex, question.question_images.length - 1, true));
                                }
                            }
                        });
                    } else {
                        // Free form: Guide answer has its own guide_answer_images array
                        if (guideAnswer.includes('|')) {
                            const guideAnswerIndices = extractTableImageIndices(guideAnswer);
                            
                            // NOTE: Duplicate checking removed - handled by validateImageConsistency()
                            
                            // Validate guide answer table indices
                            guideAnswerIndices.forEach(imgIndex => {
                                const arrayIndex = parseInt(imgIndex);
                                if (arrayIndex < 0 || arrayIndex >= question.guide_answer_images.length) {
                                    if (question.guide_answer_images.length === 0) {
                                        errors.push(ErrorMessages.missingTableImageAnswer(qIndex, imgIndex));
                                    } else {
                                        errors.push(ErrorMessages.outOfRangeAnswer(qIndex, imgIndex, question.guide_answer_images.length - 1));
                                    }
                                }
                            });
                        }
                    }
                    
                    // Validate indices against their respective arrays
                    sharedQuestionIndices.forEach(imgIndex => {
                        const arrayIndex = parseInt(imgIndex);
                        if (arrayIndex < 0 || arrayIndex >= question.question_images.length) {
                            if (question.question_images.length === 0) {
                                errors.push(ErrorMessages.missingTableImageQuestion(qIndex, imgIndex));
                            } else {
                                errors.push(ErrorMessages.outOfRangeQuestion(qIndex, imgIndex, question.question_images.length - 1, false));
                            }
                        }
                    });
                });
            }
            
            return errors;
        }

        // Validate that image references in text have corresponding image bboxes
        function validateImageReferences(jsonData) {
            const errors = [];
            
            // Check content sections
            if (jsonData.instructional_content) {
                jsonData.instructional_content.forEach((content, index) => {
                    const text = content.text || '';
                    const images = content.images || [];
                    
                    if (text) {
                        // Check for both image references and table references (tables are images)
                        const { uniqueIndices } = getContentTextIndices(content);
                        
                        uniqueIndices.forEach(imgIndex => {
                            const arrayIndex = parseInt(imgIndex);
                            if (arrayIndex < 0 || arrayIndex >= images.length) {
                                // Only flag if there are no images at all, otherwise count mismatch will handle it
                                if (images.length === 0) {
                                    errors.push(ErrorMessages.missingImageContent(index, imgIndex));
                                }
                                // Skip out-of-range errors when images exist - count mismatch will handle it
                            }
                        });
                    }
                });
            }
            
            // Check practice questions
            if (jsonData.practice_questions) {
                jsonData.practice_questions.forEach((question, qIndex) => {
                    const questionImages = question.question_images || [];
                    const guideAnswerImages = question.guide_answer_images || [];
                    
                    const { uniqueQuestionIndices, uniqueGuideIndices } = getQuestionTextIndices(question);
                    
                    uniqueQuestionIndices.forEach(imgIndex => {
                        const arrayIndex = parseInt(imgIndex);
                        if (arrayIndex < 0 || arrayIndex >= questionImages.length) {
                            // Only flag if there are no images at all, otherwise count mismatch will handle it
                            if (questionImages.length === 0) {
                                errors.push(ErrorMessages.missingImageQuestion(qIndex, imgIndex));
                            }
                            // Skip out-of-range errors when images exist - count mismatch will handle it
                        }
                    });
                    
                    // Check guide answer (for both MCQ and free_form, guide_answer uses guide_answer_images)
                    {
                        // Free form: Check guide answer against guide_answer_images (including table references)
                    uniqueGuideIndices.forEach(imgIndex => {
                        const arrayIndex = parseInt(imgIndex);
                        if (arrayIndex < 0 || arrayIndex >= guideAnswerImages.length) {
                            // Only flag if there are no images at all, otherwise count mismatch will handle it
                            if (guideAnswerImages.length === 0) {
                                errors.push(ErrorMessages.missingImageAnswer(qIndex, imgIndex));
                            }
                            // Skip out-of-range errors when images exist - count mismatch will handle it
                        }
                    });
                    }
                });
            }
            
            return errors;
        }

        // Helper function to extract image indices from text
        function extractImageIndices(text) {
            const imageIndices = [];
            if (!text) return imageIndices;
            
            // Look for both formats: ![description](index) and ![]()(index)
            const regex1 = /!\[.*?\]\((\d+)\)/g;  // Standard markdown
            const regex2 = /!\[\]\((\d+)\)/g;      // Empty description
            
            let match;
            while ((match = regex1.exec(text)) !== null) {
                imageIndices.push(match[1]);
            }
            while ((match = regex2.exec(text)) !== null) {
                imageIndices.push(match[1]);
            }
            
            return imageIndices;
        }

        // Validate that image bboxes have corresponding image references in text
        function validateImageBboxes(jsonData) {
            const errors = [];
            
            // Check content sections
            if (jsonData.instructional_content) {
                jsonData.instructional_content.forEach((content, index) => {
                    const images = content.images || [];
                    
                    if (images.length > 0) {
                        const { uniqueIndices } = getContentTextIndices(content);
                        const referencedIndices = new Set(uniqueIndices);
                        
                        // Check if there are image bboxes that don't have corresponding references
                        for (let i = 0; i < images.length; i++) {
                            if (!referencedIndices.has(i)) {
                                errors.push(ErrorMessages.unusedImageContent(index, i));
                            }
                        }
                    }
                });
            }
            
            // Check practice questions
            if (jsonData.practice_questions) {
                jsonData.practice_questions.forEach((question, qIndex) => {
                    const questionImages = question.question_images || [];
                    const guideAnswerImages = question.guide_answer_images || [];
                    const questionType = question.question_type || 'free_form';
                    
                    const { uniqueQuestionIndices, uniqueGuideIndices } = getQuestionTextIndices(question);
                    
                    // Check question images against setup text, question text, and choices (for MCQ)
                    // Setup text, question text, and choices share the same question_images array
                    if (questionImages.length > 0) {
                        const referencedIndices = new Set(uniqueQuestionIndices);
                        
                        for (let i = 0; i < questionImages.length; i++) {
                            if (!referencedIndices.has(i)) {
                                errors.push(ErrorMessages.unusedImageQuestion(qIndex, i, (questionType === 'multiple_choice' || questionType === 'checkbox')));
                            }
                        }
                    }
                    
                    // Check guide answer images against guide answer (for both MCQ and free_form)
                    {
                        // Free form: Check guide answer images against guide answer (including table references)
                    if (guideAnswerImages.length > 0) {
                        const referencedIndices = new Set(uniqueGuideIndices);
                        
                        for (let i = 0; i < guideAnswerImages.length; i++) {
                            if (!referencedIndices.has(i)) {
                                errors.push(ErrorMessages.unusedImageAnswer(qIndex, i));
                                }
                            }
                        }
                    }
                });
            }
            
            return errors;
        }

        // Validate image consistency (duplicate indices and mismatched counts)
        function validateImageConsistency(jsonData) {
            const errors = [];
            
            // Check content sections
            if (jsonData.instructional_content) {
                jsonData.instructional_content.forEach((content, index) => {
                    const images = content.images || [];
                    const text = content.text || '';
                    
                    if (text) {
                        const { allIndices, uniqueIndices } = getContentTextIndices(content);
                        
                        // Check for duplicate indices within the same text
                        const duplicateIndices = findDuplicates(allIndices);
                        if (duplicateIndices.length > 0) {
                            errors.push(ErrorMessages.duplicateImagesContent(index, duplicateIndices));
                        }
                        
                        // Check for mismatched image count
                        if (uniqueIndices.length !== images.length) {
                            errors.push(ErrorMessages.countMismatchContent(index, uniqueIndices.length, images.length));
                        }
                    }
                });
            }
            
            // Check practice questions
            if (jsonData.practice_questions) {
                jsonData.practice_questions.forEach((question, qIndex) => {
                    const questionImages = question.question_images || [];
                    const guideAnswerImages = question.guide_answer_images || [];
                    const questionType = question.question_type || 'free_form';
                    
                    const { allQuestionIndices, allGuideIndices, uniqueGuideIndices } = getQuestionTextIndices(question);
                    
                    // Check for duplicates and mismatched counts based on question type
                    if (questionType === 'multiple_choice' || questionType === 'checkbox') {
                        // Get unique indices from the already extracted allQuestionIndices
                        const uniqueQuestionIndices = getUniqueIndices(allQuestionIndices);
                        
                        // Check for duplicate indices across setup, question, and choices
                        const duplicateQuestionIndices = findDuplicates(allQuestionIndices);
                        if (duplicateQuestionIndices.length > 0) {
                            errors.push(ErrorMessages.duplicateImagesQuestion(qIndex, duplicateQuestionIndices, true));
                        }
                        
                        // Check for mismatched question image count (compare unique indices with bbox count)
                        if (uniqueQuestionIndices.length !== questionImages.length) {
                            errors.push(ErrorMessages.countMismatchQuestion(qIndex, uniqueQuestionIndices.length, questionImages.length, true));
                        }
                    } else {
                        // Free form: Check setup and question text for duplicates and mismatched counts
                        const uniqueQuestionIndices = getUniqueIndices(allQuestionIndices);
                        
                        // Check for duplicate indices between setup text and question text
                        const duplicateQuestionIndices = findDuplicates(allQuestionIndices);
                        if (duplicateQuestionIndices.length > 0) {
                            errors.push(ErrorMessages.duplicateImagesQuestion(qIndex, duplicateQuestionIndices, false));
                        }
                        
                        // Check for mismatched question image count (compare unique indices with bbox count)
                        if (uniqueQuestionIndices.length !== questionImages.length) {
                            errors.push(ErrorMessages.countMismatchQuestion(qIndex, uniqueQuestionIndices.length, questionImages.length, false));
                        }
                    }
                    
                    // Check guide answer for duplicates and mismatched counts (both MCQ and free_form)
                    // Guide answer has its own guide_answer_images array
                    
                    // Check for duplicate indices within guide answer
                    const duplicateGuideAnswerIndices = findDuplicates(allGuideIndices);
                    if (duplicateGuideAnswerIndices.length > 0) {
                        errors.push(ErrorMessages.duplicateImagesAnswer(qIndex, duplicateGuideAnswerIndices));
                    }
                    
                    // Check for mismatched guide answer image count
                    if (allGuideIndices.length !== guideAnswerImages.length) {
                        errors.push(ErrorMessages.countMismatchAnswer(qIndex, allGuideIndices.length, guideAnswerImages.length));
                    }
                });
            }
            
            return errors;
        }

        // Validate image index ordering (must start from 0 and be sequential)
        function validateImageOrdering(jsonData) {
            const errors = [];
            
            // Check content sections
            if (jsonData.instructional_content) {
                jsonData.instructional_content.forEach((content, index) => {
                    const text = content.text || '';
                    const images = content.images || [];
                    
                    if (text && images.length > 0) {
                        const { allIndices, uniqueIndices } = getContentTextIndices(content);
                        const sortedIndices = [...uniqueIndices].sort((a, b) => a - b);
                        
                        // Check if indices start from 0
                        if (uniqueIndices.length > 0) {
                            if (sortedIndices[0] !== 0) {
                                errors.push(ErrorMessages.mustStartFromZeroContent(index, sortedIndices[0]));
                            }
                            
                            // Check for gaps in sequence
                            for (let i = 1; i < sortedIndices.length; i++) {
                                if (sortedIndices[i] !== sortedIndices[i-1] + 1) {
                                    errors.push(ErrorMessages.gapInSequenceContent(index, sortedIndices[i-1], sortedIndices[i]));
                                }
                            }
                            
                            // Check if indices appear in correct order in text
                            const orderedIndices = allIndices.map(idx => parseInt(idx));
                            const expectedOrder = Array.from({length: uniqueIndices.length}, (_, i) => i);
                            if (JSON.stringify(orderedIndices) !== JSON.stringify(expectedOrder)) {
                                errors.push(ErrorMessages.wrongOrderContent(index, orderedIndices));
                            }
                        }
                    }
                });
            }
            
            // Check practice questions
            if (jsonData.practice_questions) {
                jsonData.practice_questions.forEach((question, qIndex) => {
                    const questionImages = question.question_images || [];
                    const guideAnswerImages = question.guide_answer_images || [];
                    const questionType = question.question_type || 'free_form';
                    
                    const { allQuestionIndices, uniqueQuestionIndices, allGuideIndices, uniqueGuideIndices } = getQuestionTextIndices(question);
                    
                    // Check setup text, question text, and choices indices (share question_images array)
                    // For MCQ: Order is setup  question  choice1  choice2  ...
                    // For free_form: Order is setup  question
                    if (allQuestionIndices.length > 0 && questionImages.length > 0) {
                        const sortedQuestionIndices = [...uniqueQuestionIndices].sort((a, b) => a - b);
                        
                        // Check if indices start from 0 and are sequential
                        if (uniqueQuestionIndices.length > 0) {
                            if (sortedQuestionIndices[0] !== 0) {
                                errors.push(ErrorMessages.mustStartFromZeroQuestion(qIndex, sortedQuestionIndices[0]));
                            }
                            
                            // Check for gaps in sequence
                            for (let i = 1; i < sortedQuestionIndices.length; i++) {
                                if (sortedQuestionIndices[i] !== sortedQuestionIndices[i-1] + 1) {
                                    errors.push(ErrorMessages.gapInSequenceQuestion(qIndex, sortedQuestionIndices[i-1], sortedQuestionIndices[i]));
                                }
                            }
                            
                            // Check if indices appear in correct order in text (setup  question  choices)
                            const orderedQuestionIndices = allQuestionIndices.map(idx => parseInt(idx));
                            const expectedQuestionOrder = Array.from({length: uniqueQuestionIndices.length}, (_, i) => i);
                            if (JSON.stringify(orderedQuestionIndices) !== JSON.stringify(expectedQuestionOrder)) {
                                errors.push(ErrorMessages.wrongOrderQuestion(qIndex, orderedQuestionIndices, (questionType === 'multiple_choice' || questionType === 'checkbox')));
                            }
                        }
                    }
                    
                    // Check guide answer indices (has its own guide_answer_images array)
                    if (allGuideIndices.length > 0 && guideAnswerImages.length > 0) {
                        const sortedGuideAnswerIndices = [...uniqueGuideIndices].sort((a, b) => a - b);
                        
                        // Check if indices start from 0 and are sequential
                        if (uniqueGuideIndices.length > 0) {
                            if (sortedGuideAnswerIndices[0] !== 0) {
                                errors.push(ErrorMessages.mustStartFromZeroAnswer(qIndex, sortedGuideAnswerIndices[0]));
                            }
                            
                            // Check for gaps in sequence
                            for (let i = 1; i < sortedGuideAnswerIndices.length; i++) {
                                if (sortedGuideAnswerIndices[i] !== sortedGuideAnswerIndices[i-1] + 1) {
                                    errors.push(ErrorMessages.gapInSequenceAnswer(qIndex, sortedGuideAnswerIndices[i-1], sortedGuideAnswerIndices[i]));
                                }
                            }
                            
                            // Check if indices appear in correct order in text
                            const orderedGuideAnswerIndices = allGuideIndices.map(idx => parseInt(idx));
                            const expectedGuideAnswerOrder = Array.from({length: uniqueGuideIndices.length}, (_, i) => i);
                            if (JSON.stringify(orderedGuideAnswerIndices) !== JSON.stringify(expectedGuideAnswerOrder)) {
                                errors.push(ErrorMessages.wrongOrderAnswer(qIndex, orderedGuideAnswerIndices));
                            }
                        }
                    }
                });
            }
            
            return errors;
        }

        // Extract image indices from table markdown
        function extractTableImageIndices(text) {
            const imageIndices = [];
            
            // Only look for table-specific image references
            // Tables don't have their own image format - they use the same as regular images
            // This function should return empty array since tables use regular image markdown
            // The regular extractImageIndices function already handles both regular images and table images
            
            return imageIndices;
        }

        // ========== CATEGORY 1 REFACTORING: Image Index Extraction Helpers ==========
        
        /**
         * Extract all image indices from one or more text fields
         * Combines both regular image and table image extraction
         * @param {string|string[]} texts - Single text or array of texts to extract from
         * @returns {string[]} Array of all image indices (as strings)
         */
        function extractAllImageIndices(texts) {
            const allIndices = [];
            const textArray = Array.isArray(texts) ? texts : [texts];
            
            textArray.forEach(text => {
                if (text) {
                    allIndices.push(...extractImageIndices(text));
                    allIndices.push(...extractTableImageIndices(text));
                }
            });
            
            return allIndices;
        }

        /**
         * Get unique indices as integers
         * @param {string[]|number[]} indices - Array of indices (strings or numbers)
         * @returns {number[]} Sorted array of unique integer indices
         */
        function getUniqueIndices(indices) {
            const numericIndices = indices
                .map(idx => parseInt(idx, 10))
                .filter(idx => !isNaN(idx));
            return [...new Set(numericIndices)].sort((a, b) => a - b);
        }

        // ========== END CATEGORY 1 REFACTORING ==========

        // ========== CATEGORY 2 REFACTORING: Question Container Resolution ==========
        
        /**
         * Get the question container for a given element
         * Handles special case where element is inside a choice item or matching item
         * @param {HTMLElement} element - The element to find the question container for
         * @returns {HTMLElement|null} The question container element
         */
        function getQuestionContainer(element) {
            const isChoiceText = element.classList.contains('choice-text') || element.closest('.choice-item');
            const isMatchingItem = element.classList.contains('matching-item-text') || element.closest('.matching-item');
            
            if (isChoiceText) {
                // For choice texts, we need to go up to the question container, skipping the choice-item
                return element.closest('.choice-item')?.parentElement?.closest('.array-item');
            }
            
            if (isMatchingItem) {
                // For matching items, we need to go up to the question container, skipping the matching-item
                return element.closest('.matching-item')?.parentElement?.parentElement?.closest('.array-item');
            }
            
            return element.closest('.array-item');
        }

        // ========== END CATEGORY 2 REFACTORING ==========

        // ========== CATEGORY 5: CHOICE COLLECTION LOGIC ==========

        /**
         * Collects choices data from a question container
         * Replaces duplicate logic in copySection, generateJSON, saveProgress, and validation functions
         * @param {HTMLElement} questionContainer - The question container element
         * @returns {Array} Array of choice objects with {id, text} properties
         */
        function collectChoicesData(questionContainer) {
            const choices = [];
            const choicesList = questionContainer.querySelector('[id^="choices-list-"]');
            if (choicesList) {
                const choiceItems = choicesList.querySelectorAll('.choice-item');
                choiceItems.forEach((choiceItem) => {
                    const choiceIdInput = choiceItem.querySelector('.choice-id');
                    const choiceTextArea = choiceItem.querySelector('.choice-text');
                    if (choiceTextArea) {
                        const id = choiceIdInput ? choiceIdInput.value.trim() : '';
                        const text = choiceTextArea.value.trim();
                        // Only require text, ID is optional now
                        if (text) {
                            const choice = {};
                            // Add ID first if provided (to maintain order: id, then text)
                            if (id) {
                                choice.id = id;
                            }
                            choice.text = text;
                            choices.push(choice);
                        }
                    }
                });
            }
            return choices;
        }

        // ========== END CATEGORY 5 REFACTORING ==========

        // ========== CATEGORY 7: DATA COLLECTION FROM FORM ==========

        /**
         * Collects choices or guide answer based on question type
         * @param {HTMLElement} questionEl - The question container element
         * @returns {Object} Object with either {choices, value/values, guide_answer} or {guide_answer}
         */
        function collectChoicesOrAnswer(questionEl) {
            const questionType = getFieldValue(questionEl, 'Question Type', 'select');
            if (questionType === 'multiple_choice' || questionType === 'checkbox') {
                const choices = collectChoicesData(questionEl);
                
                // Get optional guide answer notes (now a textarea for both types)
                const guideAnswerNotesTextarea = questionEl.querySelector('.guide-answer-notes');
                const guideAnswer = guideAnswerNotesTextarea ? guideAnswerNotesTextarea.value.trim() : '';
                
                const result = {
                    choices: choices,
                    guide_answer: guideAnswer
                };
                
                if (questionType === 'multiple_choice') {
                    // Get correct choice UID and convert to index for export
                    ensureChoiceUids(questionEl);
                    const correctChoiceUid = getCorrectChoiceUid(questionEl);
                    if (correctChoiceUid) {
                        const choicesList = questionEl.querySelector('[id^="choices-list-"]');
                        const choices = choicesList ? Array.from(choicesList.querySelectorAll('.choice-item')) : [];
                        const choiceUidToIndex = new Map();
                        choices.forEach((item, index) => {
                            const uid = item.dataset.choiceUid;
                            if (uid) choiceUidToIndex.set(uid, index + 1);
                        });
                        const correctIndex = choiceUidToIndex.get(correctChoiceUid) || 0;
                        result.value = correctIndex;
                    }
                } else if (questionType === 'checkbox') {
                    // Build values array from checkbox states
                    const choicesList = questionEl.querySelector('[id^="choices-list-"]');
                    const values = [];
                    if (choicesList) {
                        const choiceItems = choicesList.querySelectorAll('.choice-item');
                        choiceItems.forEach((choiceItem) => {
                            const correctCheckbox = choiceItem.querySelector('.choice-correct');
                            // Only include if choice has text (matches collectChoicesData logic)
                            const choiceTextArea = choiceItem.querySelector('.choice-text');
                            if (choiceTextArea && choiceTextArea.value.trim()) {
                                values.push(correctCheckbox ? correctCheckbox.checked : false);
                            }
                        });
                    }
                    result.values = values;
                }
                
                return result;
            }
            // Free form
            const guideAnswerTextarea = questionEl.querySelector('#guide-answer-container textarea');
            const guideAnswer = guideAnswerTextarea ? guideAnswerTextarea.value.trim() : '';
            return {
                guide_answer: guideAnswer
            };
        }

        /**
         * Collects all data from a question element
         * @param {HTMLElement} questionEl - The question container element
         * @returns {Object} Complete question data object
         */
        function collectQuestionData(questionEl) {
            const questionId = getFieldValue(questionEl, 'Question ID');
            const questionType = getFieldValue(questionEl, 'Question Type', 'select');
            
            // Collect all fields for all types (annotate and create_table are like free_form)
            const setupText = getFieldValue(questionEl, 'Set-up Text', 'textarea') || null;
            const questionText = getFieldValue(questionEl, 'Question Text', 'textarea');
            const relatedQuestion = getFieldValue(questionEl, 'Related Question') || null;
            
            // Collect choices or answer based on question type
            let choicesOrAnswer;
            if (questionType === 'fill_in_the_blanks') {
                // For fill_in_the_blanks, collect blank answers
                const values = collectBlankAnswers(questionEl);
                // Query specifically within blanks container to avoid conflicts with other guide_answer textareas
                const blanksContainer = questionEl.querySelector('#blanks-container');
                const guideAnswerNotesTextarea = blanksContainer?.querySelector('.guide-answer-notes');
                const guideAnswer = guideAnswerNotesTextarea ? guideAnswerNotesTextarea.value.trim() : '';
                choicesOrAnswer = { values, guide_answer: guideAnswer };
            } else if (questionType === 'matching') {
                // For matching, collect left, right, and relationship
                const matchingData = collectMatchingData(questionEl);
                // Query specifically within matching container to avoid conflicts
                const matchingContainer = questionEl.querySelector('#matching-container');
                const guideAnswerNotesTextarea = matchingContainer?.querySelector('.guide-answer-notes');
                const guideAnswer = guideAnswerNotesTextarea ? guideAnswerNotesTextarea.value.trim() : '';
                choicesOrAnswer = { ...matchingData, guide_answer: guideAnswer };
            } else {
                // For standard types (free_form, multiple_choice, checkbox)
                choicesOrAnswer = collectChoicesOrAnswer(questionEl);
            }
            
            // Collect question images (bbox data)
            const questionImages = collectBboxData(questionEl, 'question_images', false);
            
            // Collect guide answer images (bbox data)
            const guideAnswerImages = collectBboxData(questionEl, 'answer_images', false);
            
            // Get guide PDF page
            const guidePdfPageInput = questionEl.querySelector('input[placeholder*="e.g., 78"]') || 
                                     Array.from(questionEl.querySelectorAll('input[type="number"]')).find(
                                         input => input.placeholder && input.placeholder.includes('78')
                                     );
            const guidePdfPage = guidePdfPageInput ? parseInt(guidePdfPageInput.value, 10) : null;
            
            // Build the question object
            const questionData = {
                id: questionId,
                question_type: questionType,
                set_up_text: setupText,
                question_text: questionText
            };
            
            // Add type-specific fields
            if (questionType === 'fill_in_the_blanks') {
                // Fill in the blanks: add values array
                questionData.values = choicesOrAnswer.values || [];
                questionData.guide_answer = choicesOrAnswer.guide_answer;
            } else if (questionType === 'matching') {
                // Matching: add left, right, relationship
                questionData.left = choicesOrAnswer.left || [];
                questionData.right = choicesOrAnswer.right || [];
                questionData.relationship = choicesOrAnswer.relationship || [];
                questionData.guide_answer = choicesOrAnswer.guide_answer;
            } else if ((questionType === 'multiple_choice' || questionType === 'checkbox') && choicesOrAnswer.choices) {
                // Multiple choice or checkbox: add choices
                questionData.choices = choicesOrAnswer.choices;
                
                // Add value (for multiple_choice) or values (for checkbox)
                if (questionType === 'multiple_choice' && choicesOrAnswer.value !== undefined) {
                    questionData.value = choicesOrAnswer.value;
                } else if (questionType === 'checkbox' && choicesOrAnswer.values !== undefined) {
                    questionData.values = choicesOrAnswer.values;
                }
                questionData.guide_answer = choicesOrAnswer.guide_answer;
            } else {
                // Free form: add guide_answer normally
                questionData.guide_answer = choicesOrAnswer.guide_answer;
            }
            
            questionData.question_images = questionImages;
            questionData.guide_pdf_page = guidePdfPage;
            questionData.guide_answer_images = guideAnswerImages;
            questionData.related_question = relatedQuestion;
            
            return questionData;
        }

        /**
         * Collects all data from a content section element
         * @param {HTMLElement} sectionEl - The content section container element
         * @returns {Object} Complete content section data object
         */
        function collectContentData(sectionEl) {
            const sectionTitle = getFieldValue(sectionEl, 'Section Title');
            const text = getFieldValue(sectionEl, 'Content (Markdown + LaTeX)', 'textarea');
            const images = collectBboxData(sectionEl, 'images', true);
            
            return {
                section_title: sectionTitle,
                text: text,
                images: images
            };
        }

        // ========== END CATEGORY 7 REFACTORING ==========

        // ========================================
        // CANONICAL SERIALIZE/DESERIALIZE HELPERS
        // ========================================
        // Single source of truth for copy/paste operations
        // Ensures all fields are consistently serialized and deserialized
        
        /**
         * Canonical serializer: converts a section element to a JSON payload
         * @param {HTMLElement} sectionEl - The section element to serialize
         * @returns {Object} Payload with {type: 'question'|'content', data: {...}}
         */
        function serializeSection(sectionEl) {
            if (!sectionEl) {
                throw new Error('Section element is required');
            }
            
            const isQuestion = !!sectionEl.closest('#questions_container');
            
            if (isQuestion) {
                return {
                    type: 'question',
                    data: collectQuestionData(sectionEl)
                };
            } else {
                return {
                    type: 'content',
                    data: collectContentData(sectionEl)
                };
            }
        }
        
        /**
         * Canonical deserializer: builds DOM and populates from payload
         * Handles ALL question types completely, including all optional fields
         * @param {Object} payload - Payload from serializeSection
         * @param {Object} targetContext - {container: HTMLElement, insertBefore: HTMLElement|null, isReplacement: boolean, targetEl: HTMLElement|null}
         * @returns {HTMLElement} The created/populated section element
         */
        function deserializeSection(payload, targetContext) {
            if (!payload || !payload.type || !payload.data) {
                throw new Error('Invalid payload format');
            }
            
            const { container, insertBefore, isReplacement, targetEl } = targetContext;
            
            if (payload.type === 'question') {
                return deserializeQuestion(payload.data, { container, insertBefore, isReplacement, targetEl });
            } else if (payload.type === 'content') {
                return deserializeContentSection(payload.data, { container, insertBefore, isReplacement, targetEl });
            } else {
                throw new Error(`Unknown section type: ${payload.type}`);
            }
        }
        
        /**
         * Deserialize a question from payload data
         * Handles ALL question types: free_form, multiple_choice, checkbox, fill_in_the_blanks, matching, annotate, create_table
         */
        function deserializeQuestion(data, context) {
            const { container, insertBefore, isReplacement, targetEl } = context;
            
            let questionEl;
            if (isReplacement && targetEl) {
                // Replacing existing question
                questionEl = targetEl;
            } else {
                // Creating new question
                const questionCount = container.querySelectorAll(':scope > .array-item').length + 1;
                questionEl = document.createElement('div');
                questionEl.className = 'array-item';
                questionEl.setAttribute('data-item-type', 'question');
                questionEl.innerHTML = getQuestionHTML(questionCount);
                if (insertBefore) {
                    container.insertBefore(questionEl, insertBefore);
                } else {
                    container.appendChild(questionEl);
                }
            }
            
            // Set basic fields
            const questionIdInput = findFieldByLabel(questionEl, 'Question ID', 'input');
            if (questionIdInput) {
                questionIdInput.value = data.id || '';
            }
            
            const questionType = data.question_type || 'free_form';
            // CRITICAL: Set dataset and select using helper
            setQuestionType(questionEl, questionType);
            const questionTypeSelect = questionEl.querySelector('select.question-type-select, select[onchange*="toggleQuestionType"]');
            if (questionTypeSelect) {
                // Trigger toggle to show/hide appropriate fields
                toggleQuestionType(questionTypeSelect);
            }
            
            setFieldValue(questionEl, 'Set-up Text', data.set_up_text || '', 'textarea');
            setFieldValue(questionEl, 'Question Text', data.question_text || '', 'textarea');
            setFieldValue(questionEl, 'Guide PDF Page', data.guide_pdf_page || '');
            setFieldValue(questionEl, 'Related Question', data.related_question || '');
            
            // Handle type-specific data
            if (questionType === 'fill_in_the_blanks') {
                deserializeFillInBlanks(questionEl, data);
            } else if (questionType === 'matching') {
                deserializeMatching(questionEl, data);
            } else if (questionType === 'multiple_choice' || questionType === 'checkbox') {
                deserializeChoices(questionEl, data, questionType);
            } else {
                // Free form, annotate, create_table
                deserializeFreeForm(questionEl, data);
            }
            
            // Fill bbox data (images)
            const questionImagesGroup = findFormGroupByLabel(questionEl, 'Question Images');
            const answerImagesGroup = findFormGroupByLabel(questionEl, 'Answer Images');
            if (questionImagesGroup) {
                fillBboxGroup(questionImagesGroup, data.question_images || []);
            }
            if (answerImagesGroup) {
                fillBboxGroup(answerImagesGroup, data.guide_answer_images || []);
            }
            
            // Finalize the element (attach previews, validation, etc.)
            setTimeout(() => {
                attachPreviews(questionEl);
                attachBboxValidation(questionEl);
                finalizePastedSection(questionEl, { type: 'question' });
                
                // Update direction buttons
                const dirBtns = questionEl.querySelectorAll('.dir-btn');
                dirBtns.forEach(btn => {
                    const textarea = btn.closest('.text-field-container')?.querySelector('textarea');
                    if (textarea) {
                        const isLTR = textarea.hasAttribute('data-ltr');
                        btn.textContent = isLTR ? 'RTL' : 'LTR';
                    }
                });
            }, 100);
            
            return questionEl;
        }
        
        /**
         * Deserialize fill-in-the-blanks question
         */
        function deserializeFillInBlanks(questionEl, data) {
            updateBlankAnswersUI(questionEl);
            
            if (data.values && Array.isArray(data.values)) {
                const blankItems = questionEl.querySelectorAll('.blank-answer-item');
                blankItems.forEach((item, index) => {
                    const textarea = item.querySelector('.blank-answer-input');
                    if (textarea && data.values[index] !== undefined) {
                        textarea.value = data.values[index];
                    }
                });
                updateFilledBlanksPreview(questionEl);
            }
            
            // Set guide answer (in blanks container)
            const blanksContainer = questionEl.querySelector('#blanks-container');
            const guideAnswerNotesTextarea = blanksContainer?.querySelector('.guide-answer-notes');
            if (guideAnswerNotesTextarea) {
                guideAnswerNotesTextarea.value = data.guide_answer || '';
            }
        }
        
        /**
         * Deserialize matching question
         */
        function deserializeMatching(questionEl, data) {
            const leftList = questionEl.querySelector('[id^="matching-left-list-"]');
            const rightList = questionEl.querySelector('[id^="matching-right-list-"]');
            
            // Populate left items
            if (leftList && data.left && Array.isArray(data.left)) {
                leftList.innerHTML = '';
                data.left.forEach((itemText) => {
                    const addLeftBtn = questionEl.querySelector('button[onclick*="addMatchingItem"][onclick*="left"]');
                    if (addLeftBtn) {
                        addMatchingItem(addLeftBtn, 'left');
                        const lastItem = leftList.lastElementChild;
                        if (lastItem) {
                            const textarea = lastItem.querySelector('.matching-item-text');
                            if (textarea) textarea.value = itemText;
                        }
                    }
                });
            }
            
            // Populate right items
            if (rightList && data.right && Array.isArray(data.right)) {
                rightList.innerHTML = '';
                data.right.forEach((itemText) => {
                    const addRightBtn = questionEl.querySelector('button[onclick*="addMatchingItem"][onclick*="right"]');
                    if (addRightBtn) {
                        addMatchingItem(addRightBtn, 'right');
                        const lastItem = rightList.lastElementChild;
                        if (lastItem) {
                            const textarea = lastItem.querySelector('.matching-item-text');
                            if (textarea) textarea.value = itemText;
                        }
                    }
                });
            }
            
            // Populate relationships (convert indices to UIDs)
            const relationshipsList = questionEl.querySelector('[id^="relationships-list-"]');
            if (relationshipsList && data.relationship && Array.isArray(data.relationship)) {
                relationshipsList.innerHTML = '';
                ensureMatchingUids(questionEl);
                const leftItems = questionEl.querySelectorAll('[id^="matching-left-list-"] .matching-item');
                const rightItems = questionEl.querySelectorAll('[id^="matching-right-list-"] .matching-item');
                const leftIndexToUid = new Map();
                const rightIndexToUid = new Map();
                leftItems.forEach((item, index) => {
                    const uid = item.dataset.leftUid;
                    if (uid) leftIndexToUid.set(index + 1, uid);
                });
                rightItems.forEach((item, index) => {
                    const uid = item.dataset.rightUid;
                    if (uid) rightIndexToUid.set(index + 1, uid);
                });
                data.relationship.forEach(([leftIdx, rightIdx]) => {
                    const addRelBtn = questionEl.querySelector('button[onclick*="addRelationship"]');
                    if (addRelBtn) {
                        addRelationship(addRelBtn);
                        const lastRel = relationshipsList.lastElementChild;
                        if (lastRel) {
                            const leftUid = leftIndexToUid.get(leftIdx);
                            const rightUid = rightIndexToUid.get(rightIdx);
                            if (leftUid) lastRel.dataset.leftUid = leftUid;
                            if (rightUid) lastRel.dataset.rightUid = rightUid;
                        }
                    }
                });
                afterQuestionTypeListMutation(questionEl);
            }
            
            // Set guide answer (in matching container)
            const matchingContainer = questionEl.querySelector('#matching-container');
            const matchingGuideAnswerTextarea = matchingContainer?.querySelector('.guide-answer-notes');
            if (matchingGuideAnswerTextarea) {
                matchingGuideAnswerTextarea.value = data.guide_answer || '';
            }
        }
        
        /**
         * Deserialize multiple choice or checkbox question
         */
        function deserializeChoices(questionEl, data, questionType) {
            const choicesList = questionEl.querySelector('[id^="choices-list-"]');
            if (choicesList && data.choices && Array.isArray(data.choices)) {
                choicesList.innerHTML = '';
                data.choices.forEach((choice) => {
                    addChoice(choicesList.parentElement.querySelector('.add-btn'), 'end', questionType);
                    const lastChoice = choicesList.lastElementChild;
                    if (lastChoice) {
                        const choiceIdInput = lastChoice.querySelector('.choice-id');
                        const choiceTextArea = lastChoice.querySelector('.choice-text');
                        const choiceCorrectInput = lastChoice.querySelector('.choice-correct');
                        if (choiceIdInput) {
                            choiceIdInput.value = choice.id || '';
                            updateChoiceHeader(choiceIdInput);
                        }
                        if (choiceTextArea) {
                            choiceTextArea.value = choice.text || '';
                        }
                        if (choiceCorrectInput && choice.checked !== undefined) {
                            choiceCorrectInput.checked = choice.checked;
                        }
                    }
                });
            }
            
            // Set guide answer (in choices container)
            const choicesContainer = questionEl.querySelector('#choices-container');
            const choicesGuideAnswer = choicesContainer?.querySelector('.guide-answer-notes');
            if (choicesGuideAnswer) {
                choicesGuideAnswer.value = data.guide_answer || '';
            }
            
            // Restore correct answer state using UID-based approach
            ensureChoiceUids(questionEl);
            if (questionType === 'multiple_choice') {
                // Convert index to UID (support both 'value' and 'correct_answer_index')
                const correctIndex = data.correct_answer_index || data.value;
                if (correctIndex) {
                    const choicesList = questionEl.querySelector('[id^="choices-list-"]');
                    if (choicesList) {
                        const choices = choicesList.querySelectorAll('.choice-item');
                        const correctChoice = choices[correctIndex - 1];
                        if (correctChoice && correctChoice.dataset.choiceUid) {
                            setCorrectChoiceUid(questionEl, correctChoice.dataset.choiceUid);
                        }
                    }
                }
            } else if (questionType === 'checkbox') {
                // Restore checkbox correctness from choices[].checked (UID-based)
                const correctUids = new Set();
                const choicesList = questionEl.querySelector('[id^="choices-list-"]');
                if (choicesList) {
                    const choices = choicesList.querySelectorAll('.choice-item');
                    choices.forEach((choiceItem, index) => {
                        // Support both new format (choices[].checked) and old format (values array)
                        const isChecked = (data.choices && data.choices[index] && data.choices[index].checked) ||
                                        (data.values && data.values[index]);
                        if (isChecked) {
                            const uid = choiceItem.dataset.choiceUid;
                            if (uid) correctUids.add(uid);
                        }
                    });
                }
                setCorrectChoiceUids(questionEl, correctUids);
            }
            
            // Attach listeners and sync UI
            attachChoiceListeners(questionEl);
            afterQuestionTypeListMutation(questionEl);
        }
        
        /**
         * Deserialize free form question (also used for annotate, create_table)
         */
        function deserializeFreeForm(questionEl, data) {
            const guideAnswerTextarea = questionEl.querySelector('#guide-answer-container textarea');
            if (guideAnswerTextarea) {
                guideAnswerTextarea.value = data.guide_answer || '';
            }
        }
        
        /**
         * Deserialize a content section from payload data
         */
        function deserializeContentSection(data, context) {
            const { container, insertBefore, isReplacement, targetEl } = context;
            
            let sectionEl;
            if (isReplacement && targetEl) {
                sectionEl = targetEl;
            } else {
                addContentSection();
                sectionEl = container.lastElementChild;
                if (insertBefore && sectionEl) {
                    container.insertBefore(sectionEl, insertBefore);
                }
            }
            
            // Fill in the data
            setFieldValue(sectionEl, 'Section Title', data.section_title || '');
            setFieldValue(sectionEl, 'Content (Markdown + LaTeX)', data.text || '', 'textarea');
            
            // Fill images
            const imagesGroup = findFormGroupByLabel(sectionEl, 'Section Images');
            if (imagesGroup) {
                fillBboxGroup(imagesGroup, data.images || []);
            }
            
            // Finalize the element
            setTimeout(() => {
                attachPreviews(sectionEl);
                attachBboxValidation(sectionEl);
                finalizePastedSection(sectionEl, { type: 'content' });
                
                // Update direction buttons
                const dirBtns = sectionEl.querySelectorAll('.dir-btn');
                dirBtns.forEach(btn => {
                    const textarea = btn.closest('.text-field-container')?.querySelector('textarea');
                    if (textarea) {
                        const isLTR = textarea.hasAttribute('data-ltr');
                        btn.textContent = isLTR ? 'RTL' : 'LTR';
                    }
                });
            }, 100);
            
            return sectionEl;
        }
        
        /**
         * Sanity check: serialize -> deserialize -> serialize should be equivalent
         * Dev-only function for testing copy/paste correctness
         */
        function verifySerializeDeserializeRoundTrip(sectionEl) {
            if (typeof console === 'undefined' || !console.assert) return;
            
            try {
                const original = serializeSection(sectionEl);
                const deserialized = deserializeSection(original, {
                    container: document.createElement('div'),
                    insertBefore: null,
                    isReplacement: false,
                    targetEl: null
                });
                const reSerialized = serializeSection(deserialized);
                
                // Compare key fields (deep equality check would be better but this is a quick sanity check)
                const fieldsMatch = 
                    original.type === reSerialized.type &&
                    original.data.id === reSerialized.data.id &&
                    original.data.question_type === reSerialized.data.question_type &&
                    original.data.question_text === reSerialized.data.question_text;
                
                if (!fieldsMatch) {
                    console.warn('Serialize/deserialize round trip mismatch:', {
                        original,
                        reSerialized
                    });
                }
                
                return fieldsMatch;
            } catch (e) {
                console.error('Serialize/deserialize round trip error:', e);
                return false;
            }
        }

        // ========== CATEGORY 8: BBOX DATA COLLECTION CONSOLIDATION ==========

        /**
         * Unified function to collect bbox data from any container
         * Consolidates collectContentBboxData and collectQuestionBboxData
         * @param {HTMLElement} container - The container element (content or question)
         * @param {string} type - Type of bbox: 'images', 'question_images', or 'answer_images'
         * @param {boolean} allowDefaultPage - Whether to use default page for content images
         * @returns {Array} Array of bbox objects with page and position
         */
        function collectBboxData(container, type, allowDefaultPage = false) {
            let bboxContainer;
            
            // Select the appropriate bbox container
            if (type === 'images') {
                bboxContainer = container.querySelectorAll('.bbox-container')[0];
            } else if (type === 'question_images') {
                bboxContainer = container.querySelectorAll('.bbox-container')[0];
            } else if (type === 'answer_images') {
                bboxContainer = container.querySelectorAll('.bbox-container')[1];
            }
            
            if (!bboxContainer) return [];
            
            // Get default page for content images if needed
            let defaultPageForImages = 0;
            if (allowDefaultPage && type === 'images') {
                const defaultTextbookPdfPage = parseInt(document.getElementById('textbook_pdf_page')?.value || '0', 10) || 0;
                const fallbackTextbookPage = parseInt(document.getElementById('textbook_page')?.value || '0', 10) || 0;
                defaultPageForImages = defaultTextbookPdfPage || fallbackTextbookPage || 0;
            }
            
            const bboxItems = bboxContainer.querySelectorAll('.array-item');
            const contextName = type === 'images' ? 'Content' : 'Question';
            
            return Array.from(bboxItems).map(item => {
                const inputs = item.querySelectorAll('.bbox-inputs input');
                const page = inputs[0].value;
                const x0 = inputs[1].value;
                const y0 = inputs[2].value;
                const x1 = inputs[3].value;
                const y1 = inputs[4].value;
                
                // Validate all bbox values are integers
                if (page && !Number.isInteger(parseFloat(page))) {
                    throw new Error(`${contextName} bbox page must be a whole number`);
                }
                if (x0 && !Number.isInteger(parseFloat(x0))) {
                    throw new Error(`${contextName} bbox X0 coordinate must be a whole number`);
                }
                if (y0 && !Number.isInteger(parseFloat(y0))) {
                    throw new Error(`${contextName} bbox Y0 coordinate must be a whole number`);
                }
                if (x1 && !Number.isInteger(parseFloat(x1))) {
                    throw new Error(`${contextName} bbox X1 coordinate must be a whole number`);
                }
                if (y1 && !Number.isInteger(parseFloat(y1))) {
                    throw new Error(`${contextName} bbox Y1 coordinate must be a whole number`);
                }
                
                // Check required fields based on type
                if (allowDefaultPage && type === 'images') {
                    // Content images: coordinates required, page can be default
                    if (!x0 || !y0 || !x1 || !y1) {
                        return null; // Will be filtered out
                    }
                } else {
                    // Question/Answer images: all fields required including page
                    if (!page || !x0 || !y0 || !x1 || !y1) {
                        return null; // Will be filtered out
                    }
                }
                
                // Use default page if applicable and page is empty
                const pageNumber = page ? parseInt(page) : (allowDefaultPage && type === 'images' ? defaultPageForImages : 0);
                
                return {
                    page: pageNumber,
                    position: [
                        [parseInt(x0), parseInt(y0)],
                        [parseInt(x1), parseInt(y1)]
                    ]
                };
            }).filter(bbox => bbox !== null);
        }

        // ========== END CATEGORY 8 REFACTORING ==========

        // ========== CATEGORY 9: IMAGE INSERTION LOGIC CONSOLIDATION ==========

        /**
         * Get the next available image index for a textarea field
         * Handles question fields (setup, question, choice, guide answer) and content fields
         * For choice texts, follows strict order: setup  question  choice1  choice2  ...
         * @param {HTMLTextAreaElement} textarea - The textarea element
         * @returns {number} The next available image index
         */
        function getNextImageIndexForField(textarea) {
            // Get the base next index
            let nextIndex = getNextImageIndex(textarea);
            
            // For questions, check other text fields that share the same image array
            if (textarea.closest('#questions_container')) {
                // Get the question container (handles choice text special case)
                const questionContainer = getQuestionContainer(textarea);
                const isChoiceText = textarea.classList.contains('choice-text') || textarea.closest('.choice-item');
                const isMatchingItem = textarea.classList.contains('matching-item-text') || textarea.closest('.matching-item');
                
                if (isChoiceText && questionContainer) {
                    // Choice texts follow strict order: setup  question  choice1  choice2  ...
                    // Collect indices from setup, question, and choices UP TO AND INCLUDING current choice
                    let allQuestionIndices = [];
                    
                    // Get setup and question text indices first
                    const setupText = questionContainer.querySelector('textarea[placeholder*="Text shared across multiple questions"]')?.value || '';
                    const questionText = questionContainer.querySelector('textarea[placeholder*="Enter question text"]')?.value || '';
                    allQuestionIndices.push(...extractAllImageIndices([setupText, questionText]));
                    
                    // Get indices from choices in order, UP TO AND INCLUDING the current choice
                    const currentChoiceItem = textarea.closest('.choice-item');
                    const choicesList = questionContainer.querySelector('[id^="choices-list-"]');
                    if (choicesList && currentChoiceItem) {
                        const choiceItems = choicesList.querySelectorAll('.choice-item');
                        for (let i = 0; i < choiceItems.length; i++) {
                            const choiceItem = choiceItems[i];
                            const choiceTextArea = choiceItem.querySelector('.choice-text');
                            if (choiceTextArea) {
                                allQuestionIndices.push(...extractAllImageIndices(choiceTextArea.value || ''));
                            }
                            // Stop after processing the current choice
                            if (choiceItem === currentChoiceItem) {
                                break;
                            }
                        }
                    }
                    
                    // Remove duplicates and get next available index
                    const uniqueIndices = getUniqueIndices(allQuestionIndices);
                    nextIndex = uniqueIndices.length === 0 ? 0 : Math.max(...uniqueIndices) + 1;
                } else if (isMatchingItem && questionContainer) {
                    // For matching items: collect ALL existing image indices from the ENTIRE group
                    // (setup  question  ALL left items  ALL right items)
                    // Then return the next available index (max + 1)
                    let allQuestionIndices = [];
                    
                    // Get setup and question text indices
                    const setupText = questionContainer.querySelector('textarea[placeholder*="Text shared across multiple questions"]')?.value || '';
                    const questionText = questionContainer.querySelector('textarea[placeholder*="Enter question text"]')?.value || '';
                    allQuestionIndices.push(...extractAllImageIndices([setupText, questionText]));
                    
                    const matchingContainer = questionContainer.querySelector('#matching-container');
                    
                    if (matchingContainer) {
                        // Use more specific selectors for left and right lists
                        const leftList = matchingContainer.querySelector('[id^="matching-left-list-"]');
                        const rightList = matchingContainer.querySelector('[id^="matching-right-list-"]');
                        
                        // Collect ALL indices from ALL left items
                        if (leftList) {
                            const leftItems = leftList.querySelectorAll('.matching-item');
                            leftItems.forEach(item => {
                                const itemTextArea = item.querySelector('.matching-item-text');
                                if (itemTextArea) {
                                    allQuestionIndices.push(...extractAllImageIndices(itemTextArea.value || ''));
                                }
                            });
                        }
                        
                        // Collect ALL indices from ALL right items
                        if (rightList) {
                            const rightItems = rightList.querySelectorAll('.matching-item');
                            rightItems.forEach(item => {
                                const itemTextArea = item.querySelector('.matching-item-text');
                                if (itemTextArea) {
                                    allQuestionIndices.push(...extractAllImageIndices(itemTextArea.value || ''));
                                }
                            });
                        }
                    }
                    
                    // Remove duplicates and get next available index
                    const uniqueIndices = getUniqueIndices(allQuestionIndices);
                    nextIndex = uniqueIndices.length === 0 ? 0 : Math.max(...uniqueIndices) + 1;
                } else {
                    // Determine which image array this field uses
                    const isGuideAnswer = textarea.closest('textarea[placeholder*="guide answer"]');
                    
                    if (isGuideAnswer) {
                        // Guide answer uses guide_answer_images array - check only other guide answer fields
                        const otherGuideAnswers = questionContainer.querySelectorAll('textarea[placeholder*="guide answer"]');
                        let allGuideAnswerIndices = extractAllImageIndices(textarea.value);
                        otherGuideAnswers.forEach(field => {
                            if (field !== textarea) {
                                allGuideAnswerIndices.push(...extractAllImageIndices(field.value));
                            }
                        });
                        
                        // Remove duplicates and get next available index
                        const uniqueIndices = getUniqueIndices(allGuideAnswerIndices);
                        nextIndex = uniqueIndices.length === 0 ? 0 : Math.max(...uniqueIndices) + 1;
                    } else {
                        // Setup text and question text share question_images array - check both
                        const setupText = questionContainer.querySelector('textarea[placeholder*="Text shared across multiple questions"]')?.value || '';
                        const questionText = questionContainer.querySelector('textarea[placeholder*="Enter question text"]')?.value || '';
                        
                        let allQuestionIndices = extractAllImageIndices(textarea.value);
                        if (textarea.placeholder.includes('Text shared across multiple questions')) {
                            allQuestionIndices.push(...extractAllImageIndices(questionText));
                        } else if (textarea.placeholder.includes('Enter question text')) {
                            allQuestionIndices.push(...extractAllImageIndices(setupText));
                        }
                        
                        // Remove duplicates and get next available index
                        const uniqueIndices = getUniqueIndices(allQuestionIndices);
                        nextIndex = uniqueIndices.length === 0 ? 0 : Math.max(...uniqueIndices) + 1;
                    }
                }
            }
            
            return nextIndex;
        }

        // ========== END CATEGORY 9 REFACTORING ==========

        // ========== CATEGORY 9.5: TABLE VALIDATION HELPERS ==========
        
        /**
         * Check if text contains a valid markdown table
         * @param {string} text - The text to check
         * @returns {boolean} True if text contains a valid markdown table
         */
        function containsValidTable(text) {
            const result = validateTableMarkdown(text);
            return result.valid && result.hasTables;
        }
        
        /**
         * Remove math expressions from text to avoid detecting special characters inside them
         * @param {string} text - The text to process
         * @returns {string} Text with math expressions removed
         */
        function removeMathExpressions(text) {
            if (!text || typeof text !== 'string') {
                return text || '';
            }
            // Remove block math first ($$...$$) to avoid conflicts with inline math
            // Use [\s\S] instead of [^$] to match newlines and all characters except $ would miss newlines
            let result = text.replace(/\$\$[\s\S]*?\$\$/g, '');
            // Remove inline math ($...$)
            // Use [\s\S] to match any character including newlines
            result = result.replace(/\$[\s\S]*?\$/g, '');
            return result;
        }
        
        /**
         * Strip blockquote prefix from a line (handles "> " or ">")
         * @param {string} line - The line to process
         * @returns {string} Line with blockquote prefix removed
         */
        function stripBlockquotePrefix(line) {
            if (!line || typeof line !== 'string') {
                return line || '';
            }
            // Remove blockquote prefix: "> " or ">" at the start
            return line.replace(/^>\s?/, '').trim();
        }
        
        /**
         * Validate all markdown tables in text and return detailed errors
         * @param {string} text - The text to check
         * @returns {Object} { valid: boolean, errors: string[], hasTables: boolean }
         */
        function validateTableMarkdown(text) {
            if (!text || typeof text !== 'string') {
                return { valid: true, errors: [], hasTables: false };
            }
            
            const lines = text.split('\n');
            const errors = [];
            let hasTables = false;
            let inTable = false;
            let currentTableStart = -1;
            let currentTableEnd = -1;
            let currentTable = [];
            let separatorFound = false;
            let separatorLineNum = -1;
            let expectedColumnCount = null;
            let lastTableRowContent = null; // Track the last table row content for multi-line cells
            let lastTableRowLineNum = -1; // Track the line number of the last table row
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                const rawLine = lines[i]; // Keep original with whitespace
                
                // Check if this line is part of a blockquote
                const isBlockquoteLine = /^\s*>/.test(rawLine);
                // Strip blockquote prefix for table processing
                const lineForTableCheck = isBlockquoteLine ? stripBlockquotePrefix(line) : line;
                
                // Remove math expressions to avoid detecting pipes inside them
                let lineWithoutMath = removeMathExpressions(lineForTableCheck);
                
                // Check if line has pipes after removing math expressions
                // Require at least 2 pipes for a table (which creates 3 cells)
                const hasPipes = lineWithoutMath.includes('|') && lineWithoutMath.split('|').length >= 3;
                
                // Check if line starts with a pipe (even if it doesn't have enough pipes for a full row)
                // This handles multi-line cells where a row might start with | but continue on next line
                // Use lineForTableCheck (with blockquote prefix stripped) for this check
                const startsWithPipe = lineWithoutMath.trim().startsWith('|');
                
                // Check if original line (before removing math and blockquote) starts with pipe
                // This is used for continuation detection - a line starting with LaTeX should still be a continuation
                const originalStartsWithPipe = lineForTableCheck.trim().startsWith('|');
                
                // Empty lines always end tables (check original line, not stripped)
                const isEmptyLine = lineForTableCheck.length === 0;
                
                // Check if this could be a continuation of the previous table row
                // A continuation is a line that doesn't start with | in the original text but we're in a table
                // and the previous line was a table row that didn't end with a pipe (or had incomplete cells)
                // IMPORTANT: Can only be a continuation if lastTableRowContent exists and doesn't end with |
                // Also check if both current and previous lines are blockquote lines (same blockquote context)
                const lastLineWasBlockquote = lastTableRowLineNum > 0 && 
                    lastTableRowLineNum <= lines.length && 
                    lines[lastTableRowLineNum - 1] && 
                    /^\s*>/.test(lines[lastTableRowLineNum - 1]);
                const isContinuation = !isEmptyLine && inTable && !originalStartsWithPipe && lastTableRowContent !== null && 
                    lastTableRowContent.trim() !== '' && 
                    !lastTableRowContent.trim().endsWith('|') &&
                    (isBlockquoteLine === lastLineWasBlockquote); // Must be in same context (both blockquote or both not)
                
                // A line is part of a table if:
                // 1. It has enough pipes (hasPipes), OR
                // 2. It starts with a pipe and we're already in a table (handles partial rows), OR
                // 3. It's a continuation of a previous table row
                // Empty lines are NEVER table rows
                const isTableRow = !isEmptyLine && (hasPipes || (startsWithPipe && inTable) || isContinuation);
                
                if (isTableRow) {
                    hasTables = true;
                    
                    if (!inTable) {
                        // Starting a new table
                        inTable = true;
                        currentTableStart = i + 1;
                        currentTable = [];
                        separatorFound = false;
                        separatorLineNum = -1;
                        expectedColumnCount = null;
                        lastTableRowContent = null;
                        lastTableRowLineNum = -1;
                    }
                    
                    // If this is a continuation line, merge it with the previous row
                    if (isContinuation && lastTableRowContent !== null) {
                        // Merge the continuation with the last row, preserving the newline
                        // Use newline to preserve line breaks in cells for proper rendering
                        // Use lineForTableCheck (blockquote prefix already stripped) for consistency
                        const mergedRow = lastTableRowContent + '\n' + lineForTableCheck;
                        // Update the last entry in currentTable
                        if (currentTable.length > 0) {
                            currentTable[currentTable.length - 1].content = mergedRow;
                        }
                        lastTableRowContent = mergedRow;
                        currentTableEnd = i;
                    } else if (!isContinuation) {
                        // New table row (not a continuation)
                        // Store the line without blockquote prefix for table processing
                        currentTable.push({ lineNum: i + 1, content: lineForTableCheck });
                        currentTableEnd = i;
                        lastTableRowContent = lineForTableCheck;
                        lastTableRowLineNum = i + 1;
                    }
                    
                    // Count columns (number of pipes) - use merged content if available
                    // contentToCheck should already have blockquote prefix stripped
                    const contentToCheck = lastTableRowContent || lineForTableCheck;
                    // Remove math expressions before counting pipes to ignore pipes inside LaTeX
                    const contentWithoutMath = removeMathExpressions(contentToCheck);
                    const pipeCount = (contentWithoutMath.match(/\|/g) || []).length;
                    
                    // Check if this is a separator row (only for lines that look like separators)
                    // contentToCheck already has blockquote prefix stripped, so separator detection works correctly
                    const isSeparator = /^[\s|:-]+$/.test(contentToCheck) && contentToCheck.includes('-');
                    
                    if (isSeparator) {
                        if (separatorFound) {
                            errors.push({
                                message: `Multiple separator rows found in the same table. Each table should have only one separator row (|---|---|).`,
                                content: contentToCheck
                            });
                        }
                        separatorFound = true;
                        separatorLineNum = i + 1;
                        
                        // Separator must have same pipe count as expected columns
                        if (expectedColumnCount !== null && pipeCount !== expectedColumnCount) {
                            errors.push({
                                message: `Separator row has ${pipeCount} pipes but expected ${expectedColumnCount} based on other rows. All rows including the separator must have the same number of columns.`,
                                content: contentToCheck
                            });
                        }
                        
                        // Separator sets the expected column count if not set
                        if (expectedColumnCount === null) {
                            expectedColumnCount = pipeCount;
                        }
                        // Reset last row tracking after separator
                        lastTableRowContent = null;
                        lastTableRowLineNum = -1;
                    } else {
                        // Regular row - check column count consistency
                        // CRITICAL: Only validate if we have a complete row (ends with |)
                        // Never validate incomplete rows that might continue on the next line
                        const rowEndsWithPipe = contentToCheck.trim().endsWith('|');
                        const rowStartsWithPipe = contentToCheck.trim().startsWith('|');
                        const isIncompleteRow = rowStartsWithPipe && !rowEndsWithPipe;
                        
                        // Only validate complete rows - never validate incomplete rows
                        if (rowEndsWithPipe && !isIncompleteRow) {
                            // Only validate complete rows
                        if (expectedColumnCount === null) {
                            expectedColumnCount = pipeCount;
                        } else if (pipeCount !== expectedColumnCount) {
                                errors.push({
                                    message: `Inconsistent column count. Expected ${expectedColumnCount} pipes but found ${pipeCount}. All rows in a table must have the same number of columns.`,
                                    content: contentToCheck
                                });
                        }
                            // Row is complete, reset tracking for next row
                            lastTableRowContent = null;
                            lastTableRowLineNum = -1;
                        } else if (isIncompleteRow) {
                            // This is an incomplete row that will continue on the next line
                            // Do NOT validate it - wait until it's complete
                            // Keep lastTableRowContent so next line can merge with it
                        }
                        // If row doesn't end with pipe, it might continue on next line
                        // Keep lastTableRowContent so next line can merge with it
                        // DO NOT validate incomplete rows - they will be validated when complete
                    }
                    
                } else if (inTable) {
                    // End of table (non-pipe line after table lines, and not a continuation)
                    // Note: Continuations are handled in the main branch above
                    if (currentTable.length > 0) {
                        // Validate the completed table
                        if (!separatorFound) {
                        const tableContent = currentTable.map(row => row.content).join('\n');
                        errors.push({
                            message: `Table is missing a separator row. Add a row like |---|---| after the header.`,
                            content: tableContent
                        });
                        }
                        if (currentTable.length < 2) {
                        const tableContent = currentTable.map(row => row.content).join('\n');
                        errors.push({
                            message: `Table has only ${currentTable.length} row(s). A valid table needs at least 2 rows (header + separator, or separator + data).`,
                            content: tableContent
                        });
                        }
                        
                        // Check if line after table is empty (when there's more content)
                        if (line.length > 0) {
                            // Get the last few table rows and the problematic content
                            const tableContent = currentTable.slice(-3).map(row => row.content).join('\n');
                            const problematicContent = line.length > 50 ? line.substring(0, 50) + '...' : line;
                            errors.push({
                                message: `Content immediately after table without an empty line. Add an empty line after the table before adding new content.`,
                                content: tableContent + '\n' + problematicContent
                            });
                        }
                    }
                    
                    inTable = false;
                    currentTable = [];
                    separatorFound = false;
                    separatorLineNum = -1;
                    expectedColumnCount = null;
                    lastTableRowContent = null;
                    lastTableRowLineNum = -1;
                }
            }
            
            // Check if we ended while still in a table
            if (inTable && currentTable.length > 0) {
                if (!separatorFound) {
                    const tableContent = currentTable.map(row => row.content).join('\n');
                    errors.push({
                        message: `Table is missing a separator row. Add a row like |---|---| after the header.`,
                        content: tableContent
                    });
                }
                if (currentTable.length < 2) {
                    const tableContent = currentTable.map(row => row.content).join('\n');
                    errors.push({
                        message: `Table has only ${currentTable.length} row(s). A valid table needs at least 2 rows (header + separator, or separator + data).`,
                        content: tableContent
                    });
                }
            }
            
            return {
                valid: errors.length === 0,
                errors: errors,
                hasTables: hasTables
            };
        }
        
        /**
         * Show table validation errors for a textarea
         * @param {HTMLTextAreaElement} textarea - The textarea element
         */
        function showTableValidationErrors(textarea) {
            if (!textarea) return;
            
            const text = textarea.value;
            const result = validateTableMarkdown(text);
            
            // Find or create error container - insert right after textarea
            const container = textarea.closest('.text-field-container') || textarea.parentElement;
            if (!container) return;
            
            let errorDiv = container.querySelector('.table-validation-errors');
            
            if (result.hasTables && !result.valid && result.errors.length > 0) {
                // Show errors
                if (!errorDiv) {
                    errorDiv = document.createElement('div');
                    errorDiv.className = 'table-validation-errors';
                    errorDiv.style.cssText = 'margin-top: 8px;';
                    // Insert right after the textarea
                    textarea.parentNode.insertBefore(errorDiv, textarea.nextSibling);
                }
                
                errorDiv.style.display = 'block';
                errorDiv.innerHTML = `
                    <div style="padding: 10px; background: #ffe6e6; border: 1px solid #ff4d4d; border-radius: 6px; color: #cc0000;">
                        <strong> Table Markdown Errors:</strong>
                        ${result.errors.map(err => {
                            const errorMsg = typeof err === 'string' ? err : err.message;
                            const errorContent = typeof err === 'object' && err.content ? err.content : '';
                            if (errorContent) {
                                return `
                                    <div style="margin: 8px 0; padding: 8px; background: #fff; border-left: 3px solid #ff4d4d; border-radius: 4px;">
                                        <div style="margin-bottom: 6px;">${errorMsg}</div>
                                        <div style="font-size: 0.9em; color: #666;">
                                            <strong>Your Code:</strong>
                                            <code style="display: block; margin-top: 4px; padding: 6px; background: #f5f5f5; border-radius: 3px; white-space: pre-wrap; font-family: monospace; font-size: 0.85em;">${escapeHtml(errorContent)}</code>
                                        </div>
                                    </div>
                                `;
                            } else {
                                return `<div style="margin: 4px 0;">${errorMsg}</div>`;
                            }
                        }).join('')}
                    </div>
                `;
                textarea.classList.add('validation-error');
            } else {
                // Clear errors
                if (errorDiv) {
                    errorDiv.style.display = 'none';
                    errorDiv.innerHTML = '';
                }
                textarea.classList.remove('validation-error');
            }
        }
        
        // ========== CATEGORY 9.6: LIST VALIDATION HELPERS ==========
        
        function getListMarkerLineInfo(line) {
            if (line === null || line === undefined) return null;
            const trimmed = String(line).trim();
            if (!trimmed) return null;
            
            // Remove math expressions to avoid detecting list markers inside them
            let lineWithoutMath = trimmed.replace(/\$[^$]+\$/g, '');
            lineWithoutMath = lineWithoutMath.replace(/\$\$[^$]+\$\$/g, '');
            
            let match = lineWithoutMath.match(/^\s*([*+-])\s*$/);
            if (match) {
                const rawMatch = String(line).match(/^\s*([*+-])\s*$/);
                const marker = rawMatch ? rawMatch[1] : match[1];
                return { type: 'bullet', marker, rawMarker: marker, isMarkerOnly: true };
            }
            
            match = lineWithoutMath.match(/^\s*(\d+)\.\s*$/);
            if (match) {
                const rawMatch = String(line).match(/^\s*(\d+)\.\s*$/);
                const num = rawMatch ? rawMatch[1] : match[1];
                const marker = `${num}.`;
                return { type: 'numbered', marker, rawMarker: marker, isMarkerOnly: true };
            }
            
            match = lineWithoutMath.match(/^\s*([*+-])\s+.+$/);
            if (match) {
                const rawMatch = String(line).match(/^\s*([*+-])\s+.+$/);
                const marker = rawMatch ? rawMatch[1] : match[1];
                return { type: 'bullet', marker, rawMarker: marker, isMarkerOnly: false };
            }
            
            match = lineWithoutMath.match(/^\s*(\d+)\.\s+.+$/);
            if (match) {
                const rawMatch = String(line).match(/^\s*(\d+)\.\s+.+$/);
                const num = rawMatch ? rawMatch[1] : match[1];
                const marker = `${num}.`;
                return { type: 'numbered', marker, rawMarker: marker, isMarkerOnly: false };
            }
            
            return null;
        }
        
        function normalizeEmptyListItemsForPreview(text) {
            if (!text || typeof text !== 'string') return text;
            const lines = text.split('\n');
            const infos = lines.map(line => getListMarkerLineInfo(line));
            const normalized = [];
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const info = infos[i];
                const prevInfo = i > 0 ? infos[i - 1] : null;
                const nextInfo = i < infos.length - 1 ? infos[i + 1] : null;
                
                if (info) {
                    const prevLine = i > 0 ? lines[i - 1] : null;
                    if (prevLine !== null) {
                        const prevTrimmed = prevLine.trim();
                        if (prevTrimmed !== '' && !prevInfo) {
                            normalized.push('');
                        }
                    }
                }
                
                let outLine = line;
                if (info && info.isMarkerOnly) {
                    const inRun = (prevInfo && prevInfo.type === info.type) || (nextInfo && nextInfo.type === info.type);
                    if (inRun) {
                        if (info.type === 'bullet') {
                            const match = String(line).match(/^(\s*)([*+-])\s*$/);
                            if (match) {
                                outLine = `${match[1]}${match[2]} \u200B`;
                            }
                        } else if (info.type === 'numbered') {
                            const match = String(line).match(/^(\s*)(\d+)\.\s*$/);
                            if (match) {
                                outLine = `${match[1]}${match[2]}. \u200B`;
                            }
                        }
                    }
                }
                
                normalized.push(outLine);
            }
            
            return normalized.join('\n');
        }
        
        /**
         * Validate markdown lists and check for empty lines after lists
         * @param {string} text - The text to check
         * @returns {Object} { valid: boolean, errors: string[], hasLists: boolean }
         */
        function validateListMarkdown(text) {
            if (!text || typeof text !== 'string') {
                return { valid: true, errors: [], hasLists: false };
            }
            
            const lines = text.split('\n');
            const errors = [];
            let hasLists = false;
            let inList = false;
            let listStartLine = -1;
            let lastListLine = -1;
            let currentListItems = []; // Track the actual list items in the current list
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const trimmed = line.trim();
                const listInfo = getListMarkerLineInfo(line);
                const isListItem = !!listInfo;
                const isBlankLine = trimmed === '';
                
                if (isListItem) {
                    hasLists = true;
                    
                    if (!inList) {
                        // Starting a new list
                        inList = true;
                        listStartLine = i + 1;
                        currentListItems = []; // Reset list items
                        
                        if (i > 0) {
                            const prevLine = lines[i - 1];
                            const prevTrimmed = prevLine.trim();
                            const prevInfo = getListMarkerLineInfo(prevLine);
                            if (prevTrimmed !== '' && !prevInfo) {
                                errors.push({
                                    message: 'List starts without an empty line before it. Add an empty line before the list.',
                                    content: `${prevLine}\n${line}`
                                });
                            }
                        }
                    }
                    
                    // Add this list item to our tracking
                    currentListItems.push(line);
                    lastListLine = i + 1;
                } else if (inList) {
                    // We were in a list, check if this line ends the list
                    if (isBlankLine) {
                        // Blank line after list - this is correct, list ends here
                        inList = false;
                        listStartLine = -1;
                        lastListLine = -1;
                        currentListItems = []; // Clear tracked items
                    } else {
                        // Non-blank line immediately after list without empty line
                        // This is an error - content will be appended to the list
                        // Use the actual list items we tracked, not a filtered slice
                        const listContent = currentListItems.join('\n');
                        const problematicContent = line.length > 50 ? line.substring(0, 50) + '...' : line;
                        errors.push({
                            message: `Content immediately after list without an empty line. Add an empty line after the list before adding new content.`,
                            content: listContent + '\n' + problematicContent
                        });
                        // End the list here
                        inList = false;
                        listStartLine = -1;
                        lastListLine = -1;
                        currentListItems = []; // Clear tracked items
                    }
                }
            }
            
            // If we ended while still in a list, that's okay - it's at the end of the content
            // No need to require an empty line at the very end
            
            return {
                valid: errors.length === 0,
                errors: errors,
                hasLists: hasLists
            };
        }
        
        /**
         * Show list validation errors for a textarea
         * @param {HTMLTextAreaElement} textarea - The textarea element
         */
        function showListValidationErrors(textarea) {
            if (!textarea) return;
            
            const text = textarea.value;
            const result = validateListMarkdown(text);
            
            // Find or create error container - insert right after textarea
            const container = textarea.closest('.text-field-container') || textarea.parentElement;
            if (!container) return;
            
            let errorDiv = container.querySelector('.list-validation-errors');
            
            if (result.hasLists && !result.valid && result.errors.length > 0) {
                // Show errors
                if (!errorDiv) {
                    errorDiv = document.createElement('div');
                    errorDiv.className = 'list-validation-errors';
                    errorDiv.style.cssText = 'margin-top: 8px;';
                    // Insert right after the textarea
                    textarea.parentNode.insertBefore(errorDiv, textarea.nextSibling);
                }
                
                errorDiv.style.display = 'block';
                errorDiv.innerHTML = `
                    <div style="padding: 10px; background: #ffe6e6; border: 1px solid #ff4d4d; border-radius: 6px; color: #cc0000;">
                        <strong> List Markdown Errors:</strong>
                        ${result.errors.map(err => {
                            const errorMsg = typeof err === 'string' ? err : err.message;
                            const errorContent = typeof err === 'object' && err.content ? err.content : '';
                            if (errorContent) {
                                return `
                                    <div style="margin: 8px 0; padding: 8px; background: #fff; border-left: 3px solid #ff4d4d; border-radius: 4px;">
                                        <div style="margin-bottom: 6px;">${errorMsg}</div>
                                        <div style="font-size: 0.9em; color: #666;">
                                            <strong>Your Code:</strong>
                                            <code style="display: block; margin-top: 4px; padding: 6px; background: #f5f5f5; border-radius: 3px; white-space: pre-wrap; font-family: monospace; font-size: 0.85em;">${escapeHtml(errorContent)}</code>
                                        </div>
                                    </div>
                                `;
                            } else {
                                return `<div style="margin: 4px 0;">${errorMsg}</div>`;
                            }
                        }).join('')}
                    </div>
                `;
                textarea.classList.add('validation-error');
            } else {
                // Clear errors
                if (errorDiv) {
                    errorDiv.style.display = 'none';
                    errorDiv.innerHTML = '';
                }
                // Don't remove validation-error class here as it might be set by other validations
                // Only remove if no other errors exist
                const hasOtherErrors = container.querySelector('.table-validation-errors')?.style.display !== 'none';
                if (!hasOtherErrors) {
                    textarea.classList.remove('validation-error');
                }
            }
        }
        
        // ========== CATEGORY 9.7: BLOCKQUOTE VALIDATION HELPERS ==========
        
        /**
         * Validate markdown blockquotes and check for empty lines after blockquotes
         * @param {string} text - The text to check
         * @returns {Object} { valid: boolean, errors: string[], hasBlockquotes: boolean }
         */
        function validateBlockquoteMarkdown(text) {
            if (!text || typeof text !== 'string') {
                return { valid: true, errors: [], hasBlockquotes: false };
            }
            
            const lines = text.split('\n');
            const errors = [];
            let hasBlockquotes = false;
            let inBlockquote = false;
            let blockquoteStartLine = -1;
            let lastBlockquoteLine = -1;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const trimmed = line.trim();
                
                // Remove math expressions to avoid detecting blockquote markers inside them
                let lineWithoutMath = trimmed.replace(/\$[^$]+\$/g, '');
                lineWithoutMath = lineWithoutMath.replace(/\$\$[^$]+\$\$/g, '');
                
                // Check if line is a blockquote (starts with >)
                // Allow for indentation (spaces or tabs) before the >
                const isBlockquoteLine = /^\s*>/.test(lineWithoutMath);
                const isBlankLine = trimmed === '';
                const isBlankBlockquote = trimmed === '>';
                
                // Validate blockquote formatting: if it's a blockquote with content, must have exactly one space after >
                if (isBlockquoteLine && !isBlankBlockquote) {
                    // Check the original line (preserving leading whitespace) to see the exact spacing after >
                    const leadingWhitespaceMatch = line.match(/^(\s*)/);
                    const leadingWhitespace = leadingWhitespaceMatch ? leadingWhitespaceMatch[1] : '';
                    const afterLeadingWhitespace = line.substring(leadingWhitespace.length);
                    
                    // After removing leading whitespace, check if > is followed by exactly one space
                    if (afterLeadingWhitespace.startsWith('>')) {
                        const afterGT = afterLeadingWhitespace.substring(1);
                        
                        // Must have exactly one space after > when there's content
                        if (afterGT.length === 0) {
                            // This should have been caught by isBlankBlockquote, but just in case
                            // Blank blockquote is valid, skip
                        } else if (!afterGT.startsWith(' ')) {
                            // No space after > (starts with non-space character like 'text' or tab)
                            errors.push({
                                message: `Blockquote on line ${i + 1} must have exactly one space after the ">" character. Found "${afterGT[0] === '\t' ? 'tab' : afterGT[0]}" instead of a space.`,
                                content: line.length > 100 ? line.substring(0, 100) + '...' : line,
                                lineNumber: i + 1
                            });
                        } else if (afterGT.length > 1 && afterGT[1] === ' ') {
                            // Multiple spaces after > (second character is also a space)
                            errors.push({
                                message: `Blockquote on line ${i + 1} must have exactly one space after the ">" character. Found multiple spaces.`,
                                content: line.length > 100 ? line.substring(0, 100) + '...' : line,
                                lineNumber: i + 1
                            });
                        }
                        // If afterGT starts with exactly one space (and second char is not space), it's valid
                    }
                }
                
                if (isBlockquoteLine) {
                    hasBlockquotes = true;
                    
                    if (!inBlockquote) {
                        // Starting a new blockquote
                        inBlockquote = true;
                        blockquoteStartLine = i + 1;
                    }
                    
                    lastBlockquoteLine = i + 1;
                } else if (inBlockquote) {
                    // We were in a blockquote, check if this line ends the blockquote
                    if (isBlankLine) {
                        // Blank line after blockquote - this is correct, blockquote ends here
                        inBlockquote = false;
                        blockquoteStartLine = -1;
                        lastBlockquoteLine = -1;
                    } else {
                        // Non-blank line immediately after blockquote without empty line
                        // This is an error - content will be appended to the blockquote
                        // Get the last few blockquote lines and the problematic content
                        const blockquoteStart = Math.max(0, i - 5); // Get up to 5 lines before
                        const blockquoteContent = lines.slice(blockquoteStart, i).filter(l => /^\s*>/.test(l)).join('\n');
                        const problematicContent = line.length > 50 ? line.substring(0, 50) + '...' : line;
                        errors.push({
                            message: `Content immediately after blockquote without an empty line. Add an empty line after the blockquote before adding new content.`,
                            content: blockquoteContent + '\n' + problematicContent
                        });
                        // End the blockquote here
                        inBlockquote = false;
                        blockquoteStartLine = -1;
                        lastBlockquoteLine = -1;
                    }
                }
            }
            
            // If we ended while still in a blockquote, that's okay - it's at the end of the content
            // No need to require an empty line at the very end
            
            return {
                valid: errors.length === 0,
                errors: errors,
                hasBlockquotes: hasBlockquotes
            };
        }
        
        /**
         * Show blockquote validation errors for a textarea
         * @param {HTMLTextAreaElement} textarea - The textarea element
         */
        function showBlockquoteValidationErrors(textarea) {
            if (!textarea) return;
            
            const text = textarea.value;
            const result = validateBlockquoteMarkdown(text);
            
            // Find or create error container - insert right after textarea
            const container = textarea.closest('.text-field-container') || textarea.parentElement;
            if (!container) return;
            
            let errorDiv = container.querySelector('.blockquote-validation-errors');
            
            if (result.hasBlockquotes && !result.valid && result.errors.length > 0) {
                // Show errors
                if (!errorDiv) {
                    errorDiv = document.createElement('div');
                    errorDiv.className = 'blockquote-validation-errors';
                    errorDiv.style.cssText = 'margin-top: 8px;';
                    // Insert right after the textarea
                    textarea.parentNode.insertBefore(errorDiv, textarea.nextSibling);
                }
                
                errorDiv.style.display = 'block';
                errorDiv.innerHTML = `
                    <div style="padding: 10px; background: #ffe6e6; border: 1px solid #ff4d4d; border-radius: 6px; color: #cc0000;">
                        <strong> Blockquote Markdown Errors:</strong>
                        ${result.errors.map(err => {
                            const errorMsg = typeof err === 'string' ? err : err.message;
                            const errorContent = typeof err === 'object' && err.content ? err.content : '';
                            if (errorContent) {
                                return `
                                    <div style="margin: 8px 0; padding: 8px; background: #fff; border-left: 3px solid #ff4d4d; border-radius: 4px;">
                                        <div style="margin-bottom: 6px;">${errorMsg}</div>
                                        <div style="font-size: 0.9em; color: #666;">
                                            <strong>Your Code:</strong>
                                            <code style="display: block; margin-top: 4px; padding: 6px; background: #f5f5f5; border-radius: 3px; white-space: pre-wrap; font-family: monospace; font-size: 0.85em;">${escapeHtml(errorContent)}</code>
                                        </div>
                                    </div>
                                `;
                            } else {
                                return `<div style="margin: 4px 0;">${errorMsg}</div>`;
                            }
                        }).join('')}
                    </div>
                `;
                textarea.classList.add('validation-error');
            } else {
                // Clear errors
                if (errorDiv) {
                    errorDiv.style.display = 'none';
                    errorDiv.innerHTML = '';
                }
                // Don't remove validation-error class here as it might be set by other validations
                // Only remove if no other errors exist
                const hasOtherErrors = container.querySelector('.table-validation-errors')?.style.display !== 'none' ||
                                      container.querySelector('.list-validation-errors')?.style.display !== 'none';
                if (!hasOtherErrors) {
                    textarea.classList.remove('validation-error');
                }
            }
        }
        
        // ========== CATEGORY 9.8: OTHER VALIDATION ERROR DISPLAY HELPERS ==========
        
        /**
         * Show LaTeX validation errors for a textarea
         * @param {HTMLTextAreaElement} textarea - The textarea element
         */
        function showLatexValidationErrors(textarea) {
            if (!textarea) return;
            
            const text = textarea.value;
            const mathBlockErrors = validateBlockLatex(text);
            const blanksInLatexErrors = validateBlanksInLatex(text);
            const allErrors = [...mathBlockErrors, ...blanksInLatexErrors];
            
            // Find or create error container - insert right after textarea
            const container = textarea.closest('.text-field-container') || textarea.parentElement;
            if (!container) return;
            
            let errorDiv = container.querySelector('.latex-validation-errors');
            
            if (allErrors.length > 0) {
                // Show errors
                if (!errorDiv) {
                    errorDiv = document.createElement('div');
                    errorDiv.className = 'latex-validation-errors';
                    errorDiv.style.cssText = 'margin-top: 8px;';
                    // Insert right after the textarea
                    textarea.parentNode.insertBefore(errorDiv, textarea.nextSibling);
                }
                
                errorDiv.style.display = 'block';
                errorDiv.innerHTML = `
                    <div style="padding: 10px; background: #ffe6e6; border: 1px solid #ff4d4d; border-radius: 6px; color: #cc0000;">
                        <strong> LaTeX Errors:</strong>
                        ${allErrors.map(error => {
                            let errorMessage = '';
                            let fixMessage = '';
                            
                            if (error.type === 'incorrect_delimiters') {
                                errorMessage = 'Your LaTeX block needs newline characters around it';
                                fixMessage = 'Use: <code>$$\\n...your formula...\\n$$</code> (with \\n before and after)';
                            } else if (error.type === 'extra_newlines') {
                                errorMessage = 'Your LaTeX content has extra newline characters inside';
                                fixMessage = 'Remove any enters or \\n characters from inside your formula';
                            } else if (error.type === 'empty_content') {
                                errorMessage = 'Your LaTeX block is empty';
                                fixMessage = 'Add your formula between the $$\\n and \\n$$';
                            } else if (error.type === 'blank_in_latex') {
                                errorMessage = error.message || `Blank ${error.blank || ''} cannot be written inside LaTeX`;
                                fixMessage = 'Move the blank outside the LaTeX expression. Blanks should be placed before or after LaTeX, not inside it.';
                            } else {
                                errorMessage = error.message;
                                fixMessage = 'Check your LaTeX syntax';
                            }
                            
                            // Get content from error object, or use empty string if not available
                            const errorContent = error.content || '';
                            let codeDisplay = '';
                            if (error.type === 'blank_in_latex') {
                                // For blank in LaTeX errors, show the LaTeX expression with the blank
                                // Try to determine if it's inline or block LaTeX
                                const originalText = textarea.value;
                                const blankPos = originalText.indexOf(error.blank);
                                if (blankPos !== -1) {
                                    // Find the LaTeX expression containing this blank
                                    const beforeBlank = originalText.substring(0, blankPos);
                                    const afterBlank = originalText.substring(blankPos + error.blank.length);
                                    
                                    // Check for block LaTeX ($$...$$)
                                    const blockStart = beforeBlank.lastIndexOf('$$');
                                    const blockEnd = afterBlank.indexOf('$$');
                                    if (blockStart !== -1 && blockEnd !== -1) {
                                        const fullLatex = originalText.substring(blockStart, blankPos + error.blank.length + blockEnd + 2);
                                        codeDisplay = escapeHtml(fullLatex);
                                    } else {
                                        // Check for inline LaTeX ($...$)
                                        const inlineStart = beforeBlank.lastIndexOf('$');
                                        const inlineEnd = afterBlank.indexOf('$');
                                        if (inlineStart !== -1 && inlineEnd !== -1) {
                                            const fullLatex = originalText.substring(inlineStart, blankPos + error.blank.length + inlineEnd + 1);
                                            codeDisplay = escapeHtml(fullLatex);
                                        } else {
                                            codeDisplay = escapeHtml(errorContent ? `$$${errorContent}$$` : `$$...${error.blank}...$$`);
                                        }
                                    }
                                } else {
                                    codeDisplay = escapeHtml(errorContent ? `$$${errorContent}$$` : `$$...${error.blank}...$$`);
                                }
                            } else {
                                codeDisplay = errorContent ? `$$\\n${errorContent}\\n$$` : '$$\\n...\\n$$';
                            }
                            
                            return `
                                <div style="margin: 8px 0; padding: 8px; background: #fff; border-left: 3px solid #ff4d4d; border-radius: 4px;">
                                    <div style="margin-bottom: 6px;"> <strong>LaTeX Problem:</strong> ${errorMessage}</div>
                                    <div style="margin-bottom: 6px;"> <strong>How to Fix:</strong> ${fixMessage}</div>
                                    ${codeDisplay ? `
                                    <div style="font-size: 0.9em; color: #666;">
                                        <strong>Your Code:</strong>
                                        <code style="display: block; margin-top: 4px; padding: 6px; background: #f5f5f5; border-radius: 3px; white-space: pre-wrap; font-family: monospace; font-size: 0.85em;">${codeDisplay}</code>
                                    </div>
                                    ` : ''}
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;
                textarea.classList.add('validation-error');
            } else {
                // Clear errors
                if (errorDiv) {
                    errorDiv.style.display = 'none';
                    errorDiv.innerHTML = '';
                }
                const hasOtherErrors = container.querySelector('.table-validation-errors')?.style.display !== 'none' ||
                                      container.querySelector('.list-validation-errors')?.style.display !== 'none' ||
                                      container.querySelector('.blockquote-validation-errors')?.style.display !== 'none' ||
                                      container.querySelector('.image-validation-errors')?.style.display !== 'none' ||
                                      container.querySelector('.quote-validation-errors')?.style.display !== 'none' ||
                                      container.querySelector('.br-validation-errors')?.style.display !== 'none';
                if (!hasOtherErrors) {
                    textarea.classList.remove('validation-error');
                }
            }
        }
        
        /**
         * Show image validation errors for a textarea
         * @param {HTMLTextAreaElement} textarea - The textarea element
         */
        function showImageValidationErrors(textarea) {
            if (!textarea) return;
            
            const text = textarea.value;
            const imageDescErrors = validateImageDescriptions(text);
            
            // Find or create error container - insert right after textarea
            const container = textarea.closest('.text-field-container') || textarea.parentElement;
            if (!container) return;
            
            let errorDiv = container.querySelector('.image-validation-errors');
            
            if (imageDescErrors.length > 0) {
                // Show errors
                if (!errorDiv) {
                    errorDiv = document.createElement('div');
                    errorDiv.className = 'image-validation-errors';
                    errorDiv.style.cssText = 'margin-top: 8px;';
                    // Insert right after the textarea
                    textarea.parentNode.insertBefore(errorDiv, textarea.nextSibling);
                }
                
                errorDiv.style.display = 'block';
                errorDiv.innerHTML = `
                    <div style="padding: 10px; background: #ffe6e6; border: 1px solid #ff4d4d; border-radius: 6px; color: #cc0000;">
                        <strong> Image Description Errors:</strong>
                        ${imageDescErrors.map(error => {
                            if (error.type === 'malformed_image_syntax' || error.type === 'malformed_syntax') {
                                let problemMsg = 'Your image syntax has an error';
                                let fixMsg = 'Use the correct format: <code>![description](0)</code>';
                                
                                const errorMsg = error.message || '';
                                
                                if (errorMsg.includes('Space between ] and (')) {
                                    problemMsg = 'There\'s a space between ] and ( in your image';
                                    fixMsg = 'Remove the space: <code>![description](0)</code> not <code>![description] (0)</code>';
                                } else if (errorMsg.includes('Space between ! and [')) {
                                    problemMsg = 'There\'s a space between ! and [ in your image';
                                    fixMsg = 'Remove the space: <code>![description](0)</code> not <code>! [description](0)</code>';
                                } else if (errorMsg.includes('Square brackets used instead of parentheses')) {
                                    problemMsg = 'You used square brackets [] for the image number';
                                    fixMsg = 'Use parentheses instead: <code>![description](0)</code> not <code>![description][0]</code>';
                                } else if (errorMsg.includes('Parentheses used instead of square brackets')) {
                                    problemMsg = 'You used parentheses () for the description';
                                    fixMsg = 'Use square brackets instead: <code>![description](0)</code> not <code>!(description)(0)</code>';
                                } else if (errorMsg.includes('Curly braces used instead')) {
                                    if (errorMsg.includes('square brackets')) {
                                        problemMsg = 'You used curly braces {} for the image description';
                                        fixMsg = 'Use square brackets instead: <code>![description](0)</code> not <code>!{description}(0)</code>';
                                    } else {
                                        problemMsg = 'You used curly braces {} for the image number';
                                        fixMsg = 'Use parentheses instead: <code>![description](0)</code> not <code>![description]{0}</code>';
                                    }
                                } else if (errorMsg.includes('Space after opening (') || errorMsg.includes('Space before closing )')) {
                                    problemMsg = 'There are spaces around the image number';
                                    fixMsg = 'Remove spaces: <code>![description](0)</code> not <code>![description]( 0 )</code>';
                                } else if (errorMsg.includes('Missing closing ] bracket')) {
                                    problemMsg = 'Your image description is missing the closing ] bracket';
                                    fixMsg = 'Add the ] bracket: <code>![description](0)</code>';
                                } else if (errorMsg.includes('Missing opening [ bracket')) {
                                    problemMsg = 'Your image is missing the opening [ bracket';
                                    fixMsg = 'Add the [ bracket: <code>![description](0)</code>';
                                } else if (errorMsg.includes('Missing ! at the beginning')) {
                                    problemMsg = 'Your image is missing the ! at the start';
                                    fixMsg = 'Add the ! at the beginning: <code>![description](0)</code>';
                                } else if (errorMsg.includes('Missing opening ( parenthesis')) {
                                    problemMsg = 'Your image number is missing the opening ( parenthesis';
                                    fixMsg = 'Add the ( before the number: <code>![description](0)</code>';
                                } else if (errorMsg.includes('Missing closing ) parenthesis') || errorMsg.includes('Missing closing )')) {
                                    problemMsg = 'Your image number is missing the closing ) parenthesis';
                                    fixMsg = 'Add the ) after the number: <code>![description](0)</code>';
                                } else if (errorMsg.includes('extra characters')) {
                                    problemMsg = 'Your image syntax has extra characters after the number';
                                    fixMsg = 'Remove extra characters: <code>![description](0)</code>';
                                } else {
                                    // Use the message from the validation function
                                    problemMsg = errorMsg.split(':')[0] || problemMsg;
                                }
                                
                                const errorMatch = error.match || '';
                                
                                return `
                                    <div style="margin: 8px 0; padding: 8px; background: #fff; border-left: 3px solid #ff4d4d; border-radius: 4px;">
                                        <div style="margin-bottom: 6px;"> <strong>Image Problem:</strong> ${problemMsg}</div>
                                        <div style="margin-bottom: 6px;"> <strong>How to Fix:</strong> ${fixMsg}</div>
                                        ${errorMatch ? `
                                        <div style="font-size: 0.9em; color: #666;">
                                            <strong>What You Wrote:</strong>
                                            <code style="display: block; margin-top: 4px; padding: 6px; background: #f5f5f5; border-radius: 3px; white-space: pre-wrap; font-family: monospace; font-size: 0.85em;">${escapeHtml(errorMatch)}</code>
                                        </div>
                                        ` : ''}
                                    </div>
                                `;
                            } else if (error.type === 'newline_in_description') {
                                const escapedDesc = (error.description || '')
                                    .replace(/\n/g, '\\n')
                                    .replace(/\r/g, '\\r');
                                const errorIndex = error.index || '?';
                                return `
                                    <div style="margin: 8px 0; padding: 8px; background: #fff; border-left: 3px solid #ff4d4d; border-radius: 4px;">
                                        <div style="margin-bottom: 6px;"> <strong>Image Problem:</strong> Your image description cannot have line breaks (newlines) in it</div>
                                        <div style="margin-bottom: 6px;"> <strong>How to Fix:</strong> Keep the description on one line, no Enter/Return keys pressed</div>
                                        <div style="font-size: 0.9em; color: #666;">
                                            <strong>Image #${errorIndex} Description:</strong>
                                            <code style="display: block; margin-top: 4px; padding: 6px; background: #f5f5f5; border-radius: 3px; white-space: pre-wrap; font-family: monospace; font-size: 0.85em;">${escapeHtml(`![${escapedDesc}](${errorIndex})`)}</code>
                                        </div>
                                    </div>
                                `;
                            } else if (error.type === 'block_latex_in_description') {
                                const escapedDesc = escapeHtml(error.description || '');
                                const errorIndex = error.index || '?';
                                return `
                                    <div style="margin: 8px 0; padding: 8px; background: #fff; border-left: 3px solid #ff4d4d; border-radius: 4px;">
                                        <div style="margin-bottom: 6px;"> <strong>Image Problem:</strong> Block LaTeX ($$\\n...\\n$$) is not allowed in image descriptions</div>
                                        <div style="margin-bottom: 6px;"> <strong>How to Fix:</strong> Use inline LaTeX ($...$) instead. Change <code>$$\\nformula\\n$$</code> to <code>$formula$</code></div>
                                        <div style="font-size: 0.9em; color: #666;">
                                            <strong>Image #${errorIndex} Description:</strong>
                                            <code style="display: block; margin-top: 4px; padding: 6px; background: #f5f5f5; border-radius: 3px; white-space: pre-wrap; font-family: monospace; font-size: 0.85em;">${escapeHtml(`![${escapedDesc}](${errorIndex})`)}</code>
                                        </div>
                                    </div>
                                `;
                            } else {
                                // Fallback for any other error types
                                return `
                                    <div style="margin: 8px 0; padding: 8px; background: #fff; border-left: 3px solid #ff4d4d; border-radius: 4px;">
                                        <div style="margin-bottom: 6px;"> <strong>Image Problem:</strong> ${error.message || 'Image syntax error'}</div>
                                        ${error.match ? `
                                        <div style="font-size: 0.9em; color: #666;">
                                            <strong>What You Wrote:</strong>
                                            <code style="display: block; margin-top: 4px; padding: 6px; background: #f5f5f5; border-radius: 3px; white-space: pre-wrap; font-family: monospace; font-size: 0.85em;">${escapeHtml(error.match)}</code>
                                        </div>
                                        ` : ''}
                                    </div>
                                `;
                            }
                        }).join('')}
                    </div>
                `;
                textarea.classList.add('validation-error');
            } else {
                // Clear errors
                if (errorDiv) {
                    errorDiv.style.display = 'none';
                    errorDiv.innerHTML = '';
                }
                const hasOtherErrors = container.querySelector('.table-validation-errors')?.style.display !== 'none' ||
                                      container.querySelector('.list-validation-errors')?.style.display !== 'none' ||
                                      container.querySelector('.blockquote-validation-errors')?.style.display !== 'none' ||
                                      container.querySelector('.latex-validation-errors')?.style.display !== 'none' ||
                                      container.querySelector('.quote-validation-errors')?.style.display !== 'none' ||
                                      container.querySelector('.br-validation-errors')?.style.display !== 'none';
                if (!hasOtherErrors) {
                    textarea.classList.remove('validation-error');
                }
            }
        }
        
        /**
         * Show quote and dollar sign validation errors for a textarea
         * @param {HTMLTextAreaElement} textarea - The textarea element
         */
        function showQuoteValidationErrors(textarea) {
            if (!textarea) return;
            
            const text = textarea.value;
            const quoteErrors = validateQuotes(text);
            const dollarErrors = validateDollarSigns(text);
            
            // Find or create error container - insert right after textarea
            const container = textarea.closest('.text-field-container') || textarea.parentElement;
            if (!container) return;
            
            let errorDiv = container.querySelector('.quote-validation-errors');
            
            const allErrors = [...quoteErrors, ...dollarErrors];
            
            if (allErrors.length > 0) {
                // Show errors
                if (!errorDiv) {
                    errorDiv = document.createElement('div');
                    errorDiv.className = 'quote-validation-errors';
                    errorDiv.style.cssText = 'margin-top: 8px;';
                    // Insert right after the textarea
                    textarea.parentNode.insertBefore(errorDiv, textarea.nextSibling);
                }
                
                errorDiv.style.display = 'block';
                errorDiv.innerHTML = `
                    <div style="padding: 10px; background: #ffe6e6; border: 1px solid #ff4d4d; border-radius: 6px; color: #cc0000;">
                        <strong> Quote & Dollar Sign Errors:</strong>
                        ${allErrors.map(error => {
                            if (error.type === 'unmatched_dollar_signs') {
                                return `
                                    <div style="margin: 8px 0; padding: 8px; background: #fff3cd; border-left: 3px solid #ffc107; border-radius: 4px; color: #856404;">
                                        <div style="margin-bottom: 6px;"> <strong>Dollar Sign Warning:</strong> ${error.message}</div>
                                        <div> <strong>Note:</strong> This is a warning only and won't block saving or generation.</div>
                                    </div>
                                `;
                            } else {
                                const fixMessage = 'Each quote must have a matching pair - remove the extra or add the missing one';
                                return `
                                    <div style="margin: 8px 0; padding: 8px; background: #fff; border-left: 3px solid #ff4d4d; border-radius: 4px;">
                                        <div style="margin-bottom: 6px;"> <strong>Quote Error:</strong> ${error.message}</div>
                                        <div style="margin-bottom: 6px;"> <strong>How to Fix:</strong> ${fixMessage}</div>
                                        <div> <strong>Important:</strong> This will break JSON generation and cause data loss!</div>
                                    </div>
                                `;
                            }
                        }).join('')}
                    </div>
                `;
                textarea.classList.add('validation-error');
            } else {
                // Clear errors
                if (errorDiv) {
                    errorDiv.style.display = 'none';
                    errorDiv.innerHTML = '';
                }
                const hasOtherErrors = container.querySelector('.table-validation-errors')?.style.display !== 'none' ||
                                      container.querySelector('.list-validation-errors')?.style.display !== 'none' ||
                                      container.querySelector('.blockquote-validation-errors')?.style.display !== 'none' ||
                                      container.querySelector('.latex-validation-errors')?.style.display !== 'none' ||
                                      container.querySelector('.image-validation-errors')?.style.display !== 'none' ||
                                      container.querySelector('.br-validation-errors')?.style.display !== 'none';
                if (!hasOtherErrors) {
                    textarea.classList.remove('validation-error');
                }
            }
        }
        
        /**
         * Show <br> tag validation errors for a textarea
         * @param {HTMLTextAreaElement} textarea - The textarea element
         */
        function showBrTagValidationErrors(textarea) {
            if (!textarea) return;
            
            const text = textarea.value;
            const brErrors = validateBrTags(text);
            
            // Find or create error container - insert right after textarea
            const container = textarea.closest('.text-field-container') || textarea.parentElement;
            if (!container) return;
            
            let errorDiv = container.querySelector('.br-validation-errors');
            
            if (brErrors.length > 0) {
                // Show errors
                if (!errorDiv) {
                    errorDiv = document.createElement('div');
                    errorDiv.className = 'br-validation-errors';
                    errorDiv.style.cssText = 'margin-top: 8px;';
                    // Insert right after the textarea
                    textarea.parentNode.insertBefore(errorDiv, textarea.nextSibling);
                }
                
                errorDiv.style.display = 'block';
                errorDiv.innerHTML = `
                    <div style="padding: 10px; background: #ffe6e6; border: 1px solid #ff4d4d; border-radius: 6px; color: #cc0000;">
                        <strong> HTML Tag Errors:</strong>
                        ${brErrors.map(error => `
                            <div style="margin: 8px 0; padding: 8px; background: #fff; border-left: 3px solid #ff4d4d; border-radius: 4px;">
                                <div style="margin-bottom: 6px;"> <strong>HTML Tag Error:</strong> ${error.message}</div>
                                <div style="margin-bottom: 6px;"> <strong>How to Fix:</strong> Remove all &lt;br&gt; tags from your content. Use markdown line breaks or proper formatting instead.</div>
                                <div> <strong>Important:</strong> This will break JSON generation and cause data loss!</div>
                            </div>
                        `).join('')}
                    </div>
                `;
                textarea.classList.add('validation-error');
            } else {
                // Clear errors
                if (errorDiv) {
                    errorDiv.style.display = 'none';
                    errorDiv.innerHTML = '';
                }
                const hasOtherErrors = container.querySelector('.table-validation-errors')?.style.display !== 'none' ||
                                      container.querySelector('.list-validation-errors')?.style.display !== 'none' ||
                                      container.querySelector('.blockquote-validation-errors')?.style.display !== 'none' ||
                                      container.querySelector('.latex-validation-errors')?.style.display !== 'none' ||
                                      container.querySelector('.image-validation-errors')?.style.display !== 'none' ||
                                      container.querySelector('.quote-validation-errors')?.style.display !== 'none';
                if (!hasOtherErrors) {
                    textarea.classList.remove('validation-error');
                }
            }
        }
        
        // ========== END CATEGORY 9.8 ==========
        
        // ========== END CATEGORY 9.7 ==========
        
        // ========== END CATEGORY 9.6 ==========
        
        // ========== END CATEGORY 9.5 ==========
        
        // ========== CATEGORY 10: FILL IN THE BLANKS HELPERS ==========

        /**
         * Parse blanks from question text
         * Extracts blank numbers from ___1___, ___2___, etc.
         * @param {string} text - The question text
         * @returns {Array<number>} Array of blank numbers found
         */
        function parseBlanksFromText(text) {
            if (!text) return [];
            // Match exactly 3 underscores, number, 3 underscores
            const blankPattern = /___(\d+)___/g;
            const blanks = [];
            let match;
            while ((match = blankPattern.exec(text)) !== null) {
                blanks.push(parseInt(match[1], 10));
            }
            return blanks;
        }

        /**
         * Validate blank format in question text
         * Checks for correct format, sequential numbering, etc.
         * @param {string} text - The question text
         * @returns {Object} { valid: boolean, errors: Array<string>, blanks: Array<number> }
         */
        function validateBlankFormat(text) {
            const errors = [];
            
            if (!text || !text.trim()) {
                return { valid: true, errors: [], blanks: [] };
            }

            // Check for specific invalid patterns (only match clearly broken blank-like structures)
            // IMPORTANT: We intentionally ignore spaces around valid blanks so line breaks/spacing don't cause errors
            const invalidPatterns = [
                // Wrong number of underscores (exactly 2)
                { pattern: /(?<!_)__(\d+)__(?!_)/g, message: 'Only 2 underscores found (need exactly 3)', example: '__N__' },
                // Wrong number of underscores (1 underscore)
                { pattern: /(?<!_)_(\d+)_(?!_)/g, message: 'Only 1 underscore found (need exactly 3)', example: '_N_' },
                // Too many underscores (4 or more)
                { pattern: /____+(\d+)____+/g, message: 'Too many underscores (need exactly 3)', example: '____N____' },
                // Dashes instead of underscores
                { pattern: /---(\d+)---/g, message: 'Dashes used instead of underscores', example: '---N---' }
                // Note: We no longer flag spaces around blanks so patterns like "___1___ ___2___"
                // or line breaks between blanks are always accepted.
            ];

            for (const { pattern, message, example } of invalidPatterns) {
                const matches = text.match(pattern);
                if (matches) {
                    // Filter out valid blanks from the matches
                    const validBlanks = matches.filter(m => /^___\d+___$/.test(m));
                    const invalidMatches = matches.filter(m => !validBlanks.includes(m));
                    
                    if (invalidMatches.length > 0) {
                        errors.push(`Invalid blank format: ${message}. Found: "${invalidMatches[0].trim()}" (should be like ___1___)`);
                    }
                }
            }

            // Get valid blanks (in order as they appear in text)
            const blanks = parseBlanksFromText(text);
            
            if (blanks.length === 0) {
                // No blanks found - this is okay for fill_in_the_blanks type (they can add blanks later)
                return { valid: true, errors: [], blanks: [] };
            }

            // Check that blanks appear in correct order (1, 2, 3... as they appear in text)
            // NOT sorted - we want to check the actual order they appear
            for (let i = 0; i < blanks.length; i++) {
                const expectedNumber = i + 1;
                if (blanks[i] !== expectedNumber) {
                    errors.push(`Blanks must appear in order 1, 2, 3... in your text. Found ___${blanks[i]}___ at position ${i + 1}, expected ___${expectedNumber}___`);
                    break; // Only show first order error to avoid confusion
                }
            }

            // Check for duplicates (same blank number appears multiple times)
            const uniqueBlanks = [...new Set(blanks)];
            if (uniqueBlanks.length !== blanks.length) {
                const duplicates = blanks.filter((num, index) => blanks.indexOf(num) !== index);
                const uniqueDuplicates = [...new Set(duplicates)];
                errors.push(`Duplicate blank numbers found: ${uniqueDuplicates.map(n => `___${n}___`).join(', ')}`);
            }

            return {
                valid: errors.length === 0,
                errors,
                blanks: uniqueBlanks.sort((a, b) => a - b)
            };
        }

        /**
         * Update blank answers UI based on question text
         * Generates input fields for each detected blank
         * @param {HTMLElement} questionEl - The question container element
         */
        function updateBlankAnswersUI(questionEl) {
            const questionTextarea = questionEl.querySelector('textarea[placeholder*="Enter question text"]');
            const blanksContainer = questionEl.querySelector('#blanks-answers-container');
            
            if (!questionTextarea || !blanksContainer) return;

            const questionText = questionTextarea.value;
            const { valid, errors, blanks } = validateBlankFormat(questionText);

            // Show validation errors if any
            const errorContainer = questionEl.querySelector('#blanks-validation-errors');
            if (errorContainer) {
                if (errors.length > 0) {
                    errorContainer.style.display = 'block';
                    errorContainer.innerHTML = `
                        <div style="padding: 10px; background: #ffe6e6; border: 1px solid #ff4d4d; border-radius: 6px; color: #cc0000;">
                            <strong> Blank Format Errors:</strong>
                            <ul style="margin: 5px 0 0 20px; padding: 0;">
                                ${errors.map(err => `<li>${err}</li>`).join('')}
                            </ul>
                        </div>
                    `;
                } else {
                    errorContainer.style.display = 'none';
                    errorContainer.innerHTML = '';
                }
            }

            // Save existing blank answer values before clearing
            const existingValues = {};
            const existingBlankItems = blanksContainer.querySelectorAll('.blank-answer-item');
            existingBlankItems.forEach(item => {
                const blankNum = item.dataset.blankNumber;
                const textarea = item.querySelector('.blank-answer-input');
                if (blankNum && textarea) {
                    existingValues[blankNum] = textarea.value;
                }
            });

            // Clear existing inputs
            blanksContainer.innerHTML = '';

            if (blanks.length === 0) {
                blanksContainer.innerHTML = '<p style="color: var(--text-secondary); font-style: italic; padding: 10px;">No blanks detected. Use ___1___, ___2___, etc. in your question text.</p>';
                return;
            }

            // Show summary
            const summary = document.createElement('div');
            summary.style.cssText = 'padding: 8px 12px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 6px; margin-bottom: 15px; color: var(--text-primary);';
            summary.innerHTML = `<strong>Found ${blanks.length} blank${blanks.length > 1 ? 's' : ''}:</strong> ${blanks.map(n => `___${n}___`).join(', ')}`;
            blanksContainer.appendChild(summary);

            // Generate input fields for each blank
            blanks.forEach((blankNum) => {
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = getBlankAnswerItemHTML(blankNum, existingValues[blankNum] || '');
                const blankItem = tempDiv.firstElementChild;
                blanksContainer.appendChild(blankItem);
                
                // Set up the new textarea
                const textarea = blankItem.querySelector('textarea');
                if (textarea) {
                    textarea.setAttribute('dir', 'rtl');
                    
                    // Update filled blanks preview on input
                    textarea.addEventListener('input', () => {
                        updateFilledBlanksPreview(questionEl);
                    });
                }
                
                // Use canonical finalizer for previews, fonts, and autosize
                finalizeElement(blankItem, { previews: true, fonts: true, bbox: false, refresh: true, autoSize: true });
            });
            
            // Update the filled blanks preview
            updateFilledBlanksPreview(questionEl);
        }

        /**
         * Toggle direction for filled blanks preview
         * @param {HTMLElement} button - The button element
         */
        function toggleFilledBlanksDirection(button) {
            const questionEl = button.closest('.array-item');
            const preview = questionEl.querySelector('#filled-blanks-preview');
            
            if (!preview) return;
            
            const currentDir = preview.getAttribute('dir') || 'rtl';
            const newDir = currentDir === 'rtl' ? 'ltr' : 'rtl';
            
            preview.setAttribute('dir', newDir);
            preview.style.textAlign = newDir === 'rtl' ? 'right' : 'left';
            button.textContent = newDir === 'rtl' ? 'LTR' : 'RTL';
        }

        /**
         * Update the preview showing question with filled blanks
         * @param {HTMLElement} questionEl - The question container element
         */
        function updateFilledBlanksPreview(questionEl) {
            const questionTextarea = questionEl.querySelector('textarea[placeholder*="Enter question text"]');
            const preview = questionEl.querySelector('#filled-blanks-preview');
            const blanksContainer = questionEl.querySelector('#blanks-answers-container');
            
            if (!questionTextarea || !preview || !blanksContainer) return;
            
            let questionText = questionTextarea.value.trim();
            
            if (!questionText) {
                preview.innerHTML = '<p style="color: var(--text-secondary); font-style: italic;">Enter question text to see preview</p>';
                return;
            }
            
            // Get all blank answers
            const blankItems = blanksContainer.querySelectorAll('.blank-answer-item');
            const blankAnswers = {};
            
            blankItems.forEach(item => {
                const blankNum = item.dataset.blankNumber;
                const textarea = item.querySelector('.blank-answer-input');
                if (textarea && blankNum) {
                    blankAnswers[blankNum] = textarea.value.trim();
                }
            });
            
            // Check if all blanks have answers
            const blanks = parseBlanksFromText(questionText);
            const allFilled = blanks.every(num => blankAnswers[num]);
            
            if (!allFilled) {
                preview.innerHTML = '<p style="color: var(--text-secondary); font-style: italic;">Fill in all blank answers to see preview</p>';
                return;
            }
            
            // Replace blanks with answers
            let filledText = questionText;
            blanks.forEach(num => {
                const answer = blankAnswers[num] || '';
                // Replace ___num___ with the answer wrapped in a styled span
                const regex = new RegExp(`___${num}___`, 'g');
                filledText = filledText.replace(regex, `<span style="display: inline-block; padding: 2px 6px; background: linear-gradient(135deg, #28a745 0%, #20c997 100%); color: white; border-radius: 3px; font-weight: 600; box-shadow: 0 1px 3px rgba(0,0,0,0.2);">${answer}</span>`);
            });
            
            // Render markdown + math using the same logic as the main text preview
            // so that things like $\%$ behave identically.
            if (typeof renderLivePreview === 'function') {
                // Create a temporary hidden textarea that reuses renderLivePreview's pipeline
                const tempTextarea = document.createElement('textarea');
                tempTextarea.style.display = 'none';
                tempTextarea.value = filledText;
                
                // Insert it just before the preview so renderLivePreview finds the right target
                preview.parentElement.insertBefore(tempTextarea, preview);
                try {
                    renderLivePreview(tempTextarea);
                } finally {
                    tempTextarea.remove();
                }
            } else {
                // Fallback: basic Markdown + KaTeX rendering (should rarely be used)
                if (window.marked?.parse) {
                    try {
                        const normalizedText = normalizeEmptyListItemsForPreview(filledText);
                        let html = window.marked.parse(normalizedText);
                        preview.innerHTML = html;
                        
                        if (window.katex && window.renderMathInElement) {
                            try {
                                safeRenderMathInElement(preview, {
                                    delimiters: [
                                        { left: '$$', right: '$$', display: true },
                                        { left: '$', right: '$', display: false },
                                        { left: '\\(', right: '\\)', display: false },
                                        { left: '\\[', right: '\\]', display: true }
                                    ]
                                });
                                applyKatexBidi(preview);
                            } catch (e) {
                                // ignore math errors
                            }
                        }
                    } catch (e) {
                        preview.innerHTML = filledText.replace(/\n/g, '<br>');
                    }
                } else {
                    preview.innerHTML = filledText.replace(/\n/g, '<br>');
                }
            }
        }

        /**
         * Insert next blank at cursor position
         * @param {HTMLTextAreaElement} textarea - The textarea element
         */
        function insertBlankAtCursor(textarea) {
            const questionText = textarea.value;
            const blanks = parseBlanksFromText(questionText);
            const nextBlankNum = blanks.length > 0 ? Math.max(...blanks) + 1 : 1;
            const blankText = `___${nextBlankNum}___`;
            
            const cursorPos = textarea.selectionStart;
            const textBefore = textarea.value.substring(0, cursorPos);
            const textAfter = textarea.value.substring(cursorPos);
            
            textarea.value = textBefore + blankText + textAfter;
            
            const newCursorPos = cursorPos + blankText.length;
            textarea.setSelectionRange(newCursorPos, newCursorPos);
            textarea.focus();
            
            // Trigger preview refresh and UI update
            refreshPreviewFor(textarea);
            textarea.dispatchEvent(new Event('input', { bubbles: true }));
        }

        /**
         * Collect blank answers from UI
         * @param {HTMLElement} questionEl - The question container element
         * @returns {Array<string>} Array of answers in order
         */
        function collectBlankAnswers(questionEl) {
            const blanksContainer = questionEl.querySelector('#blanks-answers-container');
            if (!blanksContainer) return [];
            
            const blankItems = blanksContainer.querySelectorAll('.blank-answer-item');
            const answers = [];
            
            blankItems.forEach((item) => {
                const textarea = item.querySelector('.blank-answer-input');
                if (textarea) {
                    answers.push(textarea.value.trim());
                }
            });
            
            return answers;
        }

        // ========== END CATEGORY 10 ==========

        // ========== CATEGORY 11: MATCHING HELPERS ==========

        /**
         * Add a matching item to left or right list
         * @param {HTMLElement} button - The button element
         * @param {string} side - Either 'left' or 'right'
         */
        // Generic helper for inserting nested list items (choices or matching items)
        // Works for both choices and matching items with consistent behavior
        function insertNestedListItemRelative(button, options) {
            const {
                itemSelector, // '.choice-item' or '.matching-item'
                position, // 'before' or 'after'
                buildItemFn, // Function that creates and returns the new item element
                finalizeFn, // Function that finalizes the item (previews, fonts, etc.)
                getContextFn, // Function that gets context from the button
                recordMetaFn // Function that returns metadata for recordFormAction
            } = options;
            
            const currentItem = button.closest(itemSelector);
            if (!currentItem) return;
            
            const context = getContextFn(currentItem);
            if (!context) return;
            
            const container = context.containerEl;
            if (!container) return;
            
            // Determine reference item for insertion
            const referenceItem = position === 'before' ? currentItem : currentItem.nextSibling;
            
            // Build new item
            const newItem = buildItemFn(context);
            if (!newItem) return;
            
            // Insert into DOM
            if (referenceItem && referenceItem.parentNode === container) {
                container.insertBefore(newItem, referenceItem);
            } else {
                container.appendChild(newItem);
            }
            
            // Finalize the item
            finalizeFn(newItem, context);
            
            // Record action for undo/redo
            const recordMeta = recordMetaFn(newItem, context, referenceItem);
            recordFormAction({
                type: ACTION_TYPES.ADD_ITEM,
                element: newItem,
                parent: container,
                nextSibling: newItem.nextSibling,
                ...recordMeta
            });
            
            // Update UI using centralized hook
            if (context.questionEl) {
                afterQuestionTypeListMutation(context.questionEl);
            }
            if (context.updateNumbersFn) {
                context.updateNumbersFn();
            }
            
            markFormAsChanged();
            triggerAutoSave();
        }

        function addMatchingItem(button, side) {
            const questionEl = button.closest('.array-item');
            const listContainer = questionEl.querySelector(`#matching-${side}-list-${questionEl.querySelector('[id^="matching-left-list-"]').id.split('-')[3]}`);
            
            if (!listContainer) {
                console.error(`Could not find ${side} list container`);
                return;
            }
            
            const itemCount = listContainer.querySelectorAll('.matching-item').length + 1;
            
            const itemDiv = document.createElement('div');
            itemDiv.className = 'array-item matching-item';
            itemDiv.dataset.side = side;
            itemDiv.style.cssText = 'padding: 10px; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-primary);';
            
            itemDiv.innerHTML = getMatchingItemHTML(side, itemCount);
            
            listContainer.appendChild(itemDiv);
            
            // Ensure UID is assigned (must happen after DOM insertion)
            ensureMatchingUids(questionEl);
            
            // Finalize the item: apply font settings, attach previews, set RTL
            finalizeMatchingListItem(itemDiv);
            
            // Record action for undo/redo (after adding to DOM so we have the actual element)
            recordFormAction({
                type: ACTION_TYPES.ADD_ITEM,
                element: itemDiv,
                parent: listContainer,
                nextSibling: itemDiv.nextSibling,
                containerId: null,
                updateNumbers: false,
                isMatchingItem: true, // Flag to identify matching items
                questionEl: questionEl, // Store question element for UI updates
                side: side // Store which side (left/right)
            });
            
            // Update all item numbers
            updateMatchingItemNumbers(questionEl, side);
            
            // Update relationship UI
            syncMatchingUI(questionEl);
        }

        function addMatchingItemBefore(button) {
            const item = button.closest('.matching-item');
            if (!item) return;
            
            const side = item.dataset.side;
            const context = getListContext(item);
            if (!context) return;
            
            insertNestedListItemRelative(button, {
                itemSelector: '.matching-item',
                position: 'before',
                buildItemFn: (context) => {
                    const listContainer = context.containerEl;
                    const itemCount = listContainer.querySelectorAll('.matching-item').length + 1;
                    
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'array-item matching-item';
                    itemDiv.dataset.side = side;
                    itemDiv.style.cssText = 'padding: 10px; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-primary);';
                    itemDiv.innerHTML = getMatchingItemHTML(side, itemCount);
                    
                    return itemDiv;
                },
                finalizeFn: (newItem, context) => {
                    // Ensure UID is assigned (must happen after DOM insertion)
                    if (context.questionEl) {
                        ensureMatchingUids(context.questionEl);
                    }
                    finalizeMatchingListItem(newItem);
                    if (context.questionEl) {
                        updateMatchingItemNumbers(context.questionEl, side);
                    }
                },
                getContextFn: (item) => getListContext(item),
                recordMetaFn: (newItem, context, referenceItem) => ({
                    containerId: context.containerId,
                    updateNumbers: false,
                    isMatchingItem: true,
                    questionEl: context.questionEl,
                    side: side
                })
            });
        }

        function addMatchingItemAfter(button) {
            const item = button.closest('.matching-item');
            if (!item) return;
            
            const side = item.dataset.side;
            const context = getListContext(item);
            if (!context) return;
            
            insertNestedListItemRelative(button, {
                itemSelector: '.matching-item',
                position: 'after',
                buildItemFn: (context) => {
                    const listContainer = context.containerEl;
                    const itemCount = listContainer.querySelectorAll('.matching-item').length + 1;
                    
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'array-item matching-item';
                    itemDiv.dataset.side = side;
                    itemDiv.style.cssText = 'padding: 10px; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-primary);';
                    itemDiv.innerHTML = getMatchingItemHTML(side, itemCount);
                    
                    return itemDiv;
                },
                finalizeFn: (newItem, context) => {
                    // Ensure UID is assigned (must happen after DOM insertion)
                    if (context.questionEl) {
                        ensureMatchingUids(context.questionEl);
                    }
                    finalizeMatchingListItem(newItem);
                    if (context.questionEl) {
                        updateMatchingItemNumbers(context.questionEl, side);
                    }
                },
                getContextFn: (item) => getListContext(item),
                recordMetaFn: (newItem, context, referenceItem) => ({
                    containerId: context.containerId,
                    updateNumbers: false,
                    isMatchingItem: true,
                    questionEl: context.questionEl,
                    side: side
                })
            });
        }

        /**
         * Remove a matching item
         * @param {HTMLElement} button - The remove button
         */
        function removeMatchingItem(button) {
            const item = button.closest('.matching-item');
            if (!item) return;
            
            const side = item.dataset.side;
            const context = getListContext(item);
            if (!context) return;
            
            if (!confirmRemoveListItem(`matching-${side}`)) return;
            
            // Record action for undo/redo BEFORE removing
            // Preserve the actual DOM node (not a clone) for proper restoration
            recordFormAction({
                type: ACTION_TYPES.REMOVE_ITEM,
                element: item, // Preserve actual DOM node
                parent: item.parentNode,
                nextSibling: item.nextSibling,
                containerId: context.containerId,
                updateNumbers: true,
                isMatchingItem: true,
                questionEl: context.questionEl,
                side: side
            });
            
            // Remove from DOM
            item.remove();
            
            // Update UI using centralized hook
            afterQuestionTypeListMutation(context.questionEl);
            if (context.updateNumbersFn) {
                context.updateNumbersFn();
            }
            
            markFormAsChanged();
            triggerAutoSave();
        }

        /**
         * Move matching item up
         * @param {HTMLElement} button - The move button
         */
        function moveMatchingItemUp(button) {
            const item = button.closest('.matching-item');
            if (!item) return;
            
            const context = getListContext(item);
            if (!context) return;
            
            // Extra validation: sibling must also be a matching-item
            const prevItem = item.previousElementSibling;
            if (!prevItem || !prevItem.classList.contains('matching-item')) return;
            
            performItemMove({
                item: item,
                direction: 'up',
                container: context.containerEl,
                containerId: context.containerId,
                actionExtras: { isMatching: true, questionEl: context.questionEl, side: item.dataset.side },
                postMoveHook: () => {
            afterQuestionTypeListMutation(context.questionEl);
                    if (context.updateNumbersFn) context.updateNumbersFn();
            }
            });
        }

        /**
         * Move matching item down
         * @param {HTMLElement} button - The move button
         */
        function moveMatchingItemDown(button) {
            const item = button.closest('.matching-item');
            if (!item) return;
            
            const context = getListContext(item);
            if (!context) return;
            
            // Extra validation: sibling must also be a matching-item
            const nextItem = item.nextElementSibling;
            if (!nextItem || !nextItem.classList.contains('matching-item')) return;
            
            performItemMove({
                item: item,
                direction: 'down',
                container: context.containerEl,
                containerId: context.containerId,
                actionExtras: { isMatching: true, questionEl: context.questionEl, side: item.dataset.side },
                postMoveHook: () => {
            afterQuestionTypeListMutation(context.questionEl);
                    if (context.updateNumbersFn) context.updateNumbersFn();
            }
            });
        }

        /**
         * Renumber all matching items in a list container to be sequential 1, 2, 3...
         * @param {HTMLElement} listContainer - The list containing matching items
         */
        function renumberMatchingItems(listContainer) {
            // Get all items in this list
            const items = listContainer.querySelectorAll('.matching-item');
            
            // Determine if this is left or right list (check first item's data-side)
            const firstItem = items[0];
            if (!firstItem) return;
            
            const side = firstItem.dataset.side;
            const prefix = side === 'left' ? 'L' : 'R';
            
            // Renumber each item: 1, 2, 3...
            items.forEach((item, index) => {
                const strong = item.querySelector('strong');
                if (strong) {
                    strong.textContent = `${prefix}${index + 1}`;
                }
            });
        }

        /**
         * Update matching item numbers after reordering (legacy - calls renumberMatchingItems)
         * @param {HTMLElement} questionEl - The question container
         * @param {string} side - Either 'left' or 'right'
         */
        function updateMatchingItemNumbers(questionEl, side) {
            // Find the matching container
            const matchingContainer = questionEl.querySelector('#matching-container');
            if (!matchingContainer) return;
            
            // Get all matching lists
            const lists = matchingContainer.querySelectorAll('.matching-list');
            
            // Renumber both lists
            lists.forEach(list => {
                renumberMatchingItems(list);
            });
        }

        /**
         * Add a relationship between left and right items
         * @param {HTMLElement} button - The add button
         */
        function addRelationship(button) {
            const questionEl = button.closest('.array-item');
            const leftItems = questionEl.querySelectorAll('[id^="matching-left-list-"] .matching-item');
            const rightItems = questionEl.querySelectorAll('[id^="matching-right-list-"] .matching-item');
            
            if (leftItems.length === 0 || rightItems.length === 0) {
                alert('Please add items to both left and right lists before creating relationships.');
                return;
            }
            
            const relationshipsList = questionEl.querySelector('[id^="relationships-list-"]');
            if (!relationshipsList) return;
            
            // Clear placeholder if it exists
            const placeholder = relationshipsList.querySelector('p');
            if (placeholder) {
                placeholder.remove();
            }
            
            const relationshipDiv = document.createElement('div');
            relationshipDiv.className = 'relationship-item';
            relationshipDiv.style.cssText = 'display: flex; align-items: center; gap: 10px; padding: 10px; background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 6px;';
            
            // Build options for left items
            let leftOptions = '<option value="">Select Left Item</option>';
            leftItems.forEach((item, index) => {
                leftOptions += `<option value="${index + 1}">L${index + 1}</option>`;
            });
            
            // Build options for right items
            let rightOptions = '<option value="">Select Right Item</option>';
            rightItems.forEach((item, index) => {
                rightOptions += `<option value="${index + 1}">R${index + 1}</option>`;
            });
            
            relationshipDiv.innerHTML = `
                <select class="relationship-left" style="flex: 1; padding: 6px; background: var(--bg-secondary); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 4px;" title="Select a left item to connect">
                    ${leftOptions}
                </select>
                <span style="color: var(--text-secondary); font-weight: bold;"></span>
                <select class="relationship-right" style="flex: 1; padding: 6px; background: var(--bg-secondary); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 4px;" title="Select a right item to connect">
                    ${rightOptions}
                </select>
                ${buildActionButtonsHTML(ACTION_BUTTON_CONFIGS.RELATIONSHIP)}
            `;
            
            relationshipsList.appendChild(relationshipDiv);
            
            // Finalize the relationship item: apply font settings
            finalizeMatchingListItem(relationshipDiv);
            
            // Record action for undo/redo (after adding to DOM so we have the actual element)
            recordFormAction({
                type: ACTION_TYPES.ADD_ITEM,
                element: relationshipDiv,
                parent: relationshipsList,
                nextSibling: relationshipDiv.nextSibling,
                containerId: null,
                updateNumbers: false,
                isRelationship: true,
                questionEl: questionEl
            });
            
            // Update UI using centralized hook
            afterQuestionTypeListMutation(questionEl);
            
            markFormAsChanged();
            triggerAutoSave();
        }

        /**
         * Remove a relationship
         * @param {HTMLElement} button - The remove button
         */
        function removeRelationship(button) {
            const relationshipDiv = button.closest('.relationship-item');
            if (!relationshipDiv) return;
            
            const relationshipsList = relationshipDiv.parentElement;
            const questionEl = relationshipDiv.closest('.array-item');
            
            if (!questionEl) return;
            
            // Confirm deletion using existing confirmation pattern
            if (!confirmRemoveListItem('relationship')) {
                return;
            }
            
            // Record action for undo/redo BEFORE removing
            // Preserve the actual DOM node (not a clone) for proper restoration
            recordFormAction({
                type: ACTION_TYPES.REMOVE_ITEM,
                element: relationshipDiv, // Preserve actual DOM node
                parent: relationshipsList,
                nextSibling: relationshipDiv.nextSibling,
                containerId: null,
                updateNumbers: false,
                isRelationship: true,
                questionEl: questionEl
            });
            
            // Remove from DOM
            relationshipDiv.remove();
            
            // Add placeholder if no relationships left
            if (relationshipsList.querySelectorAll('.relationship-item').length === 0) {
                relationshipsList.innerHTML = '<p style="color: var(--text-secondary); font-style: italic; margin: 0;">No relationships added yet. Click "Add Relationship" to connect items.</p>';
            }
            
            // Update UI using centralized hook
            afterQuestionTypeListMutation(questionEl);
            
            markFormAsChanged();
            triggerAutoSave();
        }

        // Rebuild matching relationship UI (UID-based)
        function rebuildMatchingRelationshipUI(questionEl) {
            if (!questionEl) return;
            
            ensureMatchingUids(questionEl);
            
            const relationshipsList = questionEl.querySelector('[id^="relationships-list-"]');
            if (!relationshipsList) return;
            
            const relationships = relationshipsList.querySelectorAll('.relationship-item');
            const leftItems = questionEl.querySelectorAll('[id^="matching-left-list-"] .matching-item');
            const rightItems = questionEl.querySelectorAll('[id^="matching-right-list-"] .matching-item');
            
            // Create UID-to-index maps for display
            const leftUidToIndex = new Map();
            const rightUidToIndex = new Map();
            leftItems.forEach((item, index) => {
                const uid = item.dataset.leftUid;
                if (uid) leftUidToIndex.set(uid, index + 1);
            });
            rightItems.forEach((item, index) => {
                const uid = item.dataset.rightUid;
                if (uid) rightUidToIndex.set(uid, index + 1);
            });
            
            // Rebuild options for each relationship
            relationships.forEach(relDiv => {
                const leftSelect = relDiv.querySelector('.relationship-left');
                const rightSelect = relDiv.querySelector('.relationship-right');
                if (!leftSelect || !rightSelect) return;
                
                // Get stored UIDs (canonical truth)
                const storedLeftUid = relDiv.dataset.leftUid || null;
                const storedRightUid = relDiv.dataset.rightUid || null;
                
                // Rebuild left options
                let leftOptions = '<option value="">Select Left Item</option>';
                let hasValidLeftSelection = false;
                leftItems.forEach((item, index) => {
                    const leftUid = item.dataset.leftUid;
                    if (!leftUid) return;
                    const position = index + 1;
                    const selected = storedLeftUid === leftUid ? 'selected' : '';
                    if (selected) hasValidLeftSelection = true;
                    leftOptions += `<option value="${leftUid}" ${selected}>L${position}</option>`;
                });
                leftSelect.innerHTML = leftOptions;
                
                // If stored UID exists and is valid, restore selection
                // If stored UID doesn't exist yet, show placeholder but KEEP the UID in dataset
                // This allows undo/redo to restore the selection automatically when item is restored
                if (storedLeftUid) {
                    if (hasValidLeftSelection) {
                        leftSelect.value = storedLeftUid; // Restore selection if UID exists
                    } else {
                        leftSelect.value = ''; // Show placeholder, but keep dataset.leftUid for undo/redo
                    }
                }
                
                // Rebuild right options
                let rightOptions = '<option value="">Select Right Item</option>';
                let hasValidRightSelection = false;
                rightItems.forEach((item, index) => {
                    const rightUid = item.dataset.rightUid;
                    if (!rightUid) return;
                    const position = index + 1;
                    const selected = storedRightUid === rightUid ? 'selected' : '';
                    if (selected) hasValidRightSelection = true;
                    rightOptions += `<option value="${rightUid}" ${selected}>R${position}</option>`;
                });
                rightSelect.innerHTML = rightOptions;
                
                // If stored UID exists and is valid, restore selection
                // If stored UID doesn't exist yet, show placeholder but KEEP the UID in dataset
                // This allows undo/redo to restore the selection automatically when item is restored
                if (storedRightUid) {
                    if (hasValidRightSelection) {
                        rightSelect.value = storedRightUid; // Restore selection if UID exists
                    } else {
                        rightSelect.value = ''; // Show placeholder, but keep dataset.rightUid for undo/redo
                    }
                }
                
                // Update stored UIDs when selection changes
                leftSelect.addEventListener('change', () => {
                    const selectedUid = leftSelect.value;
                    if (selectedUid) {
                        relDiv.dataset.leftUid = selectedUid;
                    } else {
                        delete relDiv.dataset.leftUid;
                    }
                    markFormAsChanged();
                    triggerAutoSave();
                });
                
                rightSelect.addEventListener('change', () => {
                    const selectedUid = rightSelect.value;
                    if (selectedUid) {
                        relDiv.dataset.rightUid = selectedUid;
                    } else {
                        delete relDiv.dataset.rightUid;
                    }
                    markFormAsChanged();
                    triggerAutoSave();
                });
            });
        }
        
        // Legacy alias for backward compatibility
        function updateRelationshipUI(questionEl) {
            rebuildMatchingRelationshipUI(questionEl);
        }
        
        // Single canonical UI sync helper for matching
        // Ensures UIDs exist and rebuilds relationship UI
        function syncMatchingUI(questionEl) {
            if (!questionEl) return;
            
            const questionType = getQuestionType(questionEl);
            if (questionType !== 'matching') return;
            
            ensureMatchingUids(questionEl);
            rebuildMatchingRelationshipUI(questionEl);
            
            // Spawn finalization: force-fit textareas/previews in this question with current content
            if (typeof AutoSizeManager !== 'undefined' && AutoSizeManager.finalizeSpawn) {
                AutoSizeManager.finalizeSpawn(questionEl);
            }
        }
        
        // Centralized hook called after any question-type list mutation (choices, matching items, relationships)
        // Ensures UIDs are present, rebuilds dependent UIs, and applies font settings/previews
        function afterQuestionTypeListMutation(questionEl) {
            if (!questionEl) return;
            
            const questionType = getQuestionType(questionEl);
            
            // Use centralized sync helpers
            if (questionType === 'multiple_choice' || questionType === 'checkbox') {
                syncChoiceUI(questionEl);
            } else if (questionType === 'matching') {
                syncMatchingUI(questionEl);
            }
            
            // Spawn finalization: force-fit textareas/previews in this question with current content
            if (typeof AutoSizeManager !== 'undefined' && AutoSizeManager.finalizeSpawn) {
                AutoSizeManager.finalizeSpawn(questionEl);
            }
        }

        /**
         * Collect matching data from UI
         * @param {HTMLElement} questionEl - The question container
         * @returns {Object} { left: Array, right: Array, relationship: Array }
         */
        function collectMatchingData(questionEl) {
            ensureMatchingUids(questionEl);
            const leftItems = questionEl.querySelectorAll('[id^="matching-left-list-"] .matching-item');
            const rightItems = questionEl.querySelectorAll('[id^="matching-right-list-"] .matching-item');
            const relationships = questionEl.querySelectorAll('[id^="relationships-list-"] .relationship-item');
            
            const left = [];
            const leftUidToIndex = new Map();
            leftItems.forEach((item, index) => {
                const textarea = item.querySelector('.matching-item-text');
                if (textarea) {
                    left.push(textarea.value.trim());
                }
                const uid = item.dataset.leftUid;
                if (uid) leftUidToIndex.set(uid, index + 1);
            });
            
            const right = [];
            const rightUidToIndex = new Map();
            rightItems.forEach((item, index) => {
                const textarea = item.querySelector('.matching-item-text');
                if (textarea) {
                    right.push(textarea.value.trim());
                }
                const uid = item.dataset.rightUid;
                if (uid) rightUidToIndex.set(uid, index + 1);
            });
            
            const relationship = [];
            relationships.forEach(relDiv => {
                const leftUid = relDiv.dataset.leftUid;
                const rightUid = relDiv.dataset.rightUid;
                // Convert UIDs to indices for export
                const leftIndex = leftUid ? (leftUidToIndex.get(leftUid) || 0) : 0;
                const rightIndex = rightUid ? (rightUidToIndex.get(rightUid) || 0) : 0;
                
                if (leftIndex && rightIndex) {
                    relationship.push([leftIndex, rightIndex]);
                }
            });
            
            return { left, right, relationship };
        }

        // ========== END CATEGORY 11 ==========

        // ========== CATEGORY 4 REFACTORING: Validation Helper Functions ==========
        
        /**
         * Extract text indices for content section
         * @param {Object} content - Content section object
         * @returns {Object} Object with allIndices and uniqueIndices
         */
        function getContentTextIndices(content) {
            const text = content.text || '';
            const allIndices = extractAllImageIndices(text);
            const uniqueIndices = getUniqueIndices(allIndices);
            return { allIndices, uniqueIndices };
        }

        /**
         * Extract text indices for question section (handles MCQ, checkbox, matching, and free-form)
         * @param {Object} question - Question object
         * @returns {Object} Object with questionIndices, guideIndices, and their unique versions
         */
        function getQuestionTextIndices(question) {
            const questionText = question.question_text || '';
            const setupText = question.set_up_text || '';
            const guideAnswer = question.guide_answer || '';
            const questionType = question.question_type || 'free_form';
            const choices = question.choices || [];
            const leftItems = question.left || [];
            const rightItems = question.right || [];
            
            // Get question + setup indices
            let allQuestionIndices = extractAllImageIndices([setupText, questionText]);
            
            // Add choice indices for multiple_choice and checkbox
            if ((questionType === 'multiple_choice' || questionType === 'checkbox') && choices.length > 0) {
                choices.forEach((choice) => {
                    allQuestionIndices.push(...extractAllImageIndices(choice.text || ''));
                });
            }

            // Add left and right item indices for matching
            if (questionType === 'matching') {
                // Add all left items
                leftItems.forEach((item) => {
                    allQuestionIndices.push(...extractAllImageIndices(item || ''));
                });
                // Add all right items
                rightItems.forEach((item) => {
                    allQuestionIndices.push(...extractAllImageIndices(item || ''));
                });
            }
            
            const uniqueQuestionIndices = getUniqueIndices(allQuestionIndices);
            
            // Get guide answer indices (separate array for both multiple_choice and free-form)
            const allGuideIndices = extractAllImageIndices(guideAnswer);
            const uniqueGuideIndices = getUniqueIndices(allGuideIndices);
            
            return {
                allQuestionIndices,
                uniqueQuestionIndices,
                allGuideIndices,
                uniqueGuideIndices
            };
        }

        // ========== END CATEGORY 4 REFACTORING ==========

        // Get the next available image index for a given textarea
        function getNextImageIndex(textarea) {
            if (!textarea) return 0;
            
            const text = textarea.value || '';
            const existingIndices = extractImageIndices(text);
            
            if (existingIndices.length === 0) {
                return 0;
            }
            
            // Convert to numbers and find the highest index
            const numericIndices = existingIndices.map(idx => parseInt(idx)).filter(idx => !isNaN(idx));
            if (numericIndices.length === 0) {
                return 0;
            }
            
            const maxIndex = Math.max(...numericIndices);
            return maxIndex + 1;
        }

        // Validate block LaTeX content and return errors
        function validateImageDescriptions(content) {
            const errors = [];
            if (!content || content.trim().length === 0) {
                return errors; // Skip empty content
            }
            
            let md = content.replace(/\r\n?/g, '\n');
            
            // Check if there are any image-like patterns to validate
            const hasImagePattern = md.includes('![') || /\[([^\]]{1,100})\]\(\d+\)/.test(md);
            if (!hasImagePattern) {
                return errors; // No images to validate
            }
            
            // Protect LaTeX math expressions inside image descriptions before validation
            // This prevents false positives when descriptions contain LaTeX like $...$ or $\sqrt[3]{3}$
            const latexPlaceholders = [];
            let placeholderIndex = 0;
            
            // First, protect ALL inline math $...$ in the entire text
            // This must happen BEFORE we try to match image patterns, because LaTeX can contain brackets
            // that would confuse the image pattern matching (e.g., $\sqrt[3]{16}$)
            md = md.replace(/\$([^$\n]{1,200}?)\$/g, (mathMatch, mathContent) => {
                // Only protect if it looks like actual math (has some content and isn't just $$)
                if (mathContent.trim().length > 0) {
                    const placeholder = `@@LATEX_INLINE_IMG_${placeholderIndex}@@`;
                    latexPlaceholders[placeholderIndex] = mathMatch;
                    placeholderIndex++;
                    return placeholder;
                }
                return mathMatch; // Don't protect if it's malformed
            });
            
            // Check for malformed image syntax patterns
            const malformedPatterns = [
                { regex: /!\[([^\]]*?)\]\s+\(\d+\)/g, message: 'Space between ] and ( in image syntax' },  // ![desc] (0)
                { regex: /!\s+\[([^\]]*?)\]\(\d+\)/g, message: 'Space between ! and [ in image syntax' },  // ! [desc](0)
                { regex: /!\[([^\]]*?)\]\[\d+\]/g, message: 'Square brackets used instead of parentheses for image index' },  // ![desc][0]
                { regex: /!\(([^)]*?)\)\(\d+\)/g, message: 'Parentheses used instead of square brackets for image description' },  // !(desc)(0)
                { regex: /!\[([^\]]*?)\]\s*\[\s*\d+\s*\]/g, message: 'Square brackets used instead of parentheses for image index' },  // ![desc][0] with spaces
                { regex: /!\{([^}]*?)\}\(\d+\)/g, message: 'Curly braces used instead of square brackets for image description' },  // !{desc}(0)
                { regex: /!\[([^\]]*?)\]\{\d+\}/g, message: 'Curly braces used instead of parentheses for image index' },  // ![desc]{0}
                // Spaces inside parentheses for index
                { regex: /!\[([^\]]*?)\]\(\s+\d+\)/g, message: 'Space after opening ( in image index' },  // ![desc]( 0)
                { regex: /!\[([^\]]*?)\]\(\d+\s+\)/g, message: 'Space before closing ) in image index' },  // ![desc](0 )
                // Missing brackets patterns
                { regex: /!\[([^\]\n]{1,100})\(\d+\)/g, message: 'Missing closing ] bracket in image description' },  // ![desc(0) - no ] before (
                { regex: /!([a-zA-Z][^\[\]\n]{0,100})\]\(\d+\)/g, message: 'Missing opening [ bracket in image description' },  // !desc](0) - starts with letter, no [ after !
                { regex: /!\[([^\]]*?)\]\d+\)/g, message: 'Missing opening ( parenthesis in image index' },  // ![desc]0) - digit directly after ]
                { regex: /!\[([^\]]*?)\]\(\d+[^\)\s]/g, message: 'Missing closing ) parenthesis in image index or extra characters' },  // ![desc](0X - digit followed by non-) non-space
                { regex: /!\[([^\]]*?)\]\(\d+$/gm, message: 'Missing closing ) parenthesis in image index' },  // ![desc](0 - ends without )
                // Missing ! at the beginning - matches [desc](digit) that looks like it should be an image
                { regex: /(?<![!\w])\[([^\]]{1,100})\]\(\d+\)/g, message: 'Missing ! at the beginning of image syntax' }  // [desc](0) - no ! before [
            ];
            
            malformedPatterns.forEach(pattern => {
                const matches = md.match(pattern.regex);
                if (matches) {
                    matches.forEach(match => {
                        errors.push({
                            type: 'malformed_image_syntax',
                            message: `${pattern.message}: "${match.substring(0, 50)}${match.length > 50 ? '...' : ''}"`,
                            match: match
                        });
                    });
                }
            });
            
            // Check for newlines in image descriptions BEFORE restoring LaTeX
            // This prevents false positives from LaTeX commands like \neq or \right(
            // We check while LaTeX is still protected as placeholders
            const imageMatchesBeforeRestore = md.match(/!\[([\s\S]*?)\]\(\d+\)/g);
            if (imageMatchesBeforeRestore) {
                imageMatchesBeforeRestore.forEach(match => {
                    // Extract the description part
                    const descMatch = match.match(/!\[([\s\S]*?)\]\(/);
                    if (descMatch && descMatch[1]) {
                        let description = descMatch[1];
                        
                        // Temporarily restore LaTeX to check the full description
                        // Then remove LaTeX expressions to check for newlines outside of LaTeX
                        latexPlaceholders.forEach((latex, idx) => {
                            description = description.replace(`@@LATEX_INLINE_IMG_${idx}@@`, latex);
                        });
                        
                        // Check for block LaTeX ($$\n...\n$$) in image description - not allowed
                        if (description.includes('$$')) {
                            // Extract the index
                            const indexMatch = match.match(/\]\((\d+)\)/);
                            const index = indexMatch ? indexMatch[1] : '?';
                            errors.push({
                                type: 'block_latex_in_description',
                                message: `Block LaTeX ($$\\n...\\n$$) is not allowed in image descriptions. Use inline LaTeX ($...$) instead (image index: ${index})`,
                                description: description,
                                index: index
                            });
                        }
                        
                        // Remove all LaTeX expressions (inline and block) before checking for newlines
                        // This ensures LaTeX commands like \neq or \right( don't trigger false positives
                        const descriptionWithoutMath = removeMathExpressions(description);
                        
                        // Check if description contains newlines (both literal \n and actual newlines)
                        // Only check the parts outside of LaTeX expressions
                        if (descriptionWithoutMath.includes('\n') || descriptionWithoutMath.includes('\r') || descriptionWithoutMath.includes('\\n') || descriptionWithoutMath.includes('\\r')) {
                            // Extract the index
                            const indexMatch = match.match(/\]\((\d+)\)/);
                            const index = indexMatch ? indexMatch[1] : '?';
                            errors.push({
                                type: 'newline_in_description',
                                message: `Image description cannot contain newline characters (image index: ${index})`,
                                description: description,
                                index: index
                            });
                        }
                    }
                });
            }
            
            // Restore LaTeX math expressions after validation (for any remaining processing)
            latexPlaceholders.forEach((latex, idx) => {
                md = md.replace(`@@LATEX_INLINE_IMG_${idx}@@`, latex);
            });
            
            return errors;
        }

        /**
         * Validate that blanks (___i___) are not written inside LaTeX expressions
         * @param {string} content - The text to check
         * @returns {Array} Array of error objects
         */
        function validateBlanksInLatex(content) {
            const errors = [];
            if (!content || content.trim().length === 0) {
                return errors; // Skip empty content
            }
            
            // Pattern to match blanks: ___1___, ___2___, etc.
            const blankPattern = /___(\d+)___/g;
            
            // Find all LaTeX expressions (both inline $...$ and block $$...$$)
            // First, find block LaTeX ($$...$$) - handle both formats
            const blockLatexPattern = /\$\$[\s\S]*?\$\$/g;
            const blockRanges = [];
            let blockMatch;
            blockLatexPattern.lastIndex = 0;
            
            // Process block LaTeX and track their positions
            while ((blockMatch = blockLatexPattern.exec(content)) !== null) {
                const match = blockMatch[0];
                const startPos = blockMatch.index;
                const endPos = startPos + match.length;
                
                // Track this block LaTeX range
                blockRanges.push({ start: startPos, end: endPos });
                
                // Check if this block LaTeX contains any blanks
                const blankMatches = match.match(blankPattern);
                if (blankMatches) {
                    // Extract the content inside the LaTeX (without the $$ delimiters)
                    const innerContent = match.replace(/^\$\$/, '').replace(/\$\$$/, '');
                    blankMatches.forEach(blankMatch => {
                        errors.push({
                            type: 'blank_in_latex',
                            message: `Blank ${blankMatch} cannot be written inside LaTeX. Blanks should be outside LaTeX expressions.`,
                            content: innerContent,
                            blank: blankMatch
                        });
                    });
                }
            }
            
            // Find all inline LaTeX expressions
            const inlineLatexPattern = /\$[^$\n]*?\$/g;
            let inlineMatch;
            inlineLatexPattern.lastIndex = 0;
            
            while ((inlineMatch = inlineLatexPattern.exec(content)) !== null) {
                const match = inlineMatch[0];
                const startPos = inlineMatch.index;
                const endPos = startPos + match.length;
                
                // Check if this inline LaTeX is inside a block LaTeX
                const isInsideBlock = blockRanges.some(range => 
                    startPos >= range.start && endPos <= range.end
                );
                
                if (!isInsideBlock) {
                    // This is a genuine inline LaTeX expression
                    // Check if it contains any blanks
                    const blankMatches = match.match(blankPattern);
                    if (blankMatches) {
                        // Extract the content inside the LaTeX (without the $ delimiters)
                        const innerContent = match.replace(/^\$/, '').replace(/\$$/, '');
                        blankMatches.forEach(blankMatch => {
                            errors.push({
                                type: 'blank_in_latex',
                                message: `Blank ${blankMatch} cannot be written inside LaTeX. Blanks should be outside LaTeX expressions.`,
                                content: innerContent,
                                blank: blankMatch
                            });
                        });
                    }
                }
            }
            
            return errors;
        }

        function validateBlockLatex(content) {
            const errors = [];
            if (!content || content.trim().length === 0) {
                return errors; // Skip empty content
            }
            
            let md = content.replace(/\r\n?/g, '\n');
            
            // Only check for block LaTeX if there are $$ patterns
            if (!md.includes('$$')) {
                return errors; // No block LaTeX to validate
            }
            
            // Check for old format $$...$$ (without newlines) and show error
            const oldFormatMatches = md.match(/\$\$([\s\S]*?)\$\$/g);
            if (oldFormatMatches) {
                oldFormatMatches.forEach(match => {
                    // Skip if this is already a valid newline format
                    if (!match.match(/^\$\$\s*\\n[\s\S]*?\\n\s*\$\$$/)) {
                        // Make sure this is actually block LaTeX (not just $$ in text)
                        const inner = match.replace(/^\$\$/, '').replace(/\$\$$/, '');
                        if (inner.trim().length > 0) { // Only error if there's actual content
                            errors.push({
                                type: 'incorrect_delimiters',
                                message: 'Block latex must use newline delimiters: $$\\n...\\n$$ or $$ \\n...\\n $$',
                                content: inner
                            });
                        }
                    }
                });
            }
            
            // Check for valid format with extra newlines
            const validFormatMatches = md.match(/\$\$\s*\\n([\s\S]*?)\\n\s*\$\$/g);
            if (validFormatMatches) {
                validFormatMatches.forEach(match => {
                    const innerMatch = match.match(/\$\$\s*\\n([\s\S]*?)\\n\s*\$\$/);
                    if (innerMatch) {
                        const inner = innerMatch[1];
                        // Check for extra newlines inside the content
                        if (inner.includes('\\n') || inner.includes('\n')) {
                            errors.push({
                                type: 'extra_newlines',
                                message: 'Block latex cannot contain extra newline characters inside the content',
                                content: inner
                            });
                        }
                        // Check for empty content
                        if (inner.trim().length === 0) {
                            errors.push({
                                type: 'empty_content',
                                message: 'Block latex cannot be empty',
                                content: inner
                            });
                        }
                    }
                });
            }
            
            return errors;
        }

        // Validate <br> tags in content
        function validateBrTags(content) {
            const errors = [];
            if (!content || content.trim().length === 0) {
                return errors; // Skip empty content
            }
            
            // Check for <br> tags (case insensitive, with or without closing tag)
            const brPattern = /<br\s*\/?>/gi;
            const matches = content.match(brPattern);
            if (matches && matches.length > 0) {
                errors.push({
                    type: 'br_tag',
                    message: `<br> tags are not allowed in the content. Found ${matches.length} occurrence(s).`
                });
            }
            
            return errors;
        }

        // Validate unmatched quotes that would break JSON
        function validateQuotes(content) {
            const errors = [];
            if (!content || content.trim().length === 0) {
                return errors; // Skip empty content
            }
            
            // Count unescaped double quotes - if odd number, they are unmatched
            const unescapedQuotes = (content.match(/(?<!\\)"/g) || []).length;
            if (unescapedQuotes > 0 && unescapedQuotes % 2 !== 0) {
                errors.push({
                    type: 'unmatched_quotes',
                    message: `Text contains ${unescapedQuotes} double quote(s) that are not properly matched. Each quote must have a matching pair - remove the extra or add the missing one.`
                });
            }
            
            return errors;
        }
        
        function validateDollarSigns(content) {
            const errors = [];
            if (!content || content.trim().length === 0) {
                return errors; // Skip empty content
            }
            
            // Count unescaped dollar signs - if odd number, they are unmatched
            const unescapedDollars = (content.match(/(?<!\\)\$/g) || []).length;
            if (unescapedDollars > 0 && unescapedDollars % 2 !== 0) {
                errors.push({
                    type: 'unmatched_dollar_signs',
                    message: `Text contains ${unescapedDollars} dollar sign(s) that are not properly matched. Each $ should have a matching pair for LaTeX math. Please review and correct if needed.`
                });
            }
            
            return errors;
        }
        
        // Get a descriptive location for a textarea element
        function getTextareaLocation(textarea) {
            // Check if textarea is in content sections container
            if (textarea.closest('#content_sections_container')) {
                // Find which main content section this textarea belongs to
                const contentSections = document.querySelectorAll('#content_sections_container > .array-item');
                for (let i = 0; i < contentSections.length; i++) {
                    if (contentSections[i].contains(textarea)) {
                        return `Content Section ${i + 1}`;
                    }
                }
            }
            
            // Check if textarea is in questions container
            if (textarea.closest('#questions_container')) {
                // Find which main question this textarea belongs to
                const questions = document.querySelectorAll('#questions_container > .array-item');
                for (let i = 0; i < questions.length; i++) {
                    if (questions[i].contains(textarea)) {
                        return `Question ${i + 1}`;
                    }
                }
            }
            
            // Check for specific form fields
            const textareaId = textarea.id;
            if (textareaId) {
                switch (textareaId) {
                    case 'lesson_preamble':
                        return 'Lesson Preamble';
                    default:
                        return `Field "${textareaId}"`;
                }
            }
            
            // Check for label text
            const label = textarea.previousElementSibling?.textContent?.trim();
            if (label && label.length > 0 && label.length < 50) {
                return label.replace(':', '').trim();
            }
            
            // Check parent container for clues
            const parent = textarea.closest('.form-group, .array-item, .form-section');
            if (parent) {
                const parentLabel = parent.querySelector('label')?.textContent?.trim();
                if (parentLabel) {
                    return parentLabel.replace(':', '').trim();
                }
            }
            
            return 'Unknown Location';
        }

        function generateJSON() {
            // If PDF viewer is active, switch to JSON preview
            const pdfBtn = document.getElementById('toggle-pdf-btn');
            if (pdfBtn && pdfBtn.classList.contains('active')) {
                showJsonPreview();
            }
            
            // Validate basic form data
            const textbookPage = document.getElementById('textbook_page').value;
            const textbookPdfPage = document.getElementById('textbook_pdf_page').value;
            const guidebookStart = document.getElementById('guidebook_start_page').value;
            const guidebookEnd = document.getElementById('guidebook_end_page').value;
            const pageType = document.getElementById('page_type').value;
            
            // Validation
            const validationErrors = [];
            const validationWarnings = [];
            
            if (!textbookPage) {
                validationErrors.push("Textbook page is required");
            } else if (!Number.isInteger(parseFloat(textbookPage))) {
                validationErrors.push("Textbook page must be a whole number");
            }
            if (!textbookPdfPage) {
                validationErrors.push("Textbook PDF page is required");
            } else if (!Number.isInteger(parseFloat(textbookPdfPage))) {
                validationErrors.push("Textbook PDF page must be a whole number");
            }
            if (!guidebookStart) {
                validationErrors.push("Guidebook start page is required");
            } else if (!Number.isInteger(parseFloat(guidebookStart))) {
                validationErrors.push("Guidebook start page must be a whole number");
            }
            if (!guidebookEnd) {
                validationErrors.push("Guidebook end page is required");
            } else if (!Number.isInteger(parseFloat(guidebookEnd))) {
                validationErrors.push("Guidebook end page must be a whole number");
            }
            if (guidebookStart && guidebookEnd && parseInt(guidebookStart) > parseInt(guidebookEnd)) {
                validationErrors.push("Guidebook start page cannot be greater than end page");
            }
            if (!pageType || pageType.trim().length === 0) {
                validationErrors.push("Page type is required");
            }
            
            // Validate no duplicate question IDs
            const questionIds = new Map(); // Map to track question IDs and their locations
            const questionContainers = document.querySelectorAll('#questions_container > .array-item');
            questionContainers.forEach((questionEl, index) => {
                const questionIdInput = findFieldByLabel(questionEl, 'Question ID', 'input');
                if (questionIdInput && questionIdInput.value && questionIdInput.value.trim()) {
                    const qid = questionIdInput.value.trim();
                    if (questionIds.has(qid)) {
                        const firstLocation = questionIds.get(qid);
                        validationErrors.push(`Duplicate Question ID "${qid}" found in Question ${index + 1} (also in Question ${firstLocation})`);
                    } else {
                        questionIds.set(qid, index + 1);
                    }
                }
            });
            
            // Validate block LaTeX in all content sections and questions (exclude output fields)
            const allTextareas = document.querySelectorAll('textarea');
            allTextareas.forEach((textarea, index) => {
                // Skip validation for output/display fields
                const textareaId = textarea.id;
                if (textareaId === 'json_input' || textareaId === 'json_output' || 
                    textarea.classList.contains('output-field') || 
                    textarea.hasAttribute('readonly')) {
                    return; // Skip this textarea
                }
                
                const content = textarea.value || '';
                const mathBlockErrors = validateBlockLatex(content);
                if (mathBlockErrors.length > 0) {
                    const location = getTextareaLocation(textarea);
                    mathBlockErrors.forEach(error => {
                        validationErrors.push(`Block LaTeX Error in ${location}: ${error.message}`);
                    });
                }
                
                // Validate blanks in LaTeX
                const blanksInLatexErrors = validateBlanksInLatex(content);
                if (blanksInLatexErrors.length > 0) {
                    const location = getTextareaLocation(textarea);
                    blanksInLatexErrors.forEach(error => {
                        validationErrors.push(`Blank in LaTeX Error in ${location}: ${error.message}`);
                    });
                }
                
                const imageDescErrors = validateImageDescriptions(content);
                if (imageDescErrors.length > 0) {
                    const location = getTextareaLocation(textarea);
                    imageDescErrors.forEach(error => {
                        validationErrors.push(`Image Description Error in ${location}: ${error.message}`);
                    });
                }
                
                const quoteErrors = validateQuotes(content);
                if (quoteErrors.length > 0) {
                    const location = getTextareaLocation(textarea);
                    quoteErrors.forEach(error => {
                        validationErrors.push(`Quote Error in ${location}: ${error.message}`);
                    });
                }
                
                const dollarErrors = validateDollarSigns(content);
                if (dollarErrors.length > 0) {
                    const location = getTextareaLocation(textarea);
                    dollarErrors.forEach(error => {
                        validationWarnings.push(`Dollar Sign Warning in ${location}: ${error.message}`);
                    });
                }
                
                // Validate <br> tags
                const brErrors = validateBrTags(content);
                if (brErrors.length > 0) {
                    const location = getTextareaLocation(textarea);
                    brErrors.forEach(error => {
                        validationErrors.push(`HTML Tag Error in ${location}: ${error.message}`);
                    });
                }
                
                // Validate table markdown
                const tableValidation = validateTableMarkdown(content);
                if (tableValidation.hasTables && !tableValidation.valid && tableValidation.errors.length > 0) {
                    const location = getTextareaLocation(textarea);
                    tableValidation.errors.forEach(error => {
                        const errorMsg = typeof error === 'string' ? error : error.message;
                        validationErrors.push(`Table Markdown Error in ${location}: ${errorMsg}`);
                    });
                }
                
                // Validate list markdown
                const listValidation = validateListMarkdown(content);
                if (listValidation.hasLists && !listValidation.valid && listValidation.errors.length > 0) {
                    const location = getTextareaLocation(textarea);
                    listValidation.errors.forEach(error => {
                        const errorMsg = typeof error === 'string' ? error : error.message;
                        validationErrors.push(`List Markdown Error in ${location}: ${errorMsg}`);
                    });
                }
                
                // Validate blockquote markdown
                const blockquoteValidation = validateBlockquoteMarkdown(content);
                if (blockquoteValidation.hasBlockquotes && !blockquoteValidation.valid && blockquoteValidation.errors.length > 0) {
                    const location = getTextareaLocation(textarea);
                    blockquoteValidation.errors.forEach(error => {
                        const errorMsg = typeof error === 'string' ? error : error.message;
                        validationErrors.push(`Blockquote Markdown Error in ${location}: ${errorMsg}`);
                    });
                }
            });
            
            if (validationErrors.length > 0) {
                alert("Validation errors:\n" + validationErrors.join("\n"));
                return;
            }
            
            // Collect form data and generate JSON
            const jsonData = {
                textbook_page: textbookPage ? parseInt(textbookPage) : null,
                textbook_pdf_page: textbookPdfPage ? parseInt(textbookPdfPage) : null,
                guidebook_pdf_pages: generateGuidebookPageArray(),
                page_type: document.getElementById('page_type').value || "content",
                lesson_preamble: null,
                instructional_content: [],
                practice_questions: []
            };

            // Collect content sections - only get the main content sections (direct children)
            const contentElements = document.querySelectorAll('#content_sections_container > .array-item');
            contentElements.forEach((contentEl, index) => {
                try {
                    const contentData = collectContentData(contentEl);
                    
                    // Warn if section title is empty
                    if (!contentData.section_title) {
                        validationWarnings.push(ErrorMessages.warningSectionTitle(index));
                    }
                    
                    // Require content text
                    if (!contentData.text || /^\d+$/.test(contentData.text)) {
                        validationErrors.push(ErrorMessages.requiredContent(index));
                    } else {
                        jsonData.instructional_content.push(contentData);
                    }
                } catch (error) {
                    validationErrors.push(`Content Section ${index + 1}: ${error.message}`);
                }
            });

            // Add lesson preamble if provided
            const lessonId = document.getElementById('lesson_id').value;
            if (lessonId) {
                // Validate lesson ID is a string
                if (typeof lessonId !== 'string' || lessonId.trim().length === 0) {
                    validationErrors.push("Lesson ID must be a non-empty string");
                }
                
                if (validationErrors.length > 0) {
                    alert("Validation errors:\n" + validationErrors.join("\n"));
                    return;
                }
                
                jsonData.lesson_preamble = {
                    id: lessonId.trim(),
                    title: document.getElementById('lesson_title').value || "",
                    lesson_standards: Array.from(document.querySelectorAll('#lesson_standards textarea')).map(textarea => textarea.value).filter(v => v),
                    terminology: Array.from(document.querySelectorAll('#terminology textarea')).map(textarea => textarea.value).filter(v => v),
                    text: document.getElementById('lesson_text').value || ""
                };
            }

            // Collect questions - only get the main questions (direct children)
            const questionElements = document.querySelectorAll('#questions_container > .array-item');
            questionElements.forEach((questionEl, index) => {
                try {
                    const questionData = collectQuestionData(questionEl);
                    
                    // Enforce required fields for each question
                    if (!questionData.id) {
                        validationErrors.push(ErrorMessages.requiredQuestionID(index));
                    }
                    
                    // Validate annotate and create_table types
                    if (questionData.question_type === 'annotate' || questionData.question_type === 'create_table') {
                        // Validate required fields
                        if (!questionData.question_text || /^\d+$/.test(questionData.question_text)) {
                            validationErrors.push(ErrorMessages.requiredQuestionText(index));
                        }
                        
                        // Validate guide answer is required for these types
                        if (!questionData.guide_answer || questionData.guide_answer.trim().length === 0) {
                            validationErrors.push(`Question ${index + 1}: Guide Answer is required for ${questionData.question_type === 'annotate' ? 'annotate' : 'create_table'} question type`);
                        }
                        
                        // Validate guide PDF page
                        if (!questionData.guide_pdf_page) {
                            validationErrors.push(ErrorMessages.requiredGuidePage(index));
                        } else if (isNaN(questionData.guide_pdf_page) || !Number.isInteger(questionData.guide_pdf_page) || questionData.guide_pdf_page <= 0) {
                            validationErrors.push(ErrorMessages.invalidGuidePage(index));
                        } else {
                            // Validate guide PDF page is within guidebook range
                            const gbStart = parseInt(guidebookStart, 10);
                            const gbEnd = parseInt(guidebookEnd, 10);
                            if (!isNaN(gbStart) && !isNaN(gbEnd) && gbStart > 0 && gbEnd > 0) {
                                if (questionData.guide_pdf_page < gbStart || questionData.guide_pdf_page > gbEnd) {
                                    validationErrors.push(ErrorMessages.guidePageOutOfRange(index, questionData.guide_pdf_page, gbStart, gbEnd));
                                }
                            }
                        }
                    } else if (questionData.question_type === 'fill_in_the_blanks') {
                        // Fill in the blanks validation
                        if (!questionData.question_text || /^\d+$/.test(questionData.question_text)) {
                            validationErrors.push(ErrorMessages.requiredQuestionText(index));
                        } else {
                            // Validate blank format
                            const { valid, errors, blanks } = validateBlankFormat(questionData.question_text);
                            
                            if (blanks.length === 0) {
                                validationErrors.push(ErrorMessages.noBlanksFound(index));
                            } else if (!valid) {
                                errors.forEach(err => {
                                    validationErrors.push(ErrorMessages.invalidBlankFormat(index, err));
                                });
                            }
                            
                            // Validate values array
                            if (!questionData.values || !Array.isArray(questionData.values)) {
                                validationErrors.push(ErrorMessages.blankAnswerMismatch(index, blanks.length, 0));
                            } else {
                                // Check count matches
                                if (questionData.values.length !== blanks.length) {
                                    validationErrors.push(ErrorMessages.blankAnswerMismatch(index, blanks.length, questionData.values.length));
                                }
                                
                                // Check for empty answers
                                const emptyBlanks = [];
                                questionData.values.forEach((answer, idx) => {
                                    if (!answer || answer.trim() === '') {
                                        emptyBlanks.push(`___${blanks[idx]}___`);
                                    }
                                });
                                if (emptyBlanks.length > 0) {
                                    validationErrors.push(ErrorMessages.missingBlankAnswers(index, emptyBlanks));
                                }
                            }
                        }
                        
                        // Validate guide PDF page
                        if (!questionData.guide_pdf_page) {
                            validationErrors.push(ErrorMessages.requiredGuidePage(index));
                        } else if (isNaN(questionData.guide_pdf_page) || !Number.isInteger(questionData.guide_pdf_page) || questionData.guide_pdf_page <= 0) {
                            validationErrors.push(ErrorMessages.invalidGuidePage(index));
                        } else {
                            // Validate guide PDF page is within guidebook range
                            const gbStart = parseInt(guidebookStart, 10);
                            const gbEnd = parseInt(guidebookEnd, 10);
                            if (!isNaN(gbStart) && !isNaN(gbEnd) && gbStart > 0 && gbEnd > 0) {
                                if (questionData.guide_pdf_page < gbStart || questionData.guide_pdf_page > gbEnd) {
                                    validationErrors.push(ErrorMessages.guidePageOutOfRange(index, questionData.guide_pdf_page, gbStart, gbEnd));
                                }
                            }
                        }
                    } else if (questionData.question_type === 'matching') {
                        // Matching validation
                        if (!questionData.question_text || /^\d+$/.test(questionData.question_text)) {
                            validationErrors.push(ErrorMessages.requiredQuestionText(index));
                        }
                        
                        // Validate left items
                        if (!questionData.left || questionData.left.length === 0) {
                            validationErrors.push(ErrorMessages.matchingNoLeftItems(index));
                        } else {
                            questionData.left.forEach((item, itemIdx) => {
                                if (!item || item.trim() === '') {
                                    validationErrors.push(ErrorMessages.matchingEmptyLeftItem(index, itemIdx + 1));
                                }
                            });
                        }
                        
                        // Validate right items
                        if (!questionData.right || questionData.right.length === 0) {
                            validationErrors.push(ErrorMessages.matchingNoRightItems(index));
                        } else {
                            questionData.right.forEach((item, itemIdx) => {
                                if (!item || item.trim() === '') {
                                    validationErrors.push(ErrorMessages.matchingEmptyRightItem(index, itemIdx + 1));
                                }
                            });
                        }
                        
                        // Validate relationships
                        if (questionData.relationship && Array.isArray(questionData.relationship)) {
                            questionData.relationship.forEach((rel, relIdx) => {
                                if (!Array.isArray(rel) || rel.length !== 2) {
                                    validationErrors.push(ErrorMessages.matchingIncompleteRelationship(index, relIdx + 1));
                                } else {
                                    const [leftIdx, rightIdx] = rel;
                                    const leftCount = questionData.left ? questionData.left.length : 0;
                                    const rightCount = questionData.right ? questionData.right.length : 0;
                                    
                                    if (!leftIdx || !rightIdx) {
                                        validationErrors.push(ErrorMessages.matchingIncompleteRelationship(index, relIdx + 1));
                                    } else if (leftIdx < 1 || leftIdx > leftCount || rightIdx < 1 || rightIdx > rightCount) {
                                        validationErrors.push(ErrorMessages.matchingInvalidRelationship(index, leftIdx, rightIdx, leftCount, rightCount));
                                    }
                                }
                            });
                        }
                        
                        // Validate guide PDF page
                        if (!questionData.guide_pdf_page) {
                            validationErrors.push(ErrorMessages.requiredGuidePage(index));
                        } else if (isNaN(questionData.guide_pdf_page) || !Number.isInteger(questionData.guide_pdf_page) || questionData.guide_pdf_page <= 0) {
                            validationErrors.push(ErrorMessages.invalidGuidePage(index));
                        } else {
                            // Validate guide PDF page is within guidebook range
                            const gbStart = parseInt(guidebookStart, 10);
                            const gbEnd = parseInt(guidebookEnd, 10);
                            if (!isNaN(gbStart) && !isNaN(gbEnd) && gbStart > 0 && gbEnd > 0) {
                                if (questionData.guide_pdf_page < gbStart || questionData.guide_pdf_page > gbEnd) {
                                    validationErrors.push(ErrorMessages.guidePageOutOfRange(index, questionData.guide_pdf_page, gbStart, gbEnd));
                                }
                            }
                        }
                    } else {
                        // Validate other fields for all other types
                        if (!questionData.question_text || /^\d+$/.test(questionData.question_text)) {
                            validationErrors.push(ErrorMessages.requiredQuestionText(index));
                        }
                        
                        if (questionData.question_type === 'multiple_choice') {
                            // Multiple choice validation
                            if (!questionData.choices || questionData.choices.length === 0) {
                                validationErrors.push(ErrorMessages.requiredChoices(index));
                            } else {
                                // Validate choice IDs consistency (all filled or all empty)
                                const choicesWithIDs = questionData.choices.filter(c => c.id && c.id.trim() !== '');
                                if (choicesWithIDs.length > 0 && choicesWithIDs.length < questionData.choices.length) {
                                    validationErrors.push(ErrorMessages.inconsistentChoiceIDs(index, 'multiple_choice'));
                            }
                            }
                            // Validate value field (1-indexed position)
                            if (!questionData.value || typeof questionData.value !== 'number') {
                                validationErrors.push(ErrorMessages.requiredCorrectAnswer(index));
                            } else if (questionData.value < 1 || questionData.value > questionData.choices.length) {
                                validationErrors.push(`Question ${index + 1} (Multiple Choice) - Problem: Selected answer position (${questionData.value}) is out of range. You have ${questionData.choices.length} choices.\n    Fix: Select a valid answer position.`);
                            }
                            // guide_answer is now optional (for notes)
                        } else if (questionData.question_type === 'checkbox') {
                            // Checkbox validation
                            if (!questionData.choices || questionData.choices.length === 0) {
                                validationErrors.push(ErrorMessages.requiredCheckboxChoices(index));
                            } else {
                                // Validate choice IDs consistency (all filled or all empty)
                                const choicesWithIDs = questionData.choices.filter(c => c.id && c.id.trim() !== '');
                                if (choicesWithIDs.length > 0 && choicesWithIDs.length < questionData.choices.length) {
                                    validationErrors.push(ErrorMessages.inconsistentChoiceIDs(index, 'checkbox'));
                                }
                                
                                // Validate values array
                                if (!questionData.values || !Array.isArray(questionData.values)) {
                                    validationErrors.push(ErrorMessages.requiredCheckedChoice(index));
                                } else if (questionData.values.length !== questionData.choices.length) {
                                    validationErrors.push(`Question ${index + 1} (Checkbox) - Problem: Mismatch between number of choices (${questionData.choices.length}) and values array (${questionData.values.length}).\n    Fix: Make sure each choice has a corresponding correct/incorrect value.`);
                                } else if (!questionData.values.some(v => v === true)) {
                                    validationErrors.push(ErrorMessages.requiredCheckedChoice(index));
                                }
                            }
                            // guide_answer is now optional (for notes)
                        } else {
                            // Free form - validate guide answer
                            if (!questionData.guide_answer) {
                                validationErrors.push(ErrorMessages.requiredAnswer(index));
                            }
                        }
                        
                        // Validate guide PDF page is an integer
                        if (!questionData.guide_pdf_page) {
                            validationErrors.push(ErrorMessages.requiredGuidePage(index));
                        } else if (isNaN(questionData.guide_pdf_page) || !Number.isInteger(questionData.guide_pdf_page) || questionData.guide_pdf_page <= 0) {
                            validationErrors.push(ErrorMessages.invalidGuidePage(index));
                        } else {
                            // Validate guide PDF page is within guidebook range
                            const gbStart = parseInt(guidebookStart, 10);
                            const gbEnd = parseInt(guidebookEnd, 10);
                            if (!isNaN(gbStart) && !isNaN(gbEnd) && gbStart > 0 && gbEnd > 0) {
                                if (questionData.guide_pdf_page < gbStart || questionData.guide_pdf_page > gbEnd) {
                                    validationErrors.push(ErrorMessages.guidePageOutOfRange(index, questionData.guide_pdf_page, gbStart, gbEnd));
                                }
                            }
                        }
                    }
                    
                    // Only add question if no validation errors for this question
                    if (!validationErrors.some(e => e.startsWith(`Question ${index + 1}:`)) && 
                        !validationErrors.some(e => e.includes(`Question ${index + 1}`))) {
                        jsonData.practice_questions.push(questionData);
                    }
                } catch (error) {
                    validationErrors.push(`Question ${index + 1}: ${error.message}`);
                }
            });

            
            // Validate image consistency (duplicate indices and mismatched counts)
            // NOTE: This comprehensive check covers both missing references and unused bboxes
            // Removed validateImageReferences() and validateImageBboxes() to prevent duplicate error messages
            const imageConsistencyErrors = validateImageConsistency(jsonData);
            if (imageConsistencyErrors.length > 0) {
                validationErrors.push(...imageConsistencyErrors);
            }
            
            // Validate image index ordering (must start from 0 and be sequential)
            const imageOrderingErrors = validateImageOrdering(jsonData);
            if (imageOrderingErrors.length > 0) {
                validationErrors.push(...imageOrderingErrors);
            }
            
            // Final validation check - errors block, warnings just inform
            if (validationErrors.length > 0) {
                alert("Validation errors found:\n" + validationErrors.join("\n"));
                return;
            }
            
            // Show warnings if any (but don't block generation)
            if (validationWarnings.length > 0) {
                alert("Validation warnings:\n" + validationWarnings.join("\n"));
            }
            
            // Display formatted JSON
            const jsonOutput = document.getElementById('json_output');
            jsonOutput.innerHTML = formatJSON(jsonData);
            jsonOutput.setAttribute('data-raw-json', JSON.stringify(jsonData));
            
            // Track JSON generation with detailed statistics
            const stats = getFormStats();
            const jsonString = JSON.stringify(jsonData);
            
            // Calculate section sizes from generated data
            const contentSizes = jsonData.instructional_content.map(c => 
                ((c.section_title || '') + (c.text || '')).length
            );
            const questionSizes = jsonData.practice_questions.map(q => {
                let size = (q.question_text || '').length + (q.set_up_text || '').length;
                if (q.guide_answer) size += q.guide_answer.length;
                if (q.choices) {
                    size += q.choices.reduce((sum, c) => sum + (c.text || '').length, 0);
                }
                return size;
            });
        }
        
        // Collect form data without validation (for undo/redo purposes)
        function collectFormDataWithoutValidation() {
            const textbookPage = document.getElementById('textbook_page').value;
            const textbookPdfPage = document.getElementById('textbook_pdf_page').value;
            const guidebookStart = document.getElementById('guidebook_start_page').value;
            const guidebookEnd = document.getElementById('guidebook_end_page').value;
            const pageType = document.getElementById('page_type').value;
            
            // Collect form data and generate JSON (without validation)
            const jsonData = {
                textbook_page: textbookPage ? parseInt(textbookPage) : null,
                textbook_pdf_page: textbookPdfPage ? parseInt(textbookPdfPage) : null,
                guidebook_pdf_pages: generateGuidebookPageArray(),
                page_type: pageType || "content",
                lesson_preamble: null,
                instructional_content: [],
                practice_questions: []
            };

            // Collect content sections - only get the main content sections (direct children)
            const contentElements = document.querySelectorAll('#content_sections_container > .array-item');
            contentElements.forEach((contentEl) => {
                try {
                    const contentData = collectContentData(contentEl);
                    jsonData.instructional_content.push(contentData);
                } catch (error) {
                    // Skip sections that fail to collect
                    console.warn('Failed to collect content section:', error);
                }
            });

            // Add lesson preamble if provided
            const lessonId = document.getElementById('lesson_id').value;
            if (lessonId) {
                jsonData.lesson_preamble = {
                    id: lessonId.trim(),
                    title: document.getElementById('lesson_title').value || "",
                    lesson_standards: Array.from(document.querySelectorAll('#lesson_standards textarea')).map(textarea => textarea.value).filter(v => v),
                    terminology: Array.from(document.querySelectorAll('#terminology textarea')).map(textarea => textarea.value).filter(v => v),
                    text: document.getElementById('lesson_text').value || ""
                };
            }

            // Collect questions - only get the main questions (direct children)
            const questionElements = document.querySelectorAll('#questions_container > .array-item');
            questionElements.forEach((questionEl) => {
                try {
                    const questionData = collectQuestionData(questionEl);
                    jsonData.practice_questions.push(questionData);
                } catch (error) {
                    // Skip questions that fail to collect
                    console.warn('Failed to collect question:', error);
                }
            });
            
            return jsonData;
        }

        /**
         * Format JSON with arrays on one line
         * @param {*} obj - The object to format
         * @param {number} indent - Current indentation level
         * @returns {string} Formatted JSON string
         */
        function formatJSONWithCompactArrays(obj, indent = 0) {
            const indentStr = '  '.repeat(indent);
            const nextIndentStr = '  '.repeat(indent + 1);
            
            if (obj === null) return 'null';
            if (obj === undefined) return 'undefined';
            if (typeof obj === 'boolean') return obj.toString();
            if (typeof obj === 'number') return obj.toString();
            if (typeof obj === 'string') return JSON.stringify(obj);
            
            if (Array.isArray(obj)) {
                if (obj.length === 0) return '[]';
                
                // Check if all items are primitives (not objects)
                const allPrimitives = obj.every(item => 
                    item === null || 
                    item === undefined || 
                    typeof item === 'boolean' || 
                    typeof item === 'number' || 
                    typeof item === 'string' ||
                    (Array.isArray(item) && item.every(i => typeof i === 'number' || typeof i === 'string' || typeof i === 'boolean'))
                );
                
                if (allPrimitives) {
                    // Simple array - format on one line
                    const items = obj.map(item => {
                        if (Array.isArray(item)) {
                            return '[' + item.map(i => JSON.stringify(i)).join(', ') + ']';
                        }
                        return JSON.stringify(item);
                    });
                    return '[' + items.join(', ') + ']';
                }
                
                // Array contains objects - format each object on multiple lines
                const items = obj.map(item => {
                    if (typeof item === 'object' && !Array.isArray(item)) {
                        // Format object with each field on its own line, but keep arrays in it compact
                        return formatJSONWithCompactArrays(item, indent + 1);
                    }
                    return JSON.stringify(item);
                });
                
                return '[\n' + items.map(item => nextIndentStr + item).join(',\n') + '\n' + indentStr + ']';
            }
            
            if (typeof obj === 'object') {
                // Format objects with proper indentation
                const entries = Object.entries(obj);
                if (entries.length === 0) return '{}';
                
                const lines = entries.map(([key, value]) => {
                    const valueStr = formatJSONWithCompactArrays(value, indent + 1);
                    return `${nextIndentStr}"${key}": ${valueStr}`;
                });
                
                return '{\n' + lines.join(',\n') + '\n' + indentStr + '}';
            }
            
            return JSON.stringify(obj);
        }

        function formatJSON(obj) {
            // Custom JSON formatter that keeps arrays on one line
            const jsonString = formatJSONWithCompactArrays(obj, 0);
            
            // Use a completely different approach - build HTML directly without regex conflicts
            let result = '';
            let i = 0;
            let inString = false;
            let stringStart = -1;
            let stringContent = '';
            
            while (i < jsonString.length) {
                const char = jsonString[i];
                const nextChar = jsonString[i + 1];
                
                if (char === '"' && !inString) {
                    // Start of a string
                    inString = true;
                    stringStart = i;
                    stringContent = '';
                    i++;
                    continue;
                }
                
                if (char === '"' && inString) {
                    // End of a string
                    inString = false;
                    
                    // Check if this string is a key (followed by colon) or a value
                    let isKey = false;
                    let j = i + 1;
                    while (j < jsonString.length && (jsonString[j] === ' ' || jsonString[j] === '\n' || jsonString[j] === '\t')) {
                        j++;
                    }
                    if (jsonString[j] === ':') {
                        isKey = true;
                    }
                    
                    if (isKey) {
                        result += '<span class="json-key">"' + escapeHtml(stringContent) + '"</span>';
                    } else {
                        result += '<span class="json-string">"' + escapeHtml(stringContent) + '"</span>';
                    }
                    
                    i++;
                    continue;
                }
                
                if (inString) {
                    stringContent += char;
                    i++;
                    continue;
                }
                
                // Handle numbers
                if (char >= '0' && char <= '9') {
                    let number = '';
                    while (i < jsonString.length && 
                           ((jsonString[i] >= '0' && jsonString[i] <= '9') || jsonString[i] === '.' || jsonString[i] === 'e' || jsonString[i] === 'E' || jsonString[i] === '+' || jsonString[i] === '-')) {
                        number += jsonString[i];
                        i++;
                    }
                    result += '<span class="json-number">' + number + '</span>';
                    continue;
                }
                
                // Handle booleans and null
                if (char === 't' && jsonString.substring(i, i + 4) === 'true') {
                    result += '<span class="json-boolean">true</span>';
                    i += 4;
                    continue;
                }
                if (char === 'f' && jsonString.substring(i, i + 5) === 'false') {
                    result += '<span class="json-boolean">false</span>';
                    i += 5;
                    continue;
                }
                if (char === 'n' && jsonString.substring(i, i + 4) === 'null') {
                    result += '<span class="json-null">null</span>';
                    i += 4;
                    continue;
                }
                
                // Add other characters as-is
                result += char;
                i++;
            }
            
            return result;
        }

        // Generate guidebook page array with start and end pages only
        function generateGuidebookPageArray() {
            const startPage = parseInt(document.getElementById('guidebook_start_page').value);
            const endPage = parseInt(document.getElementById('guidebook_end_page').value);
            
            if (!startPage || !endPage) {
                return [];
            }
            
            // Always return array with exactly 2 elements: start and end
            return [startPage, endPage];
        }
        // Toggle between raw JSON and formatted preview

        // Normalize bbox formats (old/new) into array of { page, position: [[x0,y0],[x1,y1]] }
        function normalizeBboxArray(bbox, defaultPage) {
            if (!bbox) return [];
            // If it's already an array of objects with page/position
            if (Array.isArray(bbox) && bbox.length > 0 && typeof bbox[0] === 'object' && bbox[0] !== null && 'position' in bbox[0]) {
                return bbox.map(item => ({
                    page: Number.isInteger(item.page) ? item.page : (defaultPage || 0),
                    position: Array.isArray(item.position) ? item.position : [[0,0],[0,0]]
                }));
            }
            // If it's an array of coordinate pairs (multiple bboxes)
            if (Array.isArray(bbox) && bbox.length > 0 && Array.isArray(bbox[0]) && Array.isArray(bbox[0][0])) {
                return bbox.map(pair => ({ page: defaultPage || 0, position: pair }));
            }
            // If it's a single bbox in the form [[x0,y0],[x1,y1]] (only if elements are numbers, not arrays)
            if (Array.isArray(bbox) && bbox.length === 2 && Array.isArray(bbox[0]) && Array.isArray(bbox[1]) && 
                typeof bbox[0][0] === 'number' && typeof bbox[0][1] === 'number' && 
                typeof bbox[1][0] === 'number' && typeof bbox[1][1] === 'number') {
                return [{ page: defaultPage || 0, position: bbox }];
            }
            return [];
        }

        function setInputValue(selector, value) {
            const el = document.querySelector(selector);
            if (el) el.value = value == null ? '' : value;
        }

        function clearDynamicContainers() {
            // Clear all live previews first to fix rendering issue
            const allPreviews = document.querySelectorAll('.live-preview');
            allPreviews.forEach(preview => {
                preview.innerHTML = '';
            });
            
            // Content sections
            const contentContainer = document.getElementById('content_sections_container');
            if (contentContainer) contentContainer.innerHTML = '';
            // Questions
            const questionsContainer = document.getElementById('questions_container');
            if (questionsContainer) questionsContainer.innerHTML = '';
            // Lesson arrays
            const standards = document.getElementById('lesson_standards');
            if (standards) standards.innerHTML = '';
            const terminology = document.getElementById('terminology');
            if (terminology) terminology.innerHTML = '';
        }

        function fillStringArray(containerId, values, addFn) {
            const container = document.getElementById(containerId);
            if (!container) return;
            container.innerHTML = '';
            (values || []).forEach(val => {
                addFn();
                const last = container.lastElementChild;
                // Look for either input or textarea (lesson standards now use textarea)
                const field = last && (last.querySelector('textarea') || last.querySelector('input'));
                if (field) field.value = val;
            });
        }

        function fillBboxGroup(groupEl, bboxList) {
            if (!groupEl) return;
            const container = groupEl.querySelector('.bbox-container');
            if (!container) return;
            
            // Determine the type of bbox group to use appropriate before/after functions
            const labelEl = groupEl.querySelector('label');
            const labelText = labelEl ? labelEl.textContent : '';
            
            let beforeFunc = 'addContentBboxBefore';
            let afterFunc = 'addContentBboxAfter';
            let beforeTitle = 'Add BBox Before';
            let afterTitle = 'Add BBox After';
            
            // Determine correct functions based on label text
            if (labelText.includes('Question Images')) {
                beforeFunc = 'addQuestionImageBefore';
                afterFunc = 'addQuestionImageAfter';
                beforeTitle = 'Add Image Before';
                afterTitle = 'Add Image After';
            } else if (labelText.includes('Answer Images')) {
                beforeFunc = 'addAnswerImageBefore';
                afterFunc = 'addAnswerImageAfter';
                beforeTitle = 'Add Image Before';
                afterTitle = 'Add Image After';
            } else if (labelText.includes('Section Images')) {
                beforeFunc = 'addContentImageBefore';
                afterFunc = 'addContentImageAfter';
                beforeTitle = 'Add Image Before';
                afterTitle = 'Add Image After';
            }
            
            // Clear existing rows
            container.innerHTML = '';
            const rowsToCreate = (bboxList && bboxList.length) ? bboxList.length : 1;
            
            // Template for a single bbox/image row (now includes Before/After buttons)
            const rowHTML = `
                <div class="array-item">
                    <div class="bbox-inputs">
                        <input type="number" placeholder="Page" class="bbox-page" min="1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                        <input type="number" placeholder="X0" class="bbox-x0" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                        <input type="number" placeholder="Y0" class="bbox-y0" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                        <input type="number" placeholder="X1" class="bbox-x1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                        <input type="number" placeholder="Y1" class="bbox-y1" step="1" oninput="validateInteger(this)" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
                    </div>
                    <div class="row-actions">
                        <button class="reorder-btn" onclick="moveItemUp(this)" title="Move Up"><i class="fas fa-arrow-up"></i></button>
                        <button class="reorder-btn" onclick="moveItemDown(this)" title="Move Down"><i class="fas fa-arrow-down"></i></button>
                        <button class="add-bbox-btn" onclick="${beforeFunc}(this)" title="${beforeTitle}">
                            <i class="fas fa-plus"></i> Before
                        </button>
                        <button class="add-bbox-btn" onclick="${afterFunc}(this)" title="${afterTitle}">
                            <i class="fas fa-plus"></i> After
                        </button>
                        <button class="add-btn" onclick="openBboxDrawer(this)"><i class="fas fa-pen-square"></i> Draw</button>
                        <button class="add-btn" onclick="pasteBboxJson(this)"><i class="fas fa-paste"></i> Paste</button>
                        <button class="add-btn" onclick="copyBboxJson(this)"><i class="fas fa-copy"></i> Copy</button>
                        <button class="duplicate-btn" onclick="duplicateBbox(this)" title="Duplicate"><i class="fas fa-clone"></i></button>
                        <button class="remove-btn" onclick="removeArrayItem(this)"></button>
                    </div>
                </div>`;
            for (let i = 0; i < rowsToCreate; i++) {
                const wrapper = document.createElement('div');
                wrapper.innerHTML = rowHTML.trim();
                container.appendChild(wrapper.firstElementChild);
            }
            const items = container.querySelectorAll('.array-item');
            (bboxList || []).forEach((bbox, idx) => {
                const inputs = items[idx] ? items[idx].querySelectorAll('.bbox-inputs input') : null;
                if (!inputs || inputs.length < 5) return;
                inputs[0].value = bbox.page || '';
                inputs[1].value = bbox.position?.[0]?.[0] ?? '';
                inputs[2].value = bbox.position?.[0]?.[1] ?? '';
                inputs[3].value = bbox.position?.[1]?.[0] ?? '';
                inputs[4].value = bbox.position?.[1]?.[1] ?? '';
            });
            
            // Finalize all bbox rows to ensure font settings are applied
            items.forEach(item => {
                finalizeBBoxRow(item);
            });
        }

        function populateContentSections(data, defaultPage) {
            const sections = Array.isArray(data?.instructional_content) ? data.instructional_content : [];
            const container = document.getElementById('content_sections_container');
            
            // Set bulk operation flag to skip redundant updates
            isBulkOperation = true;
            
            sections.forEach((sec, idx) => {
                addContentSection();
                const sectionEl = container.lastElementChild;
                const groups = sectionEl.querySelectorAll('.form-group');
                // 0: title, 1: text, 2: images
                const title = (sec.section_title ?? sec.title ?? '').toString();
                const text = (sec.text ?? '').toString();
                groups[0].querySelector('input').value = title;
                groups[1].querySelector('textarea').value = text;
                const normImages = normalizeBboxArray(sec.images, defaultPage);
                fillBboxGroup(groups[2], normImages);
            });
            
            // Reset bulk operation flag
            isBulkOperation = false;
            
            // Ensure numbering is correct after populating all sections
            updateContentSectionNumbers();
        }

        // Helper function to find form field by label text
        function findFieldByLabel(container, labelText, fieldType = 'input') {
            const formGroups = container.querySelectorAll('.form-group');
            for (const group of formGroups) {
                const label = group.querySelector('label');
                if (label && label.textContent.includes(labelText)) {
                    if (fieldType === 'input') {
                        return group.querySelector('input');
                    } else if (fieldType === 'textarea') {
                        return group.querySelector('textarea');
                    } else if (fieldType === 'select') {
                        return group.querySelector('select');
                    } else if (fieldType === 'checkbox') {
                        return group.querySelector('input[type="checkbox"]');
                    }
                }
            }
            return null;
        }

        // Helper function to find form group by label text
        function findFormGroupByLabel(container, labelText) {
            const formGroups = container.querySelectorAll('.form-group');
            for (const group of formGroups) {
                const label = group.querySelector('label');
                if (label && label.textContent.includes(labelText)) {
                    return group;
                }
            }
            return null;
        }

        // ========== CATEGORY 3 REFACTORING: Field Selection by Label ==========
        
        /**
         * Get field value by label text
         * @param {HTMLElement} container - The container element
         * @param {string} labelText - The label text to search for
         * @param {string} fieldType - The type of field ('input', 'textarea', 'select', 'checkbox')
         * @returns {string|boolean} The field value (trimmed) or empty string if not found
         */
        function getFieldValue(container, labelText, fieldType = 'input') {
            const field = findFieldByLabel(container, labelText, fieldType);
            if (!field) return fieldType === 'checkbox' ? false : '';
            
            if (fieldType === 'checkbox') {
                return field.checked;
            }
            return field.value.trim();
        }

        /**
         * Set field value by label text
         * @param {HTMLElement} container - The container element
         * @param {string} labelText - The label text to search for
         * @param {any} value - The value to set
         * @param {string} fieldType - The type of field ('input', 'textarea', 'select', 'checkbox')
         */
        function setFieldValue(container, labelText, value, fieldType = 'input') {
            const field = findFieldByLabel(container, labelText, fieldType);
            if (!field) return;
            
            if (fieldType === 'checkbox') {
                field.checked = !!value;
            } else {
                field.value = value;
            }
        }

        // ========== END CATEGORY 3 REFACTORING ==========

        function populateQuestions(data, defaultPage) {
            const questions = Array.isArray(data?.practice_questions) ? data.practice_questions : [];
            const container = document.getElementById('questions_container');
            
            // Set bulk operation flag to skip redundant updates
            isBulkOperation = true;
            
            questions.forEach(q => {
                addQuestion();
                const qEl = container.lastElementChild;
                
                // Find fields by label instead of array indices
                const questionIdInput = findFieldByLabel(qEl, 'Question ID');
                if (questionIdInput) {
                    questionIdInput.value = (q.id ?? '').toString();
                }
                
                
                const questionTypeSelect = findFieldByLabel(qEl, 'Question Type', 'select');
                const questionType = q.question_type || 'free_form';
                if (questionTypeSelect) {
                    questionTypeSelect.value = questionType;
                    // Trigger toggle to show/hide appropriate fields
                    toggleQuestionType(questionTypeSelect);
                }
                
                const setupTextTextarea = findFieldByLabel(qEl, 'Set-up Text', 'textarea');
                if (setupTextTextarea) {
                    setupTextTextarea.value = (q.set_up_text ?? '').toString();
                }
                
                const questionTextTextarea = findFieldByLabel(qEl, 'Question Text', 'textarea');
                if (questionTextTextarea) {
                    questionTextTextarea.value = (q.question_text ?? '').toString();
                }
                
                // Handle different question types
                if (questionType === 'fill_in_the_blanks') {
                    // Fill in the blanks: populate blank answers
                    updateBlankAnswersUI(qEl);
                    
                    // Populate answers for each blank
                    if (q.values && Array.isArray(q.values)) {
                        const blankItems = qEl.querySelectorAll('.blank-answer-item');
                        blankItems.forEach((item, index) => {
                            const textarea = item.querySelector('.blank-answer-input');
                            if (textarea && q.values[index] !== undefined) {
                                textarea.value = q.values[index];
                                // Trigger preview
                                attachPreviews(item);
                            }
                        });
                        
                        // Update the filled blanks preview after loading values
                        updateFilledBlanksPreview(qEl);
                    }
                    
                    // Populate guide answer notes (optional) - query within blanks container
                    const blanksContainer = qEl.querySelector('#blanks-container');
                    const guideAnswerNotesTextarea = blanksContainer?.querySelector('.guide-answer-notes');
                    if (guideAnswerNotesTextarea) {
                        guideAnswerNotesTextarea.value = (q.guide_answer ?? '').toString();
                    }
                } else if (questionType === 'matching') {
                    // Matching: populate left items, right items, and relationships
                    const leftList = qEl.querySelector('[id^="matching-left-list-"]');
                    const rightList = qEl.querySelector('[id^="matching-right-list-"]');
                    
                    // Populate left items
                    if (leftList && q.left && Array.isArray(q.left)) {
                        leftList.innerHTML = '';
                        q.left.forEach((itemText) => {
                            const addLeftBtn = qEl.querySelector('button[onclick*="addMatchingItem"][onclick*="left"]');
                            if (addLeftBtn) {
                                addMatchingItem(addLeftBtn, 'left');
                                const lastItem = leftList.lastElementChild;
                                if (lastItem) {
                                    const textarea = lastItem.querySelector('.matching-item-text');
                                    if (textarea) {
                                        textarea.value = itemText;
                                        attachPreviews(lastItem);
                                    }
                                }
                            }
                        });
                    }
                    
                    // Populate right items
                    if (rightList && q.right && Array.isArray(q.right)) {
                        rightList.innerHTML = '';
                        q.right.forEach((itemText) => {
                            const addRightBtn = qEl.querySelector('button[onclick*="addMatchingItem"][onclick*="right"]');
                            if (addRightBtn) {
                                addMatchingItem(addRightBtn, 'right');
                                const lastItem = rightList.lastElementChild;
                                if (lastItem) {
                                    const textarea = lastItem.querySelector('.matching-item-text');
                                    if (textarea) {
                                        textarea.value = itemText;
                                        attachPreviews(lastItem);
                                    }
                                }
                            }
                        });
                    }
                    
                    // Populate relationships (convert indices to UIDs)
                    const relationshipsList = qEl.querySelector('[id^="relationships-list-"]');
                    if (relationshipsList && q.relationship && Array.isArray(q.relationship)) {
                        relationshipsList.innerHTML = '';
                        ensureMatchingUids(qEl);
                        const leftItems = qEl.querySelectorAll('[id^="matching-left-list-"] .matching-item');
                        const rightItems = qEl.querySelectorAll('[id^="matching-right-list-"] .matching-item');
                        const leftIndexToUid = new Map();
                        const rightIndexToUid = new Map();
                        leftItems.forEach((item, index) => {
                            const uid = item.dataset.leftUid;
                            if (uid) leftIndexToUid.set(index + 1, uid);
                        });
                        rightItems.forEach((item, index) => {
                            const uid = item.dataset.rightUid;
                            if (uid) rightIndexToUid.set(index + 1, uid);
                        });
                        q.relationship.forEach(([leftIdx, rightIdx]) => {
                            const addRelBtn = qEl.querySelector('button[onclick*="addRelationship"]');
                            if (addRelBtn) {
                                addRelationship(addRelBtn);
                                const lastRel = relationshipsList.lastElementChild;
                                if (lastRel) {
                                    const leftUid = leftIndexToUid.get(leftIdx);
                                    const rightUid = rightIndexToUid.get(rightIdx);
                                    if (leftUid) lastRel.dataset.leftUid = leftUid;
                                    if (rightUid) lastRel.dataset.rightUid = rightUid;
                                }
                            }
                        });
                        // Rebuild UI to show correct selections
                        afterQuestionTypeListMutation(qEl);
                    }
                    
                    // Populate guide answer notes (optional) - query within matching container
                    const matchingContainer = qEl.querySelector('#matching-container');
                    const guideAnswerNotesTextarea = matchingContainer?.querySelector('.guide-answer-notes');
                    if (guideAnswerNotesTextarea) {
                        guideAnswerNotesTextarea.value = (q.guide_answer ?? '').toString();
                    }
                } else if ((questionType === 'multiple_choice' || questionType === 'checkbox') && q.choices && Array.isArray(q.choices)) {
                    // Fill choices
                    const choicesList = qEl.querySelector('[id^="choices-list-"]');
                    if (choicesList) {
                        choicesList.innerHTML = '';
                        q.choices.forEach((choice, choiceIndex) => {
                            addChoice(choicesList.parentElement.querySelector('.add-btn'), 'end', questionType);
                            const lastChoice = choicesList.lastElementChild;
                            if (lastChoice) {
                                const choiceIdInput = lastChoice.querySelector('.choice-id');
                                const choiceTextArea = lastChoice.querySelector('.choice-text');
                                const choiceCorrectInput = lastChoice.querySelector('.choice-correct');
                                if (choiceIdInput) {
                                    choiceIdInput.value = (choice.id ?? '').toString();
                                    // Update header to reflect the ID
                                    updateChoiceHeader(choiceIdInput);
                                }
                                if (choiceTextArea) {
                                    choiceTextArea.value = (choice.text ?? '').toString();
                                }
                                // For checkbox: restore from values array
                                if (choiceCorrectInput && q.values && q.values[choiceIndex] !== undefined) {
                                    choiceCorrectInput.checked = q.values[choiceIndex];
                                } else if (choiceCorrectInput && choice.checked !== undefined) {
                                    // Backward compatibility: support old 'checked' field
                                    choiceCorrectInput.checked = choice.checked;
                                }
                            }
                        });
                    }
                    
                    // Attach listeners for real-time updates
                    attachChoiceListeners(qEl);
                    
                    // Ensure UIDs exist and restore correct answer state from UID-based state
                    ensureChoiceUids(qEl);
                    if (questionType === 'multiple_choice') {
                        // Convert index to UID (support both 'value' and 'correct_answer_index' fields)
                        const correctIndex = q.correct_answer_index || q.value;
                        if (correctIndex) {
                            const choices = choicesList.querySelectorAll('.choice-item');
                            const correctChoice = choices[correctIndex - 1];
                            if (correctChoice && correctChoice.dataset.choiceUid) {
                                setCorrectChoiceUid(qEl, correctChoice.dataset.choiceUid);
                            }
                        }
                    } else if (questionType === 'checkbox') {
                        // Restore checkbox correctness from choices[].checked (UID-based)
                        const correctUids = new Set();
                        const choices = choicesList.querySelectorAll('.choice-item');
                        choices.forEach((choiceItem, index) => {
                            // Support both new format (choices[].checked) and old format (values array)
                            const isChecked = (q.choices && q.choices[index] && q.choices[index].checked) ||
                                            (q.values && q.values[index]);
                            if (isChecked) {
                                const uid = choiceItem.dataset.choiceUid;
                                if (uid) correctUids.add(uid);
                            }
                        });
                        setCorrectChoiceUids(qEl, correctUids);
                    }
                    // Rebuild UI using centralized hook
                    afterQuestionTypeListMutation(qEl);
                    
                    // Populate guide answer notes (optional) for both multiple choice and checkbox
                    const guideAnswerNotesTextarea = qEl.querySelector('.guide-answer-notes');
                    if (guideAnswerNotesTextarea) {
                        guideAnswerNotesTextarea.value = (q.guide_answer ?? '').toString();
                    }
                } else {
                    // Free form - fill guide answer
                    const guideAnswerTextarea = qEl.querySelector('#guide-answer-container textarea');
                    if (guideAnswerTextarea) {
                        guideAnswerTextarea.value = (q.guide_answer ?? '').toString();
                    }
                }
                
                // Find Guide PDF Page field by label
                const guidePdfPageInput = findFieldByLabel(qEl, 'Guide PDF Page');
                const guidePdfPage = (q.guide_pdf_page ?? null);
                if (guidePdfPageInput && guidePdfPage != null) {
                    guidePdfPageInput.value = guidePdfPage;
                }

                const questionImages = normalizeBboxArray(q.question_images, defaultPage);
                const answerImages = normalizeBboxArray(q.guide_answer_images, guidePdfPage || defaultPage);

                // Find image groups by label
                const questionImagesGroup = findFormGroupByLabel(qEl, 'Question Images');
                const answerImagesGroup = findFormGroupByLabel(qEl, 'Answer Images');
                if (questionImagesGroup) {
                    fillBboxGroup(questionImagesGroup, questionImages);
                }
                if (answerImagesGroup) {
                    fillBboxGroup(answerImagesGroup, answerImages);
                }

                // Find related question field by label
                const relatedQuestionInput = findFieldByLabel(qEl, 'Related Question');
                const related = q.related_question == null ? '' : q.related_question;
                if (relatedQuestionInput) {
                    relatedQuestionInput.value = related;
                }
                
                // Attach previews and bbox validation after populating
                attachPreviews(qEl);
                attachBboxValidation(qEl);
            });
            
            // Reset bulk operation flag
            isBulkOperation = false;
            
            // Ensure numbering is correct after populating all questions
            updateQuestionNumbers();
            
            // Render previews for restored questions only (scoped)
            if (typeof PreviewBox !== 'undefined' && PreviewBox.ensureRendered) {
                PreviewBox.ensureRendered(container);
            }
        }

        function populateFormFromJSON(data) {
            // No special scroll code at start - hydration reset happens at the end
            
            // Clear entire form first
            resetForm(true);

            // Basic info
            setInputValue('#textbook_page', data.textbook_page ?? '');
            setInputValue('#textbook_pdf_page', data.textbook_pdf_page ?? '');
            const gb = Array.isArray(data.guidebook_pdf_pages) ? data.guidebook_pdf_pages : [];
            if (gb.length === 1) {
                setInputValue('#guidebook_start_page', gb[0]);
                setInputValue('#guidebook_end_page', gb[0]);
            } else if (gb.length >= 2) {
                setInputValue('#guidebook_start_page', gb[0]);
                setInputValue('#guidebook_end_page', gb[1]);
            } else {
                setInputValue('#guidebook_start_page', '');
                setInputValue('#guidebook_end_page', '');
            }
            if (data.page_type) {
                const pageTypeEl = document.getElementById('page_type');
                if (pageTypeEl) pageTypeEl.value = data.page_type;
            }

            // Lesson preamble
            const lp = data.lesson_preamble;
            if (lp && typeof lp === 'object') {
                setInputValue('#lesson_id', lp.id ?? lp.lesson_id ?? '');
                setInputValue('#lesson_title', lp.title ?? lp.lesson_title ?? '');
                setInputValue('#lesson_text', lp.text ?? '');
                fillStringArray('lesson_standards', lp.lesson_standards || [], addLessonStandard);
                fillStringArray('terminology', lp.terminology || [], addTerminology);
            } else {
                // keep empty arrays
                fillStringArray('lesson_standards', [], addLessonStandard);
                fillStringArray('terminology', [], addTerminology);
            }

            const defaultPage = data.textbook_pdf_page || data.textbook_page || 0;

            // Content sections
            populateContentSections(data, defaultPage);

            // Questions
            populateQuestions(data, defaultPage);
            
            // Attach bbox validation to all loaded bboxes
            attachBboxValidation(document);
            
            // Ensure all textareas maintain correct direction after population
            const allTextareas = document.querySelectorAll('textarea, input[type="text"]');
            allTextareas.forEach(ta => {
                if (ta.hasAttribute('data-ltr')) {
                    // LTR fields (JSON input, etc.)
                    ta.setAttribute('dir', 'ltr');
                } else {
                    // RTL fields (content, questions, titles, lesson standards, etc.)
                    ta.setAttribute('dir', 'rtl');
                }
                // CSS will handle the styling based on data-ltr attribute
            });
            
            // Update all direction toggle buttons to show correct text
            const allDirBtns = document.querySelectorAll('.dir-btn');
            allDirBtns.forEach(btn => {
                const textarea = btn.closest('.text-field-container')?.querySelector('textarea') || 
                                btn.parentElement?.querySelector('textarea') ||
                                btn.parentElement?.querySelector('input[type="text"]');
                if (textarea) {
                    const isLTR = textarea.hasAttribute('data-ltr');
                    // Button shows what clicking it will do
                    btn.textContent = isLTR ? 'RTL' : 'LTR';
                }
            });
            
            // Apply font settings synchronously so Correct Answer Position and all output get font in same tick (no timer)
            const inputFormEl = document.getElementById('input-form');
            if (inputFormEl && typeof applyFontSettings === 'function') {
                applyFontSettings(inputFormEl);
            }
            const savedFontSize = localStorage.getItem('fontSize');
            const savedLineHeight = localStorage.getItem('lineHeight');
            if (savedFontSize && typeof changeFontSize === 'function') {
                changeFontSize(savedFontSize);
            }
            if (savedLineHeight && typeof changeLineHeight === 'function') {
                changeLineHeight(savedLineHeight);
            }
            
            // If final preview tab is active, regenerate it after loading JSON
            const finalPreviewTab = document.getElementById('final-preview');
            if (finalPreviewTab && finalPreviewTab.classList.contains('active')) {
                if (isDocumentHydrating) {
                    // During hydration, generate preview synchronously
                    generateFinalPreview();
                } else {
                    // Normal operation: use setTimeout to ensure DOM is fully updated
                    setTimeout(() => {
                        generateFinalPreview();
                    }, 100);
                }
            }

            // After JSON population is complete, ensure previews and register autosize targets for whole input form
            const mainActive = document.querySelector('.main-tab-content.active');
            const activeRoot = (mainActive && mainActive.id === 'input-form' && mainActive.querySelector('.tab-content.active')) || mainActive || document;
            const inputForm = document.getElementById('input-form');
            if (typeof PreviewBox !== 'undefined' && PreviewBox.ensureRendered) {
                PreviewBox.ensureRendered(activeRoot);
            }
            if (typeof AutoSizeManager !== 'undefined') {
                if (AutoSizeManager.register) {
                    AutoSizeManager.register(inputForm || activeRoot);
                }
                // Force-fit visible panel with current content (values already set by populate)
                if (AutoSizeManager.finalizeSpawn) {
                    AutoSizeManager.finalizeSpawn(activeRoot);
                }
                if (AutoSizeManager.fitPending) {
                    AutoSizeManager.fitPending(activeRoot);
                }
            }
            
            // Reset scroll to top at the end of hydration (ONLY for load JSON / restore flows)
            if (isDocumentHydrating) {
                // Run after DOM/class updates so the real scrollers exist
                requestAnimationFrame(() => {
                    resetScrollOnHydration();
                    // Clear hydration flag AFTER reset completes
                    isDocumentHydrating = false;
                });
            }
        }

        // Try to repair and parse malformed JSON inputs commonly encountered
        /**
         * Convert Python dict syntax to JSON syntax
         * @param {string} text - The text that might be a Python dict
         * @returns {string} JSON-compatible text
         */
        function convertPythonDictToJSON(text) {
            let result = '';
            let i = 0;
            let inSingleQuoteString = false;
            let inDoubleQuoteString = false;
            let currentString = '';
            
            while (i < text.length) {
                const char = text[i];
                const nextChar = text[i + 1];
                
                // Handle escape sequences in strings
                if (char === '\\' && inSingleQuoteString) {
                    if (nextChar === "'") {
                        // Escaped single quote in single-quote string
                        currentString += "'";
                        i += 2;
                        continue;
                    } else if (nextChar === '\\') {
                        // Escaped backslash - add single backslash to content
                        currentString += '\\';
                        i += 2;
                        continue;
                    } else if (nextChar === 'n') {
                        // Newline escape sequence - convert to actual newline
                        currentString += '\n';
                        i += 2;
                        continue;
                    } else if (nextChar === 't') {
                        // Tab escape sequence - convert to actual tab
                        currentString += '\t';
                        i += 2;
                        continue;
                    } else if (nextChar === 'r') {
                        // Carriage return escape sequence - convert to actual CR
                        currentString += '\r';
                        i += 2;
                        continue;
                    }
                    // For any other escaped character, keep both the backslash and character
                    currentString += char;
                    i++;
                    continue;
                }
                
                // Handle escape sequences in double-quote strings
                if (char === '\\' && inDoubleQuoteString) {
                    if (nextChar === '"') {
                        // Escaped double quote
                        result += '\\"';
                        i += 2;
                        continue;
                    } else if (nextChar === '\\') {
                        // Escaped backslash
                        result += '\\\\';
                        i += 2;
                        continue;
                    }
                    // For other escape sequences, keep as-is
                    result += char;
                    i++;
                    continue;
                }
                
                // Handle single quotes
                if (char === "'" && !inDoubleQuoteString) {
                    if (!inSingleQuoteString) {
                        // Start of single-quote string
                        inSingleQuoteString = true;
                        result += '"'; // Use double quote in JSON
                    } else {
                        // End of single-quote string
                        inSingleQuoteString = false;
                        // Escape special characters for JSON
                        let escapedString = '';
                        for (let j = 0; j < currentString.length; j++) {
                            const ch = currentString[j];
                            const prevCh = j > 0 ? currentString[j-1] : '';
                            
                            // Escape backslashes (must be done first!)
                            if (ch === '\\') {
                                escapedString += '\\\\';
                            }
                            // Escape double quotes that aren't already escaped
                            else if (ch === '"' && prevCh !== '\\') {
                                escapedString += '\\"';
                            }
                            // Escape newlines for JSON
                            else if (ch === '\n') {
                                escapedString += '\\n';
                            }
                            // Escape tabs for JSON
                            else if (ch === '\t') {
                                escapedString += '\\t';
                            }
                            // Escape carriage returns for JSON
                            else if (ch === '\r') {
                                escapedString += '\\r';
                            }
                            // Keep other characters as-is
                            else {
                                escapedString += ch;
                            }
                        }
                        result += escapedString + '"';
                        currentString = '';
                    }
                    i++;
                    continue;
                }
                
                // Handle double quotes
                if (char === '"' && !inSingleQuoteString) {
                    inDoubleQuoteString = !inDoubleQuoteString;
                    result += char;
                    i++;
                    continue;
                }
                
                // Accumulate string content or regular content
                if (inSingleQuoteString) {
                    currentString += char;
                } else {
                    result += char;
                }
                
                i++;
            }
            
            // Replace Python boolean/null values with JSON equivalents (only outside strings)
            // This is now safe because we've already processed all strings
            result = result.replace(/\bTrue\b/g, 'true');
            result = result.replace(/\bFalse\b/g, 'false');
            result = result.replace(/\bNone\b/g, 'null');
            
            return result;
        }

        function attemptRepairAndParseJSON(rawText) {
            const notes = [];
            let t = (rawText || '').trim().replace(/^\uFEFF/, '');

            // Normalize line endings
            t = t.replace(/\r\n?/g, '\n');

            // Remove trailing commas like ,] or ,}
            const t1 = t;
            t = t.replace(/,\s*([\]\}])/g, '$1');
            if (t !== t1) notes.push('removed trailing commas');

            // Fix a premature closing brace before known top-level fields
            const t2 = t;
            t = t.replace(/\}\s*,\s*"(instructional_content)"/g, ', "$1"')
                 .replace(/\}\s*,\s*"(practice_questions)"/g, ', "$1"')
                 .replace(/\}\s*,\s*"(lesson_preamble)"/g, ', "$1"');
            if (t !== t2) notes.push('merged split top-level object');

            // Balance top-level braces if mismatched
            const opens = (t.match(/\{/g) || []).length;
            const closes = (t.match(/\}/g) || []).length;
            if (opens > closes) {
                t += '}'.repeat(opens - closes);
                notes.push('added missing }');
            } else if (closes > opens) {
                let diff = closes - opens;
                while (diff-- > 0) t = t.replace(/\}\s*$/, '');
                notes.push('removed extra } at end');
            }

            // Attempt parse
            let data;
            try {
                data = JSON.parse(t);
            } catch (e) {
                return { ok: false, error: e, notes };
            }

            // Map a stray top-level text into lesson_preamble.text
            if (typeof data.text === 'string') {
                if (!data.lesson_preamble || typeof data.lesson_preamble !== 'object') {
                    data.lesson_preamble = { id: '', title: '', lesson_standards: [], terminology: [], text: data.text };
                } else if (!data.lesson_preamble.text) {
                    data.lesson_preamble.text = data.text;
                }
                delete data.text;
                notes.push('moved stray top-level "text" into lesson_preamble.text');
            }

            // Ensure guidebook_pdf_pages is either null or a 2-length array
            if (Array.isArray(data.guidebook_pdf_pages)) {
                if (data.guidebook_pdf_pages.length === 1) {
                    data.guidebook_pdf_pages = [data.guidebook_pdf_pages[0], data.guidebook_pdf_pages[0]];
                    notes.push('normalized guidebook_pdf_pages to [start, end]');
                } else if (data.guidebook_pdf_pages.length > 2) {
                    data.guidebook_pdf_pages = [data.guidebook_pdf_pages[0], data.guidebook_pdf_pages[data.guidebook_pdf_pages.length - 1]];
                    notes.push('trimmed guidebook_pdf_pages to 2 items');
                }
            }

            return { ok: true, data, notes };
        }

        function loadJSON() {
            const txt = document.getElementById('json_input').value;
            if (!txt || !txt.trim()) {
                alert(' Please paste your JSON data in the text box before clicking "Load JSON".');
                return;
            }
            
            // Add confirmation popup for loading JSON
            if (!confirm(' Warning: Loading new JSON will delete everything you\'ve entered in the form.\n\nDo you want to continue?')) {
                return;
            }
            
            // Save current form state for undo (without validation)
            let previousState = null;
            try {
                previousState = collectFormDataWithoutValidation();
            } catch (e) {
                console.warn('Could not save form state for undo:', e);
            }
            
            let data;
            let convertedText = txt;
            
            // Try parsing as regular JSON first
            try {
                data = JSON.parse(txt);
            } catch (e) {
                // If it fails, try converting Python dict syntax to JSON
                try {
                    convertedText = convertPythonDictToJSON(txt);
                    data = JSON.parse(convertedText);
                } catch (e2) {
                    // If Python conversion also fails, try repair
                    const result = attemptRepairAndParseJSON(convertedText);
                    if (!result.ok) {
                        alert(' Problem: The data you pasted is not valid JSON or Python dict format and couldn\'t be fixed automatically.\n\n Fix: Check for common issues:\n    Missing commas between items\n    Missing quotation marks\n    Extra or missing brackets { }\n    Python: Use True/False/None (will be auto-converted)\n\n Tip: Use a JSON validator tool to find the exact error.');
                        return;
                    }
                    data = result.data;
                }
            }
            try {
                // Clear saved data when loading new JSON
                clearSavedData();
                
                // Set hydration flag to prevent scroll restoration during load
                isDocumentHydrating = true;
                
                // Record action for undo/redo BEFORE populating (so population actions aren't recorded)
                recordFormAction({
                    type: ACTION_TYPES.LOAD_JSON,
                    jsonData: data,
                    previousState: previousState
                });
                
                // Set flag to prevent actions during population from being recorded
                isFormUndoRedoInProgress = true;
                try {
                populateFormFromJSON(data);
                } finally {
                    isFormUndoRedoInProgress = false;
                }
                window.__fpFormState = data;
                
                // Start a new session when JSON is loaded (user is starting new work)
                // Clear previous undo history but keep the LOAD_JSON action we just recorded
                if (formUndoHistory.length > 1) {
                    const loadJsonAction = formUndoHistory[formUndoHistory.length - 1];
                    formUndoHistory.length = 0;
                    formUndoHistory.push(loadJsonAction);
                }
                // Redo history is already cleared by recordFormAction
                updateUndoRedoButtons();
                
                // Register whole input form; spawn-finalize visible panel (force-fit with current content)
                if (typeof AutoSizeManager !== 'undefined') {
                    if (AutoSizeManager.register) {
                        AutoSizeManager.register(document.getElementById('input-form') || document.body);
                    }
                    const activeRoot = resolveActivePanelRoot();
                    if (AutoSizeManager.finalizeSpawn) {
                        AutoSizeManager.finalizeSpawn(activeRoot);
                    }
                if (AutoSizeManager.fitPending) {
                    AutoSizeManager.fitPending(activeRoot);
                }
            }
                applyBboxesEverywhere({ forceRetag: true });
            
                // Mark form as changed and trigger autosave after loading JSON
                // This ensures autosave flow runs (with validation gating)
                markFormAsChanged();
                triggerAutoSave();
                
                alert(' Success! Your form has been filled with the data from the JSON.');
            } catch (e) {
                console.error(e);
                alert('Failed to populate form from JSON: ' + e.message);
                // Clear hydration flag on error
                isDocumentHydrating = false;
            }
        }

        // Reset/clear the form fields
        function resetForm(isInternalCall) {
            // Clear saved data when clearing form
            if (!isInternalCall) {
                clearSavedData();
                hasUnsavedChanges = false;
                updateSaveIndicator('none');
            }
            
            // Clear all live previews first to fix rendering issue
            const allPreviews = document.querySelectorAll('.live-preview');
            allPreviews.forEach(preview => {
                preview.innerHTML = '';
            });
            
            // basic
            setInputValue('#textbook_page', '');
            setInputValue('#textbook_pdf_page', '');
            setInputValue('#guidebook_start_page', '');
            setInputValue('#guidebook_end_page', '');
            const pageTypeEl = document.getElementById('page_type');
            if (pageTypeEl) pageTypeEl.value = 'content';

            // lesson preamble
            setInputValue('#lesson_id', '');
            setInputValue('#lesson_title', '');
            setInputValue('#lesson_text', '');

            // dynamic containers
            clearDynamicContainers();

            // Recreate one empty row for lesson standards and terminology
            const standards = document.getElementById('lesson_standards');
            if (standards) {
                standards.innerHTML = '';
                addLessonStandard();
            }
            const terminology = document.getElementById('terminology');
            if (terminology) {
                terminology.innerHTML = '';
                addTerminology();
            }

            // Clear JSON output/preview and input unless internal
            const jsonOutput = document.getElementById('json_output');
            if (jsonOutput) {
                jsonOutput.innerHTML = '<span class="json-key">//</span> <span class="json-string">JSON will be generated here...</span>';
                jsonOutput.removeAttribute('data-raw-json');
            }
            if (!isInternalCall) {
                setInputValue('#json_input', '');
            }
            
            // Re-attach previews after clearing to ensure proper initialization
            setTimeout(() => {
                attachPreviews(document);
                
                // Ensure all textareas are set to correct direction after reset
                const allTextareas = document.querySelectorAll('textarea, input[type="text"]');
                allTextareas.forEach(ta => {
                    if (ta.hasAttribute('data-ltr')) {
                        // LTR fields (JSON input, lesson standards)
                        ta.setAttribute('dir', 'ltr');
                    } else {
                        // RTL fields (content, questions, titles, etc.)
                        ta.setAttribute('dir', 'rtl');
                    }
                    // CSS will handle the styling based on data-ltr attribute
                });
                
                // Update all direction toggle buttons to show correct text
                const allDirBtns = document.querySelectorAll('.dir-btn');
                allDirBtns.forEach(btn => {
                    const textarea = btn.closest('.text-field-container')?.querySelector('textarea') || 
                                    btn.parentElement?.querySelector('textarea') ||
                                    btn.parentElement?.querySelector('input[type="text"]');
                    if (textarea) {
                        const isLTR = textarea.hasAttribute('data-ltr');
                        // Button shows what clicking it will do
                        btn.textContent = isLTR ? 'RTL' : 'LTR';
                    }
                });
            }, 100);
        }


        // Markdown toolbar functions - Undo/Redo history tracking
        const undoHistory = new Map(); // Map of field -> array of operations
        const redoHistory = new Map(); // Map of field -> array of operations
        
        function addToUndoHistory(field, operation) {
            if (!undoHistory.has(field)) {
                undoHistory.set(field, []);
            }
            const history = undoHistory.get(field);
            history.push(operation);
            // Keep only last 50 operations
            if (history.length > 50) {
                history.shift();
            }
            // Clear redo history when a new operation is added
            if (redoHistory.has(field)) {
                redoHistory.get(field).length = 0;
            }
        }
        
        function insertMarkdown(element, syntax, wrap = true) {
            const start = element.selectionStart;
            const end = element.selectionEnd;
            const selectedText = element.value.substring(start, end);
            const textBefore = element.value.substring(0, start);
            const textAfter = element.value.substring(end);
            
            let newText, newCursorPos;
            
            if (selectedText && wrap) {
                // Wrap selected text
                newText = textBefore + syntax[0] + selectedText + syntax[1] + textAfter;
                newCursorPos = start + syntax[0].length + selectedText.length + syntax[1].length;
            } else {
                // Insert placeholder
                newText = textBefore + syntax[0] + syntax[1] + textAfter;
                newCursorPos = start + syntax[0].length;
            }
            
            const oldValue = element.value;
            element.value = newText;
            element.setSelectionRange(newCursorPos, newCursorPos);
            element.focus();
            
            // Track this operation for undo
            addToUndoHistory(element, {
                type: 'markdown',
                oldValue: oldValue,
                newValue: newText,
                oldSelection: { start: start, end: end },
                newSelection: { start: newCursorPos, end: newCursorPos }
            });
            
            if (element.tagName === 'TEXTAREA') {
                refreshPreviewFor(element);
            }
            element.dispatchEvent(new Event('input', { bubbles: true }));
            
            // Mark form as changed and trigger auto-save
            markFormAsChanged();
            triggerAutoSave();
        }
        
        function insertBold(element) {
            const field = element.tagName === 'BUTTON' ? element.parentElement.querySelector('textarea, input[type="text"]') : element;
            insertMarkdown(field, ['**', '**'], true);
        }
        
        function insertItalic(element) {
            const field = element.tagName === 'BUTTON' ? element.parentElement.querySelector('textarea, input[type="text"]') : element;
            insertMarkdown(field, ['*', '*'], true);
        }
        
        function insertBulletList(element) {
            const field = element.tagName === 'BUTTON' ? element.parentElement.querySelector('textarea') : element;
            if (!field || field.tagName !== 'TEXTAREA') return; // Only works with textareas
            
            const start = field.selectionStart;
            const end = field.selectionEnd;
            const text = field.value;
            const textBefore = text.substring(0, start);
            const textAfter = text.substring(end);
            
            // Find the start of the current line(s)
            const lineStart = textBefore.lastIndexOf('\n') + 1;
            const lineEnd = textAfter.indexOf('\n') === -1 ? text.length : end + textAfter.indexOf('\n');
            
            const selectedText = text.substring(lineStart, lineEnd);
            const lines = selectedText.split('\n');
            
            // Process each line
            const processedLines = lines.map(line => {
                const trimmed = line.trim();
                if (trimmed === '') return line; // Preserve empty lines as-is
                // Check if line already starts with bullet
                if (trimmed.startsWith('- ') || trimmed.match(/^[-*+]\s/)) {
                    return line; // Already a bullet, don't change
                }
                // Add bullet marker
                const indent = line.match(/^(\s*)/)[1];
                return indent + '- ' + trimmed;
            });
            
            const newText = text.substring(0, lineStart) + processedLines.join('\n') + text.substring(lineEnd);
            const oldValue = field.value;
            field.value = newText;
            
            // Set cursor position
            const newCursorPos = start + (processedLines.join('\n').length - selectedText.length);
            field.setSelectionRange(newCursorPos, newCursorPos);
            field.focus();
            
            // Track this operation for undo
            addToUndoHistory(field, {
                type: 'bullet_list',
                oldValue: oldValue,
                newValue: newText,
                oldSelection: { start: start, end: end },
                newSelection: { start: newCursorPos, end: newCursorPos }
            });
            
            refreshPreviewFor(field);
            field.dispatchEvent(new Event('input', { bubbles: true }));
            
            // Mark form as changed and trigger auto-save
            markFormAsChanged();
            triggerAutoSave();
        }
        
        function insertNumberedList(element) {
            const field = element.tagName === 'BUTTON' ? element.parentElement.querySelector('textarea') : element;
            if (!field || field.tagName !== 'TEXTAREA') return; // Only works with textareas
            
            const start = field.selectionStart;
            const end = field.selectionEnd;
            const text = field.value;
            const textBefore = text.substring(0, start);
            const textAfter = text.substring(end);
            
            // Find the start of the current line(s)
            const lineStart = textBefore.lastIndexOf('\n') + 1;
            const lineEnd = textAfter.indexOf('\n') === -1 ? text.length : end + textAfter.indexOf('\n');
            
            const selectedText = text.substring(lineStart, lineEnd);
            const lines = selectedText.split('\n');
            
            // Process each line
            let lineNumber = 1;
            // Check if there's a numbered list before this to continue numbering
            const beforeText = text.substring(0, lineStart);
            const lastNumberedLine = beforeText.match(/(\d+)\.\s[^\n]*$/);
            if (lastNumberedLine) {
                lineNumber = parseInt(lastNumberedLine[1]) + 1;
            }
            
            const processedLines = lines.map(line => {
                const trimmed = line.trim();
                if (trimmed === '') return line; // Preserve empty lines as-is
                // Check if line already starts with number
                if (trimmed.match(/^\d+\.\s/)) {
                    return line; // Already numbered, don't change
                }
                // Add number marker
                const indent = line.match(/^(\s*)/)[1];
                const numbered = indent + lineNumber + '. ' + trimmed;
                lineNumber++;
                return numbered;
            });
            
            const newText = text.substring(0, lineStart) + processedLines.join('\n') + text.substring(lineEnd);
            const oldValue = field.value;
            field.value = newText;
            
            // Set cursor position
            const newCursorPos = start + (processedLines.join('\n').length - selectedText.length);
            field.setSelectionRange(newCursorPos, newCursorPos);
            field.focus();
            
            // Track this operation for undo
            addToUndoHistory(field, {
                type: 'numbered_list',
                oldValue: oldValue,
                newValue: newText,
                oldSelection: { start: start, end: end },
                newSelection: { start: newCursorPos, end: newCursorPos }
            });
            
            refreshPreviewFor(field);
            field.dispatchEvent(new Event('input', { bubbles: true }));
            
            // Mark form as changed and trigger auto-save
            markFormAsChanged();
            triggerAutoSave();
        }
        
        function insertBlockquote(element) {
            const field = element.tagName === 'BUTTON' ? element.parentElement.querySelector('textarea') : element;
            if (!field || field.tagName !== 'TEXTAREA') return; // Only works with textareas
            
            const start = field.selectionStart;
            const end = field.selectionEnd;
            const text = field.value;
            const textBefore = text.substring(0, start);
            const textAfter = text.substring(end);
            
            // Find the start of the current line(s)
            const lineStart = textBefore.lastIndexOf('\n') + 1;
            const lineEnd = textAfter.indexOf('\n') === -1 ? text.length : end + textAfter.indexOf('\n');
            
            const selectedText = text.substring(lineStart, lineEnd);
            const lines = selectedText.split('\n');
            
            // Process each line
            const processedLines = lines.map(line => {
                const trimmed = line.trim();
                // Handle empty lines - add blockquote marker
                if (trimmed === '') {
                    const indent = line.match(/^(\s*)/)[1];
                    return indent + '> ';
                }
                // Check if line already starts with blockquote (with proper spacing: > followed by exactly one space)
                if (trimmed.match(/^>\s[^\s]/) || trimmed === '>') {
                    return line; // Already a blockquote, don't change
                }
                // Add blockquote marker with exactly one space (per validation requirement)
                const indent = line.match(/^(\s*)/)[1];
                return indent + '> ' + trimmed;
            });
            
            const newText = text.substring(0, lineStart) + processedLines.join('\n') + text.substring(lineEnd);
            const oldValue = field.value;
            field.value = newText;
            
            // Calculate new cursor position
            let newCursorPos;
            // If cursor was on an empty line (no selection and line is empty), place cursor after "> "
            if (start === end && selectedText.trim() === '') {
                // Find where the cursor should be - right after "> " on the current line
                const beforeNewText = text.substring(0, lineStart);
                const currentLineInNewText = processedLines[0]; // First processed line
                newCursorPos = beforeNewText.length + currentLineInNewText.length;
            } else {
                // Multiple lines or selection - place cursor at the end of the processed text
                newCursorPos = start + (processedLines.join('\n').length - selectedText.length);
            }
            
            field.setSelectionRange(newCursorPos, newCursorPos);
            field.focus();
            
            // Track this operation for undo
            addToUndoHistory(field, {
                type: 'blockquote',
                oldValue: oldValue,
                newValue: newText,
                oldSelection: { start: start, end: end },
                newSelection: { start: newCursorPos, end: newCursorPos }
            });
            
            refreshPreviewFor(field);
            field.dispatchEvent(new Event('input', { bubbles: true }));
            
            // Mark form as changed and trigger auto-save
            markFormAsChanged();
            triggerAutoSave();
        }
        
        function removeMarkdownFormatting(element) {
            try {
                const field = element.tagName === 'BUTTON' ? element.parentElement.querySelector('textarea, input[type="text"]') : element;
                if (!field) {
                    console.error('removeMarkdownFormatting: Could not find field');
                    return;
                }
                
                // Get undo history for this field
                const history = undoHistory.get(field);
                if (!history || history.length === 0) {
                    // No history to undo
                    return;
                }
                
                // Get the last operation
                const lastOp = history.pop();
                
                // Save current state before undo for redo
                const currentValue = field.value;
                const currentSelection = { start: field.selectionStart, end: field.selectionEnd };
                
                // Add to redo history - this will restore us back to the state before undo
                if (!redoHistory.has(field)) {
                    redoHistory.set(field, []);
                }
                redoHistory.get(field).push({
                    type: lastOp.type,
                    oldValue: lastOp.oldValue, // Where we are going (after undo)
                    newValue: lastOp.newValue, // Where we want to go back to (before undo)
                    oldSelection: lastOp.oldSelection, // Selection after undo
                    newSelection: lastOp.newSelection // Selection before undo (what we want to restore)
                });
                
                // Restore the old value and selection (undo)
                field.value = lastOp.oldValue;
                field.setSelectionRange(lastOp.oldSelection.start, lastOp.oldSelection.end);
                field.focus();
                
                // Refresh preview if it's a textarea
                if (field.tagName === 'TEXTAREA') {
                    refreshPreviewFor(field);
                }
                field.dispatchEvent(new Event('input', { bubbles: true }));
                
                // Mark form as changed and trigger auto-save
                markFormAsChanged();
                triggerAutoSave();
            } catch (error) {
                console.error('Error in removeMarkdownFormatting:', error);
            }
        }
        
        function redoMarkdownFormatting(element) {
            try {
                const field = element.tagName === 'BUTTON' ? element.parentElement.querySelector('textarea, input[type="text"]') : element;
                if (!field) {
                    console.error('redoMarkdownFormatting: Could not find field');
                    return;
                }
                
                // Get redo history for this field
                const history = redoHistory.get(field);
                if (!history || history.length === 0) {
                    // No history to redo
                    return;
                }
                
                // Get the last redo operation
                const lastOp = history.pop();
                
                // Save current state before redo for undo
                const currentValue = field.value;
                const currentSelection = { start: field.selectionStart, end: field.selectionEnd };
                
                // Add current state back to undo history (so we can undo the redo)
                if (!undoHistory.has(field)) {
                    undoHistory.set(field, []);
                }
                undoHistory.get(field).push({
                    type: lastOp.type,
                    oldValue: lastOp.oldValue, // Current state (after undo)
                    newValue: lastOp.newValue, // State we're going to (before undo)
                    oldSelection: lastOp.oldSelection, // Current selection
                    newSelection: lastOp.newSelection // Selection we're restoring
                });
                
                // Restore the redo value and selection (redo - go back to state before undo)
                field.value = lastOp.newValue;
                field.setSelectionRange(lastOp.newSelection.start, lastOp.newSelection.end);
                field.focus();
                
                // Refresh preview if it's a textarea
                if (field.tagName === 'TEXTAREA') {
                    refreshPreviewFor(field);
                }
                field.dispatchEvent(new Event('input', { bubbles: true }));
                
                // Mark form as changed and trigger auto-save
                markFormAsChanged();
                triggerAutoSave();
            } catch (error) {
                console.error('Error in redoMarkdownFormatting:', error);
            }
        }
        
        function insertInlineLatex(element) {
            const field = element.tagName === 'BUTTON' ? element.parentElement.querySelector('textarea, input[type="text"]') : element;
            const start = field.selectionStart;
            const end = field.selectionEnd;
            const selectedText = field.value.substring(start, end);
            const textBefore = field.value.substring(0, start);
            const textAfter = field.value.substring(end);
            
            let newText, newCursorPos;
            
            if (selectedText) {
                // Wrap selected text with $
                newText = textBefore + '$' + selectedText + '$' + textAfter;
                newCursorPos = start + 1 + selectedText.length + 1;
            } else {
                // Insert $$ with cursor in middle
                newText = textBefore + '$$' + textAfter;
                newCursorPos = start + 1;
            }
            
            const oldValue = field.value;
            field.value = newText;
            field.setSelectionRange(newCursorPos, newCursorPos);
            field.focus();
            
            // Track this operation for undo
            addToUndoHistory(field, {
                type: 'inline_latex',
                oldValue: oldValue,
                newValue: newText,
                oldSelection: { start: start, end: end },
                newSelection: { start: newCursorPos, end: newCursorPos }
            });
            
            if (field.tagName === 'TEXTAREA') {
                refreshPreviewFor(field);
            }
            field.dispatchEvent(new Event('input', { bubbles: true }));
            
            // Mark form as changed and trigger auto-save
            markFormAsChanged();
            triggerAutoSave();
        }
        
        function insertBlockLatex(element) {
            const field = element.tagName === 'BUTTON' ? element.parentElement.querySelector('textarea') : element;
            if (!field || field.tagName !== 'TEXTAREA') return; // Only works with textareas
            
            const start = field.selectionStart;
            const end = field.selectionEnd;
            const selectedText = field.value.substring(start, end);
            const textBefore = field.value.substring(0, start);
            const textAfter = field.value.substring(end);
            
            let newText, newCursorPos;
            
            if (selectedText) {
                // Wrap selected text with $$\n...\n$$ (literal \n strings)
                newText = textBefore + '$$\\n' + selectedText + '\\n$$' + textAfter;
                newCursorPos = start + 4 + selectedText.length + 4;
            } else {
                // Insert $$\n\n$$ with cursor in middle (literal \n strings)
                newText = textBefore + '$$\\n\\n$$' + textAfter;
                newCursorPos = start + 4;
            }
            
            const oldValue = field.value;
            field.value = newText;
            field.setSelectionRange(newCursorPos, newCursorPos);
            field.focus();
            
            // Track this operation for undo
            addToUndoHistory(field, {
                type: 'block_latex',
                oldValue: oldValue,
                newValue: newText,
                oldSelection: { start: start, end: end },
                newSelection: { start: newCursorPos, end: newCursorPos }
            });
            
            refreshPreviewFor(field);
            field.dispatchEvent(new Event('input', { bubbles: true }));
            
            // Mark form as changed and trigger auto-save
            markFormAsChanged();
            triggerAutoSave();
        }
        
        // Insert table into text field with automatic indexing
        function insertTable(textarea) {
            // Check if this is a restricted field (lesson text)
            const isLessonText = textarea.id === 'lesson_text';
            
            if (isLessonText) {
                alert('Tables are not allowed in lesson preamble text. Please add tables only in question text, guide answers, set-up text, or content sections.');
                return;
            }
            
            const tableDescription = prompt('Enter table description (optional):');
            
            // Get the next available image index automatically
            const nextIndex = getNextImageIndexForField(textarea);
            
            const numColumns = prompt('Enter number of columns (e.g., 3):');
            if (!numColumns || isNaN(numColumns) || numColumns < 1) {
                alert('Please enter a valid number of columns');
                return;
            }
            
            const numRows = prompt('Enter number of rows (e.g., 3):');
            if (!numRows || isNaN(numRows) || numRows < 1) {
                alert('Please enter a valid number of rows');
                return;
            }
            
            // Build table structure
            let tableMarkdown = '';
            
            // Add image reference with automatic index
            if (tableDescription && tableDescription.trim()) {
                tableMarkdown += `![${tableDescription.trim()}](${nextIndex})\n`;
            } else {
                tableMarkdown += `![](${nextIndex})\n`;
            }
            
            // Add table headers
            const headers = [];
            for (let i = 1; i <= numColumns; i++) {
                headers.push(`Header ${i}`);
            }
            tableMarkdown += `| ${headers.join(' | ')} |\n`;
            
            // Add separator line
            const separators = [];
            for (let i = 1; i <= numColumns; i++) {
                separators.push('----------');
            }
            tableMarkdown += `| ${separators.join(' | ')} |\n`;
            
            // Add data rows
            for (let row = 1; row <= numRows; row++) {
                const cells = [];
                for (let col = 1; col <= numColumns; col++) {
                    cells.push(`Row ${row}, Cell ${col}`);
                }
                tableMarkdown += `| ${cells.join(' | ')} |\n`;
            }
            
            // Insert at cursor position or at end
            const cursorPos = textarea.selectionStart;
            const textBefore = textarea.value.substring(0, cursorPos);
            const textAfter = textarea.value.substring(cursorPos);
            
            textarea.value = textBefore + tableMarkdown + textAfter;
            
            // Set cursor position after the inserted table
            const newCursorPos = cursorPos + tableMarkdown.length;
            textarea.setSelectionRange(newCursorPos, newCursorPos);
            textarea.focus();
            refreshPreviewFor(textarea);
            
            // Trigger input event to update radio buttons (if in a multiple choice question)
            // This will trigger the existing event listener that updates radio buttons
            textarea.dispatchEvent(new Event('input', { bubbles: true }));
            
            // Mark form as changed and trigger auto-save
            markFormAsChanged();
            triggerAutoSave();
        }

        // Insert image into text field with automatic indexing
        function insertImage(textarea) {
            
            // Check if this is a restricted field (lesson text)
            const isLessonText = textarea.id === 'lesson_text';
            
            if (isLessonText) {
                alert('Images are not allowed in lesson preamble text. Please add images only in question text, guide answers, set-up text, or content sections.');
                return;
            }
            
            const imageDescription = prompt('Enter image description (optional):');
            if (imageDescription === null) return; // User cancelled
            
            // Get the next available image index automatically
            const nextIndex = getNextImageIndexForField(textarea);
            
            // Build image markdown with automatic index
            let imageMarkdown = '';
            if (imageDescription && imageDescription.trim()) {
                imageMarkdown = `![${imageDescription.trim()}](${nextIndex})`;
            } else {
                imageMarkdown = `![](${nextIndex})`;
            }
            
            
            // Insert at cursor position or at end
            const cursorPos = textarea.selectionStart;
            const textBefore = textarea.value.substring(0, cursorPos);
            const textAfter = textarea.value.substring(cursorPos);
            
            textarea.value = textBefore + imageMarkdown + textAfter;
            
            // Set cursor position after the inserted image
            const newCursorPos = cursorPos + imageMarkdown.length;
            textarea.setSelectionRange(newCursorPos, newCursorPos);
            textarea.focus();
            
            refreshPreviewFor(textarea);
            
            // Trigger input event to update radio buttons (if in a multiple choice question)
            // This will trigger the existing event listener that updates radio buttons
            textarea.dispatchEvent(new Event('input', { bubbles: true }));
            
            // Mark form as changed and trigger auto-save
            markFormAsChanged();
            triggerAutoSave();
        }

        // Copy JSON to clipboard
        function copyJSON() {
            const jsonOutput = document.getElementById('json_output');
            const jsonText = jsonOutput.textContent || jsonOutput.innerText;
            
            // Create a temporary textarea to copy the text
            const textarea = document.createElement('textarea');
            textarea.value = jsonText;
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);
            
            // Show feedback
            const copyBtn = event.target.closest('button');
            const originalText = copyBtn.innerHTML;
            copyBtn.innerHTML = '<i class="fas fa-check"></i> Copied!';
            copyBtn.style.background = '#28a745';
            
            setTimeout(() => {
                copyBtn.innerHTML = originalText;
                copyBtn.style.background = '';
            }, 2000);
            
        }

        // Confirm before clearing the form
        function confirmClearForm() {
            if (confirm(' Warning: This will delete everything you\'ve entered in the form and clear your saved progress.\n\nAre you sure you want to clear the form?')) {
                // Save current form state for undo (without validation)
                let savedState = null;
                try {
                    savedState = collectFormDataWithoutValidation();
                } catch (e) {
                    console.warn('Could not save form state for undo:', e);
                }
                
                // Record action for undo/redo BEFORE clearing (so clearing actions aren't recorded)
                recordFormAction({
                    type: ACTION_TYPES.CLEAR_FORM,
                    savedState: savedState,
                    clearFunction: resetForm
                });
                
                // Set flag to prevent actions during reset from being recorded
                isFormUndoRedoInProgress = true;
                try {
                resetForm(false);
                } finally {
                    isFormUndoRedoInProgress = false;
                }
            }
        }

        // ===== MANUAL SAVE FUNCTIONALITY =====
        
        const SAVE_KEY = 'transcription_form_save';
        let hasUnsavedChanges = false;
        let lastSavedData = null;
        let autoSaveTimeout = null;
        let fieldValues = new Map(); // Track field values to detect changes
        let lastValidationErrorSet = null; // Track last validation errors to prevent spam
        let lastValidationWarningTime = 0; // Track last warning time for debouncing
        
        // Update save indicator
        function updateSaveIndicator(status) {
            const indicator = document.getElementById('saveIndicator');
            if (!indicator) return;
            
            const text = indicator.querySelector('span');
            if (!text) return;
            
            indicator.className = 'auto-save-indicator';
            
            if (status === 'unsaved') {
                indicator.classList.add('saving');
                text.textContent = ' Unsaved changes';
            } else if (status === 'saving') {
                indicator.classList.add('saving');
                text.textContent = 'Saving...';
            } else if (status === 'saved') {
                indicator.classList.add('saved');
                text.textContent = ' All saved';
            } else {
                text.textContent = 'No changes';
            }
        }
        
        // Track that form has changes
        function markFormAsChanged() {
            hasUnsavedChanges = true;
            updateSaveIndicator('unsaved');
        }
        
        // Debounced auto-save function
        function triggerAutoSave() {
            // Clear any pending auto-save
            if (autoSaveTimeout) {
                clearTimeout(autoSaveTimeout);
            }
            
            // Only save if there are unsaved changes
            if (!hasUnsavedChanges) {
                return;
            }
            
            // Debounce: wait 1 second after last change before saving
            autoSaveTimeout = setTimeout(() => {
                if (hasUnsavedChanges) {
                    try {
                        updateSaveIndicator('saving');
                        saveProgress(true); // Pass true to indicate this is an auto-save
                    } catch (error) {
                        console.error('Auto-save failed:', error);
                        updateSaveIndicator('unsaved');
                    }
                }
            }, 1000);
        }
        
        // Manual save function - uses the same generateJSON logic
        // Optional parameter: isAutoSave - if true, suppress some alerts for validation warnings
        function saveProgress(isAutoSave = false) {
            if (window.__saveInProgress) return;
            window.__saveInProgress = true;
            try {
                // Use the exact same logic as generateJSON() to create the JSON structure
                const textbookPage = document.getElementById('textbook_page').value;
                const textbookPdfPage = document.getElementById('textbook_pdf_page').value;
                const guidebookStart = document.getElementById('guidebook_start_page').value;
                const guidebookEnd = document.getElementById('guidebook_end_page').value;
                const pageType = document.getElementById('page_type').value;
                
                // Validate block LaTeX in all content sections and questions before saving (exclude output fields)
                const validationErrors = [];
                const validationWarnings = [];
                const allTextareas = document.querySelectorAll('textarea');
                allTextareas.forEach((textarea, index) => {
                    // Skip validation for output/display fields
                    const textareaId = textarea.id;
                    if (textareaId === 'json_input' || textareaId === 'json_output' || 
                        textarea.classList.contains('output-field') || 
                        textarea.hasAttribute('readonly')) {
                        return; // Skip this textarea
                    }
                    
                    const content = textarea.value || '';
                    const mathBlockErrors = validateBlockLatex(content);
                    if (mathBlockErrors.length > 0) {
                        mathBlockErrors.forEach(error => {
                            validationErrors.push(`Block LaTeX Error in ${getTextareaLocation(textarea)}: ${error.message}`);
                        });
                    }
                    
                    // Validate blanks in LaTeX
                    const blanksInLatexErrors = validateBlanksInLatex(content);
                    if (blanksInLatexErrors.length > 0) {
                        blanksInLatexErrors.forEach(error => {
                            validationErrors.push(`Blank in LaTeX Error in ${getTextareaLocation(textarea)}: ${error.message}`);
                        });
                    }
                    
                    const imageDescErrors = validateImageDescriptions(content);
                    if (imageDescErrors.length > 0) {
                        imageDescErrors.forEach(error => {
                            validationErrors.push(`Image Description Error in ${getTextareaLocation(textarea)}: ${error.message}`);
                        });
                    }
                    
                    const quoteErrors = validateQuotes(content);
                    if (quoteErrors.length > 0) {
                        quoteErrors.forEach(error => {
                            validationErrors.push(`Quote Error in ${getTextareaLocation(textarea)}: ${error.message}`);
                        });
                    }
                    
                    // Validate <br> tags
                    const brErrors = validateBrTags(content);
                    if (brErrors.length > 0) {
                        brErrors.forEach(error => {
                            validationErrors.push(`HTML Tag Error in ${getTextareaLocation(textarea)}: ${error.message}`);
                        });
                    }
                    
                    const dollarErrors = validateDollarSigns(content);
                    if (dollarErrors.length > 0) {
                        dollarErrors.forEach(error => {
                            validationWarnings.push(`Dollar Sign Warning in ${getTextareaLocation(textarea)}: ${error.message}`);
                        });
                    }
                    
                    // Validate table markdown
                    const tableValidation = validateTableMarkdown(content);
                    if (tableValidation.hasTables && !tableValidation.valid && tableValidation.errors.length > 0) {
                        tableValidation.errors.forEach(error => {
                            const errorMsg = typeof error === 'string' ? error : error.message;
                            validationErrors.push(`Table Markdown Error in ${getTextareaLocation(textarea)}: ${errorMsg}`);
                        });
                    }
                    
                    // Validate list markdown
                    const listValidation = validateListMarkdown(content);
                    if (listValidation.hasLists && !listValidation.valid && listValidation.errors.length > 0) {
                        listValidation.errors.forEach(error => {
                            const errorMsg = typeof error === 'string' ? error : error.message;
                            validationErrors.push(`List Markdown Error in ${getTextareaLocation(textarea)}: ${errorMsg}`);
                        });
                    }
                    
                    // Validate blockquote markdown
                    const blockquoteValidation = validateBlockquoteMarkdown(content);
                    if (blockquoteValidation.hasBlockquotes && !blockquoteValidation.valid && blockquoteValidation.errors.length > 0) {
                        blockquoteValidation.errors.forEach(error => {
                            const errorMsg = typeof error === 'string' ? error : error.message;
                            validationErrors.push(`Blockquote Markdown Error in ${getTextareaLocation(textarea)}: ${errorMsg}`);
                        });
                    }
                });
                
                // Required top-level fields
                if (!textbookPage) validationErrors.push('Textbook page is required');
                if (!textbookPdfPage) validationErrors.push('Textbook PDF page is required');
                if (!guidebookStart) validationErrors.push('Guidebook start page is required');
                if (!guidebookEnd) validationErrors.push('Guidebook end page is required');
                if (guidebookStart && guidebookEnd && parseInt(guidebookStart) > parseInt(guidebookEnd)) {
                    validationErrors.push('Guidebook start page cannot be greater than end page');
                }
                if (!pageType || pageType.trim().length === 0) validationErrors.push('Page type is required');

                if (validationErrors.length > 0) {
                    // For auto-save, don't show alerts but log to console and keep unsaved state
                    if (isAutoSave) {
                        // Debounce warnings: only log if errors changed or enough time passed (5 seconds)
                        const errorSetKey = validationErrors.join('|');
                        const now = Date.now();
                        const timeSinceLastWarning = now - lastValidationWarningTime;
                        const errorsChanged = lastValidationErrorSet !== errorSetKey;
                        
                        if (errorsChanged || timeSinceLastWarning > 5000) {
                            console.warn('Auto-save blocked by validation errors:', validationErrors);
                            lastValidationErrorSet = errorSetKey;
                            lastValidationWarningTime = now;
                        }
                        updateSaveIndicator('unsaved');
                        return;
                    }
                    alert("Cannot save - Validation errors found:\n" + validationErrors.join("\n"));
                    return;
                }
                
                // Build JSON using the same structure as generateJSON()
                const jsonData = {
                    textbook_page: textbookPage ? parseInt(textbookPage) : null,
                    textbook_pdf_page: textbookPdfPage ? parseInt(textbookPdfPage) : null,
                    guidebook_pdf_pages: generateGuidebookPageArray(),
                    page_type: document.getElementById('page_type').value || "content",
                    lesson_preamble: null,
                    instructional_content: [],
                    practice_questions: []
                };

                // Collect content sections (same logic as generateJSON) - only get the main content sections (direct children)
                const contentElements = document.querySelectorAll('#content_sections_container > .array-item');
                contentElements.forEach((contentEl, index) => {
                    try {
                        const contentData = collectContentData(contentEl);
                        
                        // Warn if section title is empty
                        if (!contentData.section_title) {
                            validationWarnings.push(ErrorMessages.warningSectionTitle(index));
                        }
                        
                        if (!contentData.text || /^\d+$/.test(contentData.text)) {
                            validationErrors.push(ErrorMessages.requiredContent(index));
                        } else {
                            jsonData.instructional_content.push(contentData);
                        }
                    } catch (error) {
                        validationErrors.push(`Content Section ${index + 1}: ${error.message}`);
                    }
                });

                // Add lesson preamble if provided
                const lessonId = document.getElementById('lesson_id').value;
                if (lessonId) {
                    jsonData.lesson_preamble = {
                        id: lessonId.trim(),
                        title: document.getElementById('lesson_title').value || "",
                        lesson_standards: Array.from(document.querySelectorAll('#lesson_standards textarea')).map(textarea => textarea.value).filter(v => v),
                        terminology: Array.from(document.querySelectorAll('#terminology textarea')).map(textarea => textarea.value).filter(v => v),
                        text: document.getElementById('lesson_text').value || ""
                    };
                }

                // Collect questions (same logic as generateJSON) - only get the main questions (direct children)
                const questionElements = document.querySelectorAll('#questions_container > .array-item');
                questionElements.forEach((questionEl, index) => {
                    try {
                        const questionData = collectQuestionData(questionEl);
                        
                        // Validate required fields
                        if (!questionData.id) validationErrors.push(ErrorMessages.requiredQuestionID(index));
                        
                        // Validate annotate and create_table types
                        if (questionData.question_type === 'annotate' || questionData.question_type === 'create_table') {
                            // Validate required fields
                            if (!questionData.question_text || /^\d+$/.test(questionData.question_text)) {
                                validationErrors.push(ErrorMessages.requiredQuestionText(index));
                            }
                            
                            // Validate guide PDF page
                            if (!questionData.guide_pdf_page) {
                                validationErrors.push(ErrorMessages.requiredGuidePage(index));
                            } else if (isNaN(questionData.guide_pdf_page) || !Number.isInteger(questionData.guide_pdf_page) || questionData.guide_pdf_page <= 0) {
                                validationErrors.push(ErrorMessages.invalidGuidePage(index));
                            } else {
                                // Validate guide PDF page is within guidebook range
                                const gbStart = parseInt(guidebookStart, 10);
                                const gbEnd = parseInt(guidebookEnd, 10);
                                if (!isNaN(gbStart) && !isNaN(gbEnd) && gbStart > 0 && gbEnd > 0) {
                                    if (questionData.guide_pdf_page < gbStart || questionData.guide_pdf_page > gbEnd) {
                                        validationErrors.push(ErrorMessages.guidePageOutOfRange(index, questionData.guide_pdf_page, gbStart, gbEnd));
                                    }
                                }
                            }
                        } else if (questionData.question_type === 'fill_in_the_blanks') {
                            // Fill in the blanks validation (same as in generateJSON)
                            if (!questionData.question_text || /^\d+$/.test(questionData.question_text)) {
                                validationErrors.push(ErrorMessages.requiredQuestionText(index));
                            } else {
                                const { valid, errors, blanks } = validateBlankFormat(questionData.question_text);
                                
                                if (blanks.length === 0) {
                                    validationErrors.push(ErrorMessages.noBlanksFound(index));
                                } else if (!valid) {
                                    errors.forEach(err => {
                                        validationErrors.push(ErrorMessages.invalidBlankFormat(index, err));
                                    });
                                }
                                
                                if (!questionData.values || !Array.isArray(questionData.values)) {
                                    validationErrors.push(ErrorMessages.blankAnswerMismatch(index, blanks.length, 0));
                                } else {
                                    if (questionData.values.length !== blanks.length) {
                                        validationErrors.push(ErrorMessages.blankAnswerMismatch(index, blanks.length, questionData.values.length));
                                    }
                                    
                                    const emptyBlanks = [];
                                    questionData.values.forEach((answer, idx) => {
                                        if (!answer || answer.trim() === '') {
                                            emptyBlanks.push(`___${blanks[idx]}___`);
                                        }
                                    });
                                    if (emptyBlanks.length > 0) {
                                        validationErrors.push(ErrorMessages.missingBlankAnswers(index, emptyBlanks));
                                    }
                                }
                            }
                            
                            if (!questionData.guide_pdf_page) {
                                validationErrors.push(ErrorMessages.requiredGuidePage(index));
                            } else if (isNaN(questionData.guide_pdf_page) || !Number.isInteger(questionData.guide_pdf_page) || questionData.guide_pdf_page <= 0) {
                                validationErrors.push(ErrorMessages.invalidGuidePage(index));
                            } else {
                                // Validate guide PDF page is within guidebook range
                                const gbStart = parseInt(guidebookStart, 10);
                                const gbEnd = parseInt(guidebookEnd, 10);
                                if (!isNaN(gbStart) && !isNaN(gbEnd) && gbStart > 0 && gbEnd > 0) {
                                    if (questionData.guide_pdf_page < gbStart || questionData.guide_pdf_page > gbEnd) {
                                        validationErrors.push(ErrorMessages.guidePageOutOfRange(index, questionData.guide_pdf_page, gbStart, gbEnd));
                                    }
                                }
                            }
                        } else if (questionData.question_type === 'matching') {
                            // Matching validation (same as in generateJSON)
                            if (!questionData.question_text || /^\d+$/.test(questionData.question_text)) {
                                validationErrors.push(ErrorMessages.requiredQuestionText(index));
                            }
                            
                            if (!questionData.left || questionData.left.length === 0) {
                                validationErrors.push(ErrorMessages.matchingNoLeftItems(index));
                            } else {
                                questionData.left.forEach((item, itemIdx) => {
                                    if (!item || item.trim() === '') {
                                        validationErrors.push(ErrorMessages.matchingEmptyLeftItem(index, itemIdx + 1));
                                    }
                                });
                            }
                            
                            if (!questionData.right || questionData.right.length === 0) {
                                validationErrors.push(ErrorMessages.matchingNoRightItems(index));
                            } else {
                                questionData.right.forEach((item, itemIdx) => {
                                    if (!item || item.trim() === '') {
                                        validationErrors.push(ErrorMessages.matchingEmptyRightItem(index, itemIdx + 1));
                                    }
                                });
                            }
                            
                            if (questionData.relationship && Array.isArray(questionData.relationship)) {
                                questionData.relationship.forEach((rel, relIdx) => {
                                    if (!Array.isArray(rel) || rel.length !== 2) {
                                        validationErrors.push(ErrorMessages.matchingIncompleteRelationship(index, relIdx + 1));
                                    } else {
                                        const [leftIdx, rightIdx] = rel;
                                        const leftCount = questionData.left ? questionData.left.length : 0;
                                        const rightCount = questionData.right ? questionData.right.length : 0;
                                        
                                        if (!leftIdx || !rightIdx) {
                                            validationErrors.push(ErrorMessages.matchingIncompleteRelationship(index, relIdx + 1));
                                        } else if (leftIdx < 1 || leftIdx > leftCount || rightIdx < 1 || rightIdx > rightCount) {
                                            validationErrors.push(ErrorMessages.matchingInvalidRelationship(index, leftIdx, rightIdx, leftCount, rightCount));
                                        }
                                    }
                                });
                            }
                            
                            if (!questionData.guide_pdf_page) {
                                validationErrors.push(ErrorMessages.requiredGuidePage(index));
                            } else if (isNaN(questionData.guide_pdf_page) || !Number.isInteger(questionData.guide_pdf_page) || questionData.guide_pdf_page <= 0) {
                                validationErrors.push(ErrorMessages.invalidGuidePage(index));
                            } else {
                                // Validate guide PDF page is within guidebook range
                                const gbStart = parseInt(guidebookStart, 10);
                                const gbEnd = parseInt(guidebookEnd, 10);
                                if (!isNaN(gbStart) && !isNaN(gbEnd) && gbStart > 0 && gbEnd > 0) {
                                    if (questionData.guide_pdf_page < gbStart || questionData.guide_pdf_page > gbEnd) {
                                        validationErrors.push(ErrorMessages.guidePageOutOfRange(index, questionData.guide_pdf_page, gbStart, gbEnd));
                                    }
                                }
                            }
                        } else {
                            // Validate other fields for all other types
                            if (!questionData.question_text || /^\d+$/.test(questionData.question_text)) {
                                validationErrors.push(ErrorMessages.requiredQuestionText(index));
                            }
                            
                            if (questionData.question_type === 'multiple_choice') {
                                if (!questionData.choices || questionData.choices.length === 0) {
                                    validationErrors.push(ErrorMessages.requiredChoices(index));
                                } else {
                                    // Validate choice IDs consistency (all filled or all empty)
                                    const choicesWithIDs = questionData.choices.filter(c => c.id && c.id.trim() !== '');
                                    if (choicesWithIDs.length > 0 && choicesWithIDs.length < questionData.choices.length) {
                                        validationErrors.push(ErrorMessages.inconsistentChoiceIDs(index, 'multiple_choice'));
                                }
                                }
                                // Validate value field (1-indexed position)
                                if (!questionData.value || typeof questionData.value !== 'number') {
                                    validationErrors.push(ErrorMessages.requiredCorrectAnswer(index));
                                } else if (questionData.value < 1 || questionData.value > questionData.choices.length) {
                                    validationErrors.push(`Question ${index + 1} (Multiple Choice) - Problem: Selected answer position (${questionData.value}) is out of range. You have ${questionData.choices.length} choices.\n    Fix: Select a valid answer position.`);
                                }
                                // guide_answer is now optional (for notes)
                            } else if (questionData.question_type === 'checkbox') {
                                // Checkbox validation
                                if (!questionData.choices || questionData.choices.length === 0) {
                                    validationErrors.push(ErrorMessages.requiredCheckboxChoices(index));
                                } else {
                                    // Validate choice IDs consistency (all filled or all empty)
                                    const choicesWithIDs = questionData.choices.filter(c => c.id && c.id.trim() !== '');
                                    if (choicesWithIDs.length > 0 && choicesWithIDs.length < questionData.choices.length) {
                                        validationErrors.push(ErrorMessages.inconsistentChoiceIDs(index, 'checkbox'));
                                    }
                                    
                                    // Validate values array
                                    if (!questionData.values || !Array.isArray(questionData.values)) {
                                        validationErrors.push(ErrorMessages.requiredCheckedChoice(index));
                                    } else if (questionData.values.length !== questionData.choices.length) {
                                        validationErrors.push(`Question ${index + 1} (Checkbox) - Problem: Mismatch between number of choices (${questionData.choices.length}) and values array (${questionData.values.length}).\n    Fix: Make sure each choice has a corresponding correct/incorrect value.`);
                                    } else if (!questionData.values.some(v => v === true)) {
                                        validationErrors.push(ErrorMessages.requiredCheckedChoice(index));
                                    }
                                }
                                // guide_answer is now optional (for notes)
                            } else {
                                // Free form - validate guide answer
                                if (!questionData.guide_answer) {
                                    validationErrors.push(ErrorMessages.requiredAnswer(index));
                                }
                            }
                            
                            // Validate guide PDF page
                            if (!questionData.guide_pdf_page) {
                                validationErrors.push(ErrorMessages.requiredGuidePage(index));
                            } else if (isNaN(questionData.guide_pdf_page) || !Number.isInteger(questionData.guide_pdf_page) || questionData.guide_pdf_page <= 0) {
                                validationErrors.push(ErrorMessages.invalidGuidePage(index));
                            } else {
                                // Validate guide PDF page is within guidebook range
                                const gbStart = parseInt(guidebookStart, 10);
                                const gbEnd = parseInt(guidebookEnd, 10);
                                if (!isNaN(gbStart) && !isNaN(gbEnd) && gbStart > 0 && gbEnd > 0) {
                                    if (questionData.guide_pdf_page < gbStart || questionData.guide_pdf_page > gbEnd) {
                                        validationErrors.push(ErrorMessages.guidePageOutOfRange(index, questionData.guide_pdf_page, gbStart, gbEnd));
                                    }
                                }
                            }
                        }
                        
                        // Only add question if no validation errors for this question
                        if (!validationErrors.some(e => e.startsWith(`Question ${index + 1}:`)) && 
                            !validationErrors.some(e => e.includes(`Question ${index + 1}`))) {
                            jsonData.practice_questions.push(questionData);
                        }
                    } catch (error) {
                        console.warn(`Question ${index + 1}: ${error.message}`);
                    }
                });

                if (validationErrors.length > 0) {
                    // For auto-save, don't show alerts but log to console and keep unsaved state
                    if (isAutoSave) {
                        // Debounce warnings: only log if errors changed or enough time passed (5 seconds)
                        const errorSetKey = validationErrors.join('|');
                        const now = Date.now();
                        const timeSinceLastWarning = now - lastValidationWarningTime;
                        const errorsChanged = lastValidationErrorSet !== errorSetKey;
                        
                        if (errorsChanged || timeSinceLastWarning > 5000) {
                            console.warn('Auto-save blocked by validation errors:', validationErrors);
                            lastValidationErrorSet = errorSetKey;
                            lastValidationWarningTime = now;
                        }
                        updateSaveIndicator('unsaved');
                        return;
                    }
                    alert("Cannot save - Validation errors found:\n" + validationErrors.join("\n"));
                    return;
                }

                // Show warnings if any (but don't block saving)
                // Only show alerts for manual saves, not auto-saves
                if (validationWarnings.length > 0 && !isAutoSave) {
                    alert("Validation warnings:\n" + validationWarnings.join("\n"));
                }

                // Add timestamp for tracking
                jsonData._save_timestamp = new Date().toISOString();
                window.__fpFormState = jsonData;

                const dataString = JSON.stringify(jsonData);
                
                localStorage.setItem(SAVE_KEY, dataString);
                lastSavedData = dataString;
                hasUnsavedChanges = false;
                
                updateSaveIndicator('saved');
                
                // Show brief success message
                const saveBtn = document.getElementById('saveBtn');
                if (saveBtn) {
                    const originalIcon = saveBtn.innerHTML;
                    saveBtn.innerHTML = '<i class="fas fa-check"></i>';
                    saveBtn.style.background = 'rgba(40, 167, 69, 0.3)';
                    
                    setTimeout(() => {
                        saveBtn.innerHTML = originalIcon;
                        saveBtn.style.background = '';
                    }, 1500);
                }
            } catch (e) {
                console.error('Failed to save form data:', e);
                alert('Failed to save progress: ' + e.message);
            } finally {
                window.__saveInProgress = false;
            }
        }
        
        // Load form data from localStorage - returns the JSON data directly
        function loadSavedData() {
            try {
                const savedData = localStorage.getItem(SAVE_KEY);
                if (savedData) {
                    const jsonData = JSON.parse(savedData);
                    return jsonData;
                }
            } catch (e) {
                console.error('Failed to load saved data:', e);
            }
            return null;
        }
        
        // Clear saved data
        function clearSavedData() {
            try {
                localStorage.removeItem(SAVE_KEY);
                lastSavedData = null;
                hasUnsavedChanges = false;
                updateSaveIndicator('none');
            } catch (e) {
                console.error('Failed to clear saved data:', e);
            }
        }
        
        // Restore latest saved work from localStorage
        function restoreLatest() {
            // Check if there's saved data
            const savedData = loadSavedData();
            if (!savedData) {
                alert(' No saved data found. Save your work first using the "Save Progress" button.');
                return;
            }
            
            // Always confirm: restoring will replace everything currently loaded (same as other confirms)
            if (!confirm(' Restore will replace everything currently in the form with your saved data.\n\nDo you want to continue?')) {
                return;
            }
            
            // Save current form state for undo (without validation)
            let previousState = null;
            try {
                previousState = collectFormDataWithoutValidation();
            } catch (e) {
                console.warn('Could not save form state for undo:', e);
            }
            
            try {
                // Set hydration flag to prevent scroll restoration during restore
                isDocumentHydrating = true;
                
                // Record action for undo/redo BEFORE populating (so population actions aren't recorded)
                recordFormAction({
                    type: ACTION_TYPES.LOAD_JSON, // Use same type as loadJSON for consistency
                    jsonData: savedData,
                    previousState: previousState
                });
                
                // Set flag to prevent actions during population from being recorded
                isFormUndoRedoInProgress = true;
                try {
                    populateFormFromJSON(savedData);
                } finally {
                    isFormUndoRedoInProgress = false;
                }
                
                // Start a new session when restoring (similar to loadJSON behavior)
                // Clear previous undo history but keep the LOAD_JSON action we just recorded
                if (formUndoHistory.length > 1) {
                    const restoreAction = formUndoHistory[formUndoHistory.length - 1];
                    formUndoHistory.length = 0;
                    formUndoHistory.push(restoreAction);
                }
                // Redo history is already cleared by recordFormAction
                updateUndoRedoButtons();
                
                // Register whole input form; spawn-finalize visible panel (force-fit with current content)
                if (typeof AutoSizeManager !== 'undefined') {
                    if (AutoSizeManager.register) {
                        AutoSizeManager.register(document.getElementById('input-form') || document.body);
                    }
                    const activeRoot = resolveActivePanelRoot();
                    if (AutoSizeManager.finalizeSpawn) {
                        AutoSizeManager.finalizeSpawn(activeRoot);
                    }
                if (AutoSizeManager.fitPending) {
                    AutoSizeManager.fitPending(activeRoot);
                }
            }
                applyBboxesEverywhere({ forceRetag: true });
                
                // Mark form as changed and trigger autosave after restore
                // This ensures autosave flow runs (with validation gating)
                markFormAsChanged();
                triggerAutoSave();
                
                // Show success message with timestamp if available
                const timestamp = savedData._save_timestamp;
                const timestampMsg = timestamp 
                    ? `\n\nSaved: ${new Date(timestamp).toLocaleString()}`
                    : '';
                alert(' Success! Your work has been restored from the latest save.' + timestampMsg);
            } catch (e) {
                console.error(e);
                alert('Failed to restore saved data: ' + e.message);
                // Clear hydration flag on error
                isDocumentHydrating = false;
            }
        }
        
        // Track changes to form inputs and auto-save
        function attachChangeTrackers() {
            const container = document.querySelector('.container');
            if (!container) return;
            if (window.__changeTrackersAttached) return;
            window.__changeTrackersAttached = true;
            // One-time registration so one user action does not trigger multiple handlers
            // Track initial values when fields get focus
            container.addEventListener('focusin', (e) => {
                if (e.target.matches('input, textarea, select')) {
                    // Skip search input - it shouldn't trigger auto-save
                    if (e.target.id === 'searchFilter') return;
                    
                    // Store the value when field gets focus
                    fieldValues.set(e.target, e.target.value);
                }
            }, true);
            
            // Track changes and auto-save on blur
            container.addEventListener('focusout', (e) => {
                if (e.target.matches('input, textarea, select')) {
                    // Skip search input - it shouldn't trigger auto-save
                    if (e.target.id === 'searchFilter') return;
                    
                    const originalValue = fieldValues.get(e.target);
                    const currentValue = e.target.value;
                    
                    // Check if value actually changed
                    if (originalValue !== currentValue) {
                        markFormAsChanged();
                        // Trigger auto-save after field loses focus and value changed
                        triggerAutoSave();
                    }
                    
                    // Clean up stored value
                    fieldValues.delete(e.target);
                }
            }, true);
            
            // Also track input events for immediate feedback (but save on blur)
            container.addEventListener('input', (e) => {
                if (e.target.matches('input, textarea, select')) {
                    // Skip search input - it shouldn't trigger auto-save
                    if (e.target.id === 'searchFilter') return;
                    
                    // Mark as changed immediately for visual feedback
                    const originalValue = fieldValues.get(e.target);
                    const currentValue = e.target.value;
                    
                    if (originalValue !== currentValue) {
                        markFormAsChanged();
                    }
                }
            });
            
            // Track when buttons modify the form (add/remove/duplicate items)
            container.addEventListener('click', (e) => {
                if (e.target.closest('.add-btn, .remove-btn, .duplicate-btn')) {
                    markFormAsChanged();
                    // Auto-save when items are added/removed/duplicated (after a short delay)
                    triggerAutoSave();
                }
            });
            
            // Track select changes (dropdowns)
            container.addEventListener('change', (e) => {
                if (e.target.matches('select')) {
                    markFormAsChanged();
                    triggerAutoSave();
                }
            });
        }
        
        // Warn user about unsaved changes on page reload/close
        function attachUnloadWarning() {
            if (window.__unloadWarningAttached) return;
            window.__unloadWarningAttached = true;
            window.addEventListener('beforeunload', (e) => {
                if (hasUnsavedChanges) {
                    // Prompt to save before leaving
                    const message = 'You have unsaved changes. Do you want to save before leaving?';
                    e.preventDefault();
                    e.returnValue = message;
                    
                    // Try to save automatically on unload (call the save function directly)
                    try {
                        saveProgress();
                    } catch (err) {
                        console.error('Failed to auto-save on unload:', err);
                    }
                    
                    return message;
                }
            });
        }
        
        // Add keyboard shortcut for save (Ctrl+S)
        function attachSaveKeyboardShortcut() {
            if (window.__saveShortcutAttached) return;
            window.__saveShortcutAttached = true;
            document.addEventListener('keydown', (e) => {
                // Ctrl+S or Cmd+S
                if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                    e.preventDefault();
                    saveProgress();
                }
            });
        }

        // Function to check for duplicate question IDs and highlight them
        function checkDuplicateQuestionIds() {
            const questionIds = new Map(); // Map to track question IDs
            const questionContainers = document.querySelectorAll('#questions_container > .array-item');
            const duplicates = new Set();
            
            // First pass: identify all duplicates
            questionContainers.forEach((questionEl) => {
                const questionIdInput = findFieldByLabel(questionEl, 'Question ID', 'input');
                if (questionIdInput && questionIdInput.value && questionIdInput.value.trim()) {
                    const qid = questionIdInput.value.trim();
                    if (questionIds.has(qid)) {
                        duplicates.add(qid);
                    } else {
                        questionIds.set(qid, questionIdInput);
                    }
                }
            });
            
            // Second pass: highlight all fields with duplicate IDs
            questionContainers.forEach((questionEl) => {
                const questionIdInput = findFieldByLabel(questionEl, 'Question ID', 'input');
                if (questionIdInput && questionIdInput.value && questionIdInput.value.trim()) {
                    const qid = questionIdInput.value.trim();
                    if (duplicates.has(qid)) {
                        // Highlight as error
                        questionIdInput.style.borderColor = '#dc3545';
                        questionIdInput.style.borderWidth = '2px';
                        questionIdInput.title = `Duplicate Question ID: "${qid}" appears multiple times`;
                    } else {
                        // Remove highlight
                        questionIdInput.style.borderColor = '';
                        questionIdInput.style.borderWidth = '';
                        questionIdInput.title = '';
                    }
                }
            });
        }

        // Function to attach duplicate question ID validation listeners
        function attachQuestionIdValidation() {
            const questionsContainer = document.getElementById('questions_container');
            if (!questionsContainer) return;
            if (window.__questionIdValidationAttached) return;
            window.__questionIdValidationAttached = true;
            // Use event delegation on the questions container (one-time so one blur/input does not double-fire)
            questionsContainer.addEventListener('blur', function(event) {
                    // Check if the blurred element is a question ID input
                    const target = event.target;
                    if (target && target.matches('input[type="text"]')) {
                        const formGroup = target.closest('.form-group');
                        if (formGroup) {
                            const label = formGroup.querySelector('label');
                            if (label && label.textContent.includes('Question ID')) {
                                // This is a question ID field, check for duplicates
                                checkDuplicateQuestionIds();
                            }
                        }
                    }
                }, true); // Use capture phase to catch all blur events
                
                // Also check on input for immediate feedback
                questionsContainer.addEventListener('input', function(event) {
                    const target = event.target;
                    if (target && target.matches('input[type="text"]')) {
                        const formGroup = target.closest('.form-group');
                        if (formGroup) {
                            const label = formGroup.querySelector('label');
                            if (label && label.textContent.includes('Question ID')) {
                                // Debounce the check slightly to avoid too many calls
                                clearTimeout(window._questionIdCheckTimeout);
                                window._questionIdCheckTimeout = setTimeout(() => {
                                    checkDuplicateQuestionIds();
                                }, 500);
                            }
                        }
                    }
                }, true);
        }

        /**
         * Updates the CSS variable --sticky-stack-height based on actual rendered height of the sticky tabs stack.
         * Called on load, resize, and after font loading for scroll offset calculations.
         * Uses getBoundingClientRect for sub-pixel accuracy.
         */
        function updateStickyTabsHeight() {
            const stickyStack = document.querySelector('.sticky-tabs-stack');
            if (stickyStack) {
                // Use getBoundingClientRect for precise measurement including borders
                const rect = stickyStack.getBoundingClientRect();
                const height = Math.ceil(rect.height); // Round up to avoid subpixel gaps
                document.documentElement.style.setProperty('--sticky-stack-height', height + 'px');
            }
        }

        // Initialize page
        window.onload = function() {
            // Hydrate all static button groups first
            hydrateStaticButtons();
            
            // Set up sticky tabs height measurement (runs after hydration so buttons are rendered)
            updateStickyTabsHeight();
            window.addEventListener('resize', updateStickyTabsHeight);
            
            // Re-measure after fonts load (can affect tab height)
            if (document.fonts && document.fonts.ready) {
                document.fonts.ready.then(updateStickyTabsHeight);
            }
            
            // Initialize refactored form controls (using createFormControl factory)
            // Lesson ID
            const lessonIdControl = createFormControl({
                id: 'lesson_id',
                label: 'Lesson ID',
                type: 'text',
                placeholder: 'e.g., 2-1',
                dataset: { ltr: 'true' },
                attrs: { title: 'Unique identifier for the lesson (e.g., 2-1 for chapter 2, lesson 1)' }
            });
            const lessonIdContainer = document.getElementById('lesson_id_container');
            if (lessonIdContainer) {
                lessonIdContainer.appendChild(lessonIdControl.rootEl);
            }
            
            // Lesson Title
            const lessonTitleControl = createFormControl({
                id: 'lesson_title',
                type: 'text',
                placeholder: 'e.g., Parallel and Perpendicular Lines',
                attrs: { title: 'The title of the lesson (supports markdown formatting)' }
                // No data-ltr="true" - defaults to RTL for content
            });
            const lessonTitleContainer = document.getElementById('lesson_title_container');
            if (lessonTitleContainer) {
                // Create text-field-container structure with title toolbar
                const textFieldContainer = document.createElement('div');
                textFieldContainer.className = 'text-field-container';
                
                // Extract just the input element (we already have form-group structure)
                const input = lessonTitleControl.controlEl;
                lessonTitleControl.rootEl.removeChild(input);
                
                // Build the structure: input + title toolbar
                textFieldContainer.innerHTML = getTitleMarkdownButtonBarHTML('input');
                
                // Insert input before the buttons
                const temp = document.createElement('div');
                temp.appendChild(input);
                textFieldContainer.insertBefore(input, textFieldContainer.firstChild);
                
                lessonTitleContainer.appendChild(textFieldContainer);
            }
            
            // Lesson Text
            const lessonTextContainer = document.getElementById('lesson_text_container');
            if (lessonTextContainer) {
                const textFieldContainer = document.createElement('div');
                textFieldContainer.className = 'text-field-container';
                textFieldContainer.innerHTML = `
                    <span class="input-label">Input Markdown</span>
                    <textarea id="lesson_text" placeholder="Additional lesson text not captured above..." title="Additional lesson text that supports markdown formatting"></textarea>
                    ${getMarkdownButtonBarHTML()}
                `;
                lessonTextContainer.appendChild(textFieldContainer);
                // Set RTL default direction
                const textarea = textFieldContainer.querySelector('textarea');
                if (textarea) {
                    textarea.setAttribute('dir', 'rtl');
                }
            }
            
            // Page Type
            const pageTypeControl = createFormControl({
                id: 'page_type',
                label: 'Page Type',
                type: 'select',
                required: true,
                options: [
                    { value: 'content', text: 'Content', selected: true },
                    { value: 'project', text: 'Project' },
                    { value: 'vocabulary', text: 'Vocabulary' },
                    { value: 'unit_table_of_content', text: 'Unit Table of Content' },
                    { value: 'table_of_content', text: 'Table of Content' },
                    { value: 'other', text: 'Other' }
                ],
                attrs: { title: 'Categorizes the content type for organization' }
            });
            const pageTypeContainer = document.getElementById('page_type_container');
            if (pageTypeContainer) {
                pageTypeContainer.appendChild(pageTypeControl.rootEl);
            }
            
            // Basic Info number inputs - Refactored to use createFormControl factory
            // Textbook Page Number (ISSUE B: Set LTR for Basic Info inputs)
            const textbookPageControl = createRequiredNumberInput({
                id: 'textbook_page',
                label: 'Textbook Page Number',
                placeholder: 'e.g., 36',
                title: 'The actual page number in the physical textbook'
            });
            const textbookPageContainer = document.getElementById('textbook_page_container');
            if (textbookPageContainer) {
                textbookPageContainer.appendChild(textbookPageControl.rootEl);
                // Set LTR for Basic Info inputs (ISSUE B fix)
                const input = textbookPageControl.controlEl;
                if (input) {
                    input.setAttribute('data-ltr', 'true');
                    input.setAttribute('dir', 'ltr');
                }
            }
            
            // PDF Page Number (ISSUE B: Set LTR for Basic Info inputs)
            const textbookPdfPageControl = createRequiredNumberInput({
                id: 'textbook_pdf_page',
                label: 'PDF Page Number',
                placeholder: 'e.g., 44',
                title: 'The page number in the digital PDF file'
            });
            const textbookPdfPageContainer = document.getElementById('textbook_pdf_page_container');
            if (textbookPdfPageContainer) {
                textbookPdfPageContainer.appendChild(textbookPdfPageControl.rootEl);
                // Set LTR for Basic Info inputs (ISSUE B fix)
                const input = textbookPdfPageControl.controlEl;
                if (input) {
                    input.setAttribute('data-ltr', 'true');
                    input.setAttribute('dir', 'ltr');
                }
            }
            
            // Guidebook Start Page (inside bbox-inputs container, no form-group wrapper) (ISSUE B: Set LTR)
            const guidebookStartControl = createRequiredNumberInput({
                id: 'guidebook_start_page',
                label: '', // No label, just the input
                placeholder: 'Start page (e.g., 78)',
                title: 'First page number in the guidebook PDF range'
            });
            const guidebookStartContainer = document.getElementById('guidebook_start_page_container');
            if (guidebookStartContainer) {
                // Extract just the input element (remove form-group wrapper for bbox-inputs layout)
                const input = guidebookStartControl.controlEl;
                guidebookStartControl.rootEl.removeChild(input);
                // Set LTR for Basic Info inputs (ISSUE B fix)
                input.setAttribute('data-ltr', 'true');
                input.setAttribute('dir', 'ltr');
                guidebookStartContainer.appendChild(input);
            }
            
            // Guidebook End Page (inside bbox-inputs container, no form-group wrapper) (ISSUE B: Set LTR)
            const guidebookEndControl = createRequiredNumberInput({
                id: 'guidebook_end_page',
                label: '', // No label, just the input
                placeholder: 'End page (e.g., 85)',
                title: 'Last page number in the guidebook PDF range'
            });
            const guidebookEndContainer = document.getElementById('guidebook_end_page_container');
            if (guidebookEndContainer) {
                // Extract just the input element (remove form-group wrapper for bbox-inputs layout)
                const input = guidebookEndControl.controlEl;
                guidebookEndControl.rootEl.removeChild(input);
                // Set LTR for Basic Info inputs (ISSUE B fix)
                input.setAttribute('data-ltr', 'true');
                input.setAttribute('dir', 'ltr');
                guidebookEndContainer.appendChild(input);
            }
            
            // Check if user needs to reload for latest version (initial check)
            checkVersionReload();
            
            // Periodically check if reload is needed (every hour while page is open)
            setInterval(checkVersionReload, 60 * 60 * 1000);
            
            // Auto-load PDFs from IndexedDB storage (for both bbox modal and main PDF viewer)
            initializePdfStore();
            
            // Initialize dark mode
            initializeDarkMode();
            
            // Hydrate static action buttons
            hydrateStaticActionButtons();
            
            // Initialize font settings
            initializeFontSettings();
            
            // Initialize auto-resize toggle
            initializeAutoResize();
            
            // Initialize trailing spaces indicator
            initializeTrailingSpacesIndicator();
            
            // Set direction based on data-ltr attribute
            const allTextareas = document.querySelectorAll('textarea, input[type="text"]');
            allTextareas.forEach(ta => {
                if (ta.hasAttribute('data-ltr')) {
                    // LTR fields (JSON input, lesson standards)
                    ta.setAttribute('dir', 'ltr');
                } else {
                    // RTL fields (content, questions, titles, etc.)
                    ta.setAttribute('dir', 'rtl');
                }
                // CSS will handle the styling based on data-ltr attribute
            });
            
            // Hydrate static markdown toolbars in initial HTML items
            hydrateStaticMarkdownToolbars();
            
            // Apply font settings to hydrated items
            const lessonStandardsContainer = document.getElementById('lesson_standards');
            const terminologyContainer = document.getElementById('terminology');
            if (lessonStandardsContainer) {
                applyFontSettings(lessonStandardsContainer);
            }
            if (terminologyContainer) {
                applyFontSettings(terminologyContainer);
            }
            
            // Then attach previews (which will inherit the correct direction)
            attachPreviews(document);
            
            // Update all existing direction toggle buttons to show correct text
            const allDirBtns = document.querySelectorAll('.dir-btn');
            allDirBtns.forEach(btn => {
                const textarea = btn.closest('.text-field-container')?.querySelector('textarea') || 
                                btn.parentElement?.querySelector('textarea') ||
                                btn.parentElement?.querySelector('input[type="text"]');
                if (textarea) {
                    const isLTR = textarea.hasAttribute('data-ltr');
                    // Button shows what clicking it will do
                    btn.textContent = isLTR ? 'RTL' : 'LTR';
                }
            });
            
            // Try to load saved data
            const savedData = loadSavedData();
            if (savedData) {
                const savedDate = savedData._save_timestamp ? new Date(savedData._save_timestamp) : new Date();
                const timeAgo = getTimeAgo(savedDate);
                
                if (confirm(`Found saved data from ${timeAgo}. Would you like to restore it?`)) {
                    try {
                        // Set hydration flag to prevent scroll restoration during restore
                        isDocumentHydrating = true;
                        
                        // Use the same populateFormFromJSON function that loads JSON
                        populateFormFromJSON(savedData);
                        
                        // Set the initial saved state
                        lastSavedData = JSON.stringify(savedData);
                        hasUnsavedChanges = false;
                        updateSaveIndicator('saved');

                        // After restore, ensure previews rendered and register+fit autosize targets for whole input form
                        const mainActive = document.querySelector('.main-tab-content.active');
                        let activeRoot = mainActive || document;
                        if (mainActive && mainActive.id === 'input-form') {
                            const innerActive = mainActive.querySelector('.tab-content.active');
                            if (innerActive) activeRoot = innerActive;
                        }
                        if (typeof PreviewBox !== 'undefined' && PreviewBox.ensureRendered) {
                            PreviewBox.ensureRendered(activeRoot);
                        }
                        if (typeof AutoSizeManager !== 'undefined') {
                            const inputFormRoot = document.getElementById('input-form') || activeRoot;
                            if (AutoSizeManager.register) {
                                AutoSizeManager.register(inputFormRoot);
                            }
                            if (AutoSizeManager.finalizeSpawn) {
                                AutoSizeManager.finalizeSpawn(activeRoot);
                            }
                            if (AutoSizeManager.fitPending) {
                                AutoSizeManager.fitPending(activeRoot);
                            }
                        }
                        applyBboxesEverywhere({ forceRetag: true });
                        alert('Your previous work has been restored!');
                    } catch (e) {
                        console.error('Failed to restore saved data:', e);
                        alert('Failed to restore saved data. Starting with a clean form.');
                        clearSavedData();
                        // Clear hydration flag on error
                        isDocumentHydrating = false;
                    }
                } else {
                    clearSavedData();
                }
            }
            applyBboxesEverywhere({ forceRetag: true });
            
            // Autosize input handler (event-driven, works for dynamic sections)
            attachAutoResizeInputHandler();
            // One-time register of whole input form; then spawn-finalize visible panel (force-fit with current content)
            if (autoResizeEnabled && typeof AutoSizeManager !== 'undefined') {
                if (AutoSizeManager.register) {
                    AutoSizeManager.register(document.getElementById('input-form') || document.body);
                }
                if (AutoSizeManager.finalizeSpawn) {
                    AutoSizeManager.finalizeSpawn(resolveActivePanelRoot());
                }
            }
            
            // Attach change tracking (lightweight)
            attachChangeTrackers();
            
            // Attach unload warning for unsaved changes
            attachUnloadWarning();
            
            // Attach context listeners for PDF viewer auto-sync
            attachContextListeners();
            
            // Attach question ID duplicate validation
            attachQuestionIdValidation();
            
            // Attach Ctrl+S keyboard shortcut
            attachSaveKeyboardShortcut();
            
            // Attach bbox validation to all existing bbox fields on page load
            attachBboxValidation(document);
            
            // Fix any existing section/question numbering on page load
            updateContentSectionNumbers();
            updateQuestionNumbers();
            
            // Initialize new UX features
            initializeFieldValidation();
            updateQuickJumpMenu();
            
            // Set up observers for dynamic content updates
            const observer = new MutationObserver(() => {
                updateQuickJumpMenu();
            });
            
            observer.observe(document.getElementById('content_sections_container'), {
                childList: true,
                subtree: true
            });
            
            observer.observe(document.getElementById('questions_container'), {
                childList: true,
                subtree: true
            });
            
            // Check if we should auto-open What's New modal for new version
            checkAndOpenWhatsNew();
            
            // Update version displays (use DISPLAY_VERSION for UI, CURRENT_VERSION for internal tracking)
            const versionNumberEl = document.getElementById('version-number');
            const whatsNewVersionEl = document.getElementById('whats-new-version-number');
            if (versionNumberEl) {
                versionNumberEl.textContent = DISPLAY_VERSION;
            }
            if (whatsNewVersionEl) {
                whatsNewVersionEl.textContent = DISPLAY_VERSION;
            }
            
        };
        
        // Helper function to format time ago
        function getTimeAgo(date) {
            const seconds = Math.floor((new Date() - date) / 1000);
            
            if (seconds < 60) {
                return 'just now';
            }
            
            const minutes = Math.floor(seconds / 60);
            if (minutes < 60) {
                return `${minutes} minute${minutes !== 1 ? 's' : ''} ago`;
            }
            
            const hours = Math.floor(minutes / 60);
            if (hours < 24) {
                return `${hours} hour${hours !== 1 ? 's' : ''} ago`;
            }
            
            const days = Math.floor(hours / 24);
            if (days < 7) {
                return `${days} day${days !== 1 ? 's' : ''} ago`;
            }
            
            return date.toLocaleDateString() + ' at ' + date.toLocaleTimeString();
        }
        
        // Check if user needs to reload for latest version
        // Note: CURRENT_VERSION and VERSION_SEEN_KEY are defined at the top of the script (line ~10)
        function checkVersionReload() {
            try {
                const PAGE_LOAD_TIME_KEY = 'transcription_tool_page_load_time';
                const RELOAD_PROMPT_INTERVAL = 3 * 24 * 60 * 60 * 1000; // 3 days
                const PROMPT_SHOWN_KEY = 'transcription_tool_reload_prompt_shown';
                const CURRENT_VERSION_KEY = 'transcription_tool_current_version';
                // CURRENT_VERSION is defined above - use that
                const PAGE_LOAD_ID_KEY = 'transcription_tool_page_load_id';
                
                const now = new Date().getTime();
                const storedVersion = localStorage.getItem(CURRENT_VERSION_KEY);
                const storedPageLoadTime = localStorage.getItem(PAGE_LOAD_TIME_KEY);
                const currentPageLoadId = Date.now().toString() + Math.random().toString();
                const storedPageLoadId = sessionStorage.getItem(PAGE_LOAD_ID_KEY);
                
                // Check if this is a new version (page was updated)
                const isNewVersion = storedVersion !== CURRENT_VERSION;
                
                // Check if this is a fresh page load (new session or reload)
                const isFreshLoad = !storedPageLoadId;
                
                // If it's a new version, reset the page load time
                if (isNewVersion) {
                    localStorage.setItem(CURRENT_VERSION_KEY, CURRENT_VERSION);
                    localStorage.setItem(PAGE_LOAD_TIME_KEY, now.toString());
                    sessionStorage.removeItem(PROMPT_SHOWN_KEY);
                    sessionStorage.setItem(PAGE_LOAD_ID_KEY, currentPageLoadId);
                    return; // Don't prompt on fresh version load
                }
                
                // If this is a fresh page load (not just a periodic check), update the timestamp
                if (isFreshLoad) {
                    localStorage.setItem(PAGE_LOAD_TIME_KEY, now.toString());
                    sessionStorage.setItem(PAGE_LOAD_ID_KEY, currentPageLoadId);
                    return; // Don't prompt on fresh load
                }
                
                // Check how long the page has been loaded (using stored timestamp from when it was first loaded)
                if (!storedPageLoadTime) {
                    // Fallback: if no stored time, set it now
                    localStorage.setItem(PAGE_LOAD_TIME_KEY, now.toString());
                    return;
                }
                
                const pageLoadTime = parseInt(storedPageLoadTime, 10);
                const timeSincePageLoad = now - pageLoadTime;
                const promptShownTime = sessionStorage.getItem(PROMPT_SHOWN_KEY);
                
                // Only show prompt if enough time has passed since page load
                if (timeSincePageLoad > RELOAD_PROMPT_INTERVAL) {
                    // Don't show more than once per 5 minutes in the same session
                    if (!promptShownTime || (now - parseInt(promptShownTime, 10)) > 5 * 60 * 1000) {
                        // Show prompt
                        const shouldReload = confirm(
                            'You\'ve been using this page for a while. For the best experience, please reload the page to make sure you\'re using the latest version of the tool.\n\n' +
                            'Click OK to reload now, or Cancel to continue.'
                        );
                        
                        if (shouldReload) {
                            // Reset page load time on reload (will be set on fresh load after reload)
                            localStorage.setItem(PAGE_LOAD_TIME_KEY, now.toString());
                            location.reload();
                        } else {
                            // Remember we showed the prompt in this session
                            sessionStorage.setItem(PROMPT_SHOWN_KEY, now.toString());
                        }
                    }
                }
            } catch (e) {
                console.error('Error checking version reload:', e);
            }
        }

        // Open BBox drawer for textbook PDF upload
        function openBboxDrawerForTextbook() {
            // Set the target to indicate we want to load a textbook PDF
            window.__embeddedBboxTarget = { 
                inputs: null, 
                isGuide: false,
                isMainFormUpload: true 
            };
            openEmbeddedBboxModal();
        }

        // Open BBox drawer for guide PDF upload
        function openBboxDrawerForGuide() {
            // Set the target to indicate we want to load a guide PDF
            window.__embeddedBboxTarget = { 
                inputs: null, 
                isGuide: true,
                isMainFormUpload: true 
            };
            openEmbeddedBboxModal();
        }

        // Open BBox drawer for PDF uploads (textbook or guide)
        function openBboxDrawerForPDFs() {
            // Open the modal without setting a specific target, allowing user to choose PDF type
            window.__embeddedBboxTarget = { 
                inputs: null, 
                isGuide: null,
                isMainFormUpload: true 
            };
            openEmbeddedBboxModal();
        }

        // Helper function to restore original BBox modal layout
        function restoreBboxModalLayout() {
            const sidebar = document.querySelector('.bbox-sidebar');
            if (sidebar) {
                sidebar.style.display = '';
            }
            const content = document.querySelector('.bbox-content');
            if (content) {
                content.style.gridTemplateColumns = '';
            }
            const drawButtons = document.querySelectorAll('#em-add, #em-clear, #em-undo');
            drawButtons.forEach(btn => btn.style.display = '');
            const confirmBtn = document.getElementById('em-confirm');
            if (confirmBtn) {
                confirmBtn.textContent = 'Use Selected';
            }
        }

        // ===== MAIN PDF VIEWER IMPLEMENTATION =====
        
        // Global PDF Viewer State
        window.__mainPdfViewer = {
            visible: false,
            source: 'textbook', // 'textbook' | 'guide'
            currentPage: 1,
            totalPages: 0,
            scale: 1.0,
            fitToCanvasScale: null, // Scale to fit canvas, calculated per source
            pdfDoc: null,
            canvas: null,
            context: null,
            autoSyncEnabled: localStorage.getItem('pdfAutoNavEnabled') === 'true', // Load from localStorage
            lastSyncedPage: null,
            lastSyncedSource: null,
            lastManualNavTime: 0, // Track manual navigation to avoid interrupting user
            userNavigatedAway: false, // Flag to track if user manually navigated away
            elements: {},
            renderTask: null, // Track ongoing render operation
            isRendering: false // Flag to prevent concurrent renders
        };
        
        // Calculate fit-to-canvas scale for a PDF page
        function calculateFitToCanvasScale(page, container) {
            if (!page || !container) return 1.0;
            
            // Get container dimensions (account for padding)
            const containerWidth = container.clientWidth - 40; // 20px padding on each side
            const containerHeight = container.clientHeight - 40; // 20px padding on each side
            
            // Get page viewport at scale 1.0 to get natural dimensions
            const viewport = page.getViewport({ scale: 1.0 });
            
            if (!viewport || !viewport.width || !viewport.height) return 1.0;
            
            // Calculate scale to fit both width and height (use the smaller one to ensure it fits)
            const scaleX = containerWidth / viewport.width;
            const scaleY = containerHeight / viewport.height;
            const fitScale = Math.min(scaleX, scaleY, 8.0); // Cap at 8x zoom max
            
            // Ensure minimum scale
            return Math.max(fitScale, 0.1);
        }

        // Toggle Functions
        function showPdfViewer() {
            const jsonPanel = document.getElementById('json-preview-panel');
            const pdfPanel = document.getElementById('pdf-viewer-panel');
            const pdfBtn = document.getElementById('toggle-pdf-btn');
            const jsonBtn = document.getElementById('toggle-json-btn');
            
            if (!jsonPanel || !pdfPanel || !pdfBtn || !jsonBtn) return;
            
            jsonPanel.classList.remove('active');
            jsonPanel.style.display = 'none';
            
            pdfPanel.classList.add('active');
            pdfPanel.style.display = 'flex';
            
            pdfBtn.classList.add('active');
            jsonBtn.classList.remove('active');
            
            window.__mainPdfViewer.visible = true;
            
            // Initialize PDF viewer if not already loaded
            if (!window.__mainPdfViewer.canvas) {
                initializePdfViewer();
                // Wait for initialization to complete before loading PDF
                setTimeout(() => {
                    const loaded = loadPdfFromStore();
                    if (!loaded) {
                        const currentSource = window.__mainPdfViewer.source || 'textbook';
                        showPdfUploadPrompt(currentSource);
                    }
                }, 100);
            } else {
                // Viewer already initialized, try to load PDF immediately
                const loaded = loadPdfFromStore();
                if (!loaded) {
                    // Show message to upload PDF with current source
                    const currentSource = window.__mainPdfViewer.source || 'textbook';
                    showPdfUploadPrompt(currentSource);
                }
            }
            
            // Smart navigation to relevant page
            if (window.__mainPdfViewer.autoSyncEnabled) {
                setTimeout(() => navigateToContextPage(), 200);
            }
        }

        function showJsonPreview() {
            const jsonPanel = document.getElementById('json-preview-panel');
            const pdfPanel = document.getElementById('pdf-viewer-panel');
            const pdfBtn = document.getElementById('toggle-pdf-btn');
            const jsonBtn = document.getElementById('toggle-json-btn');
            
            if (!jsonPanel || !pdfPanel || !pdfBtn || !jsonBtn) return;
            
            pdfPanel.classList.remove('active');
            pdfPanel.style.display = 'none';
            
            jsonPanel.classList.add('active');
            jsonPanel.style.display = 'flex';
            
            pdfBtn.classList.remove('active');
            jsonBtn.classList.add('active');
            
            window.__mainPdfViewer.visible = false;
        }

        // Initialize PDF Viewer
        function initializePdfViewer() {
            if (window.__mainPdfViewer.__pdfViewerInitializing) return;
            window.__mainPdfViewer.__pdfViewerInitializing = true;
            const pdfPanel = document.getElementById('pdf-viewer-panel');
            if (!pdfPanel) {
                window.__mainPdfViewer.__pdfViewerInitializing = false;
                return;
            }
            
            // Create controls HTML
            const controlsHtml = `
                <div class="pdf-viewer-controls">
                    <!-- Source Toggle -->
                    <div class="pdf-source-toggle" id="pdf-source-toggle-container">
                        <!-- Buttons will be hydrated by JS -->
                    </div>
                    
                    <!-- Auto Navigation Toggle -->
                    <div style="display: flex; align-items: center; gap: 6px;" id="main-pdf-auto-nav-container">
                        <!-- Button will be hydrated by JS -->
                    </div>
                    
                    <!-- Zoom Controls: zoom-out, display, zoom-in, reset -->
                    <div style="display: flex; align-items: center; gap: 6px;">
                        <div id="main-pdf-zoom-out-button" style="display: flex; gap: 6px; align-items: center;"></div>
                        <span id="main-pdf-zoom-display">100%</span>
                        <div id="main-pdf-zoom-in-button" style="display: flex; gap: 6px; align-items: center;"></div>
                        <div id="main-pdf-zoom-reset-button" style="display: flex; gap: 6px; align-items: center;"></div>
                    </div>
                    
                    <!-- Page Navigation: prev, page indicator, next, goto input, goto button -->
                    <div style="display: flex; align-items: center; gap: 6px;">
                        <div id="main-pdf-nav-prev-button" style="display: flex; gap: 6px; align-items: center;"></div>
                        <span id="main-pdf-page-display">Page 1/0</span>
                        <div id="main-pdf-nav-next-button" style="display: flex; gap: 6px; align-items: center;"></div>
                        <input type="number" id="main-pdf-goto" min="1" placeholder="#" style="width: 60px; padding: 4px; border: 1px solid #dee2e6; border-radius: 4px;" title="Enter page number to jump to">
                        <div id="main-pdf-goto-button"></div>
                    </div>
                </div>
                <div class="pdf-canvas-container" id="pdf-canvas-container">
                    <canvas id="main-pdf-canvas"></canvas>
                </div>
            `;
            
            pdfPanel.innerHTML = controlsHtml;
            
            // Hydrate PDF viewer buttons after setting innerHTML
            renderButtonGroup('pdf-source-toggle-container', STATIC_BUTTON_CONFIGS.PDF_SOURCE_TOGGLE);
            renderButtonGroup('main-pdf-auto-nav-container', STATIC_BUTTON_CONFIGS.MAIN_PDF_AUTO_NAV);
            // Add status span to auto-nav button after creation
            const autoNavBtn = document.getElementById('auto-nav-toggle');
            if (autoNavBtn) {
                const statusSpan = document.createElement('span');
                statusSpan.id = 'auto-nav-status';
                statusSpan.textContent = 'Auto Nav: OFF';
                autoNavBtn.appendChild(document.createTextNode(' '));
                autoNavBtn.appendChild(statusSpan);
            }
            renderButtonGroup('main-pdf-zoom-out-button', STATIC_BUTTON_CONFIGS.MAIN_PDF_ZOOM_OUT);
            renderButtonGroup('main-pdf-zoom-in-button', STATIC_BUTTON_CONFIGS.MAIN_PDF_ZOOM_IN);
            renderButtonGroup('main-pdf-zoom-reset-button', STATIC_BUTTON_CONFIGS.MAIN_PDF_ZOOM_RESET);
            renderButtonGroup('main-pdf-nav-prev-button', STATIC_BUTTON_CONFIGS.MAIN_PDF_NAV_PREV);
            renderButtonGroup('main-pdf-nav-next-button', STATIC_BUTTON_CONFIGS.MAIN_PDF_NAV_NEXT);
            renderButtonGroup('main-pdf-goto-button', STATIC_BUTTON_CONFIGS.MAIN_PDF_GOTO_BUTTON);
            
            // Store element references - use setTimeout to ensure DOM is updated
            setTimeout(() => {
                const canvas = document.getElementById('main-pdf-canvas');
                if (canvas) {
                    window.__mainPdfViewer.canvas = canvas;
                    window.__mainPdfViewer.context = canvas.getContext('2d', { alpha: false });
                }
                
                window.__mainPdfViewer.elements = {
                    panel: pdfPanel,
                    canvas: canvas,
                    sourceToggle: {
                        textbook: document.getElementById('pdf-source-textbook'),
                        guide: document.getElementById('pdf-source-guide')
                    },
                    pageDisplay: document.getElementById('main-pdf-page-display'),
                    prevBtn: document.getElementById('main-pdf-prev'),
                    nextBtn: document.getElementById('main-pdf-next'),
                    gotoInput: document.getElementById('main-pdf-goto'),
                    gotoBtn: document.getElementById('main-pdf-goto-btn'),
                    zoomOutBtn: document.getElementById('main-pdf-zoom-out'),
                    zoomInBtn: document.getElementById('main-pdf-zoom-in'),
                    zoomResetBtn: document.getElementById('main-pdf-zoom-reset'),
                    zoomDisplay: document.getElementById('main-pdf-zoom-display')
                };
                
                const elements = window.__mainPdfViewer.elements;
                
                // Attach event listeners for zoom controls (use capture phase to ensure we handle first)
                if (elements.zoomInBtn) {
                    elements.zoomInBtn.addEventListener('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                        if (window.__mainPdfViewer && window.__mainPdfViewer.visible) {
                            zoomMainPdf('in');
                        }
                    }, true); // Use capture phase
                }
                if (elements.zoomOutBtn) {
                    elements.zoomOutBtn.addEventListener('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                        if (window.__mainPdfViewer && window.__mainPdfViewer.visible) {
                            zoomMainPdf('out');
                        }
                    }, true); // Use capture phase
                }
                if (elements.zoomResetBtn) {
                    elements.zoomResetBtn.addEventListener('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                        if (window.__mainPdfViewer && window.__mainPdfViewer.visible) {
                            zoomMainPdf('reset');
                        }
                    }, true); // Use capture phase
                }
                
                // Attach event listeners for navigation controls
                if (elements.prevBtn) {
                    elements.prevBtn.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        navigateMainPdf('prev');
                    });
                }
                if (elements.nextBtn) {
                    elements.nextBtn.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        navigateMainPdf('next');
                    });
                }
                if (elements.gotoBtn) {
                    elements.gotoBtn.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        navigateMainPdf('goto');
                    });
                }
                if (elements.gotoInput) {
                    elements.gotoInput.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            e.stopPropagation();
                            navigateMainPdf('goto');
                        }
                    });
                }
                
                // Add scroll listener to save main PDF viewer scroll position automatically
                const mainPdfContainer = document.getElementById('pdf-canvas-container');
                if (mainPdfContainer) {
                    let mainScrollSaveTimeout;
                    mainPdfContainer.addEventListener('scroll', () => {
                        // Don't save scroll if we're currently restoring it or switching sources
                        if (window.__restoreScrollAfterRender || window.__switchingPdfSource) {
                            return;
                        }
                        clearTimeout(mainScrollSaveTimeout);
                        mainScrollSaveTimeout = setTimeout(() => {
                            // Double-check we're not switching (race condition protection)
                            if (window.__switchingPdfSource) {
                                return;
                            }
                            window.__mainPdfScroll = {
                                scrollLeft: mainPdfContainer.scrollLeft,
                                scrollTop: mainPdfContainer.scrollTop
                            };
                            // Persist scroll position to store for the current source
                            updatePdfStore();
                        }, 100);
                    });
                }
                
                // Initialize auto-navigation button UI state
                const statusEl = document.getElementById('auto-nav-status');
                const toggleBtn = document.getElementById('auto-nav-toggle');
                const autoNavEnabled = window.__mainPdfViewer.autoSyncEnabled;
                if (statusEl) {
                    statusEl.textContent = autoNavEnabled ? 'Auto Nav: ON' : 'Auto Nav: OFF';
                }
                if (toggleBtn) {
                    toggleBtn.style.backgroundColor = autoNavEnabled ? '#28a745' : '';
                    toggleBtn.style.color = autoNavEnabled ? 'white' : '';
                }
                
                window.__mainPdfViewer.__pdfViewerInitializing = false;
                
                // Load PDF from existing store if available (now that canvas is ready)
                // Wait a tiny bit more to ensure everything is set
                setTimeout(() => {
                    loadPdfFromStore();
                }, 10);
            }, 0);
        }

        function loadPdfFromStore() {
            // Wait a bit for store to be available
            const store = window.__bboxStore;
            if (!store) {
                // Try to wait a bit and retry
                setTimeout(() => {
                    const retryStore = window.__bboxStore;
                    if (retryStore && retryStore.docs) {
                        loadPdfFromStore();
                    }
                }, 100);
                return false;
            }
            
            if (!store.docs) {
                return false;
            }
            
            const state = window.__mainPdfViewer;
            if (!state) {
                return false;
            }
            
            const source = state.source;
            const key = source === 'textbook' ? 'text' : 'guide';
            
            // Loading PDF from store
            // Ensure store entry exists for this key with proper defaults
            if (!store.docs[key]) {
                store.docs[key] = {
                    pdfDoc: null,
                    currentPage: 1,
                    totalPages: 0,
                    mainViewerScale: 1.0, // Default scale to prevent white pages
                    scale: 1.0
                };
            }
            
            const docData = store.docs[key];
            
            // Ensure critical properties exist with defaults
            if (!docData.mainViewerScale || docData.mainViewerScale <= 0) {
                docData.mainViewerScale = docData.scale && docData.scale > 0 ? docData.scale : 1.0;
            }
            
            if (docData && docData.pdfDoc) {
                
                // Clear last rendered state if PDF document changed
                if (state.pdfDoc !== docData.pdfDoc) {
                    state._lastRenderedState = null;
                }
                
                state.pdfDoc = docData.pdfDoc;
                state.totalPages = docData.totalPages || (docData.pdfDoc.numPages || 0);
                state.currentPage = docData.currentPage || 1;
                
                // Validate and set scale - ensure it's always a valid number > 0
                // This is critical to prevent white page issues after JSON load
                // Check each value individually to avoid using 0 or invalid values
                let loadedScale = null;
                if (docData.mainViewerScale && !isNaN(docData.mainViewerScale) && docData.mainViewerScale > 0) {
                    loadedScale = docData.mainViewerScale;
                } else if (docData.scale && !isNaN(docData.scale) && docData.scale > 0) {
                    loadedScale = docData.scale;
                } else {
                    // No saved scale - will be calculated as fit-to-canvas on first render
                    loadedScale = null;
                }
                
                // Final validation - should never be needed but just in case
                if (loadedScale !== null && (!loadedScale || isNaN(loadedScale) || loadedScale <= 0)) {
                    loadedScale = null;
                }
                
                // If no valid scale found, it will be calculated as fit-to-canvas during render
                // For now, set a temporary value that will be replaced
                state.scale = loadedScale || 1.0;
                state.fitToCanvasScale = null; // Will be calculated on first render
                
                // Only save scale to store if we have a valid saved scale
                if (loadedScale) {
                docData.mainViewerScale = loadedScale;
                }
                
                // Ensure currentPage is valid
                if (state.currentPage < 1) state.currentPage = 1;
                if (state.totalPages > 0 && state.currentPage > state.totalPages) {
                    state.currentPage = state.totalPages;
                }
                
                // Restore scroll position for this source
                if (docData.mainViewerScrollLeft !== undefined || docData.mainViewerScrollTop !== undefined) {
                    window.__mainPdfScroll = {
                        scrollLeft: docData.mainViewerScrollLeft || 0,
                        scrollTop: docData.mainViewerScrollTop || 0
                    };
                    window.__restoreScrollAfterRender = true;
                } else {
                    // No saved scroll position - clear the restore flag and start fresh
                    window.__mainPdfScroll = null;
                    window.__restoreScrollAfterRender = false;
                }
                
                updatePdfControls();
                
                // Force render - clear any upload prompt first
                const pdfPanel = document.getElementById('pdf-viewer-panel');
                const canvasContainer = pdfPanel?.querySelector('.pdf-canvas-container');
                if (canvasContainer) {
                    // Remove any upload prompt content
                    const uploadPrompt = canvasContainer.querySelector('[id*="pdf-upload"]');
                    if (uploadPrompt) {
                        // Restore canvas if it was replaced by upload prompt
                        if (!canvasContainer.querySelector('#main-pdf-canvas')) {
                            canvasContainer.innerHTML = '<canvas id="main-pdf-canvas"></canvas>';
                            // Reinitialize canvas reference
                            const canvas = document.getElementById('main-pdf-canvas');
                            if (canvas) {
                                state.canvas = canvas;
                                state.context = canvas.getContext('2d', { alpha: false });
                                if (state.elements) {
                                    state.elements.canvas = canvas;
                                }
                            }
                        }
                    }
                }
                
                // Only render if viewer is visible and state has actually changed
                if (state.visible) {
                    if (state.canvas && state.context) {
                        // Check if we actually need to render (state might not have changed)
                        const needsRender = !state._lastRenderedState || 
                                           state._lastRenderedState.page !== state.currentPage ||
                                           state._lastRenderedState.scale !== state.scale ||
                                           state._lastRenderedState.source !== state.source ||
                                           state._lastRenderedState.pdfDoc !== state.pdfDoc;
                        
                        if (needsRender) {
                            renderMainPdfPage();
                        } else {
                        }
                    } else {
                        // Wait a bit and try again
                        setTimeout(() => {
                            if (state.canvas && state.context && state.pdfDoc) {
                                renderMainPdfPage();
                            } else {
                                // If still not ready, try to reinitialize
                                if (!state.canvas && state.elements && state.elements.canvas) {
                                    state.canvas = state.elements.canvas;
                                    state.context = state.canvas ? state.canvas.getContext('2d', { alpha: false }) : null;
                                    if (state.canvas && state.context) {
                                        renderMainPdfPage();
                                    }
                                } else if (state.canvas && !state.context) {
                                    state.context = state.canvas.getContext('2d', { alpha: false });
                                    if (state.context) {
                                        renderMainPdfPage();
                                    }
                                }
                            }
                        }, 200);
                    }
                }
                
                return true;
            } else {
            }
            
            return false;
        }

        async function renderMainPdfPage() {
            const state = window.__mainPdfViewer;
            
            if (!state.pdfDoc) {
                showPdfUploadPrompt();
                return;
            }
            
            if (!state.canvas || !state.context) {
                return;
            }
            
            // Don't render if viewer is not visible (optimization)
            if (!state.visible) {
                return;
            }
            
            // Track last rendered state to avoid unnecessary rerenders
            if (!state._lastRenderedState) {
                state._lastRenderedState = {};
            }
            const lastRendered = state._lastRenderedState;
            const currentPage = state.currentPage || 1;
            const currentScale = state.scale || 1.0;
            const currentSource = state.source || 'textbook';
            const renderingPdfDoc = state.pdfDoc;
            state.renderToken = (state.renderToken || 0) + 1;
            const thisRenderToken = state.renderToken;
            
            // Skip render if page, scale, and source haven't changed
            if (lastRendered.page === currentPage && 
                lastRendered.scale === currentScale && 
                lastRendered.source === currentSource &&
                lastRendered.pdfDoc === state.pdfDoc) {
                return; // No changes, skip render
            }
            
            // Cancel any ongoing render operation and properly wait for cancellation
            // This prevents "Cannot use the same canvas during multiple render() operations" error
            if (state.renderTask) {
                const oldRenderTask = state.renderTask;
                state.renderTask = null;
                state.isRendering = false; // Clear flag immediately
                
                try {
                    // Cancel the render task
                    oldRenderTask.cancel();
                    
                    // Wait for cancellation to complete - the promise will reject when cancelled
                    // We must wait for this to ensure PDF.js releases the canvas
                    try {
                        await Promise.race([
                            oldRenderTask.promise,
                            new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 1000))
                        ]).catch((error) => {
                            // Expected: cancellation throws RenderingCancelledException or timeout
                            // This is normal, we just need to wait for PDF.js to release the canvas
                            if (error.name !== 'RenderingCancelledException' && error.message !== 'Timeout') {
                            }
                        });
                    } catch (cancelError) {
                        // Ignore cancellation errors - this is expected when cancelling
                    }
                } catch (e) {
                    // Ignore any errors during cancellation
                }
                
                // Wait a bit to ensure canvas is fully released before starting new render
                // This is critical to prevent canvas lock conflicts when uploading new PDFs
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            // Prevent concurrent renders - but add timeout to prevent stuck flag
            if (state.isRendering) {
                // If isRendering is true but no renderTask, clear it (defensive)
                if (!state.renderTask) {
                    state.isRendering = false;
                } else {
                    state.pendingRender = true;
                    return;
                }
            }
            
            if (!state.currentPage || state.currentPage < 1) {
                state.currentPage = 1;
            }
            if (state.currentPage > state.totalPages) {
                state.currentPage = state.totalPages;
            }
            
            // Validate scale - ensure it's always a valid number > 0
            // This prevents white page issues when scale is invalid after loading JSON or switching sources
            if (!state.scale || isNaN(state.scale) || state.scale <= 0) {
                state.scale = 1.0;
                // Save corrected scale to store immediately to prevent state corruption
                const store = window.__bboxStore = window.__bboxStore || {};
                store.docs = store.docs || { text: {}, guide: {} };
                const key = state.source === 'textbook' ? 'text' : 'guide';
                if (store.docs[key]) {
                    store.docs[key].mainViewerScale = 1.0;
                }
            }
            
            state.isRendering = true;
            
            try {
                const page = await state.pdfDoc.getPage(state.currentPage);
                const canvas = state.canvas;
                const context = state.context;
                const container = canvas.parentElement;
                
                // Get container width to constrain canvas size (account for padding)
                const containerWidth = container ? container.clientWidth - 40 : 800;
                
                // Calculate and store fit-to-canvas scale if not already set (do this first)
                if (!state.fitToCanvasScale || state.fitToCanvasScale <= 0) {
                    state.fitToCanvasScale = calculateFitToCanvasScale(page, container);
                }
                
                // CRITICAL: Final validation of scale right before creating viewport
                // This prevents white page issues when scale is invalid (e.g., after JSON load)
                if (!state.scale || isNaN(state.scale) || state.scale <= 0 || state.scale === 0) {
                    state.scale = state.fitToCanvasScale || 1.0; // Use fit-to-canvas if available, else fallback to 1.0
                    // Save corrected scale to store
                    const store = window.__bboxStore = window.__bboxStore || {};
                    store.docs = store.docs || { text: {}, guide: {} };
                    const key = state.source === 'textbook' ? 'text' : 'guide';
                    if (store.docs[key]) {
                        store.docs[key].mainViewerScale = state.scale;
                    }
                }
                
                // If scale is still 1.0 (default) and we haven't loaded a saved scale, use fit-to-canvas
                // Check if this is a fresh load by checking if scale hasn't been set from store
                if (state.scale === 1.0 && state.fitToCanvasScale && state.fitToCanvasScale > 0) {
                    // Only use fit-to-canvas if we don't have a saved scale (indicated by checking store)
                    const store = window.__bboxStore;
                    const key = state.source === 'textbook' ? 'text' : 'guide';
                    const hasSavedScale = store && store.docs && store.docs[key] && 
                                        store.docs[key].mainViewerScale && 
                                        store.docs[key].mainViewerScale !== 1.0 &&
                                        store.docs[key].mainViewerScale > 0;
                    
                    if (!hasSavedScale) {
                        state.scale = state.fitToCanvasScale;
                        // Save the fit-to-canvas scale to store
                        if (store && store.docs && store.docs[key]) {
                            store.docs[key].mainViewerScale = state.fitToCanvasScale;
                        }
                    }
                }
                
                // Render at the desired scale - this is the actual zoom level
                let viewport = page.getViewport({ scale: state.scale });
                
                // CRITICAL: Validate viewport dimensions - if they're zero or invalid, reset scale and recreate
                if (!viewport || !viewport.width || !viewport.height || viewport.width <= 0 || viewport.height <= 0) {
                    state.scale = state.fitToCanvasScale || 1.0; // Use fit-to-canvas if available
                    viewport = page.getViewport({ scale: state.scale });
                    // Save corrected scale to store
                    const store = window.__bboxStore = window.__bboxStore || {};
                    store.docs = store.docs || { text: {}, guide: {} };
                    const key = state.source === 'textbook' ? 'text' : 'guide';
                    if (store.docs[key]) {
                        store.docs[key].mainViewerScale = state.scale;
                    }
                }
                
                // Get device pixel ratio for high-DPI rendering (ensures 100% quality at all zoom levels)
                const dpr = window.devicePixelRatio || 1;
                
                // Set canvas internal dimensions with devicePixelRatio for crisp rendering
                canvas.width = Math.floor(viewport.width * dpr);
                canvas.height = Math.floor(viewport.height * dpr);
                
                // Reset transform and scale the context to account for devicePixelRatio
                context.setTransform(1, 0, 0, 1, 0, 0);
                context.scale(dpr, dpr);
                
                // Clear the canvas first
                context.clearRect(0, 0, viewport.width, viewport.height);
                
                // Set canvas CSS display size to actual zoomed size (use viewport dimensions, not multiplied)
                // The container has overflow: auto, so it will scroll when canvas is larger
                // Column width stays fixed because container has max-width: 100% and form-section has overflow: hidden
                canvas.style.width = viewport.width + 'px';
                canvas.style.height = viewport.height + 'px';
                canvas.style.maxWidth = 'none'; // Allow canvas to be larger than container for scrolling
                canvas.style.minWidth = 'none';
                canvas.style.display = 'block'; // Ensure block display
                canvas.style.boxSizing = 'content-box'; // Ensure padding/border don't affect size
                
                const renderContext = {
                    canvasContext: context,
                    viewport: viewport
                };
                
                // Store the render task so we can cancel it if needed
                const renderTask = page.render(renderContext);
                state.renderTask = renderTask;
                
                await renderTask.promise;
                
                // Stale-check: only apply completion if this render is still current
                if (thisRenderToken !== state.renderToken || state.pdfDoc !== renderingPdfDoc || state.currentPage !== currentPage || state.source !== currentSource) {
                    state.renderTask = null;
                    state.isRendering = false;
                    if (state.pendingRender) {
                        state.pendingRender = false;
                        setTimeout(() => renderMainPdfPage(), 0);
                    }
                    return;
                }
                
                // Clear render task after successful completion
                state.renderTask = null;
                state.isRendering = false;
                
                // Update last rendered state to prevent unnecessary rerenders
                state._lastRenderedState = {
                    page: currentPage,
                    scale: currentScale,
                    source: currentSource,
                    pdfDoc: state.pdfDoc
                };
                
                updatePdfControls();
                
                if (state.pendingRender) {
                    state.pendingRender = false;
                    setTimeout(() => renderMainPdfPage(), 0);
                }
                
                // Restore main PDF viewer scroll position after rendering BEFORE calling updatePdfStore
                // This ensures we don't save the wrong scroll position
                if (window.__mainPdfScroll && (window.__restoreScrollAfterRender || !window.__mainPdfScrollSaved)) {
                    const mainPdfContainer = document.getElementById('pdf-canvas-container');
                    if (mainPdfContainer) {
                        const scrollToRestore = { ...window.__mainPdfScroll };
                        
                        // Use triple requestAnimationFrame + small timeout to ensure canvas is fully rendered
                        requestAnimationFrame(() => {
                            requestAnimationFrame(() => {
                                requestAnimationFrame(() => {
                                    // Ensure flag is set to prevent scroll listener from interfering during restoration
                                    window.__restoreScrollAfterRender = true;
                                    
                                    // Small additional delay to ensure canvas dimensions are finalized
                                    setTimeout(() => {
                                mainPdfContainer.scrollLeft = scrollToRestore.scrollLeft || 0;
                                mainPdfContainer.scrollTop = scrollToRestore.scrollTop || 0;
                                        
                                        // Wait a bit before clearing the flag and allowing scroll listener to work again
                                        setTimeout(() => {
                                window.__restoreScrollAfterRender = false;
                                            window.__switchingPdfSource = false; // Clear switching flag after restoration
                                
                                // Now save the restored position to store
                                updatePdfStore();
                                        }, 100);
                                    }, 50);
                                });
                            });
                        });
                    } else {
                        // No container, just update store
                        window.__restoreScrollAfterRender = false;
                        updatePdfStore();
                    }
                } else {
                    // No scroll to restore, update store normally
                    window.__restoreScrollAfterRender = false;
                    updatePdfStore();
                }
                
            } catch (error) {
                state.isRendering = false;
                state.renderTask = null;
                
                if (state.pendingRender) {
                    state.pendingRender = false;
                    setTimeout(() => renderMainPdfPage(), 0);
                }
                
                // Don't show error if it was just a cancellation
                if (error.name === 'RenderingCancelledException') {
                    return;
                }
                
                // Handle canvas conflict error - this can happen when uploading new PDFs
                // Retry after a delay to allow the canvas to be released (only if still same doc)
                if (error.message && error.message.includes('Cannot use the same canvas')) {
                    const retryPdfDoc = renderingPdfDoc;
                    setTimeout(() => {
                        if (state.pdfDoc === retryPdfDoc && state.canvas && state.context && !state.isRendering) {
                            renderMainPdfPage();
                        }
                    }, 200);
                    return;
                }
                
                console.error('Error rendering PDF page:', error);
                showPdfError('Failed to render page: ' + (error.message || 'Unknown error'));
            }
        }

        function updatePdfControls() {
            const state = window.__mainPdfViewer;
            const elements = state.elements;
            
            if (!elements.pageDisplay) return;
            
            elements.pageDisplay.textContent = `Page ${state.currentPage}/${state.totalPages}`;
            
            if (elements.zoomDisplay) {
                elements.zoomDisplay.textContent = `${Math.round(state.scale * 100)}%`;
            }
            
            if (elements.gotoInput) {
                elements.gotoInput.value = state.currentPage;
                elements.gotoInput.max = state.totalPages;
            }
            
            if (elements.prevBtn) {
                elements.prevBtn.disabled = state.currentPage <= 1;
            }
            if (elements.nextBtn) {
                elements.nextBtn.disabled = state.currentPage >= state.totalPages;
            }
            
            if (elements.sourceToggle) {
                if (elements.sourceToggle.textbook) {
                    elements.sourceToggle.textbook.classList.toggle('active', state.source === 'textbook');
                }
                if (elements.sourceToggle.guide) {
                    elements.sourceToggle.guide.classList.toggle('active', state.source === 'guide');
                }
            }
        }

        function updatePdfStore() {
            const state = window.__mainPdfViewer;
            const store = window.__bboxStore = window.__bboxStore || {};
            store.docs = store.docs || { text: {}, guide: {} };
            
            // Save main PDF viewer scroll position for the current source
            const mainPdfContainer = document.getElementById('pdf-canvas-container');
            const key = state.source === 'textbook' ? 'text' : 'guide';
            
            if (mainPdfContainer && store.docs[key]) {
                store.docs[key].mainViewerScrollLeft = mainPdfContainer.scrollLeft;
                store.docs[key].mainViewerScrollTop = mainPdfContainer.scrollTop;
                
                
                // Don't update window.__mainPdfScroll here - it should only be updated by:
                // 1. The scroll listener (for continuous saving)
                // 2. loadPdfFromStore() (when loading saved position for a source)
                // This prevents overwriting the scroll position when switching sources
            }
            
            // Update store for page/source tracking
            if (store.docs[key]) {
                store.docs[key].currentPage = state.currentPage;
                // Save main viewer scale separately from bbox modal scale
                store.docs[key].mainViewerScale = state.scale;
            }
        }

        function navigateMainPdf(direction) {
            const state = window.__mainPdfViewer;
            
            if (!state.pdfDoc) return;
            
            let newPage = state.currentPage;
            
            switch(direction) {
                case 'prev':
                    if (state.currentPage > 1) {
                        newPage = state.currentPage - 1;
                    }
                    break;
                case 'next':
                    if (state.currentPage < state.totalPages) {
                        newPage = state.currentPage + 1;
                    }
                    break;
                case 'goto':
                    const input = state.elements.gotoInput;
                    if (input) {
                        const targetPage = parseInt(input.value, 10);
                        if (targetPage >= 1 && targetPage <= state.totalPages) {
                            newPage = targetPage;
                        }
                    }
                    break;
            }
            
            if (newPage !== state.currentPage) {
                state.currentPage = newPage;
                state.lastSyncedPage = null; // Disable auto-sync after manual navigation
                state.lastManualNavTime = Date.now(); // Track manual navigation time
                state.userNavigatedAway = true; // Mark that user manually navigated
                renderMainPdfPage();
            }
        }
        
        // Helper function for programmatic navigation (used by auto-navigation)
        function navigateMainPdfToPage(pageNum) {
            const state = window.__mainPdfViewer;
            
            if (!state.pdfDoc) return;
            
            if (pageNum >= 1 && pageNum <= state.totalPages && pageNum !== state.currentPage) {
                state.currentPage = pageNum;
                // Don't mark as user navigated since this is programmatic
                renderMainPdfPage();
                updatePdfControls(); // Ensure controls are updated
            }
        }

        function zoomMainPdf(action) {
            const state = window.__mainPdfViewer;
            
            // Ensure we're only affecting the main viewer, not bbox modal
            if (!state || !state.pdfDoc) {
                return;
            }
            
            const oldScale = state.scale;
            
            switch(action) {
                case 'in':
                    state.scale = Math.min(state.scale * 1.2, 8.0);
                    break;
                case 'out':
                    state.scale = Math.max(state.scale / 1.2, 0.3);
                    break;
                case 'reset':
                    // Reset to fit-to-canvas scale, recalculate if needed
                    if (state.pdfDoc && state.canvas && state.currentPage) {
                        state.pdfDoc.getPage(state.currentPage).then(page => {
                            const container = state.canvas.parentElement;
                            if (container && page) {
                                state.fitToCanvasScale = calculateFitToCanvasScale(page, container);
                                state.scale = state.fitToCanvasScale;
                            } else {
                                state.scale = state.fitToCanvasScale || 1.0;
                            }
                            renderMainPdfPage();
                        }).catch(err => {
                            state.scale = state.fitToCanvasScale || 1.0;
                            renderMainPdfPage();
                        });
                        return; // Early return, renderMainPdfPage will be called in the promise
                    } else {
                        // Fallback to stored fit-to-canvas scale or 1.0
                        state.scale = state.fitToCanvasScale || 1.0;
                        renderMainPdfPage();
                    }
                    break;
            }
            
            
            // Save the zoom scale for the current source
            const store = window.__bboxStore = window.__bboxStore || {};
            store.docs = store.docs || { text: {}, guide: {} };
            const key = state.source === 'textbook' ? 'text' : 'guide';
            if (store.docs[key]) {
                store.docs[key].mainViewerScale = state.scale;
            }
            
            // Only update the store's scale for the main viewer, don't affect bbox modal
                renderMainPdfPage();
        }

        function switchPdfSource(source) {
            const state = window.__mainPdfViewer;
            
            if (state.source === source) return;
            
            
            // Set flag to prevent scroll listener from interfering during source switch
            window.__switchingPdfSource = true;
            
            // CRITICAL: Save current scroll/zoom state BEFORE switching
            // Read scroll position directly from DOM to ensure we have the latest value
            const mainPdfContainer = document.getElementById('pdf-canvas-container');
            const oldSource = state.source;
            const oldKey = oldSource === 'textbook' ? 'text' : 'guide';
            const store = window.__bboxStore = window.__bboxStore || {};
            store.docs = store.docs || { text: {}, guide: {} };
            
            // Ensure store entry exists for the old source
            if (!store.docs[oldKey]) {
                store.docs[oldKey] = {};
            }
            
            // Save current scroll position directly from DOM for the source we're leaving
            if (mainPdfContainer) {
                store.docs[oldKey].mainViewerScrollLeft = mainPdfContainer.scrollLeft;
                store.docs[oldKey].mainViewerScrollTop = mainPdfContainer.scrollTop;
            }
            
            // Save current zoom/scale and page for the old source
            store.docs[oldKey].mainViewerScale = state.scale;
            store.docs[oldKey].currentPage = state.currentPage;
            
            // Clear scroll restoration state to ensure we load fresh scroll for new source
            window.__mainPdfScroll = null;
            window.__restoreScrollAfterRender = false;
            
            // Switch source
            state.source = source;
            state.lastSyncedPage = null;
            state.lastSyncedSource = null;
            // Clear last rendered state when switching sources to force render
            state._lastRenderedState = null;
            
            // Update source toggle button visual state
            if (state.elements && state.elements.sourceToggle) {
                if (state.elements.sourceToggle.textbook) {
                    state.elements.sourceToggle.textbook.classList.toggle('active', source === 'textbook');
                }
                if (state.elements.sourceToggle.guide) {
                    state.elements.sourceToggle.guide.classList.toggle('active', source === 'guide');
                }
            }
            
            // Load PDF from store for the new source (this will also trigger render and scroll restoration)
            const loaded = loadPdfFromStore();
            
            if (!loaded) {
                // PDF not found in store, show upload prompt with the correct source
                window.__switchingPdfSource = false; // Clear flag if load failed
                showPdfUploadPrompt(source);
                return;
            }
            
            // CRITICAL: Ensure scale is valid after loading to prevent white page issues
            // loadPdfFromStore() will handle rendering - we just need to validate scale is correct
            // Don't force another render here as it will conflict with loadPdfFromStore()'s render
            if (state.pdfDoc) {
                // Validate scale one more time and save to store if needed
                if (!state.scale || isNaN(state.scale) || state.scale <= 0) {
                    state.scale = 1.0;
                    // Save corrected scale to store immediately
                    const store = window.__bboxStore = window.__bboxStore || {};
                    store.docs = store.docs || { text: {}, guide: {} };
                    const key = source === 'textbook' ? 'text' : 'guide';
                    if (store.docs[key]) {
                        store.docs[key].mainViewerScale = 1.0;
                    }
                }
            }
            
            // loadPdfFromStore() will handle rendering and scroll restoration
            // Auto-navigate to the appropriate page after switching sources (only if auto-navigation is enabled)
            if (state.autoSyncEnabled && state.pdfDoc && state.totalPages) {
                if (source === 'guide') {
                    // Navigate to a page within the guidebook range when switching to guidebook
                    const guidebookPage = getGuidebookPageInRange();
                    if (guidebookPage && guidebookPage > 0 && guidebookPage <= state.totalPages) {
                            // Wait for PDF to be fully loaded and rendered, then navigate
                            setTimeout(() => {
                            // Re-check autoSyncEnabled before navigating (user might have turned it off)
                            if (state.autoSyncEnabled) {
                                navigateMainPdfToPage(guidebookPage);
                            }
                            }, 300);
                    }
                } else if (source === 'textbook') {
                    // Navigate to textbook PDF page when switching to textbook
                    const textbookPageInput = document.getElementById('textbook_pdf_page');
                    if (textbookPageInput && textbookPageInput.value) {
                        const textbookPage = parseInt(textbookPageInput.value, 10);
                        if (!isNaN(textbookPage) && textbookPage > 0 && textbookPage <= state.totalPages) {
                            // Wait for PDF to be fully loaded and rendered, then navigate
                            setTimeout(() => {
                                // Re-check autoSyncEnabled before navigating (user might have turned it off)
                                if (state.autoSyncEnabled) {
                                navigateMainPdfToPage(textbookPage);
                                }
                            }, 300);
                        }
                    }
                }
            }
            
            // Clear the switching flag after scroll restoration completes (handled in renderMainPdfPage)
            // Also set a timeout as backup in case restoration doesn't trigger
            setTimeout(() => {
                window.__switchingPdfSource = false;
            }, 500);
        }

        function showPdfUploadPrompt(source) {
            const pdfPanel = document.getElementById('pdf-viewer-panel');
            const canvasContainer = pdfPanel?.querySelector('.pdf-canvas-container');
            const state = window.__mainPdfViewer;
            const pdfSource = source || state?.source || 'textbook';
            
            if (canvasContainer) {
                const isTextbook = pdfSource === 'textbook';
                const uploadBtnId = isTextbook ? 'pdf-upload-textbook-btn' : 'pdf-upload-guide-btn';
                
                canvasContainer.innerHTML = `
                    <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; color: #6c757d; padding: 20px;">
                        <i class="fas fa-file-pdf" style="font-size: 48px; margin-bottom: 16px; opacity: 0.5;"></i>
                        <p style="font-size: 16px; margin-bottom: 8px;">No ${isTextbook ? 'Textbook' : 'Guide'} PDF loaded</p>
                        <p style="font-size: 14px; margin-bottom: 16px;">Upload a ${isTextbook ? 'Textbook' : 'Guide'} PDF to view it here</p>
                        <button id="${uploadBtnId}" class="add-btn" style="margin: 8px;">
                            <i class="fas fa-file-upload"></i> Upload ${isTextbook ? 'Textbook' : 'Guide'} PDF
                        </button>
                    </div>
                `;
                
                // Attach event listener
                const uploadBtn = document.getElementById(uploadBtnId);
                if (uploadBtn) {
                    uploadBtn.addEventListener('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        if (isTextbook) {
                            openBboxDrawerForTextbook();
                        } else {
                            openBboxDrawerForGuide();
                        }
                    });
                }
            }
        }

        function showPdfError(message) {
            const pdfPanel = document.getElementById('pdf-viewer-panel');
            const canvasContainer = pdfPanel?.querySelector('.pdf-canvas-container');
            
            if (canvasContainer) {
                canvasContainer.innerHTML = `
                    <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; color: #dc3545; padding: 20px;">
                        <i class="fas fa-exclamation-triangle" style="font-size: 48px; margin-bottom: 16px;"></i>
                        <p style="font-size: 16px; text-align: center;">${message}</p>
                    </div>
                `;
            }
        }

        // Smart Context-Aware Navigation
        function detectFormContext() {
            const context = {
                activeTab: null,
                activeSection: null,
                activeQuestion: null,
                focusedField: null,
                page: null,
                source: 'textbook',
                questionPage: null,  // For questions: textbook page
                answerPage: null     // For questions: guide page
            };
            
            // Detect active tab
            const activeTab = document.querySelector('.tab.active');
            if (activeTab) {
                context.activeTab = activeTab.textContent.trim().toLowerCase();
            }
            
            // Detect focused element
            const focused = document.activeElement;
            if (focused) {
                context.focusedField = focused;
                
                // Find parent section/question
                const section = focused.closest('.array-item');
                if (section) {
                    // Check if it's a content section
                    if (section.closest('#content_sections_container')) {
                        context.activeSection = getSectionIndex(section);
                        context.page = extractPageFromSection(section, 'content');
                    }
                    // Check if it's a question
                    else if (section.closest('#questions_container')) {
                        context.activeQuestion = getQuestionIndex(section);
                        
                        // Extract both question and answer pages for questions
                        context.questionPage = extractPageFromQuestion(section, 'question');
                        context.answerPage = extractPageFromQuestion(section, 'answer');
                        
                        // Determine if we're editing question or answer fields
                        const fieldType = detectQuestionFieldType(focused, section);
                        if (fieldType === 'answer') {
                            context.source = 'guide';
                            context.page = context.answerPage;
                        } else {
                            context.source = 'textbook';
                            context.page = context.questionPage;
                        }
                    }
                }
            }
            
            // Fallback: Check current tab and use appropriate default
            if (!context.page) {
                // Get default page based on current viewer source
                const viewerSource = window.__mainPdfViewer?.source || 'textbook';
                const defaultPages = getDefaultPageForTab(context.activeTab);
                
                if (defaultPages) {
                    if (viewerSource === 'guide' && defaultPages.guidePage) {
                        context.page = defaultPages.guidePage;
                        context.source = 'guide';
                    } else if (defaultPages.textbookPage) {
                        context.page = defaultPages.textbookPage;
                        context.source = 'textbook';
                    }
                }
            }
            
            return context;
        }

        function extractPageFromSection(section, type) {
            const bboxContainer = section.querySelector('.bbox-container');
            if (!bboxContainer) return null;
            
            const firstBboxItem = bboxContainer.querySelector('.array-item');
            if (!firstBboxItem) return null;
            
            const pageInput = firstBboxItem.querySelector('.bbox-page');
            if (pageInput && pageInput.value) {
                return parseInt(pageInput.value, 10);
            }
            
            return null;
        }

        function extractPageFromQuestion(questionEl, type) {
            let selector;
            if (type === 'question') {
                const questionBboxLabel = Array.from(questionEl.querySelectorAll('label')).find(
                    label => label.textContent.includes('Question Images')
                );
                if (questionBboxLabel) {
                    const container = questionBboxLabel.closest('.form-group')?.querySelector('.bbox-container');
                    if (container) {
                        const firstBbox = container.querySelector('.array-item .bbox-page');
                        if (firstBbox && firstBbox.value) {
                            return parseInt(firstBbox.value, 10);
                        }
                    }
                }
            } else if (type === 'answer') {
                const answerBboxLabel = Array.from(questionEl.querySelectorAll('label')).find(
                    label => label.textContent.includes('Answer Images')
                );
                if (answerBboxLabel) {
                    const container = answerBboxLabel.closest('.form-group')?.querySelector('.bbox-container');
                    if (container) {
                        const firstBbox = container.querySelector('.array-item .bbox-page');
                        if (firstBbox && firstBbox.value) {
                            return parseInt(firstBbox.value, 10);
                        }
                    }
                }
                
                // Also check guide_pdf_page field
                const guidePdfPageInput = questionEl.querySelector('input[placeholder*="Guide PDF Page"]') ||
                                        Array.from(questionEl.querySelectorAll('input')).find(
                                            input => input.previousElementSibling?.textContent?.includes('Guide PDF Page')
                                        );
                if (guidePdfPageInput && guidePdfPageInput.value) {
                    return parseInt(guidePdfPageInput.value, 10);
                }
            }
            
            return null;
        }

        function detectQuestionFieldType(focused, questionEl) {
            const answerLabels = ['Guide Answer', 'Answer Images'];
            const parentLabel = focused.closest('.form-group')?.querySelector('label');
            
            if (parentLabel) {
                const labelText = parentLabel.textContent;
                if (answerLabels.some(answerLabel => labelText.includes(answerLabel))) {
                    return 'answer';
                }
            }
            
            return 'question';
        }

        function getDefaultPageForTab(tabName) {
            if (!tabName) return null;
            
            const result = {
                textbookPage: null,
                guidePage: null
            };
            
            switch(tabName) {
                case 'basic':
                case 'preamble':
                    // Get textbook page from PDF Page Number field
                    const textbookPdfPage = document.getElementById('textbook_pdf_page');
                    if (textbookPdfPage && textbookPdfPage.value) {
                        result.textbookPage = parseInt(textbookPdfPage.value, 10);
                    }
                    
                    // Get guidebook page from Guidebook Start Page field
                    const guidebookStartPage = document.getElementById('guidebook_start_page');
                    if (guidebookStartPage && guidebookStartPage.value) {
                        result.guidePage = parseInt(guidebookStartPage.value, 10);
                    }
                    break;
                    
                case 'content':
                    const firstSection = document.querySelector('#content_sections_container > .array-item');
                    if (firstSection) {
                        const page = extractPageFromSection(firstSection, 'content');
                        if (page) {
                            result.textbookPage = page;
                            return result; // Content is textbook only
                        }
                    }
                    return getDefaultPageForTab('basic');
                    
                case 'questions':
                    const firstQuestion = document.querySelector('#questions_container > .array-item');
                    if (firstQuestion) {
                        const questionPage = extractPageFromQuestion(firstQuestion, 'question');
                        const answerPage = extractPageFromQuestion(firstQuestion, 'answer');
                        if (questionPage || answerPage) {
                            result.textbookPage = questionPage;
                            result.guidePage = answerPage;
                            return result;
                        }
                    }
                    return getDefaultPageForTab('basic');
                    
                default:
                    return getDefaultPageForTab('basic');
            }
            
            return result;
        }

        function getSectionIndex(section) {
            const container = section.closest('#content_sections_container');
            const sections = container.querySelectorAll(':scope > .array-item');
            return Array.from(sections).indexOf(section);
        }

        function getQuestionIndex(question) {
            const container = question.closest('#questions_container');
            const questions = container.querySelectorAll(':scope > .array-item');
            return Array.from(questions).indexOf(question);
        }

        function toggleAutoNavigation() {
            const state = window.__mainPdfViewer;
            state.autoSyncEnabled = !state.autoSyncEnabled;
            
            // Save to localStorage
            localStorage.setItem('pdfAutoNavEnabled', state.autoSyncEnabled);
            
            // Update UI
            const statusEl = document.getElementById('auto-nav-status');
            const toggleBtn = document.getElementById('auto-nav-toggle');
            if (statusEl) {
                statusEl.textContent = state.autoSyncEnabled ? 'Auto Nav: ON' : 'Auto Nav: OFF';
            }
            if (toggleBtn) {
                toggleBtn.style.backgroundColor = state.autoSyncEnabled ? '#28a745' : '';
                toggleBtn.style.color = state.autoSyncEnabled ? 'white' : '';
            }
            
            // Reset navigation state when enabling
            if (state.autoSyncEnabled) {
                state.userNavigatedAway = false;
                navigateToContextPage();
            }
        }

        /**
         * Get the appropriate guidebook page within the range
         * @returns {number|null} Page number within the range, or null if range is invalid
         */
        function getGuidebookPageInRange() {
            const startPageInput = document.getElementById('guidebook_start_page');
            const endPageInput = document.getElementById('guidebook_end_page');
            
            if (!startPageInput || !endPageInput || !startPageInput.value || !endPageInput.value) {
                return null;
            }
            
            const startPage = parseInt(startPageInput.value, 10);
            const endPage = parseInt(endPageInput.value, 10);
            
            if (isNaN(startPage) || isNaN(endPage) || startPage <= 0 || endPage <= 0 || startPage > endPage) {
                return null;
            }
            
            const state = window.__mainPdfViewer;
            
            // If we have a current page and it's within the range, use it
            if (state.currentPage && state.currentPage >= startPage && state.currentPage <= endPage) {
                return state.currentPage;
            }
            
            // If current page is before the range, use start page
            if (state.currentPage && state.currentPage < startPage) {
                return startPage;
            }
            
            // If current page is after the range, use end page
            if (state.currentPage && state.currentPage > endPage) {
                return endPage;
            }
            
            // If no current page context, default to start page
            return startPage;
        }

        function navigateToContextPage() {
            const state = window.__mainPdfViewer;
            
            // Don't navigate if disabled
            if (!state.autoSyncEnabled) return;
            
            // Don't navigate if no PDF loaded
            if (!state.pdfDoc) return;
            
            // Don't navigate if user recently navigated manually (within 5 seconds)
            const timeSinceManualNav = Date.now() - state.lastManualNavTime;
            if (timeSinceManualNav < 5000 && state.userNavigatedAway) {
                return;
            }
            
            const context = detectFormContext();
            
            // Determine target page and source
            let targetPage = null;
            let targetSource = null;
            let useRangeCheck = false; // Flag to enable range checking
            const TEXTBOOK_RANGE = 1; // Pages before/after for textbook range
            
            // Content tab: use textbook with PDF Page Number
            if (context.activeTab === 'content') {
                targetSource = 'textbook';
                const textbookPageInput = document.getElementById('textbook_pdf_page');
                if (textbookPageInput && textbookPageInput.value) {
                    targetPage = parseInt(textbookPageInput.value, 10);
                    useRangeCheck = true;
                }
            }
            // Questions tab: use guidebook when guide answer box is active
            else if (context.activeTab === 'questions') {
                // Check if we're in a guide answer field
                const focused = document.activeElement;
                let isGuideField = false;
                
                if (focused) {
                    const formGroup = focused.closest('.form-group');
                    if (formGroup) {
                        const label = formGroup.querySelector('label');
                        if (label) {
                            const labelText = label.textContent;
                            // Removed 'Answer Images' - no longer switches to guidebook
                            isGuideField = labelText.includes('Guide') || 
                                         labelText.includes('Answer Bounding');
                        }
                    }
                }
                
                if (isGuideField) {
                    targetSource = 'guide';
                    
                    // Check if this is specifically a Guide PDF Page field
                    const formGroup = focused.closest('.form-group');
                    const isGuidePdfPageField = formGroup && formGroup.querySelector('label')?.textContent?.includes('Guide PDF Page');
                    
                    if (isGuidePdfPageField) {
                        // For Guide PDF Page field, use its value if available
                        if (focused.value) {
                            targetPage = parseInt(focused.value, 10);
                        }
                    } else {
                    // For other guide fields (Guide Answer), 
                    // use any page within the guidebook range
                    // Note: Answer Images no longer triggers guidebook switching
                    targetPage = getGuidebookPageInRange();
                    }
                    
                    // If still no target page, fallback to guidebook range logic
                    if (!targetPage) {
                        targetPage = getGuidebookPageInRange();
                    }
                } else {
                    // Not in a guide field - only switch to textbook if we're not already on guide
                    // This prevents unwanted switching when user is using guide PDF and clicks elsewhere
                    if (state.source === 'guide') {
                        // Stay on guide if user manually switched to it, unless explicitly in textbook field
                        const focused = document.activeElement;
                        const isTextbookField = focused && (
                            focused.id === 'textbook_page' || 
                            focused.id === 'textbook_pdf_page' ||
                            focused.closest('.form-group')?.querySelector('label')?.textContent?.includes('Textbook')
                        );
                        
                        if (isTextbookField) {
                            targetSource = 'textbook';
                            const textbookPageInput = document.getElementById('textbook_pdf_page');
                            if (textbookPageInput && textbookPageInput.value) {
                                targetPage = parseInt(textbookPageInput.value, 10);
                                useRangeCheck = true;
                            }
                        } else {
                            // Stay on guide - no auto-switching
                            return;
                        }
                    } else {
                        // Currently on textbook, navigate within textbook
                        targetSource = 'textbook';
                        const textbookPageInput = document.getElementById('textbook_pdf_page');
                        if (textbookPageInput && textbookPageInput.value) {
                            targetPage = parseInt(textbookPageInput.value, 10);
                            useRangeCheck = true;
                        }
                    }
                }
            }
            // Basic/Preamble tabs: use textbook page, but don't force switch if on guide
            else {
                // Only switch to textbook if explicitly in textbook field or not on guide
                const focused = document.activeElement;
                const isTextbookField = focused && (
                    focused.id === 'textbook_page' || 
                    focused.id === 'textbook_pdf_page' ||
                    focused.closest('.form-group')?.querySelector('label')?.textContent?.includes('Textbook')
                );
                
                if (state.source === 'guide' && !isTextbookField) {
                    // Stay on guide if user is there and not explicitly in textbook field
                    return;
                }
                
                targetSource = 'textbook';
                const textbookPageInput = document.getElementById('textbook_pdf_page');
                if (textbookPageInput && textbookPageInput.value) {
                    targetPage = parseInt(textbookPageInput.value, 10);
                    useRangeCheck = true;
                }
            }
            
            // Only navigate if we have a valid target
            if (!targetPage || !targetSource) return;
            
            // Switch source if needed (always switch to correct source)
            // BUT: Don't switch if BBox modal is open from a Draw button (prevents unwanted source switching)
            if (state.source !== targetSource && !window.__bboxModalOpen) {
                switchPdfSource(targetSource);
                // After switching source, we might need to wait for PDF to load
                // The current page might not be valid, so force navigation
                navigateMainPdfToPage(targetPage);
                state.userNavigatedAway = false;
                return;
            }
            
            // If modal is open, don't switch sources even if they don't match
            if (state.source !== targetSource && window.__bboxModalOpen) {
                return;
            }
            
            // If using range check for textbook, check if current page is within acceptable range
            if (useRangeCheck && targetSource === 'textbook') {
                const rangeStart = Math.max(1, targetPage - TEXTBOOK_RANGE);
                const rangeEnd = Math.min(state.totalPages || targetPage, targetPage + TEXTBOOK_RANGE);
                
                // If current page is within range, don't navigate
                if (state.currentPage >= rangeStart && state.currentPage <= rangeEnd) {
                    return;
                }
            }
            
            // Only navigate if different from current page
            if (state.currentPage === targetPage) {
                return;
            }
            
            // Navigate to page (this will preserve zoom and scroll position)
            navigateMainPdfToPage(targetPage);
            
            // Reset user navigated away flag since we just auto-navigated
            state.userNavigatedAway = false;
        }

        function toggleAutoSync(enabled) {
            window.__mainPdfViewer.autoSyncEnabled = enabled;
            
            // Update UI
            const statusEl = document.getElementById('auto-nav-status');
            const toggleBtn = document.getElementById('auto-nav-toggle');
            if (statusEl) {
                statusEl.textContent = enabled ? 'Auto Nav: ON' : 'Auto Nav: OFF';
            }
            if (toggleBtn) {
                toggleBtn.style.backgroundColor = enabled ? '#28a745' : '';
                toggleBtn.style.color = enabled ? 'white' : '';
            }
            
            if (enabled) {
                navigateToContextPage();
            }
        }

        // Helper function to determine if a field is guide-related
        function isGuideRelatedField(element) {
            if (!element) return false;
            
            // Specific guide-related field IDs
            const guideFieldIds = ['guidebook_start_page', 'guidebook_end_page'];
            if (guideFieldIds.includes(element.id)) return true;
            
            // Check for specific field classes that should navigate to guidebook
            if (element.classList.contains('choice-text') ||
                element.classList.contains('choice-id') ||
                element.classList.contains('blank-answer-input') ||
                element.classList.contains('relationship-left') ||
                element.classList.contains('relationship-right')) {
                return true;
            }
            
            // Check if the field is in a form group with guide-related labels
            const formGroup = element.closest('.form-group');
            if (formGroup) {
                const label = formGroup.querySelector('label');
                if (label) {
                    const labelText = label.textContent || '';
                    // Guide-related labels
                    // Removed 'Answer Images' - no longer switches to guidebook
                    if (labelText.includes('Guide Answer') ||
                        labelText.includes('Guide PDF Page') ||
                        labelText.includes('Choice Text') ||
                        labelText.includes('Choice ID') ||
                        labelText.includes('Blank Answers') ||
                        labelText.includes('Relationships')) {
                        return true;
                    }
                }
            }
            
            // Check parent containers for relationships section (in case element is inside relationships container)
            const relationshipsSection = element.closest('div[id^="relationships-list-"]');
            if (relationshipsSection) {
                // Check if there's a "Relationships" label in a parent container
                const parentContainer = relationshipsSection.closest('div[style*="border"]');
                if (parentContainer) {
                    const relationshipsLabel = parentContainer.querySelector('label');
                    if (relationshipsLabel && relationshipsLabel.textContent.includes('Relationships')) {
                        return true;
                    }
                }
            }
            
            // Check if element has placeholder or attributes that indicate guide fields
            const placeholder = element.placeholder || '';
            if (placeholder.includes('Guide PDF Page')) return true;
            
            return false;
        }
        
        // Helper function to determine if a field is textbook-related
        function isTextbookRelatedField(element) {
            if (!element) return false;
            
            // Specific textbook-related field IDs
            const textbookFieldIds = [
                'textbook_page', 'textbook_pdf_page', 'lesson_id', 'lesson_title', 
                'lesson_text', 'page_type'
            ];
            if (textbookFieldIds.includes(element.id)) return true;
            
            // Check if the field is in a form group with textbook-related labels
            const formGroup = element.closest('.form-group');
            if (formGroup) {
                const label = formGroup.querySelector('label');
                if (label) {
                    const labelText = label.textContent || '';
                    // Textbook-related labels (most content fields)
                    // Removed 'Section Images' and 'Question Images' - no longer trigger source switching
                    if (labelText.includes('Textbook') ||
                        labelText.includes('Section Title') ||
                        labelText.includes('Content (Markdown') ||
                        labelText.includes('Question ID') ||
                        labelText.includes('Set-up Text') ||
                        labelText.includes('Question Text') ||
                        labelText.includes('Related Question') ||
                        labelText.includes('Lesson Standards') ||
                        labelText.includes('Terminology') ||
                        labelText.includes('Lesson Text') ||
                        labelText.includes('Page Type')) {
                        return true;
                    }
                }
            }
            
            // Check for content/question section indicators
            if (element.closest('.content-section') || 
                element.closest('.questions-container') ||
                element.closest('#lesson_standards') ||
                element.closest('#terminology')) {
                // But exclude guide answer fields within questions
                const isInGuideField = element.closest('.form-group')?.querySelector('label')?.textContent?.includes('Guide');
                return !isInGuideField;
            }
            
            return false;
        }

        function attachContextListeners() {
            if (window.__contextListenersAttached) return;
            window.__contextListenersAttached = true;
            // One-time registration so PDF auto-sync handlers do not run twice per event
            // Listen to focus events on form fields (but ignore PDF canvas and its container)
            document.addEventListener('focusin', (e) => {
                if (window.__mainPdfViewer.visible && window.__mainPdfViewer.autoSyncEnabled) {
                    // Don't trigger auto-switching when clicking on the PDF canvas or its container
                    const isCanvasOrContainer = e.target.id === 'main-pdf-canvas' || 
                                               e.target.classList.contains('pdf-canvas-container') ||
                                               e.target.closest('.pdf-canvas-container') ||
                                               e.target.closest('#pdf-viewer-panel .pdf-viewer-controls') ||
                                               e.target.id === 'json_input' ||
                                               e.target.closest('.json-controls');
                    
                    if (!isCanvasOrContainer) {
                        // Determine if this field should switch to textbook or guidebook
                        const shouldSwitchToGuide = isGuideRelatedField(e.target);
                        const shouldSwitchToTextbook = isTextbookRelatedField(e.target);
                        
                        if (shouldSwitchToGuide && window.__mainPdfViewer.source !== 'guide') {
                            switchPdfSource('guide');
                        } else if (shouldSwitchToTextbook && window.__mainPdfViewer.source !== 'textbook') {
                            switchPdfSource('textbook');
                        }
                        
                        clearTimeout(window.__contextSyncTimeout);
                        window.__contextSyncTimeout = setTimeout(() => {
                            // Re-check autoSyncEnabled before navigating (user might have turned it off)
                            if (window.__mainPdfViewer.autoSyncEnabled) {
                            navigateToContextPage();
                            }
                        }, 300);
                    }
                }
            }, true);
            
            // Listen to tab changes
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    if (window.__mainPdfViewer.visible && window.__mainPdfViewer.autoSyncEnabled) {
                        setTimeout(() => {
                            // Re-check autoSyncEnabled before navigating (user might have turned it off)
                            if (window.__mainPdfViewer.autoSyncEnabled) {
                                navigateToContextPage();
                            }
                        }, 100);
                    }
                });
            });
            
            // Listen to bbox page input changes
            document.addEventListener('input', (e) => {
                if (e.target.classList.contains('bbox-page') && 
                    window.__mainPdfViewer.visible && 
                    window.__mainPdfViewer.autoSyncEnabled) {
                    clearTimeout(window.__contextSyncTimeout);
                    window.__contextSyncTimeout = setTimeout(() => {
                        // Re-check autoSyncEnabled before navigating (user might have turned it off)
                        if (window.__mainPdfViewer.autoSyncEnabled) {
                        navigateToContextPage();
                        }
                    }, 500);
                }
            });
            
            // Listen to guidebook start/end page input changes for navigation
            document.addEventListener('input', (e) => {
                if (window.__mainPdfViewer.visible && window.__mainPdfViewer.autoSyncEnabled) {
                    const isGuidebookField = e.target.id === 'guidebook_start_page' || e.target.id === 'guidebook_end_page';
                    
                    if (isGuidebookField) {
                        // Switch to guide PDF if not already there
                        if (window.__mainPdfViewer.source !== 'guide') {
                            switchPdfSource('guide');
                        }
                        
                        // Navigate to the entered page
                        const pageValue = e.target.value;
                        if (pageValue) {
                            const page = parseInt(pageValue, 10);
                            if (page > 0) {
                                const state = window.__mainPdfViewer;
                                // Don't check totalPages here since PDF might not be loaded yet after source switch
                                clearTimeout(window.__guidebookInputTimeout);
                                window.__guidebookInputTimeout = setTimeout(() => {
                                    // Re-check autoSyncEnabled before navigating (user might have turned it off)
                                    if (state.autoSyncEnabled && state.pdfDoc && page <= state.pdfDoc.numPages) {
                                        // Use proper navigation function that updates controls and state
                                        navigateMainPdfToPage(page);
                                    }
                                }, 800); // Longer delay for typing
                            }
                        }
                    }
                }
            });
            
            // Listen to guide PDF page changes in questions
            document.addEventListener('change', (e) => {
                const target = e.target;
                if (!target || target.tagName !== 'INPUT') return;
                const label = target.closest('.form-group')?.querySelector('label');
                const isGuidePdfInput = label && label.textContent.includes('Guide PDF Page');
                
                if (isGuidePdfInput && 
                    window.__mainPdfViewer.visible && 
                    window.__mainPdfViewer.autoSyncEnabled) {
                    // Re-check autoSyncEnabled before navigating (user might have turned it off)
                    if (window.__mainPdfViewer.autoSyncEnabled) {
                        navigateToContextPage();
                    }
                }
            });
            
            // Listen to guidebook start/end page field focus events to auto-switch to guide and navigate
            document.addEventListener('focusin', (e) => {
                if (window.__mainPdfViewer.visible && window.__mainPdfViewer.autoSyncEnabled) {
                    const isGuidebookField = e.target.id === 'guidebook_start_page' || e.target.id === 'guidebook_end_page';
                    
                    if (isGuidebookField) {
                        const state = window.__mainPdfViewer;
                        // Switch to guide PDF when focusing on guidebook page fields
                        if (state.source !== 'guide') {
                            switchPdfSource('guide');
                            // Wait a moment for source switch to complete before navigating
                            setTimeout(() => {
                                // Re-check autoSyncEnabled before navigating (user might have turned it off)
                                if (!state.autoSyncEnabled) return;
                                // Navigate to a page within the guidebook range
                                const guidebookPage = getGuidebookPageInRange();
                                if (guidebookPage && guidebookPage > 0) {
                                        // Use proper navigation function that updates controls and state
                                    navigateMainPdfToPage(guidebookPage);
                                }
                            }, 100);
                            return; // Don't call navigateToContextPage as we're handling navigation above
                        } else {
                            // Already on guide, navigate immediately (but check autoSyncEnabled first)
                            if (state.autoSyncEnabled) {
                                const guidebookPage = getGuidebookPageInRange();
                                if (guidebookPage && guidebookPage > 0) {
                                    // Use proper navigation function that updates controls and state
                                    navigateMainPdfToPage(guidebookPage);
                                    return; // Don't call navigateToContextPage as we already navigated
                                }
                            }
                        }
                        
                        clearTimeout(window.__contextSyncTimeout);
                        window.__contextSyncTimeout = setTimeout(() => {
                            // Re-check autoSyncEnabled before navigating (user might have turned it off)
                            if (window.__mainPdfViewer.autoSyncEnabled) {
                            navigateToContextPage();
                            }
                        }, 300);
                    }
                }
            }, true);
        }

        function attachPdfKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                // Only handle shortcuts when PDF viewer is visible
                if (!window.__mainPdfViewer.visible) return;
                
                // Check if input/textarea is focused (don't interfere with typing)
                const activeTag = document.activeElement.tagName.toLowerCase();
                if (activeTag === 'input' || activeTag === 'textarea') {
                    // Allow shortcuts only with modifiers
                    if (!e.ctrlKey && !e.metaKey && !e.altKey) {
                        return;
                    }
                }
                
                // Page navigation
                if (e.key === 'ArrowLeft' && (e.ctrlKey || e.metaKey)) {
                    e.preventDefault();
                    navigateMainPdf('prev');
                } else if (e.key === 'ArrowRight' && (e.ctrlKey || e.metaKey)) {
                    e.preventDefault();
                    navigateMainPdf('next');
                }
                
                // Zoom
                if (e.key === '+' && (e.ctrlKey || e.metaKey)) {
                    e.preventDefault();
                    zoomMainPdf('in');
                } else if (e.key === '-' && (e.ctrlKey || e.metaKey)) {
                    e.preventDefault();
                    zoomMainPdf('out');
                } else if (e.key === '0' && (e.ctrlKey || e.metaKey)) {
                    e.preventDefault();
                    zoomMainPdf('reset');
                }
                
                // Toggle PDF/JSON (Alt+P or Cmd/Ctrl+P)
                if ((e.key === 'p' || e.key === 'P') && (e.ctrlKey || e.metaKey)) {
                    e.preventDefault();
                    if (window.__mainPdfViewer.visible) {
                        showJsonPreview();
                    } else {
                        showPdfViewer();
                    }
                }
            });
        }

        // This function is no longer needed - we read directly from window.__bboxStore
        // Keeping empty function for backward compatibility in case it's called elsewhere
        function syncPdfToMainViewer(source, pdfDoc) {
            // PDFs are stored in window.__bboxStore and read directly by loadPdfFromStore()
            // No sync needed - just load from store when viewer is shown
        }
        
        // Auto-resize all textareas on page load (for saved/restored content)
        // Only if auto-resize is enabled
        // Initial autosize is done once after attachAutoResizeInputHandler() in DOMContentLoaded (no timers)
        // ===== WHAT'S NEW MODAL =====
        // Note: CURRENT_VERSION and VERSION_SEEN_KEY are defined above (see line ~16527)
        
        function openWhatsNew() {
            const modal = document.getElementById('whats-new-modal');
            if (modal) {
                modal.style.display = 'flex';
                // Mark this version as seen
                try {
                    localStorage.setItem(VERSION_SEEN_KEY, CURRENT_VERSION);
                } catch (e) {
                    console.error('Failed to save version seen:', e);
                }
            }
        }
        
        function closeWhatsNew() {
            const modal = document.getElementById('whats-new-modal');
            if (modal) {
                modal.style.display = 'none';
            }
        }
        
        // Check if we should auto-open What's New modal on page load
        function checkAndOpenWhatsNew() {
            try {
                const lastSeenVersion = localStorage.getItem(VERSION_SEEN_KEY);
                // If no version has been seen, or if current version is different, show the modal
                if (!lastSeenVersion || lastSeenVersion !== CURRENT_VERSION) {
                    // Wait a bit for the page to fully load before showing
                    setTimeout(() => {
                        const modal = document.getElementById('whats-new-modal');
                        if (modal) {
                            modal.style.display = 'flex';
                            // Mark this version as seen immediately when auto-opening
                            try {
                                localStorage.setItem(VERSION_SEEN_KEY, CURRENT_VERSION);
                            } catch (e) {
                                console.error('Failed to save version seen:', e);
                            }
                        } else {
                            console.error('[What\'s New] Modal element not found!');
                        }
                    }, 500);
                }
            } catch (e) {
                console.error('[What\'s New] Failed to check version:', e);
            }
        }
        
        // Close modal when clicking outside
        window.addEventListener('click', function(event) {
            const modal = document.getElementById('whats-new-modal');
            if (event.target === modal) {
                closeWhatsNew();
            }
        });
    </script>
    
    <!-- What's New Modal -->
    <div id="whats-new-modal" style="display: none; position: fixed; z-index: 10000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); justify-content: center; align-items: center; padding: 20px;">
        <div class="whats-new-modal-content">
            <!-- Header -->
            <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 24px; border-radius: 12px 12px 0 0; display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <h2 style="margin: 0; font-size: 1.8rem; display: flex; align-items: center; gap: 10px;">
                        <i class="fas fa-sparkles"></i> What's New
                    </h2>
                    <p style="margin: 5px 0 0 0; opacity: 0.9; font-size: 0.95rem;">Latest updates and improvements</p>
                </div>
                <button onclick="closeWhatsNew()" style="background: rgba(255,255,255,0.2); border: none; color: white; width: 36px; height: 36px; border-radius: 50%; cursor: pointer; font-size: 1.2rem; display: flex; align-items: center; justify-content: center; transition: all 0.3s; padding: 0;">
                    <i class="fas fa-times" style="line-height: 1; display: block; transform: translateY(2px);"></i>
                </button>
            </div>
            
            <!-- Content -->
            <div class="whats-new-modal-body">
                <!-- Version (dynamically set) -->
                <div style="margin-bottom: 40px;">
                    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 20px;">
                        <span id="whats-new-current-version" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 6px 16px; border-radius: 20px; font-weight: 600; font-size: 0.9rem;">Version <span id="whats-new-version-number"></span></span>
                        <span class="whats-new-version-badge">Current Version</span>
                    </div>
                    
                    <!-- Bug Fixes -->
                    <div style="margin-bottom: 25px;">
                        <h3 class="whats-new-modal-header" style="margin: 0 0 12px 0; font-size: 1.1rem; display: flex; align-items: center; gap: 8px;">
                            <i class="fas fa-bug" style="color: #dc3545;"></i> Bug Fixes
                        </h3>
                        <ul class="whats-new-modal-list">
                            <li><strong>Fixed LaTeX Array Alignment:</strong> Fixed an issue where LaTeX arrays were always center-aligned regardless of the alignment specifier (like <code>\begin{array}{r}</code> for right alignment or <code>\begin{array}{l}</code> for left alignment). Arrays now correctly respect their alignment settings (<code>r</code>, <code>l</code>, or <code>c</code>) in all preview outputs.</li>
                            <li><strong>Fixed Arabic Text Direction in LaTeX:</strong> Fixed an issue where mixed Arabic and English text within LaTeX <code>\text{}</code> commands was not displaying with the correct text direction. Arabic text now flows right-to-left and English text flows left-to-right correctly, preserving the source order of elements in the LaTeX expression.</li>
                            <li><strong>Fixed Font Size Reset on JSON Load:</strong> Fixed an issue where loading a JSON file using the Load button would reset the font size in the input form to the default value instead of preserving the user's previously selected font size setting. Now, when you load a JSON file, your saved font size preference is automatically restored and applied to all form elements.</li>
                        </ul>
                    </div>
                    
                    <!-- New Features -->
                    <div style="margin-bottom: 25px;">
                        <h3 class="whats-new-modal-header" style="margin: 0 0 12px 0; font-size: 1.1rem; display: flex; align-items: center; gap: 8px;">
                            <i class="fas fa-star" style="color: #ffd700;"></i> New Features
                        </h3>
                        <ul class="whats-new-modal-list">
                            <li>
                                <strong>Extra Spaces and Empty Lines Indicator:</strong> 
                                <p style="margin: 8px 0;">A new toggle button <span style="background: rgba(40, 167, 69, 0.8); border: 1px solid rgba(255, 255, 255, 0.9); border-radius: 4px; padding: 3px 8px; display: inline-flex; align-items: center; gap: 4px; color: white; font-size: 0.85em; vertical-align: middle;"><i class="fas fa-exclamation-triangle"></i></span> in the header helps you spot formatting issues in your text. When enabled, the button turns <span style="background: rgba(40, 167, 69, 0.8); color: white; padding: 2px 6px; border-radius: 3px; font-size: 0.9em;">green</span>, and when disabled, it turns <span style="background: rgba(220, 53, 69, 0.8); color: white; padding: 2px 6px; border-radius: 3px; font-size: 0.9em;">red</span>. When enabled, preview boxes show a warning badge and highlight exactly where problems are located.</p>
                                <p style="margin: 8px 0;"><strong>What gets detected and how it looks:</strong></p>
                                <ul style="margin: 4px 0 8px 20px; padding-left: 0;">
                                    <li style="margin-bottom: 6px;"><strong>Leading spaces:</strong> Spaces at the beginning of lines are highlighted with a <span style="background-color: rgba(255, 0, 0, 0.25); border-top: 2px dotted rgba(255, 0, 0, 0.6); padding: 1px 4px; display: inline-block; margin: 0 2px;">red background and top border</span> - you'll see the red highlight at the start of affected lines.</li>
                                    <li style="margin-bottom: 6px;"><strong>Trailing spaces:</strong> Spaces at the end of lines are highlighted with a <span style="background-color: rgba(255, 0, 0, 0.25); border-bottom: 2px dotted rgba(255, 0, 0, 0.6); padding: 1px 4px; display: inline-block; margin: 0 2px;">red background and bottom border</span> - you'll see the red highlight at the end of affected lines.</li>
                                    <li style="margin-bottom: 6px;"><strong>Multiple consecutive spaces:</strong> Two or more spaces in a row within text are highlighted with a <span style="background-color: rgba(255, 0, 0, 0.25); border-top: 1px dotted rgba(255, 0, 0, 0.6); border-bottom: 1px dotted rgba(255, 0, 0, 0.6); padding: 1px 4px; display: inline-block; margin: 0 2px;">red background with both top and bottom borders</span> - these appear in the middle of your text when you have multiple spaces together.</li>
                                    <li style="margin-bottom: 6px;"><strong>Empty lines:</strong> Empty lines are highlighted with a <span style="background-color: rgba(255, 193, 7, 0.15); border-left: 3px solid #ffc107; padding: 4px 8px; display: inline-block; min-width: 80px; margin: 2px 0;">yellow background and left border</span> with an "Empty line" label - these appear as yellow highlighted blocks for any blank lines.</li>
                                </ul>
                                <p style="margin: 8px 0;">This makes it easy to catch formatting problems before generating your final output. Simply click the toggle button to turn the feature on or off. <strong>Note:</strong> Extra spaces at the very beginning or end of your whole text are automatically removed when generating the final output.</p>
                            </li>
                            <li>
                                <strong>Basic Info and Lesson Preamble in Final Preview:</strong>
                                <p style="margin: 8px 0;">The Final Preview tab now displays both Basic Info and Lesson Preamble sections before the Content Sections and Questions. This provides a complete preview of all your form data in one place. The Basic Info section shows textbook page numbers, PDF page numbers, guidebook page ranges, and page type. The Lesson Preamble section displays lesson ID, lesson title, lesson standards, terminology, and lesson text - all with proper markdown rendering and edit buttons, following the same design pattern as content sections.</p>
                            </li>
                        </ul>
                    </div>
                </div>
                
                <!-- Version 6.8 -->
                <div style="margin-bottom: 40px;">
                    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 20px;">
                        <span style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 6px 16px; border-radius: 20px; font-weight: 600; font-size: 0.9rem;">Version 6.8</span>
                        <span class="whats-new-version-badge">Previous Version</span>
                    </div>
                    
                    <!-- Enhancements -->
                    <div style="margin-bottom: 25px;">
                        <h3 class="whats-new-modal-header" style="margin: 0 0 12px 0; font-size: 1.1rem; display: flex; align-items: center; gap: 8px;">
                            <i class="fas fa-arrow-up" style="color: #28a745;"></i> Enhancements
                        </h3>
                        <ul class="whats-new-modal-list">
                            <li><strong>Increased Maximum Zoom:</strong> The maximum zoom level has been increased to 8x (800%) for both the bounding box drawing modal and the PDF viewer. This allows for much more detailed work when drawing bounding boxes or examining PDF pages at high magnification.</li>
                            <li><strong>Zoom Indicator in Bounding Box Modal:</strong> A zoom percentage display has been added to the bounding box drawing modal, matching the functionality in the main PDF viewer. You can now see the current zoom level at a glance while drawing bounding boxes.</li>
                            <li><strong>Optimized Layout for Better Space Usage:</strong> The UI has been enhanced to make better use of available screen space. Both the left and right columns now utilize the full vertical and horizontal real estate, adapting responsively to different zoom levels and screen sizes. This makes the interface more efficient and provides more room for your work.</li>
                            <li><strong>Expanded Font Size Options:</strong> Additional larger font sizes have been added to the font size selector. You can now choose from sizes up to 48px, giving you more flexibility to customize the text size for better readability.</li>
                            <li><strong>Font Size Persistence:</strong> The tool now remembers and automatically applies your last selected font size when you reload or refresh the page. Your font size preference is saved and restored automatically, so you don't have to adjust it every time.</li>
                        </ul>
                    </div>
                    
                    <!-- Bug Fixes -->
                    <div style="margin-bottom: 25px;">
                        <h3 class="whats-new-modal-header" style="margin: 0 0 12px 0; font-size: 1.1rem; display: flex; align-items: center; gap: 8px;">
                            <i class="fas fa-bug" style="color: #dc3545;"></i> Bug Fixes
                        </h3>
                        <ul class="whats-new-modal-list">
                            <li><strong>Fixed Collapsed Section Navigation:</strong> Fixed an issue where clicking an edit button in the Final Preview tab to navigate to a collapsed section would not automatically expand that section. Now, when you click an edit button, the target section will automatically uncollapse so you can see and edit the field immediately.</li>
                        </ul>
                    </div>
                </div>
                
                <!-- Version 6.7 -->
                <div style="margin-bottom: 40px;">
                    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 20px;">
                        <span style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 6px 16px; border-radius: 20px; font-weight: 600; font-size: 0.9rem;">Version 6.7</span>
                        <span class="whats-new-version-badge">Previous Version</span>
                    </div>
                    
                    <!-- New Features -->
                    <div style="margin-bottom: 25px;">
                        <h3 class="whats-new-modal-header" style="margin: 0 0 12px 0; font-size: 1.1rem; display: flex; align-items: center; gap: 8px;">
                            <i class="fas fa-star" style="color: #ffd700;"></i> New Features
                        </h3>
                        <ul class="whats-new-modal-list">
                            <li><strong>Final Preview Tab:</strong> A new "Final Preview" tab provides a comprehensive preview of all your content sections and questions in one place. This consolidated view shows everything exactly as it will appear in the final output, making it easy to review your work. Each preview box includes an edit button that takes you directly to the corresponding input field for quick editing.</li>
                            <li><strong>Collapsible Sections:</strong> You can now collapse and expand content and question sections to manage your workspace more easily. Click the <i class="fas fa-chevron-down"></i> button in the section header to hide or show its content. The button rotates when collapsed to indicate its state.</li>
                            <li><strong>Image Description Text Direction:</strong> All image descriptions in the preview now always display from left to right, regardless of the preview's text direction setting. This ensures consistent and readable image descriptions for all users.</li>
                        </ul>
                    </div>
                </div>
                
                <!-- Version 6.6 -->
                <div style="margin-bottom: 40px;">
                    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 20px;">
                        <span style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 6px 16px; border-radius: 20px; font-weight: 600; font-size: 0.9rem;">Version 6.6</span>
                        <span class="whats-new-version-badge">Previous Version</span>
                    </div>
                    
                    <!-- New Features -->
                    <div style="margin-bottom: 25px;">
                        <h3 class="whats-new-modal-header" style="margin: 0 0 12px 0; font-size: 1.1rem; display: flex; align-items: center; gap: 8px;">
                            <i class="fas fa-star" style="color: #ffd700;"></i> New Features
                        </h3>
                        <ul class="whats-new-modal-list">
                            <li><strong>Smart Bbox Zoom & Centering:</strong> When you press the Draw button for a bounding box that already has coordinates, the PDF viewer now automatically zooms to show the entire bounding box clearly and centers it in the middle of the screen. The zoom level is calculated to fit the bbox with optimal padding, making it easy to see and edit existing bounding boxes. This saves time when reviewing or adjusting previously drawn boxes.</li>
                            <li><strong>Form-Level Undo/Redo Buttons:</strong> New undo and redo buttons at the top of the page let you reverse or redo actions throughout the form. These buttons affect structural changes like adding or removing sections, questions, terminology, choices, matching items, bounding boxes, and images. They can save your work if you accidentally remove a section or even if you clear the entire form using the "Clear Form" button or load a JSON file. <strong>Important:</strong> This is completely different from the undo/redo buttons in each text field (which only affect markdown formatting operations like bold, italic, lists, etc.). The form-level undo/redo buttons work independently and track all major form actions, giving you a safety net for your work.</li>
                            <li><strong>Smart Search:</strong> Find anything instantly across all your content sections and questions. As you type, a dropdown shows matching results with a preview of the text and highlights your search term. Each result clearly shows whether it's a section title, content text, question answer, choice, or other field. Click any result to jump directly to it, or use arrow keys to navigate. The search bar shows how many results were found and keeps your search term so you can easily check multiple matches.</li>
                        </ul>
                    </div>
                </div>
                
                <!-- Version 6.5 -->
                <div style="margin-bottom: 40px;">
                    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 20px;">
                        <span style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 6px 16px; border-radius: 20px; font-weight: 600; font-size: 0.9rem;">Version 6.5</span>
                        <span class="whats-new-version-badge">Previous Version</span>
                    </div>
                    
                    <!-- New Features -->
                    <div style="margin-bottom: 25px;">
                        <h3 class="whats-new-modal-header" style="margin: 0 0 12px 0; font-size: 1.1rem; display: flex; align-items: center; gap: 8px;">
                            <i class="fas fa-star" style="color: #ffd700;"></i> New Features
                        </h3>
                        <ul class="whats-new-modal-list">
                            <li><strong>Auto-Save:</strong> Your work is now automatically saved as you edit! The form saves your changes automatically after you finish editing a field, so you won't lose your progress. You'll see "Saving..." and "All saved" indicators to track the save status.</li>
                            <li><strong>Blockquote Formatting Button:</strong> A new blockquote button in the markdown toolbar makes it easy to format quotes. Select your text and click the quote button, or click it on an empty line to start typing a quote.</li>
                            <li><strong>Blockquote Format Validation:</strong> The form now checks that blockquotes use the correct format (one space after the ">" character). This ensures your quotes are properly formatted and prevents formatting issues when generating the final output.</li>
                            <li><strong>Blank in LaTeX Validation:</strong> The tool now prevents you from writing blanks (<code>___1___</code>, <code>___2___</code>, etc.) inside LaTeX expressions. If you try to use a blank inside inline LaTeX (<code>$...$</code>) or block LaTeX (<code>$$\n...\n$$</code>), you'll see an error message and won't be able to save or generate the JSON until you move the blank outside the LaTeX expression.</li>
                            <li><strong>LaTeX Always Reads Left-to-Right:</strong> Math formulas in the preview now always display from left to right, even when your text is set to right-to-left (RTL). This makes math expressions easier to read and ensures they display correctly regardless of the text direction you've chosen.</li>
                            <li><strong>Reload Button & Reminder:</strong> A new reload button in the top bar lets you quickly refresh the page. The tool will also remind you to reload every few days to make sure you're using the latest version of the tool and getting all the newest features and improvements. This is especially important since the tool is updated regularly with new capabilities and bug fixes.</li>
                        </ul>
                    </div>
                </div>
                
                <!-- Version 6.4 -->
                <div style="margin-bottom: 40px;">
                    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 20px;">
                        <span style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 6px 16px; border-radius: 20px; font-weight: 600; font-size: 0.9rem;">Version 6.4</span>
                        <span class="whats-new-version-badge">Previous Version</span>
                    </div>
                    
                    <!-- Enhancements -->
                    <div style="margin-bottom: 25px;">
                        <h3 class="whats-new-modal-header" style="margin: 0 0 12px 0; font-size: 1.1rem; display: flex; align-items: center; gap: 8px;">
                            <i class="fas fa-arrow-up" style="color: #28a745;"></i> Enhancements
                        </h3>
                        <ul class="whats-new-modal-list">
                            <li><strong>Smarter Table Validation:</strong> Table validation now correctly handles LaTeX expressions inside table cells. Pipes inside LaTeX formulas (like <code>$\cancel{||||}$</code>) are no longer counted as table delimiters, preventing false validation errors.</li>
                            <li><strong>Improved Image Description Validation:</strong> Image description validation now correctly handles LaTeX commands. LaTeX commands like <code>\neq</code> or <code>\right(</code> that contain <code>\n</code> or <code>\r</code> are no longer flagged as errors. Block LaTeX (<code>$$\n...\n$$</code>) in image descriptions is now properly detected and blocked with a helpful error message suggesting to use inline LaTeX instead.</li>
                            <li><strong>Fixed Direction Button Issue:</strong> Direction buttons (RTL/LTR) now work correctly even after validation errors appear. Previously, clicking the direction button after an error would not update the preview, but this has been fixed.</li>
                        </ul>
                    </div>
                </div>
                
                <!-- Version 6.3 -->
                <div style="margin-bottom: 40px;">
                    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 20px;">
                        <span style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 6px 16px; border-radius: 20px; font-weight: 600; font-size: 0.9rem;">Version 6.3</span>
                        <span class="whats-new-version-badge">Previous Version</span>
                    </div>
                    
                    <!-- New Features -->
                    <div style="margin-bottom: 25px;">
                        <h3 class="whats-new-modal-header" style="margin: 0 0 12px 0; font-size: 1.1rem; display: flex; align-items: center; gap: 8px;">
                            <i class="fas fa-star" style="color: #ffc107;"></i> New Features
                        </h3>
                        <ul class="whats-new-modal-list">
                            <li><strong>Multi-Line Table Cells:</strong> You can now press Enter inside table cells to create line breaks. The preview will show your content on multiple lines within the same cell.</li>
                            <li><strong>List Validation:</strong> The tool now reminds you to add an empty line after lists. If you forget, you'll see a helpful error message to fix it.</li>
                            <li><strong>Blockquote Validation:</strong> The tool now reminds you to add an empty line after blockquotes. If you forget, you'll see a helpful error message to fix it.</li>
                        </ul>
                    </div>
                    
                    <!-- Enhancements -->
                    <div style="margin-bottom: 25px;">
                        <h3 class="whats-new-modal-header" style="margin: 0 0 12px 0; font-size: 1.1rem; display: flex; align-items: center; gap: 8px;">
                            <i class="fas fa-arrow-up" style="color: #28a745;"></i> Enhancements
                        </h3>
                        <ul class="whats-new-modal-list">
                            <li><strong>Better Table Validation:</strong> Table validation is now smarter and won't show errors when you use line breaks inside cells.</li>
                            <li><strong>Unified Error Display:</strong> All validation errors (tables, lists, blockquotes, LaTeX, images, quotes, and HTML tags) now appear in a consistent format and are displayed right after the input box for easier visibility.</li>
                            <li><strong>Customizable Font Settings:</strong> You can now adjust font size and line height directly from the top bar. Your preferences are saved and apply to all text inputs and previews for both Arabic and English text.</li>
                        </ul>
                    </div>
                </div>
                
                <!-- Version 6.2 -->
                <div style="margin-bottom: 40px;">
                    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 20px;">
                        <span style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 6px 16px; border-radius: 20px; font-weight: 600; font-size: 0.9rem;">Version 6.2</span>
                        <span class="whats-new-version-badge">Previous Version</span>
                    </div>
                    
                    <!-- Enhancements -->
                    <div style="margin-bottom: 25px;">
                        <h3 class="whats-new-modal-header" style="margin: 0 0 12px 0; font-size: 1.1rem; display: flex; align-items: center; gap: 8px;">
                            <i class="fas fa-arrow-up" style="color: #28a745;"></i> Enhancements
                        </h3>
                        <ul class="whats-new-modal-list">
                            <li><strong>Simplified PDF Upload:</strong> The two separate buttons "Upload Textbook PDF" and "Upload Guide PDF" in the JSON Preview tab have been combined into a single "Upload PDFs" button for a cleaner interface. You can still upload both types of PDFs from the modal.</li>
                            <li><strong>Improved PDF Viewer Stability:</strong> The PDF viewer now stays exactly where you left it when using the Draw button or working with image fields. It won't change pages, zoom levels, or switch between books unexpectedly, making it much easier to work with multiple images without losing your place.</li>
                            <li><strong>Better Performance:</strong> The tool now renders PDFs more efficiently, only updating the display when necessary for smoother interactions and faster response times.</li>
                        </ul>
                    </div>
                </div>
                
                <!-- Version 6.1 -->
                <div style="margin-bottom: 40px;">
                    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 20px;">
                        <span style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 6px 16px; border-radius: 20px; font-weight: 600; font-size: 0.9rem;">Version 6.1</span>
                        <span class="whats-new-version-badge">Previous Version</span>
                    </div>
                    
                    <!-- New Features -->
                    <div style="margin-bottom: 25px;">
                        <h3 class="whats-new-modal-header" style="margin: 0 0 12px 0; font-size: 1.1rem; display: flex; align-items: center; gap: 8px;">
                            <i class="fas fa-star" style="color: #ffc107;"></i> New Features
                        </h3>
                        <ul class="whats-new-modal-list">
                            <li><strong>Markdown Toolbar:</strong> New formatting buttons (Bold, Italic, Bullet List, Numbered List, Inline LaTeX $, Block LaTeX $$) in all text fields let you quickly format text without typing markdown syntax. Select text and click a button, or click to insert formatting placeholders. Undo and Redo buttons let you reverse or reapply your last formatting operations.</li>
                            <li><strong>Search/Filter:</strong> New search box in the top bar lets you quickly find content sections and questions by searching through titles, content text, question IDs, question text, and answers. Matching items are highlighted with a colored border.</li>
                            <li><strong>Auto-Resize Toggle:</strong> New circular button () in the top bar lets you control whether text boxes grow automatically as you type. Green = auto-resize on, red = off. Your preference is saved.</li>
                            <li><strong>HTML Tag Validation:</strong> The tool now prevents using <code>&lt;br&gt;</code> tags in your content. You'll see a red error message if you try to use them, and you won't be able to save until they're removed.</li>
                            <li><strong>Helpful Tooltips:</strong> All buttons and form fields now have tooltips that appear when you hover over them, making it easier to understand what each feature does.</li>
                        </ul>
                    </div>
                    
                    <!-- Enhancements -->
                    <div style="margin-bottom: 25px;">
                        <h3 class="whats-new-modal-header" style="margin: 0 0 12px 0; font-size: 1.1rem; display: flex; align-items: center; gap: 8px;">
                            <i class="fas fa-arrow-up" style="color: #28a745;"></i> Enhancements
                        </h3>
                        <ul class="whats-new-modal-list">
                            <li><strong>Button Improvements:</strong> All buttons now have the same size for a cleaner look.</li>
                        </ul>
                    </div>
                </div>
                
                <!-- Version 6.0 -->
                <div style="margin-bottom: 40px;">
                    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 20px;">
                        <span style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 6px 16px; border-radius: 20px; font-weight: 600; font-size: 0.9rem;">Version 6.0</span>
                        <span class="whats-new-version-badge">Previous Version</span>
                    </div>
                    
                    <!-- Bug Fixes & Improvements -->
                    <div style="margin-bottom: 25px;">
                        <h3 class="whats-new-modal-header" style="margin: 0 0 12px 0; font-size: 1.1rem; display: flex; align-items: center; gap: 8px;">
                            <i class="fas fa-bug" style="color: #dc3545;"></i> Fixes & Improvements
                        </h3>
                        <ul class="whats-new-modal-list">
                            <li><strong>LaTeX in Image Descriptions:</strong> Fixed an issue where using math formulas in image descriptions (like <code>$\sqrt[3]{16}$</code>) was incorrectly flagged as an error. The tool now correctly recognizes LaTeX syntax in image descriptions.</li>
                        </ul>
                    </div>
                </div>
                
                <!-- Version 5.9 -->
                <div style="margin-bottom: 40px;">
                    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 20px;">
                        <span style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 6px 16px; border-radius: 20px; font-weight: 600; font-size: 0.9rem;">Version 5.9</span>
                        <span class="whats-new-version-badge">Previous Version</span>
                    </div>
                    
                    <!-- New Features -->
                    <div style="margin-bottom: 25px;">
                        <h3 class="whats-new-modal-header" style="margin: 0 0 12px 0; font-size: 1.1rem; display: flex; align-items: center; gap: 8px;">
                            <i class="fas fa-star" style="color: #ffc107;"></i> New Features
                        </h3>
                        <ul class="whats-new-modal-list">
                            <li><strong>Extended Auto-Navigation:</strong> Auto-navigation now works for more fields including choices, blank answers, and relationships. The PDF automatically jumps to the correct page when you click these fields.</li>
                            <li><strong>Guide PDF Page Validation:</strong> The tool now checks that guide page numbers are within the correct range. You'll get an error if the page number is outside the range, and you won't be able to save until it's fixed.</li>
                        </ul>
                    </div>
                    
                    <!-- Enhancements -->
                    <div style="margin-bottom: 25px;">
                        <h3 class="whats-new-modal-header" style="margin: 0 0 12px 0; font-size: 1.1rem; display: flex; align-items: center; gap: 8px;">
                            <i class="fas fa-arrow-up" style="color: #28a745;"></i> Enhancements
                        </h3>
                        <ul class="whats-new-modal-list">
                            <li><strong>Smart Guidebook Navigation:</strong> The guidebook can now navigate to any page in the range, not just the start page. It stays on your current page if you're already in range.</li>
                            <li><strong>Auto-Navigation Toggle:</strong> When auto-navigation is turned off, the PDF won't jump around when you type page numbers.</li>
                            <li><strong>Answer Preview:</strong> The answer preview now displays math formulas the same way as the choice preview, and updates as you type.</li>
                        </ul>
                    </div>
                </div>
                
                <!-- Version 5.8 -->
                <div style="margin-bottom: 40px;">
                    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 20px;">
                        <span style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 6px 16px; border-radius: 20px; font-weight: 600; font-size: 0.9rem;">Version 5.8</span>
                        <span class="whats-new-version-badge">Previous Version</span>
                    </div>
                    
                    <!-- Bug Fixes & Improvements -->
                    <div style="margin-bottom: 25px;">
                        <h3 class="whats-new-modal-header" style="margin: 0 0 12px 0; font-size: 1.1rem; display: flex; align-items: center; gap: 8px;">
                            <i class="fas fa-bug" style="color: #dc3545;"></i> Fixes & Improvements
                        </h3>
                        <ul class="whats-new-modal-list">
                            <li><strong>Fill-in-the-Blanks Formatting:</strong> Fixed an issue where spaces between blanks were incorrectly flagged as errors.</li>
                            <li><strong>Preview with Answers:</strong> The answer preview now displays math formulas correctly, matching the question preview.</li>
                            <li><strong>Answer Position Direction:</strong> The direction buttons for answer position now work consistently with the choice text buttons.</li>
                            <li><strong>Dark Mode Support:</strong> The What's New dialog now works properly in dark mode.</li>
                        </ul>
                    </div>
                </div>
                
                <!-- Version 5.7 -->
                <div style="margin-bottom: 40px;">
                    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 20px;">
                        <span style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 6px 16px; border-radius: 20px; font-weight: 600; font-size: 0.9rem;">Version 5.7</span>
                        <span class="whats-new-version-badge">Previous Version</span>
                    </div>
                    
                    <!-- New Features -->
                    <div style="margin-bottom: 25px;">
                        <h3 class="whats-new-modal-header" style="margin: 0 0 12px 0; font-size: 1.1rem; display: flex; align-items: center; gap: 8px;">
                            <i class="fas fa-star" style="color: #ffc107;"></i> New Features
                        </h3>
                        <ul class="whats-new-modal-list">
                            <li><strong>What's New Modal:</strong> Stay informed about the latest updates and improvements with the new "What's New" button in the header. Click it anytime to see what's changed!</li>
                            <li><strong>One-Click Duplicate:</strong> Quickly duplicate any content section, question, or image box by clicking the purple duplicate icon <i class="fas fa-clone" style="color: #6f42c1;"></i>. The duplicated section appears right below the original with all data intact.</li>
                            <li><strong>Question ID Validation:</strong> The tool now checks for duplicate question IDs and warns you if you use the same ID twice.</li>
                        </ul>
                    </div>
                    
                    <!-- Enhancements -->
                    <div style="margin-bottom: 25px;">
                        <h3 class="whats-new-modal-header" style="margin: 0 0 12px 0; font-size: 1.1rem; display: flex; align-items: center; gap: 8px;">
                            <i class="fas fa-arrow-up" style="color: #28a745;"></i> Enhancements
                        </h3>
                        <ul class="whats-new-modal-list">
                            <li><strong>Persistent Guide Answer:</strong> Your guide answer is now saved when you switch between question types.</li>
                        </ul>
                    </div>
                    
                    <!-- Bug Fixes -->
                    <div>
                        <h3 class="whats-new-modal-header" style="margin: 0 0 12px 0; font-size: 1.1rem; display: flex; align-items: center; gap: 8px;">
                            <i class="fas fa-bug" style="color: #dc3545;"></i> Bug Fixes
                        </h3>
                        <ul class="whats-new-modal-list">
                            <li><strong>Improved Table Detection:</strong> Fixed an issue where single pipe symbols or math notation were incorrectly flagged as table errors.</li>
                        </ul>
                    </div>
                </div>
                
                <!-- Footer -->
                <div class="whats-new-modal-footer">
                    <p style="margin: 0;">Have questions or suggestions? <a href="https://forms.gle/UJKozfjrWP7sfxTC8" target="_blank" rel="noopener noreferrer" style="color: #667eea; text-decoration: none; font-weight: 600;">Share your feedback</a> - We're always improving!</p>
                </div>
            </div>
        </div>
    </div>

</body>
</html>

